{"version":3,"sources":["../static/js/6.6a376720.chunk.js","pages/Home.js","../node_modules/chart.js/src/helpers/index.js","../node_modules/chart.js/src/core/core.defaults.js","../node_modules/chart.js/src/core/core.element.js","../node_modules/chart.js/src/elements/index.js","../node_modules/chart.js/src/core/core.layouts.js","../node_modules/chart.js/src/core/core.ticks.js","../node_modules/chart.js/src/helpers/helpers.core.js","api/generalAdministrator.js","state/TechnicalTeamSurvey/action.js","api/technicalTeamAnswer.js","state/Pendings/action.js","state/Home/action.js","../node_modules/chartjs-color/index.js","../node_modules/chart.js/src/core/core.interaction.js","../node_modules/chart.js/src/platforms/platform.js","../node_modules/chart.js/src/core/core.plugins.js","../node_modules/react-responsive-carousel/lib/cssClasses.js","../node_modules/react-responsive-carousel/lib/CSSTranslate.js","../node_modules/react-easy-swipe/lib/index.js","../node_modules/react-responsive-carousel/lib/components/Thumbs.js","components/Home/HomeContainer.js","components/Home/Doughnut.js","../node_modules/react-chartkick/dist/react-chartkick.esm.js","../node_modules/chartkick/dist/chartkick.esm.js","../node_modules/chart.js/src/chart.js","../node_modules/chart.js/src/core/core.js","../node_modules/chart.js/src/helpers/helpers.easing.js","../node_modules/chart.js/src/helpers/helpers.canvas.js","../node_modules/chart.js/src/helpers/helpers.options.js","../node_modules/chart.js/src/core/core.helpers.js","../node_modules/chartjs-color/node_modules/color-convert/index.js","../node_modules/chartjs-color/node_modules/color-convert/conversions.js","../node_modules/chartjs-color-string/color-string.js","../node_modules/color-name/index.js","../node_modules/chart.js/src/elements/element.arc.js","../node_modules/chart.js/src/elements/element.line.js","../node_modules/chart.js/src/elements/element.point.js","../node_modules/chart.js/src/elements/element.rectangle.js","../node_modules/chart.js/src/platforms/platform.basic.js","../node_modules/chart.js/src/platforms/platform.dom.js","../node_modules/chart.js/src/core/core.animation.js","../node_modules/chart.js/src/core/core.controller.js","../node_modules/chart.js/src/core/core.datasetController.js","../node_modules/chart.js/src/core/core.scaleService.js","../node_modules/chart.js/src/core/core.scale.js","../node_modules/chart.js/src/core/core.tooltip.js","../node_modules/chart.js/src/scales/scale.linearbase.js","../node_modules/chart.js/src/scales/scale.category.js","../node_modules/chart.js/src/scales/scale.linear.js","../node_modules/chart.js/src/scales/scale.logarithmic.js","../node_modules/chart.js/src/scales/scale.radialLinear.js","../node_modules/chart.js/src/scales/scale.time.js","../node_modules/chart.js/src/controllers/controller.bar.js","../node_modules/chart.js/src/controllers/controller.bubble.js","../node_modules/chart.js/src/controllers/controller.doughnut.js","../node_modules/chart.js/src/controllers/controller.line.js","../node_modules/chart.js/src/controllers/controller.polarArea.js","../node_modules/chart.js/src/controllers/controller.radar.js","../node_modules/chart.js/src/controllers/controller.scatter.js","../node_modules/chart.js/src/charts/Chart.Bar.js","../node_modules/chart.js/src/charts/Chart.Bubble.js","../node_modules/chart.js/src/charts/Chart.Doughnut.js","../node_modules/chart.js/src/charts/Chart.Line.js","../node_modules/chart.js/src/charts/Chart.PolarArea.js","../node_modules/chart.js/src/charts/Chart.Radar.js","../node_modules/chart.js/src/charts/Chart.Scatter.js","../node_modules/chart.js/src/plugins/index.js","../node_modules/chart.js/src/plugins/plugin.filler.js","../node_modules/chart.js/src/plugins/plugin.legend.js","../node_modules/chart.js/src/plugins/plugin.title.js","components/Home/Carousel.js","../node_modules/react-responsive-carousel/lib/index.js","../node_modules/react-responsive-carousel/lib/components/Carousel.js","../node_modules/react-easy-swipe/lib/react-swipe.js","../node_modules/react-responsive-carousel/lib/dimensions.js","../node_modules/react-responsive-carousel/lib/customPropTypes.js","components/Home/PendingsManager.js","components/Home/PendingsTechnical.js","components/Home/PendingsEvaluator.js","components/Home/PendingsSupplier.js"],"names":["webpackJsonp","1180","module","__webpack_exports__","__webpack_require__","Home","__WEBPACK_IMPORTED_MODULE_0_react___default","a","createElement","__WEBPACK_IMPORTED_MODULE_1__components_Home_HomeContainer__","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_react__","n","1213","exports","easing","canvas","options","1217","helpers","_set","scope","values","merge","this","1224","interpolate","start","view","model","ease","i","ilen","key","actual","origin","target","type","c0","c1","keys","length","hasOwnProperty","color","valid","mix","rgbString","isFinite","Element","configuration","extend","initialize","apply","arguments","prototype","hidden","pivot","me","_view","clone","_model","_start","transition","tooltipPosition","x","y","hasValue","isNumber","inherits","1225","Arc","Line","Point","Rectangle","1233","filterByPosition","array","position","where","v","sortByWeight","reverse","forEach","_tmpIndex_","sort","b","v0","v1","weight","defaults","addBox","chart","item","boxes","fullWidth","push","removeBox","layoutItem","index","indexOf","splice","configure","prop","props","update","width","height","getMinimumBoxSize","box","minSize","isHorizontal","chartWidth","maxChartAreaWidth","horizontalBoxHeight","maxChartAreaHeight","verticalBoxWidth","minBoxSizes","horizontal","fitBox","minBoxSize","findNextWhere","minBox","scaleMargin","left","Math","max","totalLeftBoxesWidth","maxHorizontalLeftPadding","right","totalRightBoxesWidth","maxHorizontalRightPadding","top","bottom","chartHeight","finalFitVerticalBox","totalTopBoxesHeight","totalBottomBoxesHeight","placeBox","leftPadding","rightPadding","layoutOptions","layout","padding","toPadding","topPadding","bottomPadding","leftBoxes","rightBoxes","topBoxes","bottomBoxes","chartAreaBoxes","chartAreaWidth","chartAreaHeight","each","concat","maxVerticalTopPadding","maxVerticalBottomPadding","horizontalBox","getPadding","boxPadding","verticalBox","leftPaddingAddition","topPaddingAddition","newMaxChartAreaHeight","newMaxChartAreaWidth","chartArea","1234","formatters","isArray","linear","tickValue","ticks","delta","abs","floor","logDelta","log10","tickString","numDecimal","min","toFixed","logarithmic","remain","pow","toExponential","1251","noop","uid","id","isNullOrUndef","Array","toString","call","isObject","valueOrDefault","defaultValue","valueAtIndexOrDefault","callback","fn","args","thisArg","loopable","len","arrayEquals","a0","a1","source","map","klen","k","_merger","tval","sval","_mergerIf","mergeIf","sources","merger","setFn","extensions","ChartElement","constructor","Surrogate","__super__","callCallback","fromIndex","getValueOrDefault","getValueAtIndexOrDefault","1252","getGeneralAdministratorApi","__WEBPACK_IMPORTED_MODULE_0__instance__","get","saveGeneralAdministratorApi","data","post","d","1253","getTechnicalTeamSurvey","getFailedRequest","filterTechnicalTeamSurvey","setScore","setComment","finishTechnicalTeamSurvey","__WEBPACK_IMPORTED_MODULE_0__const__","__WEBPACK_IMPORTED_MODULE_1__api_call__","__WEBPACK_IMPORTED_MODULE_2__api_technicalTeamAnswer__","__WEBPACK_IMPORTED_MODULE_3__api_supplier__","__WEBPACK_IMPORTED_MODULE_4__utils_action__","__WEBPACK_IMPORTED_MODULE_5__Generic_action__","getDataTechnicalTeamSurveyProgress","getDataTechnicalTeamSurveySuccess","calculateTotal","changeScore","idSupplier","answer","new","changeComment","comment","updateErrors","updateSuppliers","idSuppliers","idSuppliersByCall","dispatch","then","response","catch","getState","technicalTeamSurvey","suppliers","find","element","comments","idService","year","undefined","supplierId","supplier","supplierByCall","suppliersByCall","idSupplierByCall","idState","items","masters","Item","TechnicalTeamAnswer","idItem","option","EvaluationScale","idEvaluationScale","name","score","error","totals","Service","service","TechnicalTeamComment","state","State","shortName","readOnly","whoEvaluateOfTechnicalTeam","User","required","visible","total","idServiceForTotal","_getState$technicalTe","updatedErrors","updatedError","assign","filter","1254","saveTechnicalTeamAnswerApi","saveTechnicalTeamCommentApi","1255","getPendings","filterPendings","__WEBPACK_IMPORTED_MODULE_1__api_supplier__","__WEBPACK_IMPORTED_MODULE_2__utils_action__","getDataPendingsProgress","getDataPendingsSuccess","1265","getAllGeneralData","getStatisticalData","getCurrentData","__WEBPACK_IMPORTED_MODULE_1__api_generalAdministrator__","__WEBPACK_IMPORTED_MODULE_2__api_call__","__WEBPACK_IMPORTED_MODULE_3__utils_action__","__WEBPACK_IMPORTED_MODULE_4__Main_action__","getDataGeneralAdministratorProgress","getDataStatisticalProgress","getDataCurrentProgress","getDataGeneralAdministratorSuccess","getDataCurrentSuccess","dataCurrent","getDataStatisticalSuccess","statisticalData","objectStatisticData","axesStatisticData","entries","parseFloat","1266","convert","string","Color","obj","rgb","hsl","hsv","hwb","cmyk","alpha","vals","getRgba","setValues","getHsla","getHwb","r","red","l","lightness","w","whiteness","c","cyan","isValid","setSpace","rgbArray","hslArray","hsvArray","hwbArray","cmykArray","rgbaArray","hslaArray","val","setChannel","green","blue","hue","saturation","saturationv","blackness","magenta","yellow","black","hexString","rgbaString","percentString","hslString","hslaString","hwbString","keyword","rgbNumber","luminosity","lum","chan","contrast","color2","lum1","lum2","level","contrastRatio","dark","light","negate","lighten","ratio","darken","saturate","desaturate","whiten","blacken","greyscale","clearer","opaquer","rotate","degrees","mixinColor","color1","p","w1","w2","toJSON","result","slice","console","spaces","maxes","getValues","space","charAt","chans","capped","round","sname","svalues","window","1267","getRelativePosition","e","native","parseVisibleItems","handler","meta","j","jlen","datasets","isDatasetVisible","getDatasetMeta","skip","getIntersectItems","elements","inRange","getNearestItems","intersect","distanceMetric","minDistance","Number","POSITIVE_INFINITY","nearestItems","center","getCenterPoint","distance","getDistanceMetricForAxis","axis","useX","useY","pt1","pt2","deltaX","deltaY","sqrt","indexMode","dataset","datasetIndex","_index","modes","single","label","_datasetIndex","x-axis","point","nearest","sizeA","getArea","sizeB","ret","intersectsItem","inXRange","inYRange","1268","basic","dom","implementation","_enabled","acquireContext","releaseContext","addEventListener","removeEventListener","1269","plugins","_plugins","_cacheId","register","plugin","unregister","idx","clear","count","getAll","notify","hook","descriptor","params","method","descriptors","cache","$plugins","config","opts","global","_invalidate","1270","_classnames","_classnames2","__esModule","default","CAROUSEL","isSlider","carousel","carousel-slider","WRAPPER","thumbs-wrapper","slider-wrapper","axis-horizontal","axis-vertical","SLIDER","isSwiping","thumbs","slider","animated","ITEM","selected","thumb","slide","ARROW_PREV","disabled","control-arrow control-prev","control-disabled","ARROW_NEXT","control-arrow control-next","DOT","dot","1271","join","1272","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","_reactSwipe","_reactSwipe2","1273","_interopRequireDefault","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","protoProps","staticProps","_react","_react2","_reactDom","_propTypes","_propTypes2","_cssClasses","_cssClasses2","_dimensions","_CSSTranslate","_CSSTranslate2","_reactEasySwipe","_reactEasySwipe2","Thumbs","_Component","_this","getPrototypeOf","setItemsWrapperRef","node","itemsWrapperRef","setItemsListRef","itemsListRef","setThumbsRef","thumbsRef","updateSizes","children","wrapperSize","clientWidth","itemSize","thumbWidth","outerWidth","visibleItems","lastPosition","showArrows","setState","firstItem","getFirstItem","selectedItem","setMountState","hasMount","handleClickItem","onSelectItem","onSwipeStart","swiping","onSwipeEnd","onSwipeMove","currentPosition","lastLeftBoundary","style","slideRight","positions","moveTo","slideLeft","images","getImages","nextProps","setupThumbs","prevProps","destroyThumbs","Children","img","toArray","image","warn","_this2","itemClass","thumbProps","ref","className","onClick","bind","cloneElement","onLoad","hasPrev","hasNext","itemListStyles","transformProp","transitionTime","WebkitTransform","MozTransform","MsTransform","OTransform","transform","msTransform","WebkitTransitionDuration","MozTransitionDuration","MsTransitionDuration","OTransitionDuration","transitionDuration","msTransitionDuration","tagName","onSwipeLeft","onSwipeRight","renderItems","Component","displayName","propsTypes","isRequired","number","defaultProps","1278","_taggedTemplateLiteral","strings","raw","freeze","__WEBPACK_IMPORTED_MODULE_1_react_redux__","__WEBPACK_IMPORTED_MODULE_2_styled_components__","__WEBPACK_IMPORTED_MODULE_3_antd__","__WEBPACK_IMPORTED_MODULE_4__state_Home_action__","__WEBPACK_IMPORTED_MODULE_5____","__WEBPACK_IMPORTED_MODULE_6__shared_FormattedMessage__","_templateObject","_templateObject2","H3","h3","theme","primary","main","Linea","div","HomeContainer","_ref","_temp","_ret","_len","_key","_props","loading","dataUser","rol","rols","spinning","justify","span","offset","mapStateToProps","home","1279","__WEBPACK_IMPORTED_MODULE_0__Doughnut__","__WEBPACK_IMPORTED_MODULE_1__Carousel__","__WEBPACK_IMPORTED_MODULE_2__PendingsManager__","__WEBPACK_IMPORTED_MODULE_3__PendingsTechnical__","__WEBPACK_IMPORTED_MODULE_4__PendingsEvaluator__","__WEBPACK_IMPORTED_MODULE_5__PendingsSupplier__","1280","__WEBPACK_IMPORTED_MODULE_3_react_chartkick__","__WEBPACK_IMPORTED_MODULE_4_chart_js__","__WEBPACK_IMPORTED_MODULE_4_chart_js___default","__WEBPACK_IMPORTED_MODULE_5_antd__","__WEBPACK_IMPORTED_MODULE_6__utils_const__","__WEBPACK_IMPORTED_MODULE_7__state_Home_action__","__WEBPACK_IMPORTED_MODULE_8__shared_FormattedMessage__","RadioGroup","Group","addAdapter","RadioGroupStyle","Doughnut","onChange","getUserContext","totalSupplier","donut","legend","suffix","colors","messages","empty","library","title","display","text","Date","getFullYear","fontColor","mapDispatchToProps","1281","PieChart","__WEBPACK_IMPORTED_MODULE_1_chartkick__","chartId","ChartComponent","superclass","newChartType","chartType","componentDidMount","componentDidUpdate","render","this$1","lineHeight","textAlign","fontSize","fontFamily","createComponent","LineChart","ColumnChart","BarChart","AreaChart","ScatterChart","GeoChart","Timeline","1282","variable","isFunction","Function","isPlainObject","obj1","obj2","parseISO8601","input","day","hour","matches","milliseconds","minutes","month","seconds","match","ISO8601_PATTERN","parseInt","DECIMAL_SEPARATOR","UTC","negativeValues","series","toStr","toFloat","toDate","DATE_PATTERN","str","replace","toArr","arr","jsOptionsFunc","defaultOptions","hideLegend","setTitle","setMin","setMax","setStacked","setXtitle","setYtitle","chartOptions","stacked","xtitle","ytitle","sortByTime","getTime","sortByNumberSeries","sortByNumber","isMinute","getMilliseconds","getSeconds","isHour","getMinutes","isDay","getHours","isWeek","dayOfWeek","getDay","isMonth","getDate","isYear","getMonth","isDate","isNaN","formatValue","pre","prefix","thousands","decimal","parts","split","allZeros","pushRequest","url","success","pendingRequests","runNext","runningRequests","maxRequests","request","shift","getJSON","requestComplete","ajaxCall","jqXHR","textStatus","errorThrown","message","$","jQuery","Zepto","ajax","dataType","complete","xhr","XMLHttpRequest","open","setRequestHeader","onload","status","JSON","parse","responseText","statusText","send","setText","document","body","innerText","textContent","chartError","errorCatcher","__render","err","fetchDataSource","dataSource","rawData","addDownloadButton","link","download","zIndex","alt","border","src","appendChild","__downloadAttached","__enterEvent","addEvent","related","relatedTarget","childOf","href","toImage","__leaveEvent","parentNode","removeChild","elem","event","fn2","attachEvent","removeEvent","detachEvent","getAdapterType","product","defaultExport$1","setOnLoadCallback","charts","defaultExport$2","defaultExport","Error","adapterType","adapter","adapters","loadAdapters","Chart","Highcharts","google","dataEmpty","renderChart","callAdapter","fnName","adapterName","__adapterObject","detectDiscrete","copySeries","newSeries","copy","processSeries","keyType","discrete","xtype","formatSeriesData","processSimple","perfectData","String","baseOptions","maintainAspectRatio","animation","tooltips","displayColors","callbacks","scales","yAxes","maxTicksLimit","scaleLabel","xAxes","gridLines","drawOnChartArea","time","defaultColors","setBarMin","setBarMax","labelString","addOpacity","hex","opacity","exec","setLabelSize","maxLabelSize","ceil","offsetWidth","labels","substring","setFormatOptions","formatOptions","myAxes","valueLabel","tooltipItem","dataLabel","jsOptions","createDataTable","s","week","minute","detectType","sortedLabels","rows","rows2","backgroundColor","fill","borderColor","pointBackgroundColor","pointHoverBackgroundColor","borderWidth","stack","curve","lineTension","points","pointRadius","pointHitRadius","minTime","maxTime","timeDiff","unit","step","displayFormats","unitStepSize","tooltipFormat","renderLineChart","renderScatterChart","drawChart","renderPieChart","cutoutPercentage","renderColumnChart","renderAreaChart","renderBarChart","lineChart","showLine","renderBubbleChart","destroy","innerHTML","ctx","getElementsByTagName","defaultOptions$1","xAxis","yAxis","credits","enabled","tooltip","plotOptions","areaspline","marker","hideLegend$1","verticalAlign","align","setTitle$1","setMin$1","setMax$1","setStacked$1","stacking","setXtitle$1","setYtitle$1","jsOptions$1","setFormatOptions$1","formatter","pointFormatter","area","symbol","pie","innerSize","categories","d2","renderTo","loaded","defaultOptions$2","fontName","pointSize","textStyle","alignment","curveType","hAxis","titleTextStyle","gridlines","baselineColor","viewWindow","vAxis","hideLegend$2","setTitle$2","setMin$2","setMax$2","setBarMin$1","setBarMax$1","setStacked$2","isStacked","setXtitle$2","italic","setYtitle$2","jsOptions$2","resize","waitForLoaded","columnType","visualization","pieHole","DataTable","addColumn","addRows","areaOpacity","renderGeoChart","colorAxis","row","renderTimeline","clearChart","draw","pack","runCallbacks","loadOptions","packages","__config","language","mapsApiKey","load","cb","Chartkick","toFormattedKey","elementId","getElementById","refresh","startRefresh","getElement","getDataSource","getData","getOptions","getChartObject","getAdapter","updateData","__updateOptions","setOptions","redraw","refreshData","sep","intervalId","setInterval","stopRefresh","clearInterval","toBase64Image","updateRefresh","__processData","__chartName","BubbleChart","eachChart","1283","Interaction","layouts","platform","Ticks","Legend","_element","Title","pluginService","PluginBase","canvasHelpers","layoutService","1284","responsive","responsiveAnimationDuration","events","hover","onHover","mode","animationDuration","defaultColor","defaultFontColor","defaultFontFamily","defaultFontSize","defaultFontStyle","showLines","construct","1285","effects","t","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","PI","easeOutSine","sin","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","asin","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","easingEffects","1286","clearRect","roundedRect","radius","rx","ry","lineTo","quadraticCurveTo","rect","drawPoint","edgeLength","xOffset","yOffset","size","drawImage","beginPath","arc","closePath","SQRT2","fillRect","strokeRect","leftX","topY","sideSize","stroke","clipArea","save","clip","unclipArea","restore","previous","flip","steppedLine","tension","bezierCurveTo","controlPointPreviousX","controlPointNextX","controlPointPreviousY","controlPointNextY","drawRoundedRectangle","1287","toLineHeight","resolve","inputs","context","1288","parseMaxStyle","styleValue","parentProperty","valueInPixels","isConstrainedValue","getConstraintDimension","domNode","maxStyle","percentageProperty","defaultView","constrainedNode","getComputedStyle","constrainedContainer","hasCNode","hasCContainer","infinity","configMerge","scaleMerge","scaleService","getScaleDefaults","scale","slen","collection","filterCallback","filtered","findIndex","arrayToSearch","startIndex","currentItem","findPreviousWhere","almostEquals","epsilon","almostWhole","rounded","reduce","NEGATIVE_INFINITY","sign","exponent","log","LOG10E","powerOf10","toRadians","toDegrees","radians","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","atan2","distanceBetweenPoints","aliasPixel","pixelWidth","splineCurve","firstPoint","middlePoint","afterPoint","current","next","d01","d12","s01","s12","fa","fb","EPSILON","splineCurveMonotone","pointBefore","pointCurrent","pointAfter","pointsWithTangents","deltaK","mK","pointsLen","slopeDeltaX","alphaK","betaK","tauK","squaredMagnitude","nextItem","loop","previousItem","niceNum","range","fraction","requestAnimFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","setTimeout","evt","mouseX","mouseY","originalEvent","currentTarget","srcElement","boundingRect","getBoundingClientRect","touches","clientX","clientY","paddingLeft","getStyle","paddingTop","paddingRight","paddingBottom","currentDevicePixelRatio","getConstraintWidth","getConstraintHeight","getMaximumWidth","container","cw","getMaximumHeight","clientHeight","h","ch","el","property","currentStyle","getPropertyValue","retinaScale","forceRatio","pixelRatio","devicePixelRatio","fontString","pixelSize","fontStyle","longestText","font","arrayOfThings","gc","garbageCollect","longest","thing","measureText","nestedThing","gcLen","textWidth","numberOfLabelLines","numberOfLines","CanvasGradient","getHoverColor","colorValue","CanvasPattern","1289","conversions","Converter","func","arg","pair","from","to","convs","routeSpace","fspace","1290","rgb2hsl","g","rgb2hsv","rgb2hwb","rgb2cmyk","m","rgb2keyword","reverseKeywords","stringify","rgb2xyz","rgb2lab","xyz","z","rgb2lch","lab2lch","hsl2rgb","t1","t2","t3","hsl2hsv","sv","hsl2hwb","hsl2cmyk","hsl2keyword","hsv2rgb","hi","f","q","hsv2hsl","sl","hsv2hwb","hsv2cmyk","hsv2keyword","hwb2rgb","wh","bl","hwb2hsl","hwb2hsv","hwb2cmyk","hwb2keyword","cmyk2rgb","cmyk2hsl","cmyk2hsv","cmyk2hwb","cmyk2keyword","xyz2rgb","xyz2lab","xyz2lch","lab2xyz","lab","y2","hr","lab2rgb","lch2lab","lch","lch2xyz","lch2rgb","keyword2rgb","cssKeywords","keyword2hsl","keyword2hsv","keyword2hwb","keyword2cmyk","keyword2lab","keyword2xyz","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellowgreen","1291","abbr","rgba","per","colorNames","getRgb","getHsl","hsla","getAlpha","hexDouble","percentaString","reverseNames","num","toUpperCase","1292","1293","inLabelRange","vm","hoverRadius","chartX","chartY","pointRelativePosition","startAngle","endAngle","betweenAngles","withinRadius","innerRadius","outerRadius","halfAngle","halfRadius","centreAngle","rangeFromCentre","_chart","sA","eA","strokeStyle","lineWidth","fillStyle","lineJoin","1294","globalDefaults","line","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","capBezierPoints","currentVM","spanGaps","_children","globalOptionLineElements","lastDrawnIndex","_loop","lineCap","setLineDash","lineDashOffset","1295","xRange","hitRadius","yRange","pointStyle","hoverBorderWidth","1296","isVertical","bar","getBarBounds","x1","x2","y1","halfWidth","base","halfHeight","rectangle","borderSkipped","cornerAt","corners","startCorner","signX","signY","barSize","halfStroke","borderLeft","borderRight","borderTop","borderBottom","borders","corner","bounds","1297","getContext","1298","readUsedSize","initCanvas","renderHeight","getAttribute","renderWidth","EXPANDO_KEY","initial","displayWidth","aspectRatio","displayHeight","listener","eventListenerOptions","createEvent","nativeEvent","fromNativeEvent","EVENT_TYPES","pos","throttled","ticking","createResizer","resizer","cls","CSS_PREFIX","cssText","expand","childNodes","shrink","_reset","scrollLeft","scrollTop","onScroll","watchForRender","expando","proxy","renderProxy","animationName","CSS_RENDER_ANIMATION","ANIMATION_START_EVENTS","reflow","offsetParent","classList","add","CSS_RENDER_MONITOR","unwatchForRender","remove","addResizeListener","insertBefore","firstChild","removeResizeListener","injectCSS","css","_style","setAttribute","createTextNode","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","supportsEventListenerOptions","supports","passive","keyframes","removeAttribute","proxies","1299","duration","onProgress","onComplete","Animation","currentStep","numSteps","onAnimationProgress","onAnimationComplete","animationService","frameDuration","animations","dropFrames","addAnimation","lazy","animating","cancelAnimation","startDigest","startTime","now","framesToDrop","advance","endTime","set","1300","initConfig","updateConfig","newOptions","ensureScalesHaveIDs","buildOrUpdateScales","_options","positionIsHorizontal","types","instances","controllers","_bufferedRender","controller","bindEvents","initToolTip","stop","silent","newWidth","newHeight","newSize","onResize","scalesOptions","scaleOptions","xAxisOptions","yAxisOptions","updated","dtype","dposition","isDefault","scaleType","scaleClass","getScaleConstructor","mergeTicksOptions","hasUpdated","addScalesToLayout","buildOrUpdateControllers","newControllers","destroyDatasetMeta","updateIndex","linkScales","ControllerClass","resetElements","reset","_data","buildOrUpdateElements","updateLayout","updateDatasets","lastActive","_bufferedRequest","updateDataset","animationOptions","animationObject","easingFunction","stepDecimal","easingValue","drawDatasets","_drawTooltip","drawDataset","getElementAtEvent","getElementsAtEvent","getElementsAtXAxis","getElementsAtEventForMode","getDatasetAtEvent","_meta","xAxisID","yAxisID","getVisibleDatasetCount","generateLegend","legendCallback","unbindEvents","toDataURL","Tooltip","_chartInstance","listeners","_listeners","eventHandler","updateHoverStyle","changed","handleEvent","bufferedRequest","hoverOptions","active","Controller","1301","listenArrayEvents","_chartjs","arrayEvents","res","object","unlistenArrayEvents","stub","DatasetController","datasetElementType","dataElementType","addElements","getMeta","getDataset","getScaleForId","scaleID","createMetaDataset","createMetaData","metaData","addElementAndReset","updateElement","resyncElements","removeHoverStyle","elementOpts","custom","setHoverStyle","hoverBackgroundColor","hoverBorderColor","numMeta","numData","insertElements","onDataPush","onDataPop","pop","onDataShift","onDataSplice","onDataUnshift","1302","constructors","registerScaleType","scaleConstructor","scaleDefaults","updateScaleDefaults","additions","1303","labelsFromTicks","getLineValue","offsetGridLines","lineValue","getPixelForTick","drawBorder","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","zeroLineBorderDash","zeroLineBorderDashOffset","beginAtZero","minRotation","maxRotation","mirror","autoSkip","autoSkipPadding","labelOffset","minor","major","computeTextSize","tick","parseFontOptions","family","parseLineHeight","Scale","getTicks","_ticks","beforeUpdate","maxWidth","maxHeight","margins","longestTextCache","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","beforeFit","fit","afterFit","afterUpdate","tickOpts","userCallback","tickFont","labelRotation","cosRotation","originalLabelWidth","labelWidth","tickWidth","angleRadians","scaleLabelOpts","gridLineOpts","isFullWidth","scaleLabelLineHeight","scaleLabelPadding","deltaHeight","largestTextWidth","tallestLabelHeightInLines","lineSpace","tickPadding","longestLabelWidth","sinRotation","labelHeight","firstLabelWidth","lastLabelWidth","handleMargins","getRightValue","rawValue","NaN","getLabelForIndex","getPixelForValue","getValueForPixel","innerWidth","pixel","finalVal","innerHeight","getPixelForDecimal","valueOffset","getBasePixel","getBaseValue","_autoSkip","skipRatio","shouldSkip","maxTicks","optionTicks","tickCount","labelRotationRadians","longestRotatedLabel","optionMajorTicks","isRotated","tickFontColor","majorTickFontColor","majorTickFont","tl","scaleLabelFontColor","scaleLabelFont","itemsToDraw","axisWidth","xTickStart","xTickEnd","yTickStart","yTickEnd","lineColor","zeroLineIndex","tx1","ty1","tx2","ty2","labelX","labelY","textBaseline","labelYOffset","xLineValue","labelXOffset","isLeft","yLineValue","glWidth","glColor","glBorderDash","glBorderDashOffset","rotation","itemToDraw","translate","lineCount","fillText","scaleLabelX","scaleLabelY","halfLineHeight","1304","titleFontStyle","titleSpacing","titleMarginBottom","titleFontColor","titleAlign","bodySpacing","bodyFontColor","bodyAlign","footerFontStyle","footerSpacing","footerMarginTop","footerFontColor","footerAlign","yPadding","xPadding","caretPadding","caretSize","cornerRadius","multiKeyBackground","beforeTitle","tooltipItems","labelCount","xLabel","afterTitle","beforeBody","beforeLabel","yLabel","labelColor","activeElement","labelTextColor","afterLabel","afterBody","beforeFooter","footer","afterFooter","mergeOpacity","colorString","pushOrConcat","toPush","createTooltipItem","xScale","_xScale","yScale","_yScale","_scale","getBaseModel","tooltipOpts","xAlign","yAlign","_bodyFontFamily","bodyFontFamily","_bodyFontStyle","bodyFontStyle","_bodyAlign","bodyFontSize","_titleFontFamily","titleFontFamily","_titleFontStyle","titleFontSize","_titleAlign","_footerFontFamily","footerFontFamily","_footerFontStyle","footerFontSize","_footerAlign","legendColorBackground","getTooltipSize","combinedBodyLength","bodyItem","before","lines","after","titleLineCount","footerLineCount","widthPadding","maxLineWidth","determineAlignment","lf","rf","olf","orf","yf","midX","midY","getBackgroundPoint","paddingAndSize","radiusAndPadding","_lastActive","getTitle","getBeforeBody","getBody","bodyItems","getAfterBody","getFooter","existingModel","_active","backgroundPoint","tooltipSize","caretX","caretY","labelColors","labelTextColors","positioners","_eventPosition","itemSort","dataPoints","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","tmp","drawTitle","pt","drawBody","xLinePadding","fillLineOfText","drawColorBoxes","textColor","drawFooter","drawBackground","hasTooltipContent","average","eventPosition","nearestElement","tp","1305","generateTicks","generationOptions","dataRange","spacing","stepSize","niceRange","niceMin","niceMax","numSpaces","precision","LinearScaleBase","handleTickRangeOptions","minSign","maxSign","suggestedMin","suggestedMax","getTickLimit","handleDirectionalChanges","numericGeneratorOptions","fixedStepSize","end","ticksAsNumbers","1306","defaultConfig","DatasetScale","getLabels","xLabels","yLabels","minIndex","maxIndex","valueCategory","offsetAmt","valueWidth","widthOffset","valueHeight","heightOffset","horz","valueDimension","1307","LinearScale","IDMatches","hasStacks","valuesPerStack","positiveValues","relativePoints","valuesForType","minVal","maxVal","tickFontSize","rightValue","innerDimension","1308","exp","significand","tickVal","endExp","endSignificand","minNotZero","lastTick","LogarithmicScale","tickValues","_getFirstTickValue","firstTickValue","1309","getValueCount","angleLines","pointLabels","getPointLabelFontOptions","pointLabelOptions","measureLabelSize","determineLimits","fitWithPointLabels","textSize","pointPosition","plFont","largestPossibleRadius","furthestLimits","furthestAngles","_pointLabelSizes","valueCount","getPointPosition","getIndexAngle","hLimits","vLimits","setReductions","drawingArea","setCenterPoint","getTextAlignForAngle","adjustPointPositionForLabelHeight","drawPointLabels","angleLineOpts","pointLabelOpts","outerDistance","getDistanceFromCenterForValue","outerPosition","xCenter","yCenter","pointLabelPosition","pointLabelFontColor","drawRadiusLine","circular","numberOrZero","param","animate","showLabelBackdrop","backdropColor","backdropPaddingY","backdropPaddingX","LinearRadialScale","radiusReductionLeft","radiusReductionRight","radiusReductionTop","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","scalingFactor","distanceFromCenter","thisAngle","getPointPositionForValue","getBasePosition","tickFontStyle","tickFontFamily","tickLabelFont","yCenterOffset","1310","sorter","arrayUnique","hash","out","buildLookupTable","timestamps","distribution","prev","curr","table","lookup","mid","i0","i1","lo","skey","tkey","momentify","parser","format","moment","startOf","valueOf","determineStepSize","capacity","factor","interval","INTERVALS","steps","determineUnitForAutoTicks","minUnit","UNITS","MAX_INTEGER","common","determineUnitForFormatting","diff","as","determineMajorUnit","generate","timeOpts","weekday","isoWeekday","majorTicksEnabled","first","last","computeOffsets","upper","lower","ticksFromTimestamps","majorUnit","determineLabelFormat","momentDate","hasTime","millisecond","second","MIN_INTEGER","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","quarter","displayFormat","TimeScale","timestamp","endOf","_horizontal","_table","_timestamps","getLabelCapacity","_unit","_majorUnit","_offsets","_labelFormat","tickFormatFunction","formatOverride","formats","minorFormat","majorFormat","majorTime","majorTickOpts","getPixelForOffset","getLabelWidth","ticksOpts","tickLabelWidth","exampleTime","exampleLabel","1311","computeMinSampleSize","pixels","computeFitCategoryTraits","ruler","thickness","barThickness","stackCount","categoryPercentage","barPercentage","chunk","computeFlexCategoryTraits","percent","rects","_ruler","getRuler","rectangleOptions","datasetLabel","updateElementGeometry","vscale","getValueScale","vpixels","calculateBarValuePixels","ipixels","calculateBarIndexPixels","head","getValueScaleId","getIndexScaleId","getIndexScale","_getStacks","stacks","getStackCount","getStackIndex","imeta","ivalue","stackIndex","maxBarThickness","Infinity","rectangleElementOptions","horizontalBar","1312","dataPoint","bubble","_resolveElementOptions","dsIndex","dataIndex","1313","animateRotate","animateScale","generateLabels","ds","arcOpts","legendItem","circumference","doughnut","getRingIndex","ringIndex","availableWidth","availableHeight","contains0","contains90","contains180","contains270","cutout","getMaxBorderWidth","radiusLength","offsetX","offsetY","animationOpts","centerX","centerY","calculateCircumference","arcs","hoverWidth","1314","lineEnabled","lineElementOptions","stepped","cubicInterpolationMode","updateBezierControlPoints","getPointBackgroundColor","getPointBorderColor","pointBorderColor","getPointBorderWidth","pointBorderWidth","pointOptions","calculatePointY","dsMeta","sumPos","sumNeg","stackedRightValue","capControlPoint","controlPoints","pointHoverRadius","pointHoverBorderColor","pointHoverBorderWidth","1315","polarArea","countVisibleElements","visibleCount","datasetStartAngle","resetRadius","1316","radar","pointElementOptions","1317","scatter","1318","Bar","1319","Bubble","1320","1321","1322","PolarArea","1323","Radar","1324","Scatter","1325","filler","1326","decodeFill","computeBoundary","scaleBottom","scaleTop","scaleZero","resolveTarget","propagate","visited","createMapper","mappers","isDrawable","drawArea","curve0","curve1","len0","len1","doFill","mapper","p0","p1","d0","d1","boundary","afterDatasetsUpdate","$filler","beforeDatasetDraw","1327","getBoxWidth","labelOpts","usePointStyle","boxWidth","createNewLegendAndAttach","legendOpts","ci","lineDash","legendHitBoxes","doughnutMode","beforeBuildLabels","buildLabels","afterBuildLabels","legendItems","globalDefault","labelFont","hitboxes","lineWidths","totalHeight","vPadding","columnWidths","totalWidth","currentColWidth","currentColHeight","itemHeight","itemWidth","lineDefault","legendWidth","cursor","drawLegendBox","isLineWidthZero","offSet","halfFontSize","xLeft","yMiddle","lh","hitBox","beforeInit","afterEvent","1328","createNewTitleBlockAndAttach","titleOpts","titleBlock","titleX","titleY","titleFont","1329","Carousel","CarouselResponsiveStyle","autoPlay","infiniteLoop","stopOnHover","rotationTime","showStatus","Slider","content","__WEBPACK_IMPORTED_MODULE_1_react_responsive_carousel__","1330","_Carousel","_Carousel2","_Thumbs","_Thumbs2","1331","_extends","_reactDom2","_customPropTypes","customPropTypes","newObj","defaultStatusFormatter","setCarouselWrapperRef","carouselWrapperRef","setListRef","listRef","setItemsRef","itemsRef","clearTimeout","timer","increment","clearAutoPlay","resetAutoPlay","isMouseEntered","startOnLeave","navigateWithKeyboard","keyNames","ArrowUp","ArrowRight","ArrowDown","ArrowLeft","nextKey","prevKey","keyCode","decrement","initialized","cancelClick","onClickItem","handleOnChange","handleClickThumb","onClickThumb","selectItem","resetPosition","getPosition","finalBoundry","axisDelta","handledDelta","setPosition","hasMoved","swipeScrollTolerance","list","findDOMNode","changeItem","newIndex","getInitialImage","getVariableImageHeight","onImageLoad","forceUpdate","setupCarousel","setupAutoPlay","destroyAutoPlay","destroyCarousel","initialImage","carouselWrapper","useKeyboardArrows","centerMode","centerSlidePercentage","slideProps","minWidth","_this3","showIndicators","statusFormatter","showThumbs","itemsLength","canShowArrows","swiperProps","tolerance","containerStyles","dynamicHeight","onSwipeUp","verticalSwipe","onSwipeDown","swipeable","allowMouseEvents","emulateTouch","renderControls","renderStatus","renderThumbs","propTypes","bool","oneOf","1332","setHasSupportToCaptureOption","hasSupport","supportsCaptureOption","getSafeEventHandlerOpts","capture","_event$touches$","pageX","pageY","screenX","screenY","ReactSwipe","_handleSwipeStart","_handleSwipeMove","_handleSwipeEnd","_onMouseDown","_onMouseMove","_onMouseUp","swiper","mouseDown","_getPosition","moveStart","_getPosition2","moving","preventDefault","movePosition","onMouseDown","onTouchStart","onTouchEnd","1333","marginLeft","marginRight","1334","propName","componentName","test","1335","__WEBPACK_IMPORTED_MODULE_2_react_router_dom__","__WEBPACK_IMPORTED_MODULE_4__state_ManagerTeamSurvey_action__","__WEBPACK_IMPORTED_MODULE_5__shared_FormattedMessage__","Column","PendingsManager","getPendingsColumns","record","Supply","supply","idSupply","companySize","CompanySize","idCompanySize","column","getManagerTeamSurvey","rowKey","managerTeamSurvey","1336","__WEBPACK_IMPORTED_MODULE_4__state_TechnicalTeamSurvey_action__","PendingsTechnical","1337","__WEBPACK_IMPORTED_MODULE_4__state_Pendings_action__","PendingsEvaluator","states","idStateSupplier","pendings","1338","__WEBPACK_IMPORTED_MODULE_4__shared_FormattedMessage__","PendingsSupplier","userInfo"],"mappings":"AAAAA,cAAc,IAERC,KACA,SAAUC,EAAQC,EAAqBC,GAE7C,YCFA,SAASC,KACP,MACEC,GAAAC,EAAAC,cAACC,EAAA,EAAD,MDCJC,OAAOC,eAAeR,EAAqB,cAAgBS,OAAO,GAC7C,IAAIC,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GACpEJ,EAA+DL,EAAoB,KCA5GD,GAAA,WDKMY,KACA,SAAUb,EAAQc,EAASZ,GAEjC,YEfAF,GAAAc,QAAAZ,EAAA,MACAF,EAAAc,QAAAC,OAAAb,EAAA,MACAF,EAAAc,QAAAE,OAAAd,EAAA,MACAF,EAAAc,QAAAG,QAAAf,EAAA,OFuBMgB,KACA,SAAUlB,EAAQc,EAASZ,GAEjC,YG7BA,IAAAiB,GAAAjB,EAAA,KAEAF,GAAAc,SAIAM,KAAA,SAAAC,EAAAC,GACA,MAAAH,GAAAI,MAAAC,KAAAH,KAAAG,KAAAH,OAAuDC,MHuCjDG,KACA,SAAUzB,EAAQc,EAASZ,GAEjC,YI9CA,SAAAwB,GAAAC,EAAAC,EAAAC,EAAAC,GACA,GACAC,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EADAC,EAAAhC,OAAAgC,KAAAX,EAGA,KAAAE,EAAA,EAAAC,EAAAQ,EAAAC,OAAgCV,EAAAC,IAAUD,EAa1C,GAZAE,EAAAO,EAAAT,GAEAK,EAAAP,EAAAI,GAIAL,EAAAc,eAAAT,KACAL,EAAAK,GAAAG,IAGAF,EAAAN,EAAAK,MAEAG,GAAA,MAAAH,EAAA,IAYA,GARAN,EAAAe,eAAAT,KACAN,EAAAM,GAAAC,GAGAC,EAAAR,EAAAM,IAEAI,QAAAD,YAEAD,GACA,cAAAE,GAEA,GADAC,EAAAK,EAAAR,GACAG,EAAAM,QACAL,EAAAI,EAAAP,GACAG,EAAAK,OAAA,CACAhB,EAAAK,GAAAM,EAAAM,IAAAP,EAAAR,GAAAgB,WACA,eAGI,eAAAT,GAAAU,SAAAZ,IAAAY,SAAAX,GAAA,CACJR,EAAAK,GAAAE,GAAAC,EAAAD,GAAAL,CACA,UAIAF,EAAAK,GAAAG,GAhDA,GAAAO,GAAAzC,EAAA,MACAiB,EAAAjB,EAAA,MAmDA8C,EAAA,SAAAC,GACA9B,EAAA+B,OAAA1B,KAAAyB,GACAzB,KAAA2B,WAAAC,MAAA5B,KAAA6B,WAGAlC,GAAA+B,OAAAF,EAAAM,WAEAH,WAAA,WACA3B,KAAA+B,QAAA,GAGAC,MAAA,WACA,GAAAC,GAAAjC,IAKA,OAJAiC,GAAAC,QACAD,EAAAC,MAAAvC,EAAAwC,MAAAF,EAAAG,SAEAH,EAAAI,UACAJ,GAGAK,WAAA,SAAAhC,GACA,GAAA2B,GAAAjC,KACAK,EAAA4B,EAAAG,OACAjC,EAAA8B,EAAAI,OACAjC,EAAA6B,EAAAC,KAGA,OAAA7B,IAAA,IAAAC,GAMAF,IACAA,EAAA6B,EAAAC,UAGA/B,IACAA,EAAA8B,EAAAI,WAGAnC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA2B,IAfAA,EAAAC,MAAA7B,EACA4B,EAAAI,OAAA,KACAJ,IAgBAM,gBAAA,WACA,OACAC,EAAAxC,KAAAoC,OAAAI,EACAC,EAAAzC,KAAAoC,OAAAK,IAIAC,SAAA,WACA,MAAA/C,GAAAgD,SAAA3C,KAAAoC,OAAAI,IAAA7C,EAAAgD,SAAA3C,KAAAoC,OAAAK,MAIAjB,EAAAE,OAAA/B,EAAAiD,SAEApE,EAAAc,QAAAkC,GJyDMqB,KACA,SAAUrE,EAAQc,EAASZ,GAEjC,YK5KAF,GAAAc,WACAd,EAAAc,QAAAwD,IAAApE,EAAA,MACAF,EAAAc,QAAAyD,KAAArE,EAAA,MACAF,EAAAc,QAAA0D,MAAAtE,EAAA,MACAF,EAAAc,QAAA2D,UAAAvE,EAAA,OLoLMwE,KACA,SAAU1E,EAAQc,EAASZ,GAEjC,YMzLA,SAAAyE,GAAAC,EAAAC,GACA,MAAA1D,GAAA2D,MAAAF,EAAA,SAAAG,GACA,MAAAA,GAAAF,eAIA,QAAAG,GAAAJ,EAAAK,GACAL,EAAAM,QAAA,SAAAH,EAAAhD,GAEA,MADAgD,GAAAI,WAAApD,EACAgD,IAEAH,EAAAQ,KAAA,SAAA/E,EAAAgF,GACA,GAAAC,GAAAL,EAAAI,EAAAhF,EACAkF,EAAAN,EAAA5E,EAAAgF,CACA,OAAAC,GAAAE,SAAAD,EAAAC,OACAF,EAAAH,WAAAI,EAAAJ,WACAG,EAAAE,OAAAD,EAAAC,SAEAZ,EAAAM,QAAA,SAAAH,SACAA,GAAAI,aArBA,GAAAhE,GAAAjB,EAAA,KA6CAF,GAAAc,SACA2E,YAQAC,OAAA,SAAAC,EAAAC,GACAD,EAAAE,QACAF,EAAAE,UAIAD,EAAAE,UAAAF,EAAAE,YAAA,EACAF,EAAAf,SAAAe,EAAAf,UAAA,MACAe,EAAAJ,OAAAI,EAAAJ,QAAA,EAEAG,EAAAE,MAAAE,KAAAH,IAQAI,UAAA,SAAAL,EAAAM,GACA,GAAAC,GAAAP,EAAAE,MAAAF,EAAAE,MAAAM,QAAAF,IAAA,GACA,IAAAC,GACAP,EAAAE,MAAAO,OAAAF,EAAA,IAUAG,UAAA,SAAAV,EAAAC,EAAA3E,GAMA,IALA,GAGAqF,GAHAC,GAAA,iCACAvE,EAAAuE,EAAA9D,OACAV,EAAA,EAGQA,EAAAC,IAAUD,EAClBuE,EAAAC,EAAAxE,GACAd,EAAAyB,eAAA4D,KACAV,EAAAU,GAAArF,EAAAqF,KAYAE,OAAA,SAAAb,EAAAc,EAAAC,GA8EA,QAAAC,GAAAC,GACA,GAAAC,GACAC,EAAAF,EAAAE,cAEAA,IACAD,EAAAD,EAAAJ,OAAAI,EAAAd,UAAAiB,EAAAC,EAAAC,GACAC,GAAAL,EAAAH,SAEAG,EAAAD,EAAAJ,OAAAW,EAAAD,GACAF,GAAAH,EAAAJ,OAGAW,EAAArB,MACAsB,WAAAP,EACAD,UACAD,QAqCA,QAAAU,GAAAV,GACA,GAAAW,GAAApG,EAAAqG,cAAAJ,EAAA,SAAAK,GACA,MAAAA,GAAAb,SAGA,IAAAW,EACA,GAAAX,EAAAE,eAAA,CACA,GAAAY,IACAC,KAAAC,KAAAC,IAAAC,EAAAC,GACAC,MAAAJ,KAAAC,IAAAI,EAAAC,GACAC,IAAA,EACAC,OAAA,EAKAxB,GAAAJ,OAAAI,EAAAd,UAAAiB,EAAAC,EAAAqB,EAAA,EAAAX,OAEAd,GAAAJ,OAAAe,EAAAV,QAAAJ,MAAAS,GA4BA,QAAAoB,GAAA1B,GACA,GAAAW,GAAApG,EAAAqG,cAAAJ,EAAA,SAAAP,GACA,MAAAA,GAAAD,UAGAc,GACAC,KAAA,EACAK,MAAA,EACAG,IAAAI,EACAH,OAAAI,EAGAjB,IACAX,EAAAJ,OAAAe,EAAAV,QAAAJ,MAAAS,EAAAQ,GAwEA,QAAAe,GAAA7B,GACAA,EAAAE,gBACAF,EAAAe,KAAAf,EAAAd,UAAA4C,EAAAZ,EACAlB,EAAAoB,MAAApB,EAAAd,UAAAW,EAAAkC,EAAAb,EAAAd,EACAJ,EAAAuB,MACAvB,EAAAwB,OAAAD,EAAAvB,EAAAF,OAGAyB,EAAAvB,EAAAwB,SAIAxB,EAAAe,OACAf,EAAAoB,MAAAL,EAAAf,EAAAH,MACAG,EAAAuB,IAAAI,EACA3B,EAAAwB,OAAAG,EAAArB,EAGAS,EAAAf,EAAAoB,OAtRA,GAAArC,EAAA,CAIA,GAAAiD,GAAAjD,EAAA1E,QAAA4H,WACAC,EAAA3H,EAAAF,QAAA8H,UAAAH,EAAAE,SACAJ,EAAAI,EAAAnB,KACAgB,EAAAG,EAAAd,MACAgB,EAAAF,EAAAX,IACAc,EAAAH,EAAAV,OAEAc,EAAAvE,EAAAgB,EAAAE,MAAA,QACAsD,EAAAxE,EAAAgB,EAAAE,MAAA,SACAuD,EAAAzE,EAAAgB,EAAAE,MAAA,OACAwD,EAAA1E,EAAAgB,EAAAE,MAAA,UACAyD,EAAA3E,EAAAgB,EAAAE,MAAA,YAGAb,GAAAkE,GAAA,GACAlE,EAAAmE,GAAA,GACAnE,EAAAoE,GAAA,GACApE,EAAAqE,GAAA,EAwCA,IAAAtC,GAAAN,EAAAiC,EAAAC,EACAN,EAAA3B,EAAAsC,EAAAC,EACAM,EAAAxC,EAAA,EACAyC,EAAAnB,EAAA,EAGAlB,GAAAV,EAAA8C,IAAAL,EAAAzG,OAAA0G,EAAA1G,QAGAwE,GAAAP,EAAA8C,IAAAJ,EAAA3G,OAAA4G,EAAA5G,QAGAuE,EAAAD,EACAG,EAAAmB,EACAjB,IAqBAjG,GAAAsI,KAAAP,EAAAQ,OAAAP,EAAAC,EAAAC,GAAA1C,EAGA,IAAAoB,GAAA,EACAG,EAAA,EACAyB,EAAA,EACAC,EAAA,CAEAzI,GAAAsI,KAAAL,EAAAM,OAAAL,GAAA,SAAAQ,GACA,GAAAA,EAAAC,WAAA,CACA,GAAAC,GAAAF,EAAAC,YACA/B,GAAAH,KAAAC,IAAAE,EAAAgC,EAAApC,MACAO,EAAAN,KAAAC,IAAAK,EAAA6B,EAAA/B,UAIA7G,EAAAsI,KAAAP,EAAAQ,OAAAP,GAAA,SAAAa,GACA,GAAAA,EAAAF,WAAA,CACA,GAAAC,GAAAC,EAAAF,YACAH,GAAA/B,KAAAC,IAAA8B,EAAAI,EAAA5B,KACAyB,EAAAhC,KAAAC,IAAA+B,EAAAG,EAAA3B,UAOA,IAAAN,GAAAY,EACAT,EAAAU,EACAJ,EAAAS,EACAR,EAAAS,CA2BA9H,GAAAsI,KAAAP,EAAAQ,OAAAP,GAAA7B,GAEAnG,EAAAsI,KAAAP,EAAA,SAAAtC,GACAkB,GAAAlB,EAAAH,QAGAtF,EAAAsI,KAAAN,EAAA,SAAAvC,GACAqB,GAAArB,EAAAH,QAIAtF,EAAAsI,KAAAL,EAAAM,OAAAL,GAAA/B,GAGAnG,EAAAsI,KAAAL,EAAA,SAAAxC,GACA2B,GAAA3B,EAAAF,SAGAvF,EAAAsI,KAAAJ,EAAA,SAAAzC,GACA4B,GAAA5B,EAAAF,SAqBAvF,EAAAsI,KAAAP,EAAAQ,OAAAP,GAAAb,GAGAR,EAAAY,EACAT,EAAAU,EACAJ,EAAAS,EACAR,EAAAS,EAEA9H,EAAAsI,KAAAP,EAAA,SAAAtC,GACAkB,GAAAlB,EAAAH,QAGAtF,EAAAsI,KAAAN,EAAA,SAAAvC,GACAqB,GAAArB,EAAAH,QAGAtF,EAAAsI,KAAAL,EAAA,SAAAxC,GACA2B,GAAA3B,EAAAF,SAEAvF,EAAAsI,KAAAJ,EAAA,SAAAzC,GACA4B,GAAA5B,EAAAF,QAIA,IAAAuD,GAAArC,KAAAC,IAAAE,EAAAD,EAAA,EACAA,IAAAmC,EACAhC,GAAAL,KAAAC,IAAAK,EAAAD,EAAA,EAEA,IAAAiC,GAAAtC,KAAAC,IAAA8B,EAAApB,EAAA,EACAA,IAAA2B,EACA1B,GAAAZ,KAAAC,IAAA+B,EAAApB,EAAA,EAKA,IAAA2B,GAAAzD,EAAA6B,EAAAC,EACA4B,EAAA3D,EAAAqB,EAAAG,CAEAmC,KAAApD,GAAAmD,IAAAjD,IACA/F,EAAAsI,KAAAP,EAAA,SAAAtC,GACAA,EAAAF,OAAAyD,IAGAhJ,EAAAsI,KAAAN,EAAA,SAAAvC,GACAA,EAAAF,OAAAyD,IAGAhJ,EAAAsI,KAAAL,EAAA,SAAAxC,GACAA,EAAAd,YACAc,EAAAH,MAAA2D,KAIAjJ,EAAAsI,KAAAJ,EAAA,SAAAzC,GACAA,EAAAd,YACAc,EAAAH,MAAA2D,KAIAlD,EAAAiD,EACAnD,EAAAoD,EAIA,IAAAzC,GAAAe,EAAAuB,EACA9B,EAAAa,EAAAkB,CAwBA/I,GAAAsI,KAAAP,EAAAQ,OAAAN,GAAAX,GAGAd,GAAAX,EACAmB,GAAAjB,EAEA/F,EAAAsI,KAAAN,EAAAV,GACAtH,EAAAsI,KAAAJ,EAAAZ,GAGA9C,EAAA0E,WACA1C,KAAAG,EACAK,IAAAI,EACAP,MAAAF,EAAAd,EACAoB,OAAAG,EAAArB,GAIA/F,EAAAsI,KAAAH,EAAA,SAAA1C,GACAA,EAAAe,KAAAhC,EAAA0E,UAAA1C,KACAf,EAAAuB,IAAAxC,EAAA0E,UAAAlC,IACAvB,EAAAoB,MAAArC,EAAA0E,UAAArC,MACApB,EAAAwB,OAAAzC,EAAA0E,UAAAjC,OAEAxB,EAAAJ,OAAAQ,EAAAE,SNsMMoD,KACA,SAAUtK,EAAQc,EAASZ,GAEjC,YOtmBA,IAAAiB,GAAAjB,EAAA,KAMAF,GAAAc,SAKAyJ,YAOAjJ,OAAA,SAAAZ,GACA,MAAAS,GAAAqJ,QAAA9J,KAAA,GAAAA,GAWA+J,OAAA,SAAAC,EAAAxE,EAAAyE,GAEA,GAAAC,GAAAD,EAAAlI,OAAA,EAAAkI,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,EAGA/C,MAAAiD,IAAAD,GAAA,GACAF,IAAA9C,KAAAkD,MAAAJ,KAEAE,EAAAF,EAAA9C,KAAAkD,MAAAJ,GAIA,IAAAK,GAAA5J,EAAA6J,MAAApD,KAAAiD,IAAAD,IACAK,EAAA,EAEA,QAAAP,EAAA,CACA,GAAAQ,IAAA,EAAAtD,KAAAkD,MAAAC,EACAG,GAAAtD,KAAAC,IAAAD,KAAAuD,IAAAD,EAAA,OACAD,EAAAP,EAAAU,QAAAF,OAEAD,GAAA,GAGA,OAAAA,IAGAI,YAAA,SAAAX,EAAAxE,EAAAyE,GACA,GAAAW,GAAAZ,EAAA9C,KAAA2D,IAAA,GAAA3D,KAAAkD,MAAA3J,EAAA6J,MAAAN,IAEA,YAAAA,EACA,IACI,IAAAY,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAApF,OAAAyE,EAAAlI,OAAA,EACJiI,EAAAc,gBAEA,OPinBMC,KACA,SAAUzL,EAAQc,EAASZ,GAEjC,YQjrBA,IAAAiB,IAIAuK,KAAA,aAOAC,IAAA,WACA,GAAAC,GAAA,CACA,mBACA,MAAAA,SAUAC,cAAA,SAAAnL,GACA,cAAAA,GAAA,oBAAAA,IASA8J,QAAAsB,MAAAtB,QAAAsB,MAAAtB,QAAA,SAAA9J,GACA,yBAAAF,OAAA8C,UAAAyI,SAAAC,KAAAtL,IASAuL,SAAA,SAAAvL,GACA,cAAAA,GAAA,oBAAAF,OAAA8C,UAAAyI,SAAAC,KAAAtL,IASAwL,eAAA,SAAAxL,EAAAyL,GACA,0BAAAzL,GAAAyL,EAAAzL,GAUA0L,sBAAA,SAAA1L,EAAAwF,EAAAiG,GACA,MAAAhL,GAAA+K,eAAA/K,EAAAqJ,QAAA9J,KAAAwF,GAAAxF,EAAAyL,IAWAE,SAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAF,GAAA,mBAAAA,GAAAN,KACA,MAAAM,GAAAlJ,MAAAoJ,EAAAD,IAaA9C,KAAA,SAAAgD,EAAAH,EAAAE,EAAAvH,GACA,GAAAlD,GAAA2K,EAAAlK,CACA,IAAArB,EAAAqJ,QAAAiC,GAEA,GADAC,EAAAD,EAAAhK,OACAwC,EACA,IAAAlD,EAAA2K,EAAA,EAAqB3K,GAAA,EAAQA,IAC7BuK,EAAAN,KAAAQ,EAAAC,EAAA1K,UAGA,KAAAA,EAAA,EAAeA,EAAA2K,EAAS3K,IACxBuK,EAAAN,KAAAQ,EAAAC,EAAA1K,UAGG,IAAAZ,EAAA8K,SAAAQ,GAGH,IAFAjK,EAAAhC,OAAAgC,KAAAiK,GACAC,EAAAlK,EAAAC,OACAV,EAAA,EAAcA,EAAA2K,EAAS3K,IACvBuK,EAAAN,KAAAQ,EAAAC,EAAAjK,EAAAT,IAAAS,EAAAT,KAYA4K,YAAA,SAAAC,EAAAC,GACA,GAAA9K,GAAAC,EAAAsD,EAAAC,CAEA,KAAAqH,IAAAC,GAAAD,EAAAnK,SAAAoK,EAAApK,OACA,QAGA,KAAAV,EAAA,EAAAC,EAAA4K,EAAAnK,OAA+BV,EAAAC,IAAUD,EAIzC,GAHAuD,EAAAsH,EAAA7K,GACAwD,EAAAsH,EAAA9K,GAEAuD,YAAAwG,QAAAvG,YAAAuG,QACA,IAAA3K,EAAAwL,YAAArH,EAAAC,GACA,aAEI,IAAAD,IAAAC,EAEJ,QAIA,WAQA5B,MAAA,SAAAmJ,GACA,GAAA3L,EAAAqJ,QAAAsC,GACA,MAAAA,GAAAC,IAAA5L,EAAAwC,MAGA,IAAAxC,EAAA8K,SAAAa,GAAA,CAMA,IALA,GAAA1K,MACAI,EAAAhC,OAAAgC,KAAAsK,GACAE,EAAAxK,EAAAC,OACAwK,EAAA,EAESA,EAAAD,IAAUC,EACnB7K,EAAAI,EAAAyK,IAAA9L,EAAAwC,MAAAmJ,EAAAtK,EAAAyK,IAGA,OAAA7K,GAGA,MAAA0K,IAQAI,QAAA,SAAAjL,EAAAG,EAAA0K,EAAA7L,GACA,GAAAkM,GAAA/K,EAAAH,GACAmL,EAAAN,EAAA7K,EAEAd,GAAA8K,SAAAkB,IAAAhM,EAAA8K,SAAAmB,GACAjM,EAAAI,MAAA4L,EAAAC,EAAAnM,GAEAmB,EAAAH,GAAAd,EAAAwC,MAAAyJ,IAQAC,UAAA,SAAApL,EAAAG,EAAA0K,GACA,GAAAK,GAAA/K,EAAAH,GACAmL,EAAAN,EAAA7K,EAEAd,GAAA8K,SAAAkB,IAAAhM,EAAA8K,SAAAmB,GACAjM,EAAAmM,QAAAH,EAAAC,GACGhL,EAAAM,eAAAT,KACHG,EAAAH,GAAAd,EAAAwC,MAAAyJ,KAaA7L,MAAA,SAAAa,EAAA0K,EAAA7L,GACA,GAEAM,GAAAQ,EAAAS,EAAAwK,EAAAC,EAFAM,EAAApM,EAAAqJ,QAAAsC,SACA9K,EAAAuL,EAAA9K,MAGA,KAAAtB,EAAA8K,SAAA7J,GACA,MAAAA,EAMA,KAHAnB,QACAM,EAAAN,EAAAuM,QAAArM,EAAA+L,QAEAnL,EAAA,EAAaA,EAAAC,IAAUD,EAEvB,GADA+K,EAAAS,EAAAxL,GACAZ,EAAA8K,SAAAa,GAKA,IADAtK,EAAAhC,OAAAgC,KAAAsK,GACAG,EAAA,EAAAD,EAAAxK,EAAAC,OAAkCwK,EAAAD,IAAUC,EAC5C1L,EAAAiB,EAAAyK,GAAA7K,EAAA0K,EAAA7L,EAIA,OAAAmB,IAUAkL,QAAA,SAAAlL,EAAA0K,GACA,MAAA3L,GAAAI,MAAAa,EAAA0K,GAAwCU,OAAArM,EAAAkM,aAUxCnK,OAAA,SAAAd,GAIA,OAHAqL,GAAA,SAAA/M,EAAAuB,GACAG,EAAAH,GAAAvB,GAEAqB,EAAA,EAAAC,EAAAqB,UAAAZ,OAA0CV,EAAAC,IAAUD,EACpDZ,EAAAsI,KAAApG,UAAAtB,GAAA0L,EAEA,OAAArL,IAMAgC,SAAA,SAAAsJ,GACA,GAAAjK,GAAAjC,KACAmM,EAAAD,KAAAhL,eAAA,eAAAgL,EAAAE,YAAA,WACA,MAAAnK,GAAAL,MAAA5B,KAAA6B,YAGAwK,EAAA,WACArM,KAAAoM,YAAAD,EAYA,OATAE,GAAAvK,UAAAG,EAAAH,UACAqK,EAAArK,UAAA,GAAAuK,GACAF,EAAAzK,OAAA/B,EAAAiD,SAEAsJ,GACAvM,EAAA+B,OAAAyK,EAAArK,UAAAoK,GAGAC,EAAAG,UAAArK,EAAAH,UACAqK,GAIA3N,GAAAc,QAAAK,EAWAA,EAAA4M,aAAA5M,EAAAkL,SAUAlL,EAAAgF,QAAA,SAAAvB,EAAAgB,EAAAoI,GACA,MAAAlC,OAAAxI,UAAA6C,QAAA6F,KAAApH,EAAAgB,EAAAoI,IAUA7M,EAAA8M,kBAAA9M,EAAA+K,eASA/K,EAAA+M,yBAAA/M,EAAAiL,uBR4rBM+B,KACA,SAAUnO,EAAQC,EAAqBC,GAE7C,YS/gCA,SAASkO,KACP,MAAOC,GAAA,EAASC,IAAI,kCAGtB,QAASC,GAA4BC,GACnC,MAAOH,GAAA,EAASI,KAAK,qBAAsBD,GT2gCdtO,EAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOmO,KACpElO,EAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOsO,IAC9E,IAAIF,GAA0CnO,EAAoB,KAKjFyO,KACA,SAAU3O,EAAQC,EAAqBC,GAE7C,YACAM,QAAOC,eAAeR,EAAqB,cAAgBS,OAAO,IACnCR,EAAoBwO,EAAEzO,EAAqB,yBAA0B,WAAa,MAAO2O,KACzF1O,EAAoBwO,EAAEzO,EAAqB,mBAAoB,WAAa,MAAO4O,KACnF3O,EAAoBwO,EAAEzO,EAAqB,4BAA6B,WAAa,MAAO6O,KAC5F5O,EAAoBwO,EAAEzO,EAAqB,WAAY,WAAa,MAAO8O,KAC3E7O,EAAoBwO,EAAEzO,EAAqB,aAAc,WAAa,MAAO+O,KAC7E9O,EAAoBwO,EAAEzO,EAAqB,4BAA6B,WAAa,MAAOgP,IACtG,IAAIC,GAAuChP,EAAoB,KAC3DiP,EAA0CjP,EAAoB,KAC9DkP,EAAyDlP,EAAoB,MAC7EmP,EAA8CnP,EAAoB,KAClEoP,EAA8CpP,EAAoB,KAClEqP,EAAgDrP,EAAoB,KUvhCvFsP,EAAqC,kBACzCnN,KAAM6M,EAAA,IAGFO,EAAoC,SAAAjB,GAAA,OACxCnM,KAAM6M,EAAA,EACNV,SAGIK,EAAmB,kBACvBxM,KAAM6M,EAAA,IAGFJ,EAA4B,SAAAN,GAAA,OAChCnM,KAAM6M,EAAA,EACNV,SAGIkB,EAAiB,kBACrBrN,KAAM6M,EAAA,IAGFS,EAAc,SAACC,EAAYhE,EAAIiE,EAAQnP,GAAzB,OAClB2B,KAAM6M,EAAA,EACNU,aACAC,SACAnP,QACAoP,KAAMlE,IAGFmE,EAAgB,SAACH,EAAYhE,EAAIoE,EAAStP,GAA1B,OACpB2B,KAAM6M,EAAA,EACNU,aACAI,UACAtP,QACAoP,KAAMlE,IAGFqE,EAAe,SAAAzB,GAAA,OACnBnM,KAAM6M,EAAA,EACNV,SAGI0B,EAAkB,SAACC,EAAaC,GAAd,OACtB/N,KAAM6M,EAAA,EACNiB,cACAC,sBAGIrB,EAAW,SAACa,EAAYlP,EAAOmP,GAApB,MAA+B,UAACQ,GAC/C7P,OAAA8O,EAAA,GAAWe,EAAUb,EAAoCJ,EAAA,EAA4BS,GAClFS,KAAK,SAACC,GACLF,EAASV,EAAYC,EAAYC,EAAOjE,GAAI2E,EAAS/B,KAAKA,KAAM9N,IAChE2P,EAASX,OACRc,MAAM,WACPH,EAASV,EAAYC,EAAYC,EAAOjE,GAAIiE,EAAQ,OACpDQ,EAASxB,SAITG,EAAa,SAACY,EAAYlP,EAAOsP,GAApB,MAAgC,UAACK,EAAUI,GACxCA,IAAWC,oBAAoBlC,KAAKmC,UAAUC,KAChE,SAAAC,GAAA,MAAWA,GAAQjF,KAAOgE,IAAYkB,SAASF,KAC/C,SAAAC,GAAA,MAAWA,GAAQE,YAAcf,EAAQe,YAAWrQ,QAClCA,GAClBF,OAAA8O,EAAA,GAAWe,EAAUb,EAAoCJ,EAAA,EAA6BY,GACnFM,KAAK,SAACC,GACLF,EAASN,EAAcH,EAAYI,EAAQpE,GAAI2E,EAAS/B,KAAKA,KAAM9N,MAClE8P,MAAM,WACPH,EAASN,EAAcH,EAAYI,EAAQpE,GAAIoE,EAAS,OACxDK,EAASxB,SAKXD,EAAyB,cAACoC,GAAD3N,UAAAZ,OAAA,OAAAwO,KAAA5N,UAAA,GAAAA,UAAA,GAAQ,GAAI6N,EAAZ7N,UAAAZ,OAAA,OAAAwO,KAAA5N,UAAA,GAAAA,UAAA,GAAyB,EAAzB,OAAgC,UAACgN,GAC9D7P,OAAA8O,EAAA,GAAWe,EAAUb,EAAoCL,EAAA,EAA2B6B,GACjFV,KAAK,SAACC,GAAa,GACV/B,GAAS+B,EAAS/B,KAAlBA,IACRA,GAAKmC,UAAYnC,EAAKmC,UAAU5D,IAAI,SAACoE,GACnC,GAAMC,GAAiB5C,EAAK6C,gBAAgBT,KAC1C,SAAAC,GAAA,MAAWA,GAAQjB,aAAeuB,EAASvF,KAEvC0F,EAAmBF,EAAexF,GAClC2F,EAAUH,EAAeG,QAEzBC,EAAQhD,EAAKiD,QAAQC,KAAK3E,IAAI,SAACnH,GACnC,GAAMiK,GAASrB,EAAKiD,QAAQE,oBACzBf,KAAK,SAAAC,GAAA,MACJA,GAAQe,SAAWhM,EAAKgG,IAAMiF,EAAQS,mBAAqBA,IACzDO,EAAShC,EACbrB,EAAKiD,QAAQK,gBACVlB,KAAK,SAAAC,GAAA,MAAWA,GAAQjF,KAAOiE,EAAOkC,oBAAqB,IAChE,QACEnG,GAAIhG,EAAKgG,GACTmF,UAAWnL,EAAKmL,UAChB5E,cACElK,IAAK4P,EAASA,EAAOjG,GAAK,KAC1BoG,KAAMH,EAASA,EAAOG,KAAO,MAE/BtR,MAAOmR,EAASA,EAAOI,MAAQ,KAC/BC,OAAO,KAILpB,KACAqB,IACN3D,GAAKiD,QAAQW,QAAQlN,QAAQ,SAACmN,GAC5B,GAAMrC,GAAUxB,EAAKiD,QAAQa,qBAAqB1B,KAAK,SAAAC,GAAA,MACrDA,GAAQS,mBAAqBA,GAAoBT,EAAQE,YAAcsB,EAAQzG,IACjFkF,GAAS/K,MACPgL,UAAWsB,EAAQzG,GACnBlL,MAAOsP,EAAUA,EAAQA,QAAU,KAErCmC,EAAOpM,MACLgL,UAAWsB,EAAQzG,GACnBlL,MAAO,QAIX,IAAM6R,GAAQ/D,EAAKiD,QAAQe,MAAM5B,KAAK,SAAAC,GAAA,MAAWA,GAAQjF,KAAO2F,IAASkB,UACnEC,EACO,+BAAVH,GAAoD,mBAAVA,GACI,KAA9CnB,EAAeuB,4BAChBvB,EAAeuB,6BAA+BnE,EAAKiD,QAAQmB,KAAK,GAAGZ,KAE/Da,GAAYH,GAChBtB,EAAeuB,6BAA+BnE,EAAKiD,QAAQmB,KAAK,GAAGZ,IASrE,OAPAb,GAAS2B,SAAU,EACnB3B,EAASuB,SAAWA,EACpBvB,EAAS0B,SAAWA,EACpB1B,EAASK,MAAQA,EACjBL,EAASL,SAAWA,EACpBK,EAASgB,OAASA,EAClBhB,EAAS4B,MAAQ,KACV5B,IAET3C,EAAKiD,QAAQW,QAAQrM,MACnB6F,GAAI,QACJoG,KAAM,kBAERxD,EAAKiD,QAAQW,QAAQlN,QAAQ,SAACmN,EAASnM,GAClB,UAAfmM,EAAQzG,KACV4C,EAAKiD,QAAQC,KAAOlD,EAAKiD,QAAQC,KAAKhI,SAElCqH,UAAWsB,EAAQzG,GACnBA,aAAc1F,EAAM6F,WACpB1J,KAAM,UACN2P,KAAM,gBAGNjB,UAAWsB,EAAQzG,GACnBA,cAAe1F,EAAM6F,WACrBiH,kBAAmBX,EAAQzG,GAC3BvJ,KAAM,WACN2P,KAAM,YAIZxD,EAAKiD,QAAQC,KAAK3L,MAChBgL,UAAW,QACXnF,WAAY1F,EAAM6F,WAClBiH,kBAAmBX,EAAQzG,GAC3BvJ,KAAM6D,EAAQsI,EAAKiD,QAAQW,QAAQ3P,OAAS,EAAI,WAAa,QAC7DuP,KAAM9L,EAAQsI,EAAKiD,QAAQW,QAAQ3P,OAAS,EAAI4P,EAAQL,KAAO,oBAGnExD,EAAKiD,QAAQK,gBAAkBtR,OAAA8O,EAAA,GAAYd,EAAKiD,QAAQK,gBAAiB,SACzEtD,EAAK0C,WAAaA,EAClBb,EAASZ,EAAkCjB,IAC3C6B,EAASX,OACRc,MAAM,WACPH,EAASxB,SAITI,EAA4B,iBAAM,UAACoB,EAAUI,GAAa,GAAAwC,GACvBxC,IAAWC,oBAAoBlC,KAA9DmC,EADsDsC,EACtDtC,UAAWU,EAD2C4B,EAC3C5B,gBACbjB,KACAD,KACA+C,EAAgBvC,EAAU5D,IAAI,SAACoE,GACnC,GAAMgC,oBACDhC,GACHK,MAAOL,EAASK,MAAMzE,IAAI,SAAAnH,GAAA,MAAApF,QAAA4S,UACrBxN,GACHsM,MAAOf,EAAS2B,SAAW3B,EAAS0B,WAAajN,EAAKlF,WAU1D,OAPIyQ,GAAS2B,UAAY3B,EAASuB,UAC5BvB,EAASK,MAAM6B,OAAO,SAAAzN,GAAA,MAAQA,GAAKlF,QAAO+B,SAAW0O,EAASK,MAAM/O,SACtE2N,EAAkBrK,KAChBsL,EAAgBT,KAAK,SAAAC,GAAA,MAAWA,GAAQjB,aAAeuB,EAASvF,KAAIA,IACtEuE,EAAYpK,KAAKoL,EAASvF,KAGvBuH,GAGLxC,GAAU0C,OAAO,SAAAxC,GAAA,MAAWA,GAAQgC,WAAUpQ,SAAW2N,EAAkB3N,OAC7EjC,OAAA8O,EAAA,GAAWe,EAAUb,EAAoCH,EAAA,GACrDe,sBACDE,KAAK,WACJD,EAASJ,EAAaiD,IACtB7C,EAASH,EAAgBC,EAAaC,MACrCI,MAAM,WACPH,EAASxB,QAGbwB,EAASJ,EAAaiD,IACtB1S,OAAA+O,EAAA,GAAW,4DAA6D,aV00BtE+D,KACA,SAAUtT,EAAQC,EAAqBC,GAE7C,YAC+BA,GAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOsT,KACpErT,EAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOuT,IAC9E,IAAInF,GAA0CnO,EAAoB,IWljCjFqT,EAA6B,SAAA/E,GAAA,MAAQH,GAAA,EAAQI,KAAK,kCAAmCD,IAErFgF,EAA8B,SAAAhF,GAAA,MAAQH,GAAA,EAAQI,KAAK,mCAAoCD,KXqjCvFiF,KACA,SAAUzT,EAAQC,EAAqBC,GAE7C,YACAM,QAAOC,eAAeR,EAAqB,cAAgBS,OAAO,IACnCR,EAAoBwO,EAAEzO,EAAqB,cAAe,WAAa,MAAOyT,KAC9ExT,EAAoBwO,EAAEzO,EAAqB,mBAAoB,WAAa,MAAO4O,KACnF3O,EAAoBwO,EAAEzO,EAAqB,iBAAkB,WAAa,MAAO0T,IAC3F,IAAIzE,GAAuChP,EAAoB,KAC3D0T,EAA8C1T,EAAoB,KAClE2T,EAA8C3T,EAAoB,KYzjCrF4T,EAA0B,kBAC9BzR,KAAM6M,EAAA,IAGF6E,EAAyB,SAAAvF,GAAA,OAC7BnM,KAAM6M,EAAA,EACNV,SAGIK,EAAmB,kBACvBxM,KAAM6M,EAAA,IAGFyE,EAAiB,SAAAnF,GAAA,OACrBnM,KAAM6M,EAAA,EACNV,SAGIkF,EAAc,SAAA1C,GAAA,MAAQ,UAACX,GAC3B7P,OAAAqT,EAAA,GAAWxD,EAAUyD,EAAyBF,EAAA,EAAgB5C,GAC3DV,KAAK,SAACC,GAAa,GACV/B,GAAS+B,EAAS/B,KAAlBA,IACRA,GAAKmC,UAAYnQ,OAAAqT,EAAA,GAAYrF,EAAKmC,UAAW,QAAQ5D,IAAI,SAACnH,GAExD,MADAA,GAAKkN,SAAU,EACRlN,IAETyK,EAAS0D,EAAuBvF,MAC/BgC,MAAM,WACPH,EAASxB,UZkiCTmF,KACA,SAAUhU,EAAQC,EAAqBC,GAE7C,YACAM,QAAOC,eAAeR,EAAqB,cAAgBS,OAAO,IACnCR,EAAoBwO,EAAEzO,EAAqB,oBAAqB,WAAa,MAAOgU,KACpF/T,EAAoBwO,EAAEzO,EAAqB,mBAAoB,WAAa,MAAO4O,KACnF3O,EAAoBwO,EAAEzO,EAAqB,qBAAsB,WAAa,MAAOiU,KACrFhU,EAAoBwO,EAAEzO,EAAqB,iBAAkB,WAAa,MAAOkU,IAC3F,IAAIjF,GAAuChP,EAAoB,KAC3DkU,EAA0DlU,EAAoB,MAC9EmU,EAA0CnU,EAAoB,KAC9DoU,EAA8CpU,EAAoB,KAClEqU,EAA6CrU,EAAoB,IACzDA,GAAoBwO,EAAEzO,EAAqB,iBAAkB,WAAa,MAAOsU,GAA2D,gBavkC7K,IAAMC,GAAsC,kBAC1CnS,KAAM6M,EAAA,IAGFuF,EAA6B,kBACjCpS,KAAM6M,EAAA,IAGFwF,EAAyB,kBAC7BrS,KAAM6M,EAAA,IAGFyF,EAAqC,SAAAnG,GAAA,OACzCnM,KAAM6M,EAAA,EACNV,SAGIoG,EAAwB,SAAAC,GAAA,OAC5BxS,KAAM6M,EAAA,EACN2F,gBAGIC,EAA4B,SAAAC,GAAA,OAChC1S,KAAM6M,EAAA,EACN6F,oBAGIlG,EAAmB,kBACvBxM,KAAM6M,EAAA,IAGF+E,EAAoB,iBAAM,UAAC5D,GAC/B7P,OAAA8T,EAAA,GAAWjE,EAAUmE,EAAqCJ,EAAA,GACvD9D,KAAK,SAACC,GAAa,GACV/B,GAAS+B,EAAS/B,KAAlBA,IACR6B,GAASsE,EAAmCnG,MAC3CgC,MAAM,WACPH,EAASxB,SAITqF,EAAqB,cAACb,GAADhQ,UAAAZ,OAAA,OAAAwO,KAAA5N,UAAA,GAAAA,UAAA,GAAU,IAAV,OAAmB,UAACgN,GAC7C7P,OAAA8T,EAAA,GAAWjE,EAAUoE,EAA4BJ,EAAA,EAA2BhB,GACzE/C,KAAK,SAACC,GAAa,GACV/B,GAAS+B,EAAS/B,KAAlBA,KACFwG,EAAsBxG,EAAOA,EAAKyG,oBACxCzU,QAAO0U,QAAQF,GAAqB9P,QAAQ,SAACU,GAC3C4I,EAAKyG,kBAAkBrP,EAAK,IAAMuP,WAAWvP,EAAK,IAAIwF,QAAQ,KAEhEiF,EAASyE,EAA0BtG,MAClCgC,MAAM,WACPH,EAASxB,SAITsF,EAAiB,iBAAM,UAAC9D,GAC5B7P,OAAA8T,EAAA,GAAWjE,EAAUqE,EAAwBL,EAAA,GAC1C/D,KAAK,SAACC,GAAa,GACV/B,GAAS+B,EAAS/B,KAAlBA,IACR6B,GAASuE,EAAsBpG,MAC9BgC,MAAM,WACPH,EAASxB,Ub+gCTuG,KACA,SAAUpV,EAAQc,EAASZ,Gc3lCjC,GAAAmV,GAAAnV,EAAA,MACAoV,EAAApV,EAAA,MAEAqV,EAAA,SAAAC,GACA,GAAAA,YAAAD,GACA,MAAAC,EAEA,MAAAhU,eAAA+T,IACA,UAAAA,GAAAC,EAGAhU,MAAAoB,OAAA,EACApB,KAAAF,QACAmU,KAAA,OACAC,KAAA,OACAC,KAAA,OACAC,KAAA,OACAC,MAAA,SACAC,MAAA,EAIA,IAAAC,EACA,kBAAAP,IACAO,EAAAT,EAAAU,QAAAR,GACAO,EACAvU,KAAAyU,UAAA,MAAAF,IACGA,EAAAT,EAAAY,QAAAV,IACHhU,KAAAyU,UAAA,MAAAF,IACGA,EAAAT,EAAAa,OAAAX,KACHhU,KAAAyU,UAAA,MAAAF,IAEE,iBAAAP,KACFO,EAAAP,MACAvE,KAAA8E,EAAAK,OAAAnF,KAAA8E,EAAAM,IACA7U,KAAAyU,UAAA,MAAAF,OACG9E,KAAA8E,EAAAO,OAAArF,KAAA8E,EAAAQ,UACH/U,KAAAyU,UAAA,MAAAF,OACG9E,KAAA8E,EAAAhR,OAAAkM,KAAA8E,EAAArV,MACHc,KAAAyU,UAAA,MAAAF,OACG9E,KAAA8E,EAAAS,OAAAvF,KAAA8E,EAAAU,UACHjV,KAAAyU,UAAA,MAAAF,OACG9E,KAAA8E,EAAAW,OAAAzF,KAAA8E,EAAAY,MACHnV,KAAAyU,UAAA,OAAAF,IAKAR,GAAAjS,WACAsT,QAAA,WACA,MAAApV,MAAAoB,OAEA6S,IAAA,WACA,MAAAjU,MAAAqV,SAAA,MAAAxT,YAEAqS,IAAA,WACA,MAAAlU,MAAAqV,SAAA,MAAAxT,YAEAsS,IAAA,WACA,MAAAnU,MAAAqV,SAAA,MAAAxT,YAEAuS,IAAA,WACA,MAAApU,MAAAqV,SAAA,MAAAxT,YAEAwS,KAAA,WACA,MAAArU,MAAAqV,SAAA,OAAAxT,YAGAyT,SAAA,WACA,MAAAtV,MAAAF,OAAAmU,KAEAsB,SAAA,WACA,MAAAvV,MAAAF,OAAAoU,KAEAsB,SAAA,WACA,MAAAxV,MAAAF,OAAAqU,KAEAsB,SAAA,WACA,GAAA3V,GAAAE,KAAAF,MACA,YAAAA,EAAAwU,MACAxU,EAAAsU,IAAAlM,QAAApI,EAAAwU,QAEAxU,EAAAsU,KAEAsB,UAAA,WACA,MAAA1V,MAAAF,OAAAuU,MAEAsB,UAAA,WACA,GAAA7V,GAAAE,KAAAF,MACA,OAAAA,GAAAmU,IAAA/L,QAAApI,EAAAwU,SAEAsB,UAAA,WACA,GAAA9V,GAAAE,KAAAF,MACA,OAAAA,GAAAoU,IAAAhM,QAAApI,EAAAwU,SAEAA,MAAA,SAAAuB,GACA,WAAApG,KAAAoG,EACA7V,KAAAF,OAAAwU,OAEAtU,KAAAyU,UAAA,QAAAoB,GACA7V,OAGA6U,IAAA,SAAAgB,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEAE,MAAA,SAAAF,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEAG,KAAA,SAAAH,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEAI,IAAA,SAAAJ,GAKA,MAJAA,KACAA,GAAA,IACAA,IAAA,MAAAA,KAEA7V,KAAA8V,WAAA,QAAAD,IAEAK,WAAA,SAAAL,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEAd,UAAA,SAAAc,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEAM,YAAA,SAAAN,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEAZ,UAAA,SAAAY,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEAO,UAAA,SAAAP,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEA3W,MAAA,SAAA2W,GACA,MAAA7V,MAAA8V,WAAA,QAAAD,IAEAV,KAAA,SAAAU,GACA,MAAA7V,MAAA8V,WAAA,SAAAD,IAEAQ,QAAA,SAAAR,GACA,MAAA7V,MAAA8V,WAAA,SAAAD,IAEAS,OAAA,SAAAT,GACA,MAAA7V,MAAA8V,WAAA,SAAAD,IAEAU,MAAA,SAAAV,GACA,MAAA7V,MAAA8V,WAAA,SAAAD,IAGAW,UAAA,WACA,MAAA1C,GAAA0C,UAAAxW,KAAAF,OAAAmU,MAEA3S,UAAA,WACA,MAAAwS,GAAAxS,UAAAtB,KAAAF,OAAAmU,IAAAjU,KAAAF,OAAAwU,QAEAmC,WAAA,WACA,MAAA3C,GAAA2C,WAAAzW,KAAAF,OAAAmU,IAAAjU,KAAAF,OAAAwU,QAEAoC,cAAA,WACA,MAAA5C,GAAA4C,cAAA1W,KAAAF,OAAAmU,IAAAjU,KAAAF,OAAAwU,QAEAqC,UAAA,WACA,MAAA7C,GAAA6C,UAAA3W,KAAAF,OAAAoU,IAAAlU,KAAAF,OAAAwU,QAEAsC,WAAA,WACA,MAAA9C,GAAA8C,WAAA5W,KAAAF,OAAAoU,IAAAlU,KAAAF,OAAAwU,QAEAuC,UAAA,WACA,MAAA/C,GAAA+C,UAAA7W,KAAAF,OAAAsU,IAAApU,KAAAF,OAAAwU,QAEAwC,QAAA,WACA,MAAAhD,GAAAgD,QAAA9W,KAAAF,OAAAmU,IAAAjU,KAAAF,OAAAwU,QAGAyC,UAAA,WACA,GAAA9C,GAAAjU,KAAAF,OAAAmU,GACA,OAAAA,GAAA,OAAAA,EAAA,MAAAA,EAAA,IAGA+C,WAAA,WAIA,OAFA/C,GAAAjU,KAAAF,OAAAmU,IACAgD,KACA1W,EAAA,EAAiBA,EAAA0T,EAAAhT,OAAgBV,IAAA,CACjC,GAAA2W,GAAAjD,EAAA1T,GAAA,GACA0W,GAAA1W,GAAA2W,GAAA,OAAAA,EAAA,MAAA9Q,KAAA2D,KAAAmN,EAAA,iBAEA,YAAAD,EAAA,SAAAA,EAAA,SAAAA,EAAA,IAGAE,SAAA,SAAAC,GAEA,GAAAC,GAAArX,KAAAgX,aACAM,EAAAF,EAAAJ,YACA,OAAAK,GAAAC,GACAD,EAAA,MAAAC,EAAA,MAEAA,EAAA,MAAAD,EAAA,MAGAE,MAAA,SAAAH,GACA,GAAAI,GAAAxX,KAAAmX,SAAAC,EACA,OAAAI,IAAA,IACA,MAGAA,GAAA,aAGAC,KAAA,WAEA,GAAAxD,GAAAjU,KAAAF,OAAAmU,GAEA,QADA,IAAAA,EAAA,OAAAA,EAAA,OAAAA,EAAA,QACA,KAGAyD,MAAA,WACA,OAAA1X,KAAAyX,QAGAE,OAAA,WAEA,OADA1D,MACA1T,EAAA,EAAiBA,EAAA,EAAOA,IACxB0T,EAAA1T,GAAA,IAAAP,KAAAF,OAAAmU,IAAA1T,EAGA,OADAP,MAAAyU,UAAA,MAAAR,GACAjU,MAGA4X,QAAA,SAAAC,GACA,GAAA3D,GAAAlU,KAAAF,OAAAoU,GAGA,OAFAA,GAAA,IAAAA,EAAA,GAAA2D,EACA7X,KAAAyU,UAAA,MAAAP,GACAlU,MAGA8X,OAAA,SAAAD,GACA,GAAA3D,GAAAlU,KAAAF,OAAAoU,GAGA,OAFAA,GAAA,IAAAA,EAAA,GAAA2D,EACA7X,KAAAyU,UAAA,MAAAP,GACAlU,MAGA+X,SAAA,SAAAF,GACA,GAAA3D,GAAAlU,KAAAF,OAAAoU,GAGA,OAFAA,GAAA,IAAAA,EAAA,GAAA2D,EACA7X,KAAAyU,UAAA,MAAAP,GACAlU,MAGAgY,WAAA,SAAAH,GACA,GAAA3D,GAAAlU,KAAAF,OAAAoU,GAGA,OAFAA,GAAA,IAAAA,EAAA,GAAA2D,EACA7X,KAAAyU,UAAA,MAAAP,GACAlU,MAGAiY,OAAA,SAAAJ,GACA,GAAAzD,GAAApU,KAAAF,OAAAsU,GAGA,OAFAA,GAAA,IAAAA,EAAA,GAAAyD,EACA7X,KAAAyU,UAAA,MAAAL,GACApU,MAGAkY,QAAA,SAAAL,GACA,GAAAzD,GAAApU,KAAAF,OAAAsU,GAGA,OAFAA,GAAA,IAAAA,EAAA,GAAAyD,EACA7X,KAAAyU,UAAA,MAAAL,GACApU,MAGAmY,UAAA,WACA,GAAAlE,GAAAjU,KAAAF,OAAAmU,IAEA4B,EAAA,GAAA5B,EAAA,OAAAA,EAAA,OAAAA,EAAA,EAEA,OADAjU,MAAAyU,UAAA,OAAAoB,QACA7V,MAGAoY,QAAA,SAAAP,GACA,GAAAvD,GAAAtU,KAAAF,OAAAwU,KAEA,OADAtU,MAAAyU,UAAA,QAAAH,IAAAuD,GACA7X,MAGAqY,QAAA,SAAAR,GACA,GAAAvD,GAAAtU,KAAAF,OAAAwU,KAEA,OADAtU,MAAAyU,UAAA,QAAAH,IAAAuD,GACA7X,MAGAsY,OAAA,SAAAC,GACA,GAAArE,GAAAlU,KAAAF,OAAAoU,IACA+B,GAAA/B,EAAA,GAAAqE,GAAA,GAGA,OAFArE,GAAA,GAAA+B,EAAA,MAAAA,IACAjW,KAAAyU,UAAA,MAAAP,GACAlU,MAOAqB,IAAA,SAAAmX,EAAAxU,GACA,GAAAyU,GAAAzY,KACAoX,EAAAoB,EACAE,MAAAjJ,KAAAzL,EAAA,GAAAA,EAEAgR,EAAA,EAAA0D,EAAA,EACA7Z,EAAA4Z,EAAAnE,QAAA8C,EAAA9C,QAEAqE,IAAA3D,EAAAnW,KAAA,EAAAmW,KAAAnW,IAAA,EAAAmW,EAAAnW,IAAA,KACA+Z,EAAA,EAAAD,CAEA,OAAA3Y,MACAiU,IACA0E,EAAAF,EAAA5D,MAAA+D,EAAAxB,EAAAvC,MACA8D,EAAAF,EAAA1C,QAAA6C,EAAAxB,EAAArB,QACA4C,EAAAF,EAAAzC,OAAA4C,EAAAxB,EAAApB,QAEA1B,MAAAmE,EAAAnE,QAAAoE,EAAAtB,EAAA9C,SAAA,EAAAoE,KAGAG,OAAA,WACA,MAAA7Y,MAAAiU,OAGA9R,MAAA,WAKA,GAGAjD,GAAA2B,EAHAiY,EAAA,GAAA/E,GACAzI,EAAAtL,KAAAF,OACAc,EAAAkY,EAAAhZ,MAGA,QAAAgF,KAAAwG,GACAA,EAAApK,eAAA4D,KACA5F,EAAAoM,EAAAxG,GACAjE,KAAc0J,SAAAC,KAAAtL,GACd,mBAAA2B,EACAD,EAAAkE,GAAA5F,EAAA6Z,MAAA,GACK,oBAAAlY,EACLD,EAAAkE,GAAA5F,EAEA8Z,QAAAtI,MAAA,0BAAAxR,GAKA,OAAA4Z,KAIA/E,EAAAjS,UAAAmX,QACAhF,KAAA,sBACAC,KAAA,gCACAC,KAAA,4BACAC,KAAA,+BACAC,MAAA,oCAGAN,EAAAjS,UAAAoX,OACAjF,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,MAAA,kBAGAN,EAAAjS,UAAAqX,UAAA,SAAAC,GAIA,OAHAtZ,GAAAE,KAAAF,OACAyU,KAEAhU,EAAA,EAAgBA,EAAA6Y,EAAAnY,OAAkBV,IAClCgU,EAAA6E,EAAAC,OAAA9Y,IAAAT,EAAAsZ,GAAA7Y,EAQA,OALA,KAAAT,EAAAwU,QACAC,EAAA1V,EAAAiB,EAAAwU,OAIAC,GAGAR,EAAAjS,UAAA2S,UAAA,SAAA2E,EAAA7E,GACA,GAIAhU,GAJAT,EAAAE,KAAAF,OACAmZ,EAAAjZ,KAAAiZ,OACAC,EAAAlZ,KAAAkZ,MACA5E,EAAA,CAKA,IAFAtU,KAAAoB,OAAA,EAEA,UAAAgY,EACA9E,EAAAC,MACE,IAAAA,EAAAtT,OAEFnB,EAAAsZ,GAAA7E,EAAAwE,MAAA,EAAAK,EAAAnY,QACAqT,EAAAC,EAAA6E,EAAAnY,YACE,QAAAwO,KAAA8E,EAAA6E,EAAAC,OAAA,KAEF,IAAA9Y,EAAA,EAAaA,EAAA6Y,EAAAnY,OAAkBV,IAC/BT,EAAAsZ,GAAA7Y,GAAAgU,EAAA6E,EAAAC,OAAA9Y,GAGA+T,GAAAC,EAAA1V,MACE,QAAA4Q,KAAA8E,EAAA0E,EAAAG,GAAA,KAEF,GAAAE,GAAAL,EAAAG,EAEA,KAAA7Y,EAAA,EAAaA,EAAA6Y,EAAAnY,OAAkBV,IAC/BT,EAAAsZ,GAAA7Y,GAAAgU,EAAA+E,EAAA/Y,GAGA+T,GAAAC,EAAAD,MAKA,GAFAxU,EAAAwU,MAAAlO,KAAAC,IAAA,EAAAD,KAAAuD,IAAA,MAAA8F,KAAA6E,EAAAxU,EAAAwU,UAEA,UAAA8E,EACA,QAGA,IAAAG,EAGA,KAAAhZ,EAAA,EAAYA,EAAA6Y,EAAAnY,OAAkBV,IAC9BgZ,EAAAnT,KAAAC,IAAA,EAAAD,KAAAuD,IAAAuP,EAAAE,GAAA7Y,GAAAT,EAAAsZ,GAAA7Y,KACAT,EAAAsZ,GAAA7Y,GAAA6F,KAAAoT,MAAAD,EAIA,QAAAE,KAAAR,GACAQ,IAAAL,IACAtZ,EAAA2Z,GAAA5F,EAAAuF,GAAAK,GAAA3Z,EAAAsZ,IAIA,WAGArF,EAAAjS,UAAAuT,SAAA,SAAA+D,EAAArO,GACA,GAAAwJ,GAAAxJ,EAAA,EAEA,YAAA0E,KAAA8E,EAEAvU,KAAAmZ,UAAAC,IAIA,iBAAA7E,KACAA,EAAAjK,MAAAxI,UAAAiX,MAAAvO,KAAAO,IAGA/K,KAAAyU,UAAA2E,EAAA7E,GACAvU,OAGA+T,EAAAjS,UAAAgU,WAAA,SAAAsD,EAAA1U,EAAAmR,GACA,GAAA6D,GAAA1Z,KAAAF,OAAAsZ,EACA,YAAA3J,KAAAoG,EAEA6D,EAAAhV,GACEmR,IAAA6D,EAAAhV,GAEF1E,MAIA0Z,EAAAhV,GAAAmR,EACA7V,KAAAyU,UAAA2E,EAAAM,GAEA1Z,OAGA,oBAAA2Z,UACAA,OAAA5F,SAGAvV,EAAAc,QAAAyU,GdmmCM6F,KACA,SAAUpb,EAAQc,EAASZ,GAEjC,YehkDA,SAAAmb,GAAAC,EAAA3V,GACA,MAAA2V,GAAAC,QAEAvX,EAAAsX,EAAAtX,EACAC,EAAAqX,EAAArX,GAIA9C,EAAAka,oBAAAC,EAAA3V,GAQA,QAAA6V,GAAA7V,EAAA8V,GACA,GACAC,GAAA3Z,EAAA4Z,EAAA3Z,EAAA4Z,EADAC,EAAAlW,EAAA6I,KAAAqN,QAGA,KAAA9Z,EAAA,EAAAC,EAAA6Z,EAAApZ,OAAoCV,EAAAC,IAAUD,EAC9C,GAAA4D,EAAAmW,iBAAA/Z,GAKA,IADA2Z,EAAA/V,EAAAoW,eAAAha,GACA4Z,EAAA,EAAAC,EAAAF,EAAAlN,KAAA/L,OAAsCkZ,EAAAC,IAAUD,EAAA,CAChD,GAAA9K,GAAA6K,EAAAlN,KAAAmN,EACA9K,GAAAnN,MAAAsY,MACAP,EAAA5K,IAYA,QAAAoL,GAAAtW,EAAAd,GACA,GAAAqX,KAQA,OANAV,GAAA7V,EAAA,SAAAkL,GACAA,EAAAsL,QAAAtX,EAAAb,EAAAa,EAAAZ,IACAiY,EAAAnW,KAAA8K,KAIAqL,EAWA,QAAAE,GAAAzW,EAAAd,EAAAwX,EAAAC,GACA,GAAAC,GAAAC,OAAAC,kBACAC,IAmBA,OAjBAlB,GAAA7V,EAAA,SAAAkL,GACA,IAAAwL,GAAAxL,EAAAsL,QAAAtX,EAAAb,EAAAa,EAAAZ,GAAA,CAIA,GAAA0Y,GAAA9L,EAAA+L,iBACAC,EAAAP,EAAAzX,EAAA8X,EAEAE,GAAAN,GACAG,GAAA7L,GACA0L,EAAAM,GACGA,IAAAN,GAEHG,EAAA3W,KAAA8K,MAIA6L,EAQA,QAAAI,GAAAC,GACA,GAAAC,IAAA,IAAAD,EAAA5W,QAAA,KACA8W,GAAA,IAAAF,EAAA5W,QAAA,IAEA,iBAAA+W,EAAAC,GACA,GAAAC,GAAAJ,EAAApV,KAAAiD,IAAAqS,EAAAlZ,EAAAmZ,EAAAnZ,GAAA,EACAqZ,EAAAJ,EAAArV,KAAAiD,IAAAqS,EAAAjZ,EAAAkZ,EAAAlZ,GAAA,CACA,OAAA2D,MAAA0V,KAAA1V,KAAA2D,IAAA6R,EAAA,GAAAxV,KAAA2D,IAAA8R,EAAA,KAIA,QAAAE,GAAA5X,EAAA2V,EAAAra,GACA,GAAA4D,GAAAwW,EAAAC,EAAA3V,EAEA1E,GAAA8b,KAAA9b,EAAA8b,MAAA,GACA,IAAAT,GAAAQ,EAAA7b,EAAA8b,MACAvL,EAAAvQ,EAAAob,UAAAJ,EAAAtW,EAAAd,GAAAuX,EAAAzW,EAAAd,GAAA,EAAAyX,GACAJ,IAEA,OAAA1K,GAAA/O,QAIAkD,EAAA6I,KAAAqN,SAAA3W,QAAA,SAAAsY,EAAAC,GACA,GAAA9X,EAAAmW,iBAAA2B,GAAA,CACA,GAAA/B,GAAA/V,EAAAoW,eAAA0B,GACA5M,EAAA6K,EAAAlN,KAAAgD,EAAA,GAAAkM,OAGA7M,OAAAnN,MAAAsY,MACAE,EAAAnW,KAAA8K,MAKAqL,MArIA,GAAA/a,GAAAjB,EAAA,KAqJAF,GAAAc,SAEA6c,OACAC,OAAA,SAAAjY,EAAA2V,GACA,GAAAzW,GAAAwW,EAAAC,EAAA3V,GACAuW,IASA,OAPAV,GAAA7V,EAAA,SAAAkL,GACA,GAAAA,EAAAsL,QAAAtX,EAAAb,EAAAa,EAAAZ,GAEA,MADAiY,GAAAnW,KAAA8K,GACAqL,IAIAA,EAAA3B,MAAA,MASAsD,MAAAN,EAYArX,MAAAqX,EAWAC,QAAA,SAAA7X,EAAA2V,EAAAra,GACA,GAAA4D,GAAAwW,EAAAC,EAAA3V,EACA1E,GAAA8b,KAAA9b,EAAA8b,MAAA,IACA,IAAAT,GAAAQ,EAAA7b,EAAA8b,MACAvL,EAAAvQ,EAAAob,UAAAJ,EAAAtW,EAAAd,GAAAuX,EAAAzW,EAAAd,GAAA,EAAAyX,EAMA,OAJA9K,GAAA/O,OAAA,IACA+O,EAAA7L,EAAAoW,eAAAvK,EAAA,GAAAsM,eAAAtP,MAGAgD,GASAuM,SAAA,SAAApY,EAAA2V,GACA,MAAAiC,GAAA5X,EAAA2V,GAA+Be,WAAA,KAW/B2B,MAAA,SAAArY,EAAA2V,GAEA,MAAAW,GAAAtW,EADA0V,EAAAC,EAAA3V,KAYAsY,QAAA,SAAAtY,EAAA2V,EAAAra,GACA,GAAA4D,GAAAwW,EAAAC,EAAA3V,EACA1E,GAAA8b,KAAA9b,EAAA8b,MAAA,IACA,IAAAT,GAAAQ,EAAA7b,EAAA8b,MACAL,EAAAN,EAAAzW,EAAAd,EAAA5D,EAAAob,UAAAC,EAmBA,OAhBAI,GAAAja,OAAA,GACAia,EAAAtX,KAAA,SAAA/E,EAAAgF,GACA,GAAA6Y,GAAA7d,EAAA8d,UACAC,EAAA/Y,EAAA8Y,UACAE,EAAAH,EAAAE,CAOA,OALA,KAAAC,IAEAA,EAAAhe,EAAAyd,cAAAzY,EAAAyY,eAGAO,IAKA3B,EAAAnC,MAAA,MAWAvW,EAAA,SAAA2B,EAAA2V,EAAAra,GACA,GAAA4D,GAAAwW,EAAAC,EAAA3V,GACA6L,KACA8M,GAAA,CAiBA,OAfA9C,GAAA7V,EAAA,SAAAkL,GACAA,EAAA0N,SAAA1Z,EAAAb,IACAwN,EAAAzL,KAAA8K,GAGAA,EAAAsL,QAAAtX,EAAAb,EAAAa,EAAAZ,KACAqa,GAAA,KAMArd,EAAAob,YAAAiC,IACA9M,MAEAA,GAWAvN,EAAA,SAAA0B,EAAA2V,EAAAra,GACA,GAAA4D,GAAAwW,EAAAC,EAAA3V,GACA6L,KACA8M,GAAA,CAiBA,OAfA9C,GAAA7V,EAAA,SAAAkL,GACAA,EAAA2N,SAAA3Z,EAAAZ,IACAuN,EAAAzL,KAAA8K,GAGAA,EAAAsL,QAAAtX,EAAAb,EAAAa,EAAAZ,KACAqa,GAAA,KAMArd,EAAAob,YAAAiC,IACA9M,MAEAA,MfmlDMiN,KACA,SAAUze,EAAQc,EAASZ,GAEjC,YgB15DA,IAAAiB,GAAAjB,EAAA,MACAwe,EAAAxe,EAAA,MACAye,EAAAze,EAAA,MAGA0e,EAAAD,EAAAE,SAAAF,EAAAD,CAOA1e,GAAAc,QAAAK,EAAA+B,QAIAC,WAAA,aASA2b,eAAA,aAQAC,eAAA,aASAC,iBAAA,aAQAC,oBAAA,cAECL,IhBq7DKM,KACA,SAAUlf,EAAQc,EAASZ,GAEjC,YiB5+DA,IAAAuF,GAAAvF,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,UACA+d,aAQAnf,EAAAc,SAKAse,YAQAC,SAAA,EAMAC,SAAA,SAAAH,GACA,GAAAjF,GAAA1Y,KAAA4d,YACA1V,OAAAyV,GAAAja,QAAA,SAAAqa,IACA,IAAArF,EAAA/T,QAAAoZ,IACArF,EAAAnU,KAAAwZ,KAIA/d,KAAA6d,YAOAG,WAAA,SAAAL,GACA,GAAAjF,GAAA1Y,KAAA4d,YACA1V,OAAAyV,GAAAja,QAAA,SAAAqa,GACA,GAAAE,GAAAvF,EAAA/T,QAAAoZ,IACA,IAAAE,GACAvF,EAAA9T,OAAAqZ,EAAA,KAIAje,KAAA6d,YAOAK,MAAA,WACAle,KAAA4d,YACA5d,KAAA6d,YAQAM,MAAA,WACA,MAAAne,MAAA4d,SAAA3c,QAQAmd,OAAA,WACA,MAAApe,MAAA4d,UAYAS,OAAA,SAAAla,EAAAma,EAAAvT,GACA,GAEAxK,GAAAge,EAAAR,EAAAS,EAAAC,EAFAC,EAAA1e,KAAA0e,YAAAva,GACA3D,EAAAke,EAAAzd,MAGA,KAAAV,EAAA,EAAaA,EAAAC,IAAUD,EAIvB,GAHAge,EAAAG,EAAAne,GACAwd,EAAAQ,EAAAR,OAEA,oBADAU,EAAAV,EAAAO,MAEAE,GAAAra,GAAA+D,OAAA6C,OACAyT,EAAAja,KAAAga,EAAA9e,UACA,IAAAgf,EAAA7c,MAAAmc,EAAAS,IACA,QAKA,WAQAE,YAAA,SAAAva,GACA,GAAAwa,GAAAxa,EAAAya,WAAAza,EAAAya,YACA,IAAAD,EAAAvU,KAAApK,KAAA6d,SACA,MAAAc,GAAAD,WAGA,IAAAf,MACAe,KACAG,EAAA1a,KAAA0a,WACApf,EAAAof,EAAApf,SAAAof,EAAApf,QAAAke,WA2BA,OAzBA3d,MAAA4d,SAAA1V,OAAA2W,EAAAlB,aAAAja,QAAA,SAAAqa,GAEA,QADAJ,EAAAhZ,QAAAoZ,GACA,CAIA,GAAA3T,GAAA2T,EAAA3T,GACA0U,EAAArf,EAAA2K,IACA,IAAA0U,KAIA,IAAAA,IACAA,EAAAnf,EAAAwC,MAAA8B,EAAA8a,OAAApB,QAAAvT,KAGAuT,EAAApZ,KAAAwZ,GACAW,EAAAna,MACAwZ,SACAte,QAAAqf,YAIAH,EAAAD,cACAC,EAAAvU,GAAApK,KAAA6d,SACAa,GASAM,YAAA,SAAA7a,SACAA,GAAAya,YjBysEMK,KACA,SAAUzgB,EAAQc,EAASZ,GAEjC,YkBl3EAM,QAAAC,eAAAK,EAAA,cACAJ,OAAA,GAGA,IAAAggB,GAAAxgB,EAAA,GAEAygB,EAEA,SAAAnL,GAAsC,MAAAA,MAAAoL,WAAApL,GAAuCqL,QAAArL,IAF7EkL,EAIA5f,GAAA+f,SACAC,SAAA,SAAAC,GACA,SAAAJ,EAAAE,UACAG,UAAA,EACAC,kBAAAF,KAIAG,QAAA,SAAAH,EAAAhE,GACA,SAAA4D,EAAAE,UACAM,kBAAAJ,EACAK,iBAAAL,EACAM,kBAAA,eAAAtE,EACAuE,gBAAA,eAAAvE,KAIAwE,OAAA,SAAAR,EAAAS,GACA,SAAAb,EAAAE,UACAY,QAAAV,EACAW,OAAAX,EACAY,UAAAH,KAIAI,KAAA,SAAAb,EAAAc,GACA,SAAAlB,EAAAE,UACAiB,OAAAf,EACAgB,MAAAhB,EACAc,cAIAG,WAAA,SAAAC,GACA,SAAAtB,EAAAE,UACAqB,8BAAA,EACAC,mBAAAF,KAIAG,WAAA,SAAAH,GACA,SAAAtB,EAAAE,UACAwB,8BAAA,EACAF,mBAAAF,KAIAK,IAAA,SAAAT,GACA,SAAAlB,EAAAE,UACA0B,KAAA,EACAV,gBlB43EMW,KACA,SAAUxiB,EAAQc,EAASZ,GAEjC,YmB37EAM,QAAAC,eAAAK,EAAA,cACAJ,OAAA,IAGAI,EAAA+f,QAAA,SAAAhc,EAAAkY,GAMA,MAJA,gBADA,eAAAA,GAAAlY,EAAA,QAAAA,EAAA,IAGA4d,KAAA,WnBq8EMC,KACA,SAAU1iB,EAAQc,EAASZ,GoBh9EjC,GAAAyiB,GAAAC,EAAAC,GAAA,SAAAtC,EAAAuC,GAEAF,GAAA9hB,EAAAZ,EAAA,OAAAyiB,EAAA,MAAA1R,MAAA4R,EAAA,mBAAAF,KAAAvf,MAAAtC,EAAA8hB,GAAAD,KAAA3iB,EAAAc,QAAA+hB,IAUCrhB,EAAA,SAAAV,EAAAiiB,GACD,YAEAviB,QAAAC,eAAAK,EAAA,cACAJ,OAAA,GAGA,IAAAsiB,GAEA,SAAAxN,GACA,MAAAA,MAAAoL,WAAApL,GACAqL,QAAArL,IAJAuN,EAQAjiB,GAAA+f,QAAAmC,EAAAnC,WpB09EMoC,KACA,SAAUjjB,EAAQc,EAASZ,GAEjC,YqBt9EA,SAAAgjB,GAAA1N,GAAsC,MAAAA,MAAAoL,WAAApL,GAAuCqL,QAAArL,GAE7E,QAAA2N,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAE3F,QAAAC,GAAAC,EAAAxX,GAAiD,IAAAwX,EAAa,SAAAC,gBAAA,4DAAyF,QAAAzX,GAAA,iBAAAA,IAAA,mBAAAA,GAAAwX,EAAAxX,EAEvJ,QAAA0X,GAAAC,EAAAC,GAA0C,sBAAAA,IAAA,OAAAA,EAA+D,SAAAN,WAAA,iEAAAM,GAAuGD,GAAArgB,UAAA9C,OAAAqjB,OAAAD,KAAAtgB,WAAyEsK,aAAelN,MAAAijB,EAAAG,YAAA,EAAAC,UAAA,EAAAC,cAAA,KAA6EJ,IAAApjB,OAAAyjB,eAAAzjB,OAAAyjB,eAAAN,EAAAC,GAAAD,EAAAO,UAAAN,GAtCrXpjB,OAAAC,eAAAK,EAAA,cACAJ,OAAA,GAGA,IAAAyjB,GAAA,WAAgC,QAAAC,GAAAhiB,EAAAmE,GAA2C,OAAAxE,GAAA,EAAgBA,EAAAwE,EAAA9D,OAAkBV,IAAA,CAAO,GAAAge,GAAAxZ,EAAAxE,EAA2Bge,GAAA+D,WAAA/D,EAAA+D,aAAA,EAAwD/D,EAAAiE,cAAA,EAAgC,SAAAjE,OAAAgE,UAAA,GAAuDvjB,OAAAC,eAAA2B,EAAA2d,EAAA9d,IAAA8d,IAA+D,gBAAAsD,EAAAgB,EAAAC,GAA2L,MAAlID,IAAAD,EAAAf,EAAA/f,UAAA+gB,GAAqEC,GAAAF,EAAAf,EAAAiB,GAA6DjB,MAExhBkB,EAAArkB,EAAA,GAEAskB,EAAAtB,EAAAqB,GAEAE,EAAAvkB,EAAA,GAIAwkB,GAFAxB,EAAAuB,GAEAvkB,EAAA,IAEAykB,EAAAzB,EAAAwB,GAEAE,EAAA1kB,EAAA,MAEA2kB,EAAA3B,EAAA0B,GAEAE,EAAA5kB,EAAA,MAEA6kB,EAAA7kB,EAAA,MAEA8kB,EAAA9B,EAAA6B,GAEAE,EAAA/kB,EAAA,MAEAglB,EAAAhC,EAAA+B,GAUAE,EAAA,SAAAC,GAGA,QAAAD,GAAA5e,GACA4c,EAAA3hB,KAAA2jB,EAEA,IAAAE,GAAA9B,EAAA/hB,MAAA2jB,EAAAjB,WAAA1jB,OAAA8kB,eAAAH,IAAAnZ,KAAAxK,KAAA+E,GAsHA,OApHA8e,GAAAE,mBAAA,SAAAC,GACAH,EAAAI,gBAAAD,GAGAH,EAAAK,gBAAA,SAAAF,GACAH,EAAAM,aAAAH,GAGAH,EAAAO,aAAA,SAAAJ,EAAAtf,GACAmf,EAAAQ,YACAR,EAAAQ,cAEAR,EAAAQ,UAAA3f,GAAAsf,GAGAH,EAAAS,YAAA,WACA,GAAAT,EAAA9e,MAAAwf,UAAAV,EAAAI,gBAAA,CAIA,GAAA1S,GAAAsS,EAAA9e,MAAAwf,SAAAtjB,OACAujB,EAAAX,EAAAI,gBAAAQ,YACAC,EAAAb,EAAA9e,MAAA4f,WAAAd,EAAA9e,MAAA4f,YAAA,EAAArB,EAAAsB,YAAAf,EAAAQ,UAAA,IACAQ,EAAAze,KAAAkD,MAAAkb,EAAAE,GACAI,EAAAvT,EAAAsT,EACAE,EAAAF,EAAAtT,CACAsS,GAAAmB,UACAN,WACAG,eACAI,UAAAF,EAAAlB,EAAAqB,aAAArB,EAAA9e,MAAAogB,cAAA,EACAL,eACAC,iBAIAlB,EAAAuB,cAAA,WACAvB,EAAAmB,UAA4BK,UAAA,IAC5BxB,EAAAS,eAGAT,EAAAyB,gBAAA,SAAA5gB,EAAAN,GACA,GAAA6V,GAAA4J,EAAA9e,MAAAwgB,YAEA,oBAAAtL,IACAA,EAAAvV,EAAAN,IAIAyf,EAAA2B,aAAA,WACA3B,EAAAmB,UACAS,SAAA,KAIA5B,EAAA6B,WAAA,WACA7B,EAAAmB,UACAS,SAAA,KAIA5B,EAAA8B,YAAA,SAAA/J,GACA,GAEAgK,IAAA/B,EAAA9S,MAAAkU,UAAApB,EAAA9S,MAAA2T,SACAmB,GAAAhC,EAAA9S,MAAA8T,aAAAhB,EAAA9S,MAAA2T,QAHA,KAMAkB,GAAAhK,EAAA,IACAA,EAAA,GAIAgK,IAAAC,GAAAjK,EAAA,IACAA,EAAA,EAGA,IAAA4I,GAAAX,EAAAI,gBAAAQ,YACAphB,EAAAuiB,EAAA,KAAApB,EAAA5I,GAAA,KAGA,uFAAAlY,QAAA,SAAAoB,GACA+e,EAAAM,aAAA2B,MAAAhhB,IAAA,EAAA0e,EAAAnE,SAAAhc,EAAAwgB,EAAA9e,MAAAwW,SAIAsI,EAAAkC,WAAA,SAAAC,GACAnC,EAAAoC,OAAApC,EAAA9S,MAAAkU,WAAA,iBAAAe,KAAA,KAGAnC,EAAAqC,UAAA,SAAAF,GACAnC,EAAAoC,OAAApC,EAAA9S,MAAAkU,WAAA,iBAAAe,KAAA,KAGAnC,EAAAoC,OAAA,SAAA5iB,GAEAA,IAAA,IAAAA,EAEAA,KAAAwgB,EAAAiB,aAAAjB,EAAAiB,aAAAzhB,EAEAwgB,EAAAmB,UACAC,UAAA5hB,EAEA8hB,aAAAtB,EAAA9S,MAAAoU,gBAIAtB,EAAA9S,OACAoU,aAAApgB,EAAAogB,aACAE,UAAA,EACAJ,UAAA,EACAP,SAAA,KACAG,aAAA,EACAC,aAAA,EACAC,YAAA,EACAoB,OAAAtC,EAAAuC,aAEAvC,EAwMA,MAnUA3B,GAAAyB,EAAAC,GA8HAjB,EAAAgB,IACAljB,IAAA,oBACAvB,MAAA,SAAAmnB,GACArmB,KAAAsmB,iBAGA7lB,IAAA,4BACAvB,MAAA,SAAA6F,EAAAgM,GACAhM,EAAAogB,eAAAnlB,KAAA+Q,MAAAoU,cACAnlB,KAAAglB,UACAG,aAAApgB,EAAAogB,aACAF,UAAAjlB,KAAAklB,aAAAngB,EAAAogB,gBAGApgB,EAAAwf,WAAAvkB,KAAA+E,MAAAwf,UACAvkB,KAAAglB,UACAmB,OAAAnmB,KAAAomB,iBAKA3lB,IAAA,qBACAvB,MAAA,SAAAqnB,GACAvmB,KAAA+E,MAAAwf,WAAAgC,EAAAhC,UAMAvkB,KAAAskB,iBAGA7jB,IAAA,uBACAvB,MAAA,WACAc,KAAAwmB,mBAGA/lB,IAAA,cACAvB,MAAA,WAGAya,OAAA6D,iBAAA,SAAAxd,KAAAskB,aAEA3K,OAAA6D,iBAAA,mBAAAxd,KAAAskB,aAIAtkB,KAAAskB,iBAGA7jB,IAAA,gBACAvB,MAAA,WAEAya,OAAA8D,oBAAA,SAAAzd,KAAAskB,aACA3K,OAAA8D,oBAAA,mBAAAzd,KAAAskB,gBAGA7jB,IAAA,YACAvB,MAAA,WACA,GAAAinB,GAAApD,EAAA0D,SAAAlb,IAAAvL,KAAA+E,MAAAwf,SAAA,SAAAngB,EAAAM,GACA,GAAAgiB,GAAAtiB,CASA,OANA,QAAAA,EAAAvD,OACA6lB,EAAA3D,EAAA0D,SAAAE,QAAAviB,EAAAW,MAAAwf,UAAA1S,OAAA,SAAA0S,GACA,cAAAA,EAAA1jB,OACqB,IAGrB6lB,GAAA,IAAAA,EAAAzlB,OAIAylB,EAHA,MAMA,OAEa,KAFbP,EAAAtU,OAAA,SAAA+U,GACA,cAAAA,IACa3lB,QACb+X,QAAA6N,KAAA,iTAEA,MAGAV,KAGA1lB,IAAA,eACAvB,MAAA,SAAAimB,GACA,GAAAF,GAAAE,CAcA,OAZAA,IAAAnlB,KAAA+Q,MAAA+T,eACAG,EAAAjlB,KAAA+Q,MAAA+T,cAGAK,EAAAnlB,KAAA+Q,MAAAkU,UAAAjlB,KAAA+Q,MAAA8T,eACAI,EAAAjlB,KAAA+Q,MAAAkU,WAGAE,EAAAnlB,KAAA+Q,MAAAkU,YACAA,EAAAE,GAGAF,KAGAxkB,IAAA,cACAvB,MAAA,WACA,GAAA4nB,GAAA9mB,IAEA,OAAAA,MAAA+Q,MAAAoV,OAAA5a,IAAA,SAAAmb,EAAAhiB,GACA,GAAAqiB,GAAA1D,EAAAhE,QAAAe,MAAA,EAAA1b,IAAAoiB,EAAA/V,MAAAoU,cAAA2B,EAAA/V,MAAAsU,UAEA2B,GACAvmB,IAAAiE,EACAuiB,IAAA,SAAAnN,GACA,MAAAgN,GAAA1C,aAAAtK,EAAApV,IAEAwiB,UAAAH,EACAI,QAAAL,EAAAxB,gBAAA8B,KAAAN,EAAApiB,EAAAoiB,EAAA/hB,MAAAwf,SAAA7f,IASA,OANA,KAAAA,IACAgiB,EAAA1D,EAAA3D,QAAAgI,aAAAX,GACAY,OAAAR,EAAA1B,iBAIApC,EAAA3D,QAAAvgB,cACA,KACAkoB,EACAN,QAKAjmB,IAAA,SACAvB,MAAA,WACA,IAAAc,KAAA+E,MAAAwf,SACA,WAIA,IAAAgD,GAAAvnB,KAAA+Q,MAAAgU,YAAA/kB,KAAA+Q,MAAAkU,UAAA,EAEAuC,EAAAxnB,KAAA+Q,MAAAgU,YAAA/kB,KAAA+Q,MAAAkU,UAAAjlB,KAAA+Q,MAAA+T,aAEA2C,KAEA7B,GAAA5lB,KAAA+Q,MAAAkU,UAAAjlB,KAAA+Q,MAAA2T,SAAA,KAEAgD,GAAA,EAAAlE,EAAAnE,SAAAuG,EAAA5lB,KAAA+E,MAAAwW,MAEAoM,EAAA3nB,KAAA+E,MAAA4iB,eAAA,IAiBA,OAfAF,IACAG,gBAAAF,EACAG,aAAAH,EACAI,YAAAJ,EACAK,WAAAL,EACAM,UAAAN,EACAO,YAAAP,EACAQ,yBAAAP,EACAQ,sBAAAR,EACAS,qBAAAT,EACAU,oBAAAV,EACAW,mBAAAX,EACAY,qBAAAZ,GAGA3E,EAAA3D,QAAAvgB,cACA,OACiBooB,UAAA7D,EAAAhE,QAAAC,UAAA,IACjB0D,EAAA3D,QAAAvgB,cACA,OACqBooB,UAAA7D,EAAAhE,QAAAK,SAAA,GAAAuH,IAAAjnB,KAAA+jB,oBACrBf,EAAA3D,QAAAvgB,cAAA,UAA6D+B,KAAA,SAAAqmB,UAAA7D,EAAAhE,QAAAmB,YAAA+G,GAAAJ,QAAAnnB,KAAA+lB,aAC7D/C,EAAA3D,QAAAvgB,cACA4kB,EAAArE,SACyBmJ,QAAA,KACzBrD,aAAAnlB,KAAA+Q,MAAAoU,aACA+B,UAAA7D,EAAAhE,QAAAU,QAAA,EAAA/f,KAAA+Q,MAAA0U,SACAgD,YAAAzoB,KAAAkmB,UACAwC,aAAA1oB,KAAA+lB,WACAJ,YAAA3lB,KAAA2lB,YACAH,aAAAxlB,KAAAwlB,aACAE,WAAA1lB,KAAA0lB,WACAI,MAAA2B,EACAR,IAAAjnB,KAAAkkB,iBACAlkB,KAAA2oB,eAEA3F,EAAA3D,QAAAvgB,cAAA,UAA6D+B,KAAA,SAAAqmB,UAAA7D,EAAAhE,QAAAuB,YAAA4G,GAAAL,QAAAnnB,KAAAkmB,kBAM7DvC,GACCZ,EAAA6F,UAEDjF,GAAAkF,YAAA,SACAlF,EAAAmF,YACAvE,SAAApB,EAAA9D,QAAAhQ,QAAA0Z,WACApB,eAAAxE,EAAA9D,QAAA2J,OACA7D,aAAAhC,EAAA9D,QAAA2J,OACArE,WAAAxB,EAAA9D,QAAA2J,QAEArF,EAAAsF,cACA9D,aAAA,EACAwC,eAAA,IACApM,KAAA,cAEAjc,EAAA+f,QAAAsE,GrB6/EMuF,KACA,SAAU1qB,EAAQC,EAAqBC,GAE7C,YAS60B,SAASijB,GAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAuC,QAASC,GAA2BC,EAAKxX,GAAM,IAAIwX,EAAM,KAAM,IAAIC,gBAAe,4DAA8D,QAAOzX,GAAqB,iBAAPA,IAA+B,mBAAPA,GAAwBwX,EAALxX,EAAW,QAAS0X,GAAUC,EAASC,GAAY,GAAuB,mBAAbA,IAAsC,OAAbA,EAAmB,KAAM,IAAIN,WAAU,iEAAkEM,GAAaD,GAASrgB,UAAU9C,OAAOqjB,OAAOD,GAAYA,EAAWtgB,WAAWsK,aAAalN,MAAMijB,EAASG,YAAW,EAAMC,UAAS,EAAKC,cAAa,KAAWJ,IAAWpjB,OAAOyjB,eAAezjB,OAAOyjB,eAAeN,EAASC,GAAYD,EAASO,UAAUN,GAAY,QAAS+G,GAAuBC,EAAQC,GAAK,MAAOrqB,QAAOsqB,OAAOtqB,OAAO4jB,iBAAiBwG,GAASC,KAAKnqB,MAAMF,OAAOsqB,OAAOD,OARluD,GAAIlqB,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GACpEoqB,EAA4C7qB,EAAoB,KAChE8qB,EAAkD9qB,EAAoB,IACtE+qB,EAAqC/qB,EAAoB,IACzDgrB,EAAmDhrB,EAAoB,MACvEirB,EAAkCjrB,EAAoB,MACtDkrB,EAAyDlrB,EAAoB,IAClGikB,EAAa,WAAW,QAASC,GAAiBhiB,EAAOmE,GAAO,IAAI,GAAIxE,GAAE,EAAEA,EAAEwE,EAAM9D,OAAOV,IAAI,CAAC,GAAIge,GAAWxZ,EAAMxE,EAAGge,GAAW+D,WAAW/D,EAAW+D,aAAY,EAAM/D,EAAWiE,cAAa,EAAQ,SAAUjE,KAAWA,EAAWgE,UAAS,GAAKvjB,OAAOC,eAAe2B,EAAO2d,EAAW9d,IAAI8d,IAAc,MAAO,UAASsD,EAAYgB,EAAWC,GAAuI,MAAvHD,IAAWD,EAAiBf,EAAY/f,UAAU+gB,GAAeC,GAAYF,EAAiBf,EAAYiB,GAAoBjB,MAAsBgI,EAAgBV,GAAwB,cAAc,uBAAuB,8BAA8B,cAAc,uBAAuB,8BAA8BW,EAAiBX,GAAwB,0DAA0D,0DsB93F7wBY,EAAKP,EAAA,EAAOQ,GAAZH,EACK,SAAA9kB,GAAA,MAASA,GAAMklB,MAAM9oB,MAAM+oB,SACnB,SAAAnlB,GAAA,MAASA,GAAMklB,MAAMhR,OAAOkR,OAIzCC,EAAQZ,EAAA,EAAOa,IAAfP,GAKAQ,EtBm3FkjE,SAAS1G,GAAgD,QAAS0G,KAAgB,GAAIC,GAASC,EAAM3G,EAAM4G,CAAK9I,GAAgB3hB,KAAKsqB,EAAe,KAAI,GAAII,GAAK7oB,UAAUZ,OAAO8J,EAAKT,MAAMogB,GAAMC,EAAK,EAAEA,EAAKD,EAAKC,IAAQ5f,EAAK4f,GAAM9oB,UAAU8oB,EAAO,OAAaH,GAAO3G,EAAM9B,EAA2B/hB,MAAMuqB,EAAKD,EAAc5H,WAAW1jB,OAAO8kB,eAAewG,IAAgB9f,KAAK5I,MAAM2oB,GAAMvqB,MAAMkI,OAAO6C,KAAe8Y,EsBl3F19E9S,OACE7R,MAAO,GtBi3F4yEurB,EAA2LD,EAAOzI,EAA2B8B,EAAM4G,GAAgkG,MAA7gHvI,GAAUoI,EAAc1G,GAA4bjB,EAAa2H,IAAgB7pB,IAAI,oBAAoBvB,MAAM,WsB72FxlFc,KAAK+E,MAAM0N,oBACXzS,KAAK+E,MAAM4N,oBtB42FyqFlS,IAAI,SAASvB,MAAM,WsBz2FhsF,GAAA0rB,GACoC5qB,KAAK+E,MAAxC8lB,EADDD,EACCC,QAASxX,EADVuX,EACUvX,YAAayX,EADvBF,EACuBE,SACxBC,EAAMD,EAASE,MAChBF,EAASE,KAAK5b,KAAK,SAAA5M,GAAA,MAAKA,KAAGyO,SAChC,OACErS,GAAAC,EAAAC,cAAC2qB,EAAA,GAAKwB,SAAUJ,GACdjsB,EAAAC,EAAAC,cAAC2qB,EAAA,GAAI5oB,KAAK,OAAOqqB,QAAQ,UACvBtsB,EAAAC,EAAAC,cAAC2qB,EAAA,GAAI0B,KAAM,GAAIC,OAAQ,GACrBxsB,EAAAC,EAAAC,cAACirB,EAAD,KAAInrB,EAAAC,EAAAC,cAAC8qB,EAAA,GAAiBxf,GAAG,wBACzBxL,EAAAC,EAAAC,cAAC6qB,EAAA,EAAa3pB,KAAK+E,QAGnBgmB,GAAe,aAARA,GAEHnsB,EAAAC,EAAAC,cAAC2qB,EAAA,GAAI0B,KAAM,GAAIC,OAAQ,GACrBxsB,EAAAC,EAAAC,cAACirB,EAAD,KAAInrB,EAAAC,EAAAC,cAAC8qB,EAAA,GAAiBxf,GAAG,6BACzBxL,EAAAC,EAAAC,cAAC6qB,EAAA,EAAa3pB,KAAK+E,SAM3BgmB,IAAQ1X,GAEFzU,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAACsrB,EAAD,MACAxrB,EAAAC,EAAAC,cAAC2qB,EAAA,EAAD,KACE7qB,EAAAC,EAAAC,cAAC2qB,EAAA,GAAI0B,KAAM,IACTvsB,EAAAC,EAAAC,cAACirB,EAAD,KAAInrB,EAAAC,EAAAC,cAAC8qB,EAAA,GAAiBxf,GAAG,oBACzBxL,EAAAC,EAAAC,cAAA,SAAGF,EAAAC,EAAAC,cAAC8qB,EAAA,GAAiBxf,GAAG,8BAEN,iBAAhBiJ,GAAkCzU,EAAAC,EAAAC,cAAC6qB,EAAA,EAAD,MAGlB,mBAAhBtW,GAAoCzU,EAAAC,EAAAC,cAAC6qB,EAAA,EAAD,MAGpB,cAAhBtW,GAA+BzU,EAAAC,EAAAC,cAAC6qB,EAAA,EAAD,MAGf,aAAhBtW,GAA8BzU,EAAAC,EAAAC,cAAC6qB,EAAA,EAAD,ctBi0F2iLW,GsBn3FrkLnrB,EAAA,WA6DtBksB,EAAkB,SAAAta,GAAA,OAEpB/D,KAAM+D,EAAMua,KAAKte,KACjB6d,QAAS9Z,EAAMua,KAAKT,QACpBC,SAAU/Z,EAAMoZ,KAAKnd,KACrBqG,YAAatC,EAAMua,KAAKjY,aAI5B5U,GAAA,EAAeO,OAAAuqB,EAAA,GACb8B,EACA3B,GACAY,ItB8yFIiB,KACA,SAAU/sB,EAAQC,EAAqBC,GAE7C,YACqB,IAAI8sB,GAA0C9sB,EAAoB,KACtDA,GAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAO+sB,GAA2C,GAC3H,IAAIC,GAA0C/sB,EAAoB,KACtDA,GAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOgtB,GAA2C,GAC3H,IAAIC,GAAiDhtB,EAAoB,KAC7DA,GAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOitB,GAAkD,GAClI,IAAIC,GAAmDjtB,EAAoB,KAC/DA,GAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOktB,GAAoD,GACpI,IAAIC,GAAmDltB,EAAoB,KAC/DA,GAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOmtB,GAAoD,GACpI,IAAIC,GAAkDntB,EAAoB,KAC9DA,GAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOotB,GAAmD,KAKlJC,KACA,SAAUttB,EAAQC,EAAqBC,GAE7C,YAYosB,SAASijB,GAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAuC,QAASC,GAA2BC,EAAKxX,GAAM,IAAIwX,EAAM,KAAM,IAAIC,gBAAe,4DAA8D,QAAOzX,GAAqB,iBAAPA,IAA+B,mBAAPA,GAAwBwX,EAALxX,EAAW,QAAS0X,GAAUC,EAASC,GAAY,GAAuB,mBAAbA,IAAsC,OAAbA,EAAmB,KAAM,IAAIN,WAAU,iEAAkEM,GAAaD,GAASrgB,UAAU9C,OAAOqjB,OAAOD,GAAYA,EAAWtgB,WAAWsK,aAAalN,MAAMijB,EAASG,YAAW,EAAMC,UAAS,EAAKC,cAAa,KAAWJ,IAAWpjB,OAAOyjB,eAAezjB,OAAOyjB,eAAeN,EAASC,GAAYD,EAASO,UAAUN,GAXj9C,GAAIjjB,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GACpEoqB,EAA4C7qB,EAAoB,KAChE8qB,EAAkD9qB,EAAoB,IACtEqtB,EAAgDrtB,EAAoB,MACpEstB,EAAyCttB,EAAoB,MAC7DutB,EAAiDvtB,EAAoBU,EAAE4sB,GACvEE,EAAqCxtB,EAAoB,IACzDytB,EAA6CztB,EAAoB,KACjE0tB,EAAmD1tB,EAAoB,MACvE2tB,EAAyD3tB,EAAoB,IAClGikB,EAAa,WAAW,QAASC,GAAiBhiB,EAAOmE,GAAO,IAAI,GAAIxE,GAAE,EAAEA,EAAEwE,EAAM9D,OAAOV,IAAI,CAAC,GAAIge,GAAWxZ,EAAMxE,EAAGge,GAAW+D,WAAW/D,EAAW+D,aAAY,EAAM/D,EAAWiE,cAAa,EAAQ,SAAUjE,KAAWA,EAAWgE,UAAS,GAAKvjB,OAAOC,eAAe2B,EAAO2d,EAAW9d,IAAI8d,IAAc,MAAO,UAASsD,EAAYgB,EAAWC,GAAuI,MAAvHD,IAAWD,EAAiBf,EAAY/f,UAAU+gB,GAAeC,GAAYF,EAAiBf,EAAYiB,GAAoBjB,MAAsBgI,EAAg/B,SAAgCT,EAAQC,GAAK,MAAOrqB,QAAOsqB,OAAOtqB,OAAO4jB,iBAAiBwG,GAASC,KAAKnqB,MAAMF,OAAOsqB,OAAOD,SAApkC,6EAA6E,6EuBn6FjnBiD,EAAaJ,EAAA,EAAMK,KACzBR,GAAA,EAAeS,WAAWP,EAAAptB,EAE1B,IAAM4tB,GAAkBztB,OAAAwqB,EAAA,GAAO8C,GAAzBzC,GAMA6C,EvB05Fk8D,SAAS9I,GAA2C,QAAS8I,KAAW,GAAInC,GAASC,EAAM3G,EAAM4G,CAAK9I,GAAgB3hB,KAAK0sB,EAAU,KAAI,GAAIhC,GAAK7oB,UAAUZ,OAAO8J,EAAKT,MAAMogB,GAAMC,EAAK,EAAEA,EAAKD,EAAKC,IAAQ5f,EAAK4f,GAAM9oB,UAAU8oB,EAAO,OAAaH,GAAO3G,EAAM9B,EAA2B/hB,MAAMuqB,EAAKmC,EAAShK,WAAW1jB,OAAO8kB,eAAe4I,IAAWliB,KAAK5I,MAAM2oB,GAAMvqB,MAAMkI,OAAO6C,KAAe8Y,EuBz5Fj1E9S,OACE7R,MAAO,iBvBw5F42E2kB,EuBx4Fr3E8I,SAAW,SAAC7S,GACV,GAAM5a,GAAQ4a,EAAElZ,OAAO1B,KACvB2kB,GAAKmB,UACH9lB,UAEF2kB,EAAK9e,MAAM2N,mBAAmBxT,IvBm4FspEurB,EAAyTD,EAAOzI,EAA2B8B,EAAM4G,GAAw+E,MAApiGvI,GAAUwK,EAAS9I,GAAgjBjB,EAAa+J,IAAWjsB,IAAI,oBAAoBvB,MAAM,WuBp5FllFc,KAAK+E,MAAM6nB,oBvBo5FooFnsB,IAAI,4BAA4BvB,MAAM,SuBl5F7pFmnB,GACxB,GAAIrmB,KAAK+E,MAAM+lB,WAAazE,EAAUyE,SAAU,IACtCA,GAAa9qB,KAAK+E,MAAlB+lB,QACJA,GAASE,MACiC,aAAzCF,EAASE,KAAK5b,KAAK,SAAA5M,GAAA,MAAKA,KAAGyO,WAC9BjR,KAAK+E,MAAM2N,yBvB64F65FjS,IAAI,SAASvB,MAAM,WuBh4Fx7F,GAAA0rB,GAC+B5qB,KAAK+E,MAAnC+lB,EADDF,EACCE,SAAUvX,EADXqX,EACWrX,gBACVE,EAAqCF,EAArCE,kBAAmBoZ,EAAkBtZ,EAAlBsZ,cACrB7f,EAAOyG,EACPhU,GACJqtB,OAAO,EACP9f,OACA+f,OAAQ,SACRC,OAAQ,IACRC,QAAS,UAAW,UAAW,UAAW,UAAW,OAAQ,OAAQ,OACrEC,UAAYC,MAAO,gBACnBC,SACEC,OACEC,SAAS,EACTC,OAAO,GAAIC,OAAOC,cAAkBZ,EAA9B,gBACNa,UAAW,YAIjB,OAAI5C,GAASE,MACiC,aAAzCF,EAASE,KAAK5b,KAAK,SAAA5M,GAAA,MAAKA,KAAGyO,UACvB,KAGPrS,EAAAC,EAAAC,cAAA,YACEF,EAAAC,EAAAC,cAAC2tB,GAAgBE,SAAU3sB,KAAK2sB,SAAUztB,MAAOc,KAAK+Q,MAAM7R,OAC1DN,EAAAC,EAAAC,cAACotB,EAAA,GAAMhtB,MAAM,iBAAgBN,EAAAC,EAAAC,cAACutB,EAAA,GAAiBjiB,GAAG,sBAClDxL,EAAAC,EAAAC,cAACotB,EAAA,GAAMhtB,MAAM,uBAAsBN,EAAAC,EAAAC,cAACutB,EAAA,GAAiBjiB,GAAG,uBAEtD0gB,EAASE,MACJF,EAASE,KAAK5b,KAAK,SAAA5M,GAAA,MAAKA,KAAGyO,aAAekb,EAAA,GAAiBA,EAAA,GAAaA,EAAA,IAC1EvtB,EAAAC,EAAAC,cAACotB,EAAA,GAAMhtB,MAAM,kBAAiBN,EAAAC,EAAAC,cAACutB,EAAA,GAAiBjiB,GAAG,oBAG1DxL,EAAAC,EAAAC,cAACitB,EAAA,EAAatsB,QvB81Fk/JitB,GuB15Fj/JvtB,EAAA,WAkEjBwuB,mBACDvB,GAGCf,EAAkB,SAAAta,GAAA,OAEpBwC,gBAAiBxC,EAAMua,KAAK/X,gBAC5BuX,SAAU/Z,EAAMoZ,KAAKnd,MAIzBvO,GAAA,EAAeO,OAAAuqB,EAAA,GACb8B,EACAsC,GACAjB,IvB80FIkB,KACA,SAAUpvB,EAAQC,EAAqBC,GAE7C,YAE+BA,GAAoBwO,EAAEzO,EAAqB,IAAK,WAAa,MAAOovB,IAO9E,IAAI1uB,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GwB97F7F2uB,EAAApvB,EAAA,MAWAqvB,EAAA,EAEAC,EAAA,SAAAC,GACA,QAAAD,KACAC,EAAArsB,MAAA5B,KAAA6B,WAiDA,MA9CAosB,KAAAD,EAAAtL,UAAAuL,GACAD,EAAAlsB,UAAA9C,OAAAqjB,OAAA4L,KAAAnsB,WACAksB,EAAAlsB,UAAAsK,YAAA4hB,EAEAA,EAAAlsB,UAAAosB,aAAA,SAAAnpB,GACA,GAAAiI,GAAAjI,EAAAiI,KACAvN,IACA,QAAAqF,KAAAC,GACAA,EAAA7D,eAAA4D,IAAA,SAAAA,GAAA,OAAAA,GAAA,WAAAA,GAAA,UAAAA,IACArF,EAAAqF,GAAAC,EAAAD,GAGA9E,MAAAqP,SACA,GAAAtK,GAAAopB,UAAAnuB,KAAAqP,QAAArC,EAAAvN,IAIAuuB,EAAAlsB,UAAAssB,kBAAA,WACApuB,KAAAkuB,aAAAluB,KAAA+E,QAGAipB,EAAAlsB,UAAAusB,mBAAA,WACAruB,KAAAkuB,aAAAluB,KAAA+E,QAGAipB,EAAAlsB,UAAAwsB,OAAA,WACA,GAAAC,GAAAvuB,KAEA+E,EAAA/E,KAAA+E,MACA+gB,GACA5gB,OAAAH,EAAAG,QAAA,QACAspB,WAAAzpB,EAAAG,QAAA,QACAD,MAAAF,EAAAE,OAAA,OACAwpB,UAAA,SACAttB,MAAA,OACAutB,SAAA,OACAC,WAAA,gFAGA,OADA3uB,MAAA+tB,QAAAhpB,EAAAqF,IAAApK,KAAA+tB,SAAA,SAAAA,IAEAnvB,EAAAC,EAAAC,cAAA,OAAkCsL,GAAApK,KAAA+tB,QAAAjI,QAAAmB,IAAA,SAAA5X,GAAyD,MAAAkf,GAAAlf,YAC3F,eAKA2e,GACCpvB,EAAAC,EAAA+pB,WAEDgG,EAAA,SAAAT,GACA,gBAAAppB,GACA,MAAAnG,GAAAC,EAAAC,cAAAkvB,EAAAhvB,OAAA4S,UAA+D7M,GAAUopB,iBAKzEN,GADAe,EAAAd,EAAA,EAAAe,WACAD,EAAAd,EAAA,EAAAD,WAQAnpB,GAPAkqB,EAAAd,EAAA,EAAAgB,aACAF,EAAAd,EAAA,EAAAiB,UACAH,EAAAd,EAAA,EAAAkB,WACAJ,EAAAd,EAAA,EAAAmB,cACAL,EAAAd,EAAA,EAAAoB,UACAN,EAAAd,EAAA,EAAAqB,WAGA3C,WAAA,SAAAY,GACAU,EAAA,EAAAtB,WAAAY,KAIA3uB,GAAA,KxBs8FM2wB,KACA,SAAU5wB,EAAQC,EAAqBC,GAE7C,YyBzhGA,SAAAsK,GAAAqmB,GACA,yBAAArwB,OAAA8C,UAAAyI,SAAAC,KAAA6kB,GAGA,QAAAC,GAAAD,GACA,MAAAA,aAAAE,UAGA,QAAAC,GAAAH,GACA,OAAAC,EAAAD,gBAAArwB,QAIA,QAAA0C,GAAAd,EAAA0K,GACA,GAAA7K,EACA,KAAAA,IAAA6K,GACAkkB,EAAAlkB,EAAA7K,KAAAuI,EAAAsC,EAAA7K,KACA+uB,EAAAlkB,EAAA7K,MAAA+uB,EAAA5uB,EAAAH,MACAG,EAAAH,OAEAuI,EAAAsC,EAAA7K,MAAAuI,EAAApI,EAAAH,MACAG,EAAAH,OAEAiB,EAAAd,EAAAH,GAAA6K,EAAA7K,SACKgP,KAAAnE,EAAA7K,KACLG,EAAAH,GAAA6K,EAAA7K,IAKA,QAAAV,GAAA0vB,EAAAC,GACA,GAAA9uB,KAGA,OAFAc,GAAAd,EAAA6uB,GACA/tB,EAAAd,EAAA8uB,GACA9uB,EASA,QAAA+uB,GAAAC,GACA,GAAAC,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA9E,EAAAtS,EAAAqX,EAAAtvB,EAAA2O,CAEA,0BADA3O,EAAA7B,OAAA8C,UAAAyI,SAAAC,KAAAolB,IAEAA,EAEA,oBAAA/uB,GAGAkvB,EAAAH,EAAAQ,MAAAC,GACAN,GACAvgB,EAAA8gB,SAAAP,EAAA,OACAG,EAAAI,SAAAP,EAAA,SACAF,EAAAS,SAAAP,EAAA,OACAD,EAAAQ,SAAAP,EAAA,OACAE,EAAAF,EAAA,GAAAO,SAAAP,EAAA,SACAI,EAAAJ,EAAA,IAAAO,SAAAP,EAAA,UACAC,EAAAD,EAAA,QAAApc,WAAA4c,EAAAR,EAAA,IAAAhX,MAAA,MACAD,EAAA0U,KAAAgD,IAAAhhB,EAAA0gB,EAAAL,EAAAC,EAAAG,EAAAE,EAAAH,GACAD,EAAA,KAAAA,EAAA,MACA3E,EAAA,GAAA2E,EAAA,IACAA,EAAA,MACA3E,GAAAkF,SAAAP,EAAA,SAEA3E,GAAA,MAAA2E,EAAA,SACAjX,GAAA,GAAAsS,EAAA,KAEA,GAAAoC,MAAA1U,QAjBA,QAJA,GA0BA,QAAA2X,GAAAC,GACA,GAAAnwB,GAAA4Z,EAAAnN,CACA,KAAAzM,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAEhC,IADAyM,EAAA0jB,EAAAnwB,GAAAyM,KACAmN,EAAA,EAAeA,EAAAnN,EAAA/L,OAAiBkZ,IAChC,GAAAnN,EAAAmN,GAAA,KACA,QAIA,UAGA,QAAAwW,GAAAvxB,GACA,SAAAA,EAGA,QAAAwxB,GAAAxxB,GACA,MAAAuU,YAAAvU,GAGA,QAAAyxB,GAAAzxB,GACA,GAAA2wB,GAAAvgB,EAAA0gB,EAAAL,CACA,qBAAAzwB,GACA,oBAAAA,GACAA,EAAA,GAAAouB,MAAA,IAAApuB,OACK,CAEL,GADAA,EAAAuxB,EAAAvxB,GACA2wB,EAAA3wB,EAAAgxB,MAAAU,GAIA,MAHAthB,GAAA8gB,SAAAP,EAAA,OACAG,EAAAI,SAAAP,EAAA,SACAF,EAAAS,SAAAP,EAAA,OACA,GAAAvC,MAAAhe,EAAA0gB,EAAAL,EAIA,IAAAkB,GAAA3xB,EAAA4xB,QAAA,SAAAA,QAAA,QAAAA,QAAA,UACA5xB,GAAAuwB,EAAAoB,IAAA,GAAAvD,MAAApuB,GAIA,MAAAA,GAGA,QAAA6xB,GAAA7xB,GACA,IAAA4J,EAAA5J,GAAA,CACA,GAAAmB,GAAA2wB,IACA,KAAA3wB,IAAAnB,GACAA,EAAA8B,eAAAX,IACA2wB,EAAA3sB,MAAAhE,EAAAnB,EAAAmB,IAGAnB,GAAA8xB,EAEA,MAAA9xB,GAGA,QAAA+xB,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,gBAAAxtB,EAAA2a,EAAA8S,GACA,GAAAlB,GAAAvsB,EAAA6I,KACAvN,EAAAM,KAA0BqxB,EA0C1B,OAzCA3xB,GAAAM,EAAAN,EAAAmyB,QAEAztB,EAAAktB,YAAA,UAAAvS,KACAuS,EAAA5xB,EAAAqf,EAAAiO,OAAA5oB,EAAAktB,YAGAvS,EAAAuO,OACAiE,EAAA7xB,EAAAqf,EAAAuO,OAIA,OAAAvO,GACAyS,EAAA9xB,EAAAqf,EAAAnV,KACK8mB,EAAAC,IACLa,EAAA9xB,EAAA,GAIAqf,EAAAzY,KACAmrB,EAAA/xB,EAAAqf,EAAAzY,KAGA,WAAAyY,IACA2S,EAAAhyB,EAAAqf,EAAA+S,SAGA/S,EAAAmO,SACAxtB,EAAAwtB,OAAAnO,EAAAmO,QAGAnO,EAAAgT,QACAJ,EAAAjyB,EAAAqf,EAAAgT,QAGAhT,EAAAiT,QACAJ,EAAAlyB,EAAAqf,EAAAiT,QAIAtyB,EAAAM,EAAAN,EAAAqf,EAAAsO,cAMA,QAAA4E,GAAAnzB,EAAAgF,GACA,MAAAhF,GAAA,GAAAozB,UAAApuB,EAAA,GAAAouB,UAGA,QAAAC,GAAArzB,EAAAgF,GACA,MAAAhF,GAAA,GAAAgF,EAAA,GAGA,QAAAsuB,GAAAtzB,EAAAgF,GACA,MAAAhF,GAAAgF,EAGA,QAAAuuB,GAAAllB,GACA,WAAAA,EAAAmlB,mBAAA,IAAAnlB,EAAAolB,aAGA,QAAAC,GAAArlB,GACA,MAAAklB,GAAAllB,IAAA,IAAAA,EAAAslB,aAGA,QAAAC,GAAAvlB,GACA,MAAAqlB,GAAArlB,IAAA,IAAAA,EAAAwlB,WAGA,QAAAC,GAAAzlB,EAAA0lB,GACA,MAAAH,GAAAvlB,MAAA2lB,WAAAD,EAGA,QAAAE,GAAA5lB,GACA,MAAAulB,GAAAvlB,IAAA,IAAAA,EAAA6lB,UAGA,QAAAC,GAAA9lB,GACA,MAAA4lB,GAAA5lB,IAAA,IAAAA,EAAA+lB,WAGA,QAAAC,GAAAlf,GACA,OAAAmf,MAAAtC,EAAA7c,KAAA2c,EAAA3c,GAAA/S,QAAA,EAGA,QAAAmyB,GAAAC,EAAAn0B,EAAAO,GAUA,GATA4zB,KAAA,GACA5zB,EAAA6zB,SACAp0B,EAAA,IACAA,IAAA,EACAm0B,GAAA,KAEAA,GAAA5zB,EAAA6zB,QAGA7zB,EAAA8zB,WAAA9zB,EAAA+zB,QAAA,CACAt0B,EAAAyxB,EAAAzxB,EACA,IAAAu0B,GAAAv0B,EAAAw0B,MAAA,IACAx0B,GAAAu0B,EAAA,GACAh0B,EAAA8zB,YACAr0B,IAAA8xB,QAAA,wBAAwCvxB,EAAA8zB,YAExCE,EAAAxyB,OAAA,IACA/B,IAAAO,EAAA+zB,SAAA,KAAAC,EAAA,IAIA,MAAAJ,GAAAn0B,GAAAO,EAAAutB,QAAA,IAGA,QAAA2G,GAAA3mB,GACA,GAAAzM,GAAA4Z,EAAAjN,CACA,KAAA3M,EAAA,EAAaA,EAAAyM,EAAA/L,OAAiBV,IAE9B,IADA2M,EAAAF,EAAAzM,GAAAyM,KACAmN,EAAA,EAAeA,EAAAjN,EAAAjM,OAAckZ,IAC7B,MAAAjN,EAAAiN,GAAA,GACA,QAIA,UAyrCA,QAAAyZ,GAAAC,EAAAC,EAAApjB,GACAqjB,GAAAxvB,MAAAsvB,EAAAC,EAAApjB,IACAsjB,IAGA,QAAAA,KACA,GAAAC,GAAAC,GAAA,CACA,GAAAC,GAAAJ,GAAAK,OACAD,KACAF,KACAI,EAAAF,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAH,MAKA,QAAAM,KACAL,KACAD,IAGA,QAAAK,GAAAR,EAAAC,EAAApjB,GACA6jB,EAAAV,EAAAC,EAAA,SAAAU,EAAAC,EAAAC,GACA,GAAAC,GAAA,iBAAAD,OAAAC,OACAjkB,GAAAikB,KAIA,QAAAJ,GAAAV,EAAAC,EAAApjB,GACA,GAAAkkB,GAAAjb,OAAAkb,QAAAlb,OAAAmb,OAAAnb,OAAAib,CAEA,IAAAA,EACAA,EAAAG,MACAC,SAAA,OACAnB,MACAC,UACApjB,QACAukB,SAAAX,QAEG,CACH,GAAAY,GAAA,GAAAC,eACAD,GAAAE,KAAA,MAAAvB,GAAA,GACAqB,EAAAG,iBAAA,mCACAH,EAAAI,OAAA,WACAhB,IACA,MAAAY,EAAAK,OACAzB,EAAA0B,KAAAC,MAAAP,EAAAQ,cAAAR,EAAAS,WAAAT,GAEAxkB,EAAAwkB,EAAA,QAAAA,EAAAS,aAGAT,EAAAU,QASA,QAAAC,GAAAxmB,EAAAke,GACAuI,SAAAC,KAAAC,UACA3mB,EAAA2mB,UAAAzI,EAEAle,EAAA4mB,YAAA1I,EAIA,QAAA2I,GAAA7mB,EAAAslB,GACAkB,EAAAxmB,EAAA,wBAAAslB,GACAtlB,EAAAyW,MAAA3kB,MAAA,UAGA,QAAAg1B,GAAAhyB,GACA,IACAA,EAAAiyB,WACG,MAAAC,GAEH,KADAH,GAAA/xB,EAAAkL,QAAAgnB,EAAA1B,SACA0B,GAIA,QAAAC,GAAAnyB,EAAAoyB,GACA,iBAAAA,GACA3C,EAAA2C,EAAA,SAAAvpB,GACA7I,EAAAqyB,QAAAxpB,EACAmpB,EAAAhyB,IACK,SAAAwwB,GACLuB,EAAA/xB,EAAAkL,QAAAslB,MAGAxwB,EAAAqyB,QAAAD,EACAJ,EAAAhyB,IAIA,QAAAsyB,GAAAtyB,GACA,GAAAkL,GAAAlL,EAAAkL,QACAqnB,EAAAZ,SAAAh3B,cAAA,IACA43B,GAAAC,UAAA,IAAAxyB,EAAA1E,QAAAk3B,SAAA,YAAAxyB,EAAA1E,QAAAk3B,SACAD,EAAA5Q,MAAAziB,SAAA,WACAqzB,EAAA5Q,MAAAnf,IAAA,OACA+vB,EAAA5Q,MAAAtf,MAAA,OACAkwB,EAAA5Q,MAAA8Q,OAAA,IACAF,EAAA5Q,MAAA0I,WAAA,OACAkI,EAAA91B,OAAA,QACA,IAAAgmB,GAAAkP,SAAAh3B,cAAA,MACA8nB,GAAAiQ,IAAA,WACAjQ,EAAAd,MAAAgR,OAAA,OAGAlQ,EAAAmQ,IAAA,q4BACAL,EAAAM,YAAApQ,GACAvX,EAAAyW,MAAAziB,SAAA,WAEAc,EAAA8yB,oBAAA,EAGA9yB,EAAA+yB,aAAAC,EAAA9nB,EAAA,qBAAAyK,GACA,GAAAsd,GAAAtd,EAAAud,aAEAD,SAAAp3B,MAAAs3B,EAAAt3B,KAAAo3B,MAAAjzB,EAAA1E,QAAAk3B,WACAD,EAAAa,KAAApzB,EAAAqzB,UACAnoB,EAAA2nB,YAAAN,MAKAvyB,EAAAszB,aAAAN,EAAA9nB,EAAA,oBAAAyK,GACA,GAAAsd,GAAAtd,EAAAud,aACAD,SAAAp3B,MAAAs3B,EAAAt3B,KAAAo3B,KACAV,EAAAgB,YACAhB,EAAAgB,WAAAC,YAAAjB,KAOA,QAAAS,GAAAS,EAAAC,EAAA/sB,GACA,GAAA8sB,EAAApa,iBAEA,MADAoa,GAAApa,iBAAAqa,EAAA/sB,GAAA,GACAA,CAEA,IAAAgtB,GAAA,WAEA,MAAAhtB,GAAAN,KAAAotB,EAAAje,OAAAke,OAGA,OADAD,GAAAG,YAAA,KAAAF,EAAAC,GACAA,EAIA,QAAAE,GAAAJ,EAAAC,EAAA/sB,GACA8sB,EAAAna,oBACAma,EAAAna,oBAAAoa,EAAA/sB,GAAA,GAEA8sB,EAAAK,YAAA,KAAAJ,EAAA/sB,GAKA,QAAAwsB,GAAA5e,EAAAxD,GACA,GAAAwD,IAAAxD,EAAgB,QAChB,MAAAA,OAAAwD,GAAwBxD,IAAAwiB,UACxB,OAAAxiB,KAAAwD,EAGA,QAAAwf,GAAA9K,GACA,GAAAA,EAAA,CACA,kBAAAA,EAAA+K,QACA,MAAAC,GACK,IAAAhL,EAAAiL,mBAAAjL,EAAAkL,OACL,MAAAC,GACK,IAAAjJ,EAAAlC,GACL,MAAAoL,IAGA,SAAAC,OAAA,mBAGA,QAAAjM,GAAAY,GACA,GAAAsL,GAAAR,EAAA9K,GACAuL,EAAA,GAAAD,GAAAtL,IAEA,IAAAwL,GAAAj0B,QAAAg0B,IACAC,GAAAr0B,KAAAo0B,GAIA,QAAAE,KACA,SAAAlf,SACA6S,EAAA7S,OAAAmf,OAGA,cAAAnf,SACA6S,EAAA7S,OAAAof,YAGApf,OAAAqf,SAAArf,OAAAqf,OAAAX,mBAAA1e,OAAAqf,OAAAV,SACA9L,EAAA7S,OAAAqf,QAIA,QAAAC,GAAAjsB,EAAAmhB,GACA,gBAAAA,GAAA,aAAAA,GAAA,aAAAA,EACA,WAAAnhB,EAAA/L,MAEA,QAAAV,GAAA,EAAmBA,EAAAyM,EAAA/L,OAAiBV,IACpC,GAAAyM,EAAAzM,GAAAyM,KAAA/L,OAAA,EACA,QAGA,UAIA,QAAAi4B,GAAA/K,EAAAhqB,GACAA,EAAA1E,QAAAytB,UAAA/oB,EAAA1E,QAAAytB,SAAAC,OAAA8L,EAAA90B,EAAA6I,KAAAmhB,GACA0H,EAAA1xB,EAAAkL,QAAAlL,EAAA1E,QAAAytB,SAAAC,QAEAgM,EAAAhL,EAAAhqB,GACAA,EAAA1E,QAAAk3B,WAAAxyB,EAAA8yB,oBAAA,YAAA9yB,EAAAw0B,SACAlC,EAAAtyB,IAOA,QAAAg1B,GAAAhL,EAAAhqB,GACA,GAAA5D,GAAAo4B,EAAAS,EAAAC,CAMA,KALAD,EAAA,SAAAjL,EACAkL,EAAAl1B,EAAA1E,QAAAk5B,QAEAE,IAEAt4B,EAAA,EAAaA,EAAAq4B,GAAA33B,OAAqBV,IAElC,GADAo4B,EAAAC,GAAAr4B,KACA84B,OAAAV,EAAAnoB,OAAA8e,EAAAqJ,EAAAS,IAGA,MAFAj1B,GAAAw0B,UAAAnoB,KACArM,EAAAm1B,gBAAAX,EACAA,EAAAS,GAAAj1B,EAIA,MAAAy0B,IAAA33B,OAAA,EACA,GAAAw3B,OAAA,iCAAAtK,GAEA,GAAAsK,OAAA,2EAmCA,QAAAc,GAAA7I,GACA,GAAAnwB,GAAA4Z,EAAAnN,CACA,KAAAzM,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAEhC,IADAyM,EAAAikB,EAAAP,EAAAnwB,GAAAyM,MACAmN,EAAA,EAAeA,EAAAnN,EAAA/L,OAAiBkZ,IAChC,IAAA+Y,EAAAlmB,EAAAmN,GAAA,IACA,QAIA,UAKA,QAAAqf,GAAA9I,GACA,GAAAnwB,GAAA4Z,EAAAsf,IACA,KAAAl5B,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAAA,CAChC,GAAAm5B,KACA,KAAAvf,IAAAuW,GAAAnwB,GACAmwB,EAAAnwB,GAAAW,eAAAiZ,KACAuf,EAAAvf,GAAAuW,EAAAnwB,GAAA4Z,GAGAsf,GAAAl1B,KAAAm1B,GAEA,MAAAD,GAGA,QAAAE,GAAAx1B,EAAAy1B,GACA,GAAAr5B,GAEAue,EAAA3a,EAAA1E,QACAixB,EAAAvsB,EAAAqyB,OAuBA,MApBAxtB,EAAA0nB,IAAA,iBAAAA,GAAA,IAAA1nB,EAAA0nB,EAAA,KACAA,IAAelgB,KAAAsO,EAAAzC,OAAA,QAAArP,KAAA0jB,IACfvsB,EAAAktB,YAAA,GAEAltB,EAAAktB,YAAA,EAEA,OAAAvS,EAAA+a,cAAApqB,KAAAqP,EAAA+a,UAAA,WAAAD,GAAA,WAAAA,EAGAz1B,EAAA01B,SAAA/a,EAAA+a,SAFA11B,EAAA01B,SAAAN,EAAA7I,GAIAvsB,EAAA01B,WACAD,EAAA,UAEAz1B,EAAA1E,QAAAq6B,QACAF,EAAAz1B,EAAA1E,QAAAq6B,OAIApJ,EAAA8I,EAAA9I,GACAnwB,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAChCmwB,EAAAnwB,GAAAyM,KAAA+sB,GAAA9I,EAAAP,EAAAnwB,GAAAyM,MAAA4sB,EAGA,OAAAlJ,GAGA,QAAAsJ,GAAA71B,GACA,GAAA5D,GAAA05B,EAAAhJ,EAAA9sB,EAAAqyB,QACA,KAAAj2B,EAAA,EAAaA,EAAA05B,EAAAh5B,OAAwBV,IACrC05B,EAAA15B,IAAAowB,EAAAsJ,EAAA15B,GAAA,IAAAqwB,EAAAqJ,EAAA15B,GAAA,IAEA,OAAA05B,GApvDA,GAAAnJ,GAAA,oCAGAT,EAAA,yGACAE,EAAA2J,OAAA,KAAA7gB,OAAA,GA0NA8gB,GACAC,qBAAA,EACAC,WAAA,EACAC,UACAC,eAAA,EACAC,cAEAzN,UACAM,OAAUqB,SAAA,GAAAhB,UAAA,SAGV0D,IACAqJ,QACAC,QAEAvxB,OACAwxB,cAAA,GAEAC,YACAlM,SAAA,GAEAhB,UAAA,UAIAmN,QAEAC,WACAC,iBAAA,GAEAH,YACAlM,SAAA,GAEAhB,UAAA,QAEAsN,QACA7xB,aAOA8xB,IACA,sEACA,sEACA,6DAGA5J,GAAA,SAAA5xB,EAAAstB,EAAAsE,OACA5hB,KAAAsd,GACAttB,EAAAstB,OAAAO,UAAAP,EACAA,IAAA,IAAAA,IACAttB,EAAAstB,OAAA1pB,SAAA0pB,IAEGsE,IACH5xB,EAAAstB,OAAAO,SAAA,IAIAgE,GAAA,SAAA7xB,EAAA4tB,GACA5tB,EAAA4tB,MAAAC,SAAA,EACA7tB,EAAA4tB,MAAAE,KAAAF,GAGAkE,GAAA,SAAA9xB,EAAAkK,GACA,OAAAA,IACAlK,EAAAg7B,OAAAC,MAAA,GAAAvxB,MAAAQ,IAAAinB,EAAAjnB,KAIA6nB,GAAA,SAAA/xB,EAAA4G,GACA5G,EAAAg7B,OAAAC,MAAA,GAAAvxB,MAAA9C,IAAAuqB,EAAAvqB,IAGA60B,GAAA,SAAAz7B,EAAAkK,GACA,OAAAA,IACAlK,EAAAg7B,OAAAI,MAAA,GAAA1xB,MAAAQ,IAAAinB,EAAAjnB,KAIAwxB,GAAA,SAAA17B,EAAA4G,GACA5G,EAAAg7B,OAAAI,MAAA,GAAA1xB,MAAA9C,IAAAuqB,EAAAvqB,IAGAorB,GAAA,SAAAhyB,EAAAoyB,GACApyB,EAAAg7B,OAAAI,MAAA,GAAAhJ,YACApyB,EAAAg7B,OAAAC,MAAA,GAAA7I,aAGAH,GAAA,SAAAjyB,EAAA4tB,GACA5tB,EAAAg7B,OAAAI,MAAA,GAAAD,WAAAtN,SAAA,EACA7tB,EAAAg7B,OAAAI,MAAA,GAAAD,WAAAQ,YAAA/N,GAGAsE,GAAA,SAAAlyB,EAAA4tB,GACA5tB,EAAAg7B,OAAAC,MAAA,GAAAE,WAAAtN,SAAA,EACA7tB,EAAAg7B,OAAAC,MAAA,GAAAE,WAAAQ,YAAA/N,GAIAgO,GAAA,SAAAC,EAAAC,GACA,GAAAziB,GAAA,4CAAsD0iB,KAAAF,EACtD,OAAAxiB,GAAA,QAAAwX,SAAAxX,EAAA,YAAAwX,SAAAxX,EAAA,YAAAwX,SAAAxX,EAAA,YAAAyiB,EAAA,IAAAD,GAGAG,GAAA,SAAAt3B,EAAA6I,EAAAvN,GACA,GAAAi8B,GAAAt1B,KAAAu1B,KAAAx3B,EAAAkL,QAAAusB,YAAA,EAAA5uB,EAAA6uB,OAAA56B,OACAy6B,GAAA,KACAA,EAAA,IAEAj8B,EAAAg7B,OAAAI,MAAA,GAAA1xB,MAAA0B,SAAA,SAAA3L,GAEA,MADAA,GAAAyxB,EAAAzxB,GACAA,EAAA+B,OAAAy6B,EACAx8B,EAAA48B,UAAA,EAAAJ,EAAA,SAEAx8B,IAKA68B,GAAA,SAAA53B,EAAA1E,EAAA0uB,GACA,GAAA6N,IACA1I,OAAAnvB,EAAA1E,QAAA6zB,OACAtG,OAAA7oB,EAAA1E,QAAAutB,OACAuG,UAAApvB,EAAA1E,QAAA8zB,UACAC,QAAArvB,EAAA1E,QAAA+zB,QAGA,IAAAwI,EAAA1I,QAAA0I,EAAAhP,QAAAgP,EAAAzI,WAAAyI,EAAAxI,QAAA,CACA,WAAArF,EAAA,CACA,GAAA8N,GAAAx8B,EAAAg7B,OAAAC,KACA,SAAAvM,IACA8N,EAAAx8B,EAAAg7B,OAAAI,OAGAoB,EAAA,GAAA9yB,MAAA0B,WACAoxB,EAAA,GAAA9yB,MAAA0B,SAAA,SAAA3L,GACA,MAAAk0B,GAAA,GAAAl0B,EAAA88B,KAKA,IAAAv8B,EAAA66B,SAAAE,UAAAne,MACA,WAAA8R,EAAA,CACA,GAAA+N,GAAA,QAAA/N,EAAA,iBACA1uB,GAAA66B,SAAAE,UAAAne,MAAA,SAAA8f,EAAAnvB,GACA,GAAAqP,GAAArP,EAAAqN,SAAA8hB,EAAAlgB,cAAAI,OAAA,EAIA,OAHAA,KACAA,GAAA,MAEA+W,EAAA/W,EAAA8f,EAAAD,GAAAF,QAIAv8B,GAAA66B,SAAAE,UAAAne,MAAA,SAAA8f,EAAAnvB,GACA,GAAAovB,GAAApvB,EAAA6uB,OAAAM,EAAAz3B,MAYA,OATAsE,GAAAozB,IAGAA,IAAArjB,QACAqjB,EAAA,IANA,MAQAA,GARA,KAWAhJ,EAAAgJ,EAAApvB,EAAAqN,SAAA8hB,EAAAlgB,cAAAjP,KAAAmvB,EAAAz3B,OAAAs3B,MAOAK,GAAAlL,EAAApxB,EAAAo6B,EAAA/I,IAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,IAEA2K,GAAA,SAAAn4B,EAAA1E,EAAA0uB,GACA,GAOAyE,GAWAryB,EAAA4Z,EAAAoiB,EAAArvB,EAAAzM,EAlBA4Z,KACAwhB,KAEA5O,EAAA9oB,EAAA1E,QAAAwtB,QAAAgO,GAEApL,GAAA,EACA2M,GAAA,EAEAtM,GAAA,EACA1gB,GAAA,EACAsgB,GAAA,EACA2M,GAAA,EACAC,GAAA,SAAAvO,GAAA,SAAAA,KAAAhqB,EAAA01B,SAEAnJ,EAAAvsB,EAAA6I,KAEA2vB,KAEAC,IACA,KAAAr8B,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAGhC,IAFAg8B,EAAA7L,EAAAnwB,GAEA4Z,EAAA,EAAeA,EAAAoiB,EAAAvvB,KAAA/L,OAAmBkZ,IAClCjN,EAAAqvB,EAAAvvB,KAAAmN,GACA1Z,EAAAi8B,EAAAxvB,EAAA,GAAA+kB,UAAA/kB,EAAA,GACA0vB,EAAAn8B,KACAm8B,EAAAn8B,GAAA,GAAA6J,OAAAomB,EAAAzvB,SAEA27B,EAAAn8B,GAAAF,GAAAqwB,EAAA1jB,EAAA,KACA,IAAAyvB,EAAAh4B,QAAAlE,IACAk8B,EAAAp4B,KAAA9D,IAKAi8B,GAAA,WAAAv4B,EAAA1E,QAAAq6B,QACA6C,EAAA/4B,KAAAuuB,EAGA,IAAA0K,KACA,KAAA1iB,EAAA,EAAaA,EAAAuW,EAAAzvB,OAAmBkZ,IAChC0iB,EAAAt4B,QAGA,IAAArF,GACAuM,CACA,KAAAA,EAAA,EAAaA,EAAAkxB,EAAA17B,OAAyBwK,IAkBtC,IAjBAlL,EAAAo8B,EAAAlxB,GACAixB,GACAx9B,EAAA,GAAAsuB,MAAAoD,EAAArwB,IAEAsvB,KAAA4C,EAAAvzB,GACA0zB,IACAA,EAAA1zB,EAAA2zB,UAEA2J,KAAA7J,EAAAzzB,EAAA0zB,GACA1C,KAAA4C,EAAA5zB,GACAsQ,KAAAwjB,EAAA9zB,GACA4wB,KAAAyC,EAAArzB,GACAu9B,KAAArK,EAAAlzB,IAEAA,EAAAqB,EAEAs7B,EAAAt3B,KAAArF,GACAib,EAAA,EAAeA,EAAAuW,EAAAzvB,OAAmBkZ,IAElC0iB,EAAA1iB,GAAA5V,SAAAkL,KAAAmtB,EAAAr8B,GAAA4Z,GAAA,KAAAyiB,EAAAr8B,GAAA4Z,GAIA,KAAA5Z,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAAA,CAChCg8B,EAAA7L,EAAAnwB,EAEA,IAAAY,GAAAo7B,EAAAp7B,OAAA8rB,EAAA1sB,GACAu8B,EAAA,SAAA3O,EAAAkN,GAAAl6B,EAAA,IAAAA,EAEA6a,GACAK,MAAAkgB,EAAA/rB,KACAxD,KAAA6vB,EAAAt8B,GACAw8B,KAAA,SAAA5O,EACA6O,YAAA77B,EACA27B,kBACAG,qBAAA97B,EACA+7B,0BAAA/7B,EACAg8B,YAAA,EAGAZ,GAAAa,QACAphB,EAAAohB,MAAAb,EAAAa,QAGA,IAAAj5B,EAAA1E,QAAA49B,QACArhB,EAAAshB,YAAA,IAGA,IAAAn5B,EAAA1E,QAAA89B,SACAvhB,EAAAwhB,YAAA,EACAxhB,EAAAyhB,eAAA,GAGAzhB,EAAAjc,EAAAic,EAAA7X,EAAA1E,QAAAuc,aACAA,EAAAjc,EAAAic,EAAAugB,EAAAnP,aACApR,EAAAjc,EAAAic,EAAAugB,EAAAvgB,aAEA3B,EAAA9V,KAAAyX,GAGA,GAAA0gB,GAAAb,EAAA56B,OAAA,GACA,GAAAy8B,GAAA7B,EAAA,GAAA5J,UACA0L,EAAA9B,EAAA,GAAA5J,SACA,KAAA1xB,EAAA,EAAeA,EAAAs7B,EAAA56B,OAAmBV,IAClCrB,EAAA28B,EAAAt7B,GAAA0xB,UACA/yB,EAAAw+B,IACAA,EAAAx+B,GAEAA,EAAAy+B,IACAA,EAAAz+B,EAIA,IAAA0+B,IAAAD,EAAAD,GAAA,KAEA,KAAAj+B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAA6C,KAAA,CACA,GAAAC,EAoBA,IAnBAtuB,GAAAouB,EAAA,MACAn+B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAA6C,KAAA,OACAC,EAAA,KACO5N,GAAA0N,EAAA,KACPn+B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAA6C,KAAA,QACAC,EAAA,IACOjO,GAAA+N,EAAA,IACPn+B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAA6C,KAAA,MACAC,EAAA,GACOhO,GAAA8N,EAAA,IACPn+B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAA+C,gBAAuDjO,KAAA,cACvDrwB,EAAAg7B,OAAAI,MAAA,GAAAG,KAAA6C,KAAA,OACAC,EAAA,MACOrB,IACPh9B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAA+C,gBAAuDtB,OAAA,UACvDh9B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAA6C,KAAA,SACAC,EAAA,SAGAA,GAAAF,EAAA,GACA,GAAAI,GAAA53B,KAAAu1B,KAAAiC,EAAAE,GAAA35B,EAAAkL,QAAAusB,YAAA,KACAY,IAAA,IAAAsB,IACAE,EAAA,EAAA53B,KAAAu1B,KAAAqC,EAAA,IAEAv+B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAAgD,gBAIAv+B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAAiD,gBACApO,EACApwB,EAAAg7B,OAAAI,MAAA,GAAAG,KAAAiD,cAAA,KACOnO,EACPrwB,EAAAg7B,OAAAI,MAAA,GAAAG,KAAAiD,cAAA,aACOxB,IACPh9B,EAAAg7B,OAAAI,MAAA,GAAAG,KAAAiD,cAAA,WAUA,OAJApC,SACAxhB,aAMAme,GAAA,SAAApL,GACAptB,KAAAwQ,KAAA,UACAxQ,KAAAotB,UAGAoL,IAAA12B,UAAAo8B,gBAAA,SAAA/5B,EAAAgqB,GACA,cAAAhqB,EAAA1E,QAAAq6B,MACA,MAAA95B,MAAAm+B,mBAAAh6B,EAAAgqB,GAAA,EAGA,IAAAyD,OAEAztB,EAAA1E,QAAA4G,KAAAstB,EAAAxvB,EAAA6I,QACA4kB,EAAAvrB,IAAA,EAGA,IAAA5G,GAAA48B,GAAAl4B,EAAApE,EAAA6xB,EAAAztB,EAAA1E,SACAs8B,IAAA53B,EAAA1E,EAAA0uB,EAEA,IAAAnhB,GAAAsvB,GAAAn4B,EAAA1E,EAAA0uB,GAAA,OAEA1uB,GAAAg7B,OAAAI,MAAA,GAAAh6B,KAAAsD,EAAA01B,SAAA,kBAEA75B,KAAAo+B,UAAAj6B,EAAA,OAAA6I,EAAAvN,IAGA+4B,GAAA12B,UAAAu8B,eAAA,SAAAl6B,GACA,GAAA1E,GAAAM,KAAwBo6B,EACxBh2B,GAAA1E,QAAAqtB,QACArtB,EAAA6+B,iBAAA,IAGA,UAAAn6B,GAAA1E,SACA4xB,GAAA5xB,EAAA0E,EAAA1E,QAAAstB,QAGA5oB,EAAA1E,QAAA4tB,OACAiE,GAAA7xB,EAAA0E,EAAA1E,QAAA4tB,OAGA5tB,EAAAM,EAAAN,EAAA0E,EAAA1E,QAAA2tB,aACA2O,GAAA53B,EAAA1E,EAAA,MAIA,QAFAo8B,MACA/7B,KACAS,EAAA,EAAiBA,EAAA4D,EAAA6I,KAAA/L,OAAuBV,IAAA,CACxC,GAAAic,GAAArY,EAAA6I,KAAAzM,EACAs7B,GAAAt3B,KAAAiY,EAAA,IACA1c,EAAAyE,KAAAiY,EAAA,IAGA,GAAAR,IACAhP,KAAAlN,EACAg9B,gBAAA34B,EAAA1E,QAAAwtB,QAAAgO,GAEAjf,GAAAjc,EAAAic,EAAA7X,EAAA1E,QAAAuc,YAEA,IAAAhP,IACA6uB,SACAxhB,UAAA2B,GAGAhc,MAAAo+B,UAAAj6B,EAAA,MAAA6I,EAAAvN,IAGA+4B,GAAA12B,UAAAy8B,kBAAA,SAAAp6B,EAAAgqB,GACA,GAAA1uB,EAEAA,GADA,QAAA0uB,EACAgD,EAAApxB,EAAAo6B,EAAA/I,IAAAC,GAAAC,GAAA4J,GAAAC,GAAA1J,GAAAC,GAAAC,IAAAxtB,IAAA1E,SAEA48B,GAAAl4B,IAAA1E,SAEAs8B,GAAA53B,EAAA1E,EAAA0uB,EACA,IAAAnhB,GAAAsvB,GAAAn4B,EAAA1E,EAAA,SACA,SAAA0uB,GACAsN,GAAAt3B,EAAA6I,EAAAvN,GAEAO,KAAAo+B,UAAAj6B,EAAA,QAAAgqB,EAAA,sBAAAnhB,EAAAvN,IAGA+4B,GAAA12B,UAAA08B,gBAAA,SAAAr6B,GACAnE,KAAAk+B,gBAAA/5B,EAAA,SAGAq0B,GAAA12B,UAAA28B,eAAA,SAAAt6B,GACAnE,KAAAu+B,kBAAAp6B,EAAA,QAGAq0B,GAAA12B,UAAAq8B,mBAAA,SAAAh6B,EAAAgqB,EAAAuQ,GACAvQ,KAAA,MAEA,IAAA1uB,GAAA48B,GAAAl4B,IAAA1E,QACAi/B,IACA3C,GAAA53B,EAAA1E,EAAA0uB,EAOA,QAJAlB,GAAA9oB,EAAA1E,QAAAwtB,QAAAgO,GAEA5gB,KACAqW,EAAAvsB,EAAA6I,KACAzM,EAAA,EAAiBA,EAAAmwB,EAAAzvB,OAAmBV,IAAA,CAGpC,OAFAg8B,GAAA7L,EAAAnwB,GACA2M,KACAiN,EAAA,EAAmBA,EAAAoiB,EAAAvvB,KAAA/L,OAAmBkZ,IAAA,CACtC,GAAAqC,IACAha,EAAAouB,EAAA2L,EAAAvvB,KAAAmN,GAAA,IACA1X,EAAAmuB,EAAA2L,EAAAvvB,KAAAmN,GAAA,IAEA,YAAAgU,IACA3R,EAAA5H,EAAAgc,EAAA2L,EAAAvvB,KAAAmN,GAAA,KAEAjN,EAAA3I,KAAAiY,GAGA,GAAArb,GAAAo7B,EAAAp7B,OAAA8rB,EAAA1sB,GACAu8B,EAAA,SAAA3O,EAAAkN,GAAAl6B,EAAA,IAAAA,CAEAkZ,GAAA9V,MACA8X,MAAAkgB,EAAA/rB,KACAmuB,SAAAD,IAAA,EACA1xB,KAAAE,EACA8vB,YAAA77B,EACA27B,kBACAG,qBAAA97B,EACA47B,KAAA,SAAA5O,IAIA,SAAAA,IACAA,EAAA,OAGA,IAAAnhB,IAAcqN,WAEd5a,GAAAg7B,OAAAI,MAAA,GAAAh6B,KAAA,SACApB,EAAAg7B,OAAAI,MAAA,GAAAx3B,SAAA,SAEArD,KAAAo+B,UAAAj6B,EAAAgqB,EAAAnhB,EAAAvN,IAGA+4B,GAAA12B,UAAA88B,kBAAA,SAAAz6B,GACAnE,KAAAm+B,mBAAAh6B,EAAA,WAGAq0B,GAAA12B,UAAA+8B,QAAA,SAAA16B,GACAA,SACAA,QAAA06B,WAIArG,GAAA12B,UAAAs8B,UAAA,SAAAj6B,EAAAtD,EAAAmM,EAAAvN,GACAO,KAAA6+B,QAAA16B,GAEAA,EAAAkL,QAAAyvB,UAAA,mBACA,IAAAC,GAAA56B,EAAAkL,QAAA2vB,qBAAA,YACA76B,SAAA,GAAAnE,MAAAotB,QAAA2R,GACAl+B,OACAmM,OACAvN,YAIA,IAAAw/B,KACA96B,SACA+6B,OACA7R,OACAE,KAAA,MAEAsO,QACA/V,OACA4I,SAAA,UAIAyQ,OACA9R,OACAE,KAAA,MAEAsO,QACA/V,OACA4I,SAAA,UAIArB,OACAE,KAAA,MAEA6R,SACAC,SAAA,GAEAtS,QACAoQ,YAAA,GAEAmC,SACAxZ,OACA4I,SAAA,SAGA6Q,aACAC,cACA9O,QACA+O,aAKAC,GAAA,SAAAjgC,EAAAstB,EAAAsE,OACA5hB,KAAAsd,GACAttB,EAAAstB,OAAAsS,UAAAtS,EACAA,IAAA,IAAAA,IACA,QAAAA,GAAA,WAAAA,EACAttB,EAAAstB,OAAA4S,cAAA5S,GAEAttB,EAAAstB,OAAA1lB,OAAA,WACA5H,EAAAstB,OAAA4S,cAAA,SACAlgC,EAAAstB,OAAA6S,MAAA7S,KAGGsE,IACH5xB,EAAAstB,OAAAsS,SAAA,IAIAQ,GAAA,SAAApgC,EAAA4tB,GACA5tB,EAAA4tB,MAAAE,KAAAF,GAGAyS,GAAA,SAAArgC,EAAAkK,GACAlK,EAAA0/B,MAAAx1B,OAGAo2B,GAAA,SAAAtgC,EAAA4G,GACA5G,EAAA0/B,MAAA94B,OAGA25B,GAAA,SAAAvgC,EAAAoyB,GACApyB,EAAA8/B,YAAA7O,OAAAuP,SAAApO,GAAA,IAAAA,EAAA,SAAAA,EAAA,MAGAqO,GAAA,SAAAzgC,EAAA4tB,GACA5tB,EAAAy/B,MAAA7R,MAAAE,KAAAF,GAGA8S,GAAA,SAAA1gC,EAAA4tB,GACA5tB,EAAA0/B,MAAA9R,MAAAE,KAAAF,GAGA+S,GAAAjP,EAAA8N,GAAAS,GAAAG,GAAAC,GAAAC,GAAAC,GAAAE,GAAAC,IAEAE,GAAA,SAAAl8B,EAAA1E,EAAA0uB,GACA,GAAA6N,IACA1I,OAAAnvB,EAAA1E,QAAA6zB,OACAtG,OAAA7oB,EAAA1E,QAAAutB,OACAuG,UAAApvB,EAAA1E,QAAA8zB,UACAC,QAAArvB,EAAA1E,QAAA+zB,UAGAwI,EAAA1I,QAAA0I,EAAAhP,QAAAgP,EAAAzI,WAAAyI,EAAAxI,WACA,QAAArF,GAAA1uB,EAAA0/B,MAAAtD,OAAAyE,YACA7gC,EAAA0/B,MAAAtD,OAAAyE,UAAA,WACA,MAAAlN,GAAA,GAAApzB,KAAAd,MAAA88B,KAIAv8B,EAAA6/B,QAAAiB,iBACA9gC,EAAA6/B,QAAAiB,eAAA,WACA,4BAAAvgC,KAAAmB,MAAA,kBAAAiyB,EAAApzB,KAAA0wB,OAAAlgB,KAAA,QAAAxQ,KAAAyC,EAAAu5B,GAAA,gBAMA5D,GAAA,SAAAhL,GACAptB,KAAAwQ,KAAA,aACAxQ,KAAAotB,UAGAgL,IAAAt2B,UAAAo8B,gBAAA,SAAA/5B,EAAAgqB,GACAA,KAAA,QACA,IAAAyD,KACA,gBAAAzD,IACAyD,GACA2N,aACAC,YACAS,SAAA,UAEAO,MACAP,SAAA,UAEAvP,QACA+O,QACAJ,SAAA,QAOA,IAAAl7B,EAAA1E,QAAA49B,QACA,eAAAlP,EACAA,EAAA,OACK,WAAAA,IACLA,EAAA,QAIA,IAAAnhB,GAAAzM,EAAA4Z,EAAA1a,EAAA2gC,GAAAj8B,IAAA1E,QAAAmyB,EACAnyB,GAAAy/B,MAAAr+B,KAAAsD,EAAA01B,SAAA,sBACAp6B,EAAA0E,MAAAtD,OACApB,EAAA0E,MAAAtD,KAAAstB,GAEAkS,GAAAl8B,EAAA1E,EAAA0uB,EAEA,IAAAuC,GAAAvsB,EAAA6I,IACA,KAAAzM,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAAA,CAEhC,GADAyM,EAAA0jB,EAAAnwB,GAAAyM,MACA7I,EAAA01B,SACA,IAAA1f,EAAA,EAAiBA,EAAAnN,EAAA/L,OAAiBkZ,IAClCnN,EAAAmN,GAAA,GAAAnN,EAAAmN,GAAA,GAAA8X,SAGAvB,GAAAnwB,GAAAk/B,QAAwBgB,OAAA,WACxB,IAAAt8B,EAAA1E,QAAA89B,SACA7M,EAAAnwB,GAAAk/B,OAAAJ,SAAA,GAIAr/B,KAAAo+B,UAAAj6B,EAAAusB,EAAAjxB,IAGA24B,GAAAt2B,UAAAq8B,mBAAA,SAAAh6B,GACA,GAAA1E,GAAA2gC,GAAAj8B,IAAA1E,WACAA,GAAA0E,MAAAtD,KAAA,UACAb,KAAAo+B,UAAAj6B,IAAA6I,KAAAvN,IAGA24B,GAAAt2B,UAAAu8B,eAAA,SAAAl6B,GACA,GAAAytB,GAAA7xB,EAAAk/B,MAEA96B,GAAA1E,QAAAwtB,SACA2E,EAAA3E,OAAA9oB,EAAA1E,QAAAwtB,QAEA9oB,EAAA1E,QAAAqtB,QACA8E,EAAA2N,aAAgCmB,KAAMC,UAAA,SAGtC,UAAAx8B,GAAA1E,SACAigC,GAAA9N,EAAAztB,EAAA1E,QAAAstB,QAGA5oB,EAAA1E,QAAA4tB,OACAwS,GAAAjO,EAAAztB,EAAA1E,QAAA4tB,MAGA,IAAA5tB,GAAAM,EAAA6xB,EAAAztB,EAAA1E,QAAA2tB,YACAiT,IAAAl8B,EAAA1E,EAAA,MACA,IAAAixB,KACA7vB,KAAA,MACA2P,KAAArM,EAAA1E,QAAA4c,OAAA,QACArP,KAAA7I,EAAA6I,MAGAhN,MAAAo+B,UAAAj6B,EAAAusB,EAAAjxB,IAGA24B,GAAAt2B,UAAAy8B,kBAAA,SAAAp6B,EAAAgqB,GACAA,KAAA,QACA,IACA5tB,GAAA4Z,EAAAoiB,EAAArvB,EADAwjB,EAAAvsB,EAAA6I,KACAvN,EAAA2gC,GAAAj8B,IAAA1E,SAAAm9B,KAAAgE,IAIA,KAHAnhC,EAAA0E,MAAAtD,KAAAstB,EACAkS,GAAAl8B,EAAA1E,EAAA0uB,GAEA5tB,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAGhC,IAFAg8B,EAAA7L,EAAAnwB,GAEA4Z,EAAA,EAAeA,EAAAoiB,EAAAvvB,KAAA/L,OAAmBkZ,IAClCjN,EAAAqvB,EAAAvvB,KAAAmN,GACAyiB,EAAA1vB,EAAA,MACA0vB,EAAA1vB,EAAA,OAAA5C,OAAAomB,EAAAzvB,QACA2/B,EAAAr8B,KAAA2I,EAAA,KAEA0vB,EAAA1vB,EAAA,IAAA3M,GAAA2M,EAAA,EAIA,YAAA/I,EAAA1E,QAAAq6B,OACA8G,EAAAh9B,KAAAuuB,GAGA1yB,EAAAy/B,MAAA0B,YAEA,IAAAC,GAAApH,IACA,KAAAl5B,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAAA,CAEhC,IADA2M,KACAiN,EAAA,EAAeA,EAAAymB,EAAA3/B,OAAuBkZ,IACtCjN,EAAA3I,KAAAq4B,EAAAgE,EAAAzmB,IAAA5Z,IAAA,EAGAsgC,IACArwB,KAAAkgB,EAAAnwB,GAAAiQ,KACAxD,KAAAE,GAEAwjB,EAAAnwB,GAAA68B,QACAyD,EAAAzD,MAAA1M,EAAAnwB,GAAA68B,OAGA3D,EAAAl1B,KAAAs8B,GAGA7gC,KAAAo+B,UAAAj6B,EAAAs1B,EAAAh6B,IAGA24B,GAAAt2B,UAAA28B,eAAA,SAAAt6B,GACAnE,KAAAu+B,kBAAAp6B,EAAA,QAGAi0B,GAAAt2B,UAAA08B,gBAAA,SAAAr6B,GACAnE,KAAAk+B,gBAAA/5B,EAAA,eAGAi0B,GAAAt2B,UAAA+8B,QAAA,SAAA16B,GACAA,SACAA,QAAA06B,WAIAzG,GAAAt2B,UAAAs8B,UAAA,SAAAj6B,EAAA6I,EAAAvN,GACAO,KAAA6+B,QAAA16B,GAEA1E,EAAA0E,MAAA28B,SAAA38B,EAAAkL,QAAAjF,GACA3K,EAAAixB,OAAA1jB,EACA7I,QAAA,GAAAnE,MAAAotB,QAAA0L,MAAAr5B,GAGA,IAAAshC,OACAvG,MAGAwG,IACAn4B,aACAo4B,SAAA,gFACAC,UAAA,EACAnU,QACAoU,WACAzS,SAAA,GACAvtB,MAAA,QAEAigC,UAAA,SACA/9B,SAAA,SAEAg+B,UAAA,WACAC,OACAH,WACAhgC,MAAA,OACAutB,SAAA,IAEA6S,kBACAC,WACArgC,MAAA,eAEAsgC,cAAA,OACAC,eAEAC,OACAR,WACAhgC,MAAA,OACAutB,SAAA,IAEA6S,kBACAE,cAAA,OACAC,eAEApC,SACA6B,WACAhgC,MAAA,OACAutB,SAAA,MAKAkT,GAAA,SAAAniC,EAAAstB,EAAAsE,GACA,OAAA5hB,KAAAsd,EAAA,CACA,GAAA1pB,EAIAA,GAHA0pB,GAEK,IAAAA,EACL,QAEAA,EAJA,OAMAttB,EAAAstB,OAAA1pB,eACGguB,KACH5xB,EAAAstB,OAAA1pB,SAAA,SAIAw+B,GAAA,SAAApiC,EAAA4tB,GACA5tB,EAAA4tB,QACA5tB,EAAA8hC,gBAA4BpgC,MAAA,OAAAutB,SAAA,SAG5BoT,GAAA,SAAAriC,EAAAkK,GACAlK,EAAAkiC,MAAAD,WAAA/3B,OAGAo4B,GAAA,SAAAtiC,EAAA4G,GACA5G,EAAAkiC,MAAAD,WAAAr7B,OAGA27B,GAAA,SAAAviC,EAAAkK,GACAlK,EAAA6hC,MAAAI,WAAA/3B,OAGAs4B,GAAA,SAAAxiC,EAAA4G,GACA5G,EAAA6hC,MAAAI,WAAAr7B,OAGA67B,GAAA,SAAAziC,EAAAoyB,GACApyB,EAAA0iC,UAAAtQ,IAAA,GAGAuQ,GAAA,SAAA3iC,EAAA4tB,GACA5tB,EAAA6hC,MAAAjU,QACA5tB,EAAA6hC,MAAAC,eAAAc,QAAA,GAGAC,GAAA,SAAA7iC,EAAA4tB,GACA5tB,EAAAkiC,MAAAtU,QACA5tB,EAAAkiC,MAAAJ,eAAAc,QAAA,GAGAE,GAAApR,EAAA6P,GAAAY,GAAAC,GAAAC,GAAAC,GAAAG,GAAAE,GAAAE,IAEAE,GAAA,SAAA33B,GACA8O,OAAAoe,YACApe,OAAAoe,YAAA,WAAAltB,GACG8O,OAAA6D,kBACH7D,OAAA6D,iBAAA,SAAA3S,GAAA,GAEAA,KAGA0tB,GAAA,SAAAnL,GACAptB,KAAAwQ,KAAA,SACAxQ,KAAAotB,UAGAmL,IAAAz2B,UAAAo8B,gBAAA,SAAA/5B,GACA,GAAAoqB,GAAAvuB,IAEAA,MAAAyiC,cAAAt+B,EAAA,WACA,GAAAytB,OAEA,IAAAztB,EAAA1E,QAAA49B,QACAzL,EAAAyP,UAAA,SAGA,IAAAl9B,EAAA1E,QAAA89B,SACA3L,EAAAsP,UAAA,EAGA,IAAAzhC,GAAA8iC,GAAAp+B,IAAA1E,QAAAmyB,GACA8Q,EAAAv+B,EAAA01B,SAAA,mBACA,YAAA11B,EAAA1E,QAAAq6B,QACA4I,EAAA,SAEA,IAAA11B,GAAAuhB,EAAA+N,gBAAAn4B,EAAA6I,KAAA01B,EAEAnU,GAAA6P,UAAAj6B,EAAAoqB,EAAAnB,QAAAuV,cAAA9T,UAAA7hB,EAAAvN,MAIA84B,GAAAz2B,UAAAu8B,eAAA,SAAAl6B,GACA,GAAAoqB,GAAAvuB,IAEAA,MAAAyiC,cAAAt+B,EAAA,WACA,GAAAytB,IACA/oB,WACAlC,IAAA,MACAzB,OAAA,OAEA6nB,UAEA5oB,GAAA1E,QAAAwtB,SACA2E,EAAA3E,OAAA9oB,EAAA1E,QAAAwtB,QAEA9oB,EAAA1E,QAAAqtB,QACA8E,EAAAgR,QAAA,IAEA,UAAAz+B,GAAA1E,SACAmiC,GAAAhQ,EAAAztB,EAAA1E,QAAAstB,QAEA5oB,EAAA1E,QAAA4tB,OACAwU,GAAAjQ,EAAAztB,EAAA1E,QAAA4tB,MAEA,IAAA5tB,GAAAM,IAAAihC,GAAApP,GAAAztB,EAAA1E,QAAA2tB,aAEApgB,EAAA,GAAAuhB,GAAAnB,QAAAuV,cAAAE,SACA71B,GAAA81B,UAAA,aACA91B,EAAA81B,UAAA,kBACA91B,EAAA+1B,QAAA5+B,EAAA6I,MAEAuhB,EAAA6P,UAAAj6B,EAAAoqB,EAAAnB,QAAAuV,cAAA9U,SAAA7gB,EAAAvN,MAIA84B,GAAAz2B,UAAAy8B,kBAAA,SAAAp6B,GACA,GAAAoqB,GAAAvuB,IAEAA,MAAAyiC,cAAAt+B,EAAA,WACA,GAAA1E,GAAA8iC,GAAAp+B,IAAA1E,SACAuN,EAAAuhB,EAAA+N,gBAAAn4B,EAAA6I,KAAA,SAAA7I,EAAA1E,QAAAq6B,MAEAvL,GAAA6P,UAAAj6B,EAAAoqB,EAAAnB,QAAAuV,cAAA7T,YAAA9hB,EAAAvN,MAIA84B,GAAAz2B,UAAA28B,eAAA,SAAAt6B,GACA,GAAAoqB,GAAAvuB,IAEAA,MAAAyiC,cAAAt+B,EAAA,WACA,GAAAytB,IACA0P,OACAE,WACArgC,MAAA,UAIA1B,EAAA0xB,EAAA6P,GAAAY,GAAAC,GAAAG,GAAAC,GAAAC,GAAAE,GAAAE,IAAAn+B,IAAA1E,QAAAmyB,GACA5kB,EAAAuhB,EAAA+N,gBAAAn4B,EAAA6I,KAAA,SAAA7I,EAAA1E,QAAAq6B,MAEAvL,GAAA6P,UAAAj6B,EAAAoqB,EAAAnB,QAAAuV,cAAA5T,SAAA/hB,EAAAvN,MAIA84B,GAAAz2B,UAAA08B,gBAAA,SAAAr6B,GACA,GAAAoqB,GAAAvuB,IAEAA,MAAAyiC,cAAAt+B,EAAA,WACA,GAAAytB,IACAuQ,WAAA,EACAjB,UAAA,EACA8B,YAAA,IAGAvjC,EAAA8iC,GAAAp+B,IAAA1E,QAAAmyB,GACA8Q,EAAAv+B,EAAA01B,SAAA,mBACA,YAAA11B,EAAA1E,QAAAq6B,QACA4I,EAAA,SAEA,IAAA11B,GAAAuhB,EAAA+N,gBAAAn4B,EAAA6I,KAAA01B,EAEAnU,GAAA6P,UAAAj6B,EAAAoqB,EAAAnB,QAAAuV,cAAA3T,UAAAhiB,EAAAvN,MAIA84B,GAAAz2B,UAAAmhC,eAAA,SAAA9+B,GACA,GAAAoqB,GAAAvuB,IAEAA,MAAAyiC,cAAAt+B,EAAA,WACA,GAAAytB,IACA7E,OAAA,OACAmW,WACAjW,OAAA9oB,EAAA1E,QAAAwtB,SAAA,uBAGAxtB,EAAAM,IAAAihC,GAAApP,GAAAztB,EAAA1E,QAAA2tB,aAEApgB,EAAA,GAAAuhB,GAAAnB,QAAAuV,cAAAE,SACA71B,GAAA81B,UAAA,aACA91B,EAAA81B,UAAA,SAAA3+B,EAAA1E,QAAA4c,OAAA,SACArP,EAAA+1B,QAAA5+B,EAAA6I,MAEAuhB,EAAA6P,UAAAj6B,EAAAoqB,EAAAnB,QAAAuV,cAAAzT,SAAAliB,EAAAvN,MAIA84B,GAAAz2B,UAAAq8B,mBAAA,SAAAh6B,GACA,GAAAoqB,GAAAvuB,IAEAA,MAAAyiC,cAAAt+B,EAAA,WACA,GAGA5D,GAAA4Z,EAAAnN,EAAAE,EAHA0kB,KACAnyB,EAAA8iC,GAAAp+B,IAAA1E,QAAAmyB,GAEAlB,EAAAvsB,EAAA6I,KAAA6vB,IACA,KAAAt8B,EAAA,EAAeA,EAAAmwB,EAAAzvB,OAAmBV,IAElC,IADA2M,EAAAwjB,EAAAnwB,GAAAyM,KACAmN,EAAA,EAAiBA,EAAAjN,EAAAjM,OAAckZ,IAAA,CAC/B,GAAAgpB,GAAA,GAAA74B,OAAAomB,EAAAzvB,OAAA,EACAkiC,GAAA,GAAAj2B,EAAAiN,GAAA,GACAgpB,EAAA5iC,EAAA,GAAA2M,EAAAiN,GAAA,GACA0iB,EAAAt4B,KAAA4+B,GAMA,IAFAn2B,EAAA,GAAAuhB,GAAAnB,QAAAuV,cAAAE,UACA71B,EAAA81B,UAAA,aACAviC,EAAA,EAAeA,EAAAmwB,EAAAzvB,OAAmBV,IAClCyM,EAAA81B,UAAA,SAAApS,EAAAnwB,GAAAiQ,KAEAxD,GAAA+1B,QAAAlG,GAEAtO,EAAA6P,UAAAj6B,EAAAoqB,EAAAnB,QAAAuV,cAAA1T,aAAAjiB,EAAAvN,MAIA84B,GAAAz2B,UAAAshC,eAAA,SAAAj/B,GACA,GAAAoqB,GAAAvuB,IAEAA,MAAAyiC,cAAAt+B,EAAA,sBACA,GAAAytB,IACA7E,OAAA,OAGA5oB,GAAA1E,QAAAwtB,SACA2E,EAAA3E,OAAA9oB,EAAA1E,QAAAwtB,OAEA,IAAAxtB,GAAAM,IAAAihC,GAAApP,GAAAztB,EAAA1E,QAAA2tB,aAEApgB,EAAA,GAAAuhB,GAAAnB,QAAAuV,cAAAE,SACA71B,GAAA81B,WAAoBjiC,KAAA,SAAAuJ,GAAA,SACpB4C,EAAA81B,WAAoBjiC,KAAA,OAAAuJ,GAAA,UACpB4C,EAAA81B,WAAoBjiC,KAAA,OAAAuJ,GAAA,QACpB4C,EAAA+1B,QAAA5+B,EAAA6I,MAEA7I,EAAAkL,QAAAyW,MAAA0I,WAAA,SAEAD,EAAA6P,UAAAj6B,EAAAoqB,EAAAnB,QAAAuV,cAAAxT,SAAAniB,EAAAvN,MAIA84B,GAAAz2B,UAAA+8B,QAAA,SAAA16B,GACAA,SACAA,QAAAk/B,cAIA9K,GAAAz2B,UAAAs8B,UAAA,SAAAj6B,EAAAtD,EAAAmM,EAAAvN,GACAO,KAAA6+B,QAAA16B,GAEAA,QAAA,GAAAtD,GAAAsD,EAAAkL,SACAmzB,GAAA,WACAr+B,QAAAm/B,KAAAt2B,EAAAvN,MAIA84B,GAAAz2B,UAAA2gC,cAAA,SAAAt+B,EAAAo/B,EAAA14B,GACA,GAAA0jB,GAAAvuB,IASA,IAPA6K,IACAA,EAAA04B,EACAA,EAAA,aAGA/I,GAAAj2B,MAAkBg/B,OAAA14B,aAElBk2B,GAAAwC,GACAvjC,KAAAwjC,mBACG,CACHzC,GAAAwC,IAAA,CAGA,IAAAE,IACAC,UAAAH,GACA14B,SAAA,WAA6B0jB,EAAAiV,iBAE7B3kB,EAAA1a,EAAAw/B,UACA9kB,GAAA+kB,WACAH,EAAAG,SAAA/kB,EAAA+kB,UAEA,cAAAL,GAAA1kB,EAAAglB,aACAJ,EAAAI,WAAAhlB,EAAAglB,YAGA7jC,KAAAotB,QAAAiL,kBACAr4B,KAAAotB,QAAA0W,KAAA,oBAAAL,GAEAzjC,KAAAotB,QAAAkL,OAAAwL,KAAA,UAAAL,KAKAlL,GAAAz2B,UAAA0hC,aAAA,WAIA,OADAO,GAFAxV,EAAAvuB,KAGAO,EAAA,EAAiBA,EAAAi6B,GAAAv5B,OAAsBV,IACvCwjC,EAAAvJ,GAAAj6B,GACAguB,EAAAnB,QAAAuV,gBAAA,cAAAoB,EAAAR,MAAAhV,EAAAnB,QAAAuV,cAAA9T,WAAA,aAAAkV,EAAAR,MAAAhV,EAAAnB,QAAAuV,cAAAxT,YAEA4U,EAAAl5B,WACA2vB,GAAA51B,OAAArE,EAAA,GACAA,MAMAg4B,GAAAz2B,UAAAw6B,gBAAA,SAAA5L,EAAAgS,EAAA5I,GACA,GAAAv5B,GAAA4Z,EAAAoiB,EAAArvB,EAAAzM,EAAAm8B,KAAAD,IACA,KAAAp8B,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAGhC,IAFAg8B,EAAA7L,EAAAnwB,GAEA4Z,EAAA,EAAeA,EAAAoiB,EAAAvvB,KAAA/L,OAAmBkZ,IAClCjN,EAAAqvB,EAAAvvB,KAAAmN,GACA1Z,EAAA,aAAAiiC,EAAAx1B,EAAA,GAAA+kB,UAAA/kB,EAAA,GACA0vB,EAAAn8B,KACAm8B,EAAAn8B,GAAA,GAAA6J,OAAAomB,EAAAzvB,QACA07B,EAAAp4B,KAAA9D,IAEAm8B,EAAAn8B,GAAAF,GAAAqwB,EAAA1jB,EAAA,GAIA,IAEAhO,GAFA29B,KACAhN,GAAA,CAEA,KAAA1V,EAAA,EAAaA,EAAAwiB,EAAA17B,OAAyBkZ,IACtC5Z,EAAAo8B,EAAAxiB,GACA,aAAAuoB,GACAxjC,EAAA,GAAAsuB,MAAAoD,EAAArwB,IACAsvB,KAAA4C,EAAAvzB,IAEAA,EADK,WAAAwjC,EACL9R,EAAArwB,GAEAA,EAEAs8B,EAAAt4B,MAAArF,GAAAgJ,OAAA00B,EAAAr8B,IAQA,IANA,aAAAmiC,EACA7F,EAAAj5B,KAAAouB,GACG,WAAA0Q,GACH7F,EAAAj5B,KAAAsuB,GAGA,WAAA4H,EAGA,IAFA+C,EAAAj5B,KAAAsuB,GAEA3xB,EAAA,EAAeA,EAAAs8B,EAAA57B,OAAkBV,IACjCs8B,EAAAt8B,GAAA,GAAAowB,EAAAkM,EAAAt8B,GAAA,GAKA,IAAAyM,GAAA,GAAAhN,MAAAotB,QAAAuV,cAAAE,SAGA,KAFAH,EAAA,aAAAA,GAAA7S,EAAA,OAAA6S,EACA11B,EAAA81B,UAAAJ,EAAA,IACAniC,EAAA,EAAaA,EAAAmwB,EAAAzvB,OAAmBV,IAChCyM,EAAA81B,UAAA,SAAApS,EAAAnwB,GAAAiQ,KAIA,OAFAxD,GAAA+1B,QAAAlG,GAEA7vB,EAGA,IAAA+mB,OAAAE,GAAA,EAAAC,GAAA,EAyDArV,GAAA,oBAAAlF,gBAAAqqB,cACApL,MAuMAqL,GAAA,SAAAxjC,EAAAm5B,GAQA,MANAn5B,GADA,WAAAm5B,EACAhJ,EAAAnwB,GACG,aAAAm5B,EACH/I,EAAApwB,GAEAkwB,EAAAlwB,IAKAs5B,GAAA,SAAA/sB,EAAA4sB,GACA,GAAAn5B,GAAA0Z,EAAAvF,IACA,KAAAuF,EAAA,EAAaA,EAAAnN,EAAA/L,OAAiBkZ,IAC9B,WAAAyf,EACAhlB,EAAArQ,MAAAqsB,EAAA5jB,EAAAmN,GAAA,IAAAyW,EAAA5jB,EAAAmN,GAAA,IAAAyW,EAAA5jB,EAAAmN,GAAA,OAEA1Z,EAAAwjC,GAAAj3B,EAAAmN,GAAA,GAAAyf,GACAhlB,EAAArQ,MAAA9D,EAAAmwB,EAAA5jB,EAAAmN,GAAA,MAQA,OALA,aAAAyf,EACAhlB,EAAAhR,KAAAouB,GACG,WAAA4H,GACHhlB,EAAAhR,KAAAsuB,GAEAtd,GA4EAkkB,GAAA,SAAAzpB,EAAAknB,EAAA92B,GACA,GAAAykC,EACA,qBAAA70B,KACA60B,EAAA70B,IACAA,EAAAymB,SAAAqO,eAAA90B,KAEA,SAAAopB,OAAA,sBAAAyL,EAGAlkC,MAAAqP,UACArP,KAAAP,QAAAM,EAAAikC,GAAAvkC,eACAO,KAAAu2B,aAEAyN,GAAA1L,OAAAjpB,EAAAjF,IAAApK,KAEAs2B,EAAAt2B,KAAAu2B,GAEAv2B,KAAAP,QAAA2kC,SACApkC,KAAAqkC,eAIAvL,IAAAh3B,UAAAwiC,WAAA,WACA,MAAAtkC,MAAAqP,SAGAypB,GAAAh3B,UAAAyiC,cAAA,WACA,MAAAvkC,MAAAu2B,YAGAuC,GAAAh3B,UAAA0iC,QAAA,WACA,MAAAxkC,MAAAgN,MAGA8rB,GAAAh3B,UAAA2iC,WAAA,WACA,MAAAzkC,MAAAP,SAGAq5B,GAAAh3B,UAAA4iC,eAAA,WACA,MAAA1kC,MAAAmE,OAGA20B,GAAAh3B,UAAA6iC,WAAA,WACA,MAAA3kC,MAAA24B,SAGAG,GAAAh3B,UAAA8iC,WAAA,SAAArO,EAAA92B,GACAO,KAAAu2B,aACA92B,GACAO,KAAA6kC,gBAAAplC,GAEA62B,EAAAt2B,KAAAu2B,IAGAuC,GAAAh3B,UAAAgjC,WAAA,SAAArlC,GACAO,KAAA6kC,gBAAAplC,GACAO,KAAA+kC,UAGAjM,GAAAh3B,UAAAijC,OAAA,WACAzO,EAAAt2B,UAAAw2B,UAGAsC,GAAAh3B,UAAAkjC,YAAA,WACA,oBAAAhlC,MAAAu2B,WAAA,CAEA,GAAA0O,IAAA,IAAAjlC,KAAAu2B,WAAA5xB,QAAA,YAEA2xB,GAAAt2B,KADAA,KAAAu2B,WAAA0O,EAAA,SAAAzX,OAAAyE,aAKA6G,GAAAh3B,UAAAuiC,aAAA,WACA,GAAA9V,GAAAvuB,KAEAokC,EAAApkC,KAAAP,QAAA2kC,OAEA,KAAApkC,KAAAklC,WAAA,CACA,IAAAd,EAKA,SAAA3L,OAAA,sBAJAz4B,MAAAklC,WAAAC,YAAA,WACA5W,EAAAyW,eACO,IAAAZ,KAOPtL,GAAAh3B,UAAAsjC,YAAA,WACAplC,KAAAklC,aACAG,cAAArlC,KAAAklC,YACAllC,KAAAklC,WAAA,OAIApM,GAAAh3B,UAAA01B,QAAA,WACA,kBAAAx3B,KAAA24B,QACA34B,KAAAmE,MAAAmhC,gBAEA,MAIAxM,GAAAh3B,UAAA+8B,QAAA,WACA7+B,KAAAs5B,iBACAt5B,KAAAs5B,gBAAAuF,QAAA7+B,MAGAA,KAAAk3B,cACAc,EAAAh4B,KAAAqP,QAAA,YAAArP,KAAAk3B,cAGAl3B,KAAAy3B,cACAO,EAAAh4B,KAAAqP,QAAA,WAAArP,KAAAy3B,eAIAqB,GAAAh3B,UAAA+iC,gBAAA,SAAAplC,GACA,GAAA8lC,GAAA9lC,EAAA2kC,SAAA3kC,EAAA2kC,UAAApkC,KAAAP,QAAA2kC,OACApkC,MAAAP,QAAAM,EAAAikC,GAAAvkC,WACA8lC,IACAvlC,KAAAolC,cACAplC,KAAAqkC,iBAIAvL,GAAAh3B,UAAAs0B,SAAA,WACAp2B,KAAAgN,KAAAhN,KAAAwlC,gBACAtM,EAAAl5B,KAAAylC,cAAAzlC,OAGA84B,GAAAh3B,UAAA6hC,SAAA,WACA,MAAA9kB,IAGA,IAAAgQ,IAAA,SAAAiK,GACA,QAAAjK,KACAiK,EAAAl3B,MAAA5B,KAAA6B,WAeA,MAZAi3B,KAAAjK,EAAAnM,UAAAoW,GACAjK,EAAA/sB,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACA+sB,EAAA/sB,UAAAsK,YAAAyiB,EAEAA,EAAA/sB,UAAA0jC,cAAA,WACA,MAAA7L,GAAA35B,KAAA,aAGA6uB,EAAA/sB,UAAA2jC,YAAA,WACA,mBAGA5W,GACCiK,IAEDjL,GAAA,SAAAiL,GACA,QAAAjL,KACAiL,EAAAl3B,MAAA5B,KAAA6B,WAeA,MAZAi3B,KAAAjL,EAAAnL,UAAAoW,GACAjL,EAAA/rB,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACA+rB,EAAA/rB,UAAAsK,YAAAyhB,EAEAA,EAAA/rB,UAAA0jC,cAAA,WACA,MAAAxL,GAAAh6B,OAGA6tB,EAAA/rB,UAAA2jC,YAAA,WACA,kBAGA5X,GACCiL,IAEDhK,GAAA,SAAAgK,GACA,QAAAhK,KACAgK,EAAAl3B,MAAA5B,KAAA6B,WAeA,MAZAi3B,KAAAhK,EAAApM,UAAAoW,GACAhK,EAAAhtB,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACAgtB,EAAAhtB,UAAAsK,YAAA0iB,EAEAA,EAAAhtB,UAAA0jC,cAAA,WACA,MAAA7L,GAAA35B,KAAA,WAGA8uB,EAAAhtB,UAAA2jC,YAAA,WACA,qBAGA3W,GACCgK,IAED/J,GAAA,SAAA+J,GACA,QAAA/J,KACA+J,EAAAl3B,MAAA5B,KAAA6B,WAeA,MAZAi3B,KAAA/J,EAAArM,UAAAoW,GACA/J,EAAAjtB,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACAitB,EAAAjtB,UAAAsK,YAAA2iB,EAEAA,EAAAjtB,UAAA0jC,cAAA,WACA,MAAA7L,GAAA35B,KAAA,WAGA+uB,EAAAjtB,UAAA2jC,YAAA,WACA,kBAGA1W,GACC+J,IAED9J,GAAA,SAAA8J,GACA,QAAA9J,KACA8J,EAAAl3B,MAAA5B,KAAA6B,WAeA,MAZAi3B,KAAA9J,EAAAtM,UAAAoW,GACA9J,EAAAltB,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACAktB,EAAAltB,UAAAsK,YAAA4iB,EAEAA,EAAAltB,UAAA0jC,cAAA,WACA,MAAA7L,GAAA35B,KAAA,aAGAgvB,EAAAltB,UAAA2jC,YAAA,WACA,mBAGAzW,GACC8J,IAED5J,GAAA,SAAA4J,GACA,QAAA5J,KACA4J,EAAAl3B,MAAA5B,KAAA6B,WAeA,MAZAi3B,KAAA5J,EAAAxM,UAAAoW,GACA5J,EAAAptB,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACAotB,EAAAptB,UAAAsK,YAAA8iB,EAEAA,EAAAptB,UAAA0jC,cAAA,WACA,MAAAxL,GAAAh6B,OAGAkvB,EAAAptB,UAAA2jC,YAAA,WACA,kBAGAvW,GACC4J,IAED7J,GAAA,SAAA6J,GACA,QAAA7J,KACA6J,EAAAl3B,MAAA5B,KAAA6B,WAeA,MAZAi3B,KAAA7J,EAAAvM,UAAAoW,GACA7J,EAAAntB,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACAmtB,EAAAntB,UAAAsK,YAAA6iB,EAEAA,EAAAntB,UAAA0jC,cAAA,WACA,MAAA7L,GAAA35B,KAAA,WAGAivB,EAAAntB,UAAA2jC,YAAA,WACA,sBAGAxW,GACC6J,IAED4M,GAAA,SAAA5M,GACA,QAAA4M,KACA5M,EAAAl3B,MAAA5B,KAAA6B,WAeA,MAZAi3B,KAAA4M,EAAAhjB,UAAAoW,GACA4M,EAAA5jC,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACA4jC,EAAA5jC,UAAAsK,YAAAs5B,EAEAA,EAAA5jC,UAAA0jC,cAAA,WACA,MAAA7L,GAAA35B,KAAA,WAGA0lC,EAAA5jC,UAAA2jC,YAAA,WACA,qBAGAC,GACC5M,IAED3J,GAAA,SAAA2J,GACA,QAAA3J,KACA2J,EAAAl3B,MAAA5B,KAAA6B,WAoBA,MAjBAi3B,KAAA3J,EAAAzM,UAAAoW,GACA3J,EAAArtB,UAAA9C,OAAAqjB,OAAAyW,KAAAh3B,WACAqtB,EAAArtB,UAAAsK,YAAA+iB,EAEAA,EAAArtB,UAAA0jC,cAAA,WACA,GAAAjlC,GAAAyM,EAAAhN,KAAAw2B,OACA,KAAAj2B,EAAA,EAAeA,EAAAyM,EAAA/L,OAAiBV,IAChCyM,EAAAzM,GAAA,GAAAswB,EAAA7jB,EAAAzM,GAAA,IACAyM,EAAAzM,GAAA,GAAAswB,EAAA7jB,EAAAzM,GAAA,GAEA,OAAAyM,IAGAmiB,EAAArtB,UAAA2jC,YAAA,WACA,kBAGAtW,GACC2J,IAEDkL,IACAnV,aACAhB,YACAiB,eACAC,YACAC,aACAE,YACAD,gBACAyW,eACAvW,YACAmJ,UACAzzB,UAAA,SAAApF,GACA,OAAAgB,KAAAhB,GACAA,EAAAyB,eAAAT,KACAoe,GAAApe,GAAAhB,EAAAgB,KAIAklC,UAAA,SAAA96B,GACA,OAAAkjB,KAAAiW,IAAA1L,OACA0L,GAAA1L,OAAAp3B,eAAA6sB,IACAljB,EAAAm5B,GAAA1L,OAAAvK,KAIAlP,UACApf,WACAm5B,YACApM,aAGA/tB,GAAA,MzBuiGMmnC,KACA,SAAUpnC,EAAQc,EAASZ,G0B1qKjC,GAAAo6B,GAAAp6B,EAAA,OAEAo6B,GAAAn5B,QAAAjB,EAAA,MAGAA,EAAA,MAAAo6B,GAEAA,EAAA70B,SAAAvF,EAAA,MACAo6B,EAAAt3B,QAAA9C,EAAA,MACAo6B,EAAApe,SAAAhc,EAAA,MACAo6B,EAAA+M,YAAAnnC,EAAA,MACAo6B,EAAAgN,QAAApnC,EAAA,MACAo6B,EAAAiN,SAAArnC,EAAA,MACAo6B,EAAAnb,QAAAjf,EAAA,MACAo6B,EAAAkN,MAAAtnC,EAAA,MAEAA,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GAEAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GAIAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GAEAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,GACAp6B,EAAA,MAAAo6B,EAGA,IAAAnb,GAAAjf,EAAA,KACA,QAAA+M,KAAAkS,GACAA,EAAAzc,eAAAuK,IACAqtB,EAAAnb,QAAAG,SAAAH,EAAAlS,GAIAqtB,GAAAiN,SAAApkC,aAEAnD,EAAAc,QAAAw5B,EACA,oBAAAnf,UACAA,OAAAmf,SAYAA,EAAAmN,OAAAtoB,EAAAoP,OAAAmZ,SASApN,EAAAqN,MAAAxoB,EAAA0P,MAAA6Y,SASApN,EAAAsN,cAAAtN,EAAAnb,QAUAmb,EAAAuN,WAAAvN,EAAAt3B,QAAAE,WASAo3B,EAAAwN,cAAAxN,EAAAn5B,QAAAH,OASAs5B,EAAAyN,cAAAzN,EAAAgN,S1BorKMU,KACA,SAAUhoC,EAAQc,EAASZ,GAEjC,Y2B9yKAA,GAAA,MAEAkB,KAAA,UACA6mC,YAAA,EACAC,4BAAA,EACAtM,qBAAA,EACAuM,QAAA,yDACAC,OACAC,QAAA,KACAC,KAAA,UACAjsB,WAAA,EACAksB,kBAAA,KAEA5f,QAAA,KACA6f,aAAA,kBACAC,iBAAA,OACAC,kBAAA,qDACAC,gBAAA,GACAC,iBAAA,SACAC,WAAA,EAGA3sB,YAGArT,QACAC,SACAX,IAAA,EACAH,MAAA,EACAI,OAAA,EACAT,KAAA,MAKA3H,EAAAc,QAAA,WAGA,GAAAw5B,GAAA,SAAA10B,EAAAya,GAEA,MADA7e,MAAAsnC,UAAAljC,EAAAya,GACA7e,KAKA,OAFA84B,WAEAA,I3BuzKMyO,KACA,SAAU/oC,EAAQc,EAASZ,GAEjC,Y4Bv2KA,IAAAiB,GAAAjB,EAAA,MAOA8oC,GACAv+B,OAAA,SAAAw+B,GACA,MAAAA,IAGAC,WAAA,SAAAD,GACA,MAAAA,MAGAE,YAAA,SAAAF,GACA,OAAAA,KAAA,IAGAG,cAAA,SAAAH,GACA,OAAAA,GAAA,MACA,GAAAA,KAEA,MAAAA,KAAA,OAGAI,YAAA,SAAAJ,GACA,MAAAA,QAGAK,aAAA,SAAAL,GACA,OAAAA,GAAA,GAAAA,IAAA,GAGAM,eAAA,SAAAN,GACA,OAAAA,GAAA,MACA,GAAAA,MAEA,KAAAA,GAAA,GAAAA,IAAA,IAGAO,YAAA,SAAAP,GACA,MAAAA,UAGAQ,aAAA,SAAAR,GACA,SAAAA,GAAA,GAAAA,MAAA,IAGAS,eAAA,SAAAT,GACA,OAAAA,GAAA,MACA,GAAAA,SAEA,KAAAA,GAAA,GAAAA,MAAA,IAGAU,YAAA,SAAAV,GACA,MAAAA,YAGAW,aAAA,SAAAX,GACA,OAAAA,GAAA,GAAAA,QAAA,GAGAY,eAAA,SAAAZ,GACA,OAAAA,GAAA,MACA,GAAAA,UAEA,KAAAA,GAAA,GAAAA,QAAA,IAGAa,WAAA,SAAAb,GACA,SAAArhC,KAAAmiC,IAAAd,GAAArhC,KAAAoiC,GAAA,KAGAC,YAAA,SAAAhB,GACA,MAAArhC,MAAAsiC,IAAAjB,GAAArhC,KAAAoiC,GAAA,KAGAG,cAAA,SAAAlB,GACA,WAAArhC,KAAAmiC,IAAAniC,KAAAoiC,GAAAf,GAAA,IAGAmB,WAAA,SAAAnB,GACA,WAAAA,EAAA,EAAArhC,KAAA2D,IAAA,MAAA09B,EAAA,KAGAoB,YAAA,SAAApB,GACA,WAAAA,EAAA,IAAArhC,KAAA2D,IAAA,MAAA09B,IAGAqB,cAAA,SAAArB,GACA,WAAAA,EACA,EAEA,IAAAA,EACA,GAEAA,GAAA,MACA,GAAArhC,KAAA2D,IAAA,MAAA09B,EAAA,IAEA,MAAArhC,KAAA2D,IAAA,QAAA09B,KAGAsB,WAAA,SAAAtB,GACA,MAAAA,IAAA,EACAA,IAEArhC,KAAA0V,KAAA,EAAA2rB,KAAA,IAGAuB,YAAA,SAAAvB,GACA,MAAArhC,MAAA0V,KAAA,GAAA2rB,GAAA,GAAAA,IAGAwB,cAAA,SAAAxB,GACA,OAAAA,GAAA,OACA,IAAArhC,KAAA0V,KAAA,EAAA2rB,KAAA,GAEA,IAAArhC,KAAA0V,KAAA,GAAA2rB,GAAA,GAAAA,GAAA,IAGAyB,cAAA,SAAAzB,GACA,GAAAlL,GAAA,QACA7jB,EAAA,EACA7Z,EAAA,CACA,YAAA4oC,EACA,EAEA,IAAAA,EACA,GAEA/uB,IACAA,EAAA,IAEA7Z,EAAA,GACAA,EAAA,EACA09B,EAAA7jB,EAAA,GAEA6jB,EAAA7jB,GAAA,EAAAtS,KAAAoiC,IAAApiC,KAAA+iC,KAAA,EAAAtqC,IAEAA,EAAAuH,KAAA2D,IAAA,MAAA09B,GAAA,IAAArhC,KAAAsiC,KAAAjB,EAAAlL,IAAA,EAAAn2B,KAAAoiC,IAAA9vB,KAGA0wB,eAAA,SAAA3B,GACA,GAAAlL,GAAA,QACA7jB,EAAA,EACA7Z,EAAA,CACA,YAAA4oC,EACA,EAEA,IAAAA,EACA,GAEA/uB,IACAA,EAAA,IAEA7Z,EAAA,GACAA,EAAA,EACA09B,EAAA7jB,EAAA,GAEA6jB,EAAA7jB,GAAA,EAAAtS,KAAAoiC,IAAApiC,KAAA+iC,KAAA,EAAAtqC,GAEAA,EAAAuH,KAAA2D,IAAA,MAAA09B,GAAArhC,KAAAsiC,KAAAjB,EAAAlL,IAAA,EAAAn2B,KAAAoiC,IAAA9vB,GAAA,IAGA2wB,iBAAA,SAAA5B,GACA,GAAAlL,GAAA,QACA7jB,EAAA,EACA7Z,EAAA,CACA,YAAA4oC,EACA,EAEA,KAAAA,GAAA,IACA,GAEA/uB,IACAA,EAAA,KAEA7Z,EAAA,GACAA,EAAA,EACA09B,EAAA7jB,EAAA,GAEA6jB,EAAA7jB,GAAA,EAAAtS,KAAAoiC,IAAApiC,KAAA+iC,KAAA,EAAAtqC,GAEA4oC,EAAA,EACA5oC,EAAAuH,KAAA2D,IAAA,MAAA09B,GAAA,IAAArhC,KAAAsiC,KAAAjB,EAAAlL,IAAA,EAAAn2B,KAAAoiC,IAAA9vB,IAAA,GAEA7Z,EAAAuH,KAAA2D,IAAA,OAAA09B,GAAA,IAAArhC,KAAAsiC,KAAAjB,EAAAlL,IAAA,EAAAn2B,KAAAoiC,IAAA9vB,GAAA,OAEA4wB,WAAA,SAAA7B,GACA,GAAAlL,GAAA,OACA,OAAAkL,OAAAlL,EAAA,GAAAkL,EAAAlL,IAGAgN,YAAA,SAAA9B,GACA,GAAAlL,GAAA,OACA,QAAAkL,GAAA,GAAAA,IAAAlL,EAAA,GAAAkL,EAAAlL,GAAA,GAGAiN,cAAA,SAAA/B,GACA,GAAAlL,GAAA,OACA,QAAAkL,GAAA,MACAA,MAAA,GAAAlL,GAAA,QAAAkL,EAAAlL,GAAA,GAEA,KAAAkL,GAAA,GAAAA,IAAA,GAAAlL,GAAA,QAAAkL,EAAAlL,GAAA,IAGAkN,aAAA,SAAAhC,GACA,SAAAD,EAAAkC,cAAA,EAAAjC,IAGAiC,cAAA,SAAAjC,GACA,MAAAA,GAAA,OACA,OAAAA,IAEAA,EAAA,OACA,QAAAA,GAAA,UAAAA,EAAA,IAEAA,EAAA,SACA,QAAAA,GAAA,WAAAA,EAAA,MAEA,QAAAA,GAAA,YAAAA,EAAA,SAGAkC,gBAAA,SAAAlC,GACA,MAAAA,GAAA,GACA,GAAAD,EAAAiC,aAAA,EAAAhC,GAEA,GAAAD,EAAAkC,cAAA,EAAAjC,EAAA,OAIAjpC,GAAAc,SACAkoC,WAYA7nC,EAAAiqC,cAAApC,G5B+2KMqC,KACA,SAAUrrC,EAAQc,EAASZ,GAEjC,Y6BzmLA,IAAAiB,GAAAjB,EAAA,MAKAY,EAAAd,EAAAc,SAKA4e,MAAA,SAAA/Z,GACAA,EAAA46B,IAAA+K,UAAA,IAAA3lC,EAAAc,MAAAd,EAAAe,SAcA6kC,YAAA,SAAAhL,EAAAv8B,EAAAC,EAAAwC,EAAAC,EAAA8kC,GACA,GAAAA,EAAA,CACA,GAAAC,GAAA7jC,KAAAuD,IAAAqgC,EAAA/kC,EAAA,GACAilC,EAAA9jC,KAAAuD,IAAAqgC,EAAA9kC,EAAA,EAEA65B,GAAA9Y,OAAAzjB,EAAAynC,EAAAxnC,GACAs8B,EAAAoL,OAAA3nC,EAAAyC,EAAAglC,EAAAxnC,GACAs8B,EAAAqL,iBAAA5nC,EAAAyC,EAAAxC,EAAAD,EAAAyC,EAAAxC,EAAAynC,GACAnL,EAAAoL,OAAA3nC,EAAAyC,EAAAxC,EAAAyC,EAAAglC,GACAnL,EAAAqL,iBAAA5nC,EAAAyC,EAAAxC,EAAAyC,EAAA1C,EAAAyC,EAAAglC,EAAAxnC,EAAAyC,GACA65B,EAAAoL,OAAA3nC,EAAAynC,EAAAxnC,EAAAyC,GACA65B,EAAAqL,iBAAA5nC,EAAAC,EAAAyC,EAAA1C,EAAAC,EAAAyC,EAAAglC,GACAnL,EAAAoL,OAAA3nC,EAAAC,EAAAynC,GACAnL,EAAAqL,iBAAA5nC,EAAAC,EAAAD,EAAAynC,EAAAxnC,OAEAs8B,GAAAsL,KAAA7nC,EAAAC,EAAAwC,EAAAC,IAIAolC,UAAA,SAAAvL,EAAAjZ,EAAAkkB,EAAAxnC,EAAAC,GACA,GAAA5B,GAAA0pC,EAAAC,EAAAC,EAAAvlC,EAAAwlC,CAEA,IAAA5kB,GAAA,iBAAAA,KAEA,+BADAjlB,EAAAilB,EAAAvb,aACA,+BAAA1J,GAEA,WADAk+B,GAAA4L,UAAA7kB,EAAAtjB,EAAAsjB,EAAA7gB,MAAA,EAAAxC,EAAAqjB,EAAA5gB,OAAA,EAAA4gB,EAAA7gB,MAAA6gB,EAAA5gB,OAKA,MAAAiuB,MAAA6W,OAAA,IAIA,OAAAlkB,GAEA,QACAiZ,EAAA6L,YACA7L,EAAA8L,IAAAroC,EAAAC,EAAAunC,EAAA,IAAA5jC,KAAAoiC,IACAzJ,EAAA+L,YACA/L,EAAAhC,MACA,MACA,gBACAgC,EAAA6L,YACAL,EAAA,EAAAP,EAAA5jC,KAAA0V,KAAA,GACA5W,EAAAqlC,EAAAnkC,KAAA0V,KAAA,KACAijB,EAAA9Y,OAAAzjB,EAAA+nC,EAAA,EAAA9nC,EAAAyC,EAAA,GACA65B,EAAAoL,OAAA3nC,EAAA+nC,EAAA,EAAA9nC,EAAAyC,EAAA,GACA65B,EAAAoL,OAAA3nC,EAAAC,EAAA,EAAAyC,EAAA,GACA65B,EAAA+L,YACA/L,EAAAhC,MACA,MACA,YACA2N,EAAA,EAAAtkC,KAAA2kC,MAAAf,EACAjL,EAAA6L,YACA7L,EAAAiM,SAAAxoC,EAAAkoC,EAAAjoC,EAAAioC,EAAA,EAAAA,EAAA,EAAAA,GACA3L,EAAAkM,WAAAzoC,EAAAkoC,EAAAjoC,EAAAioC,EAAA,EAAAA,EAAA,EAAAA,EACA,MACA,mBACA,GAAAtf,GAAA4e,EAAA5jC,KAAA2kC,MACAG,EAAA1oC,EAAA4oB,EACA+f,EAAA1oC,EAAA2oB,EACAggB,EAAAhlC,KAAA2kC,MAAAf,CACAjL,GAAA6L,YACA5qC,KAAA+pC,YAAAhL,EAAAmM,EAAAC,EAAAC,IAAApB,EAAA,GACAjL,EAAA+L,YACA/L,EAAAhC,MACA,MACA,eACA2N,EAAA,EAAAtkC,KAAA2kC,MAAAf,EACAjL,EAAA6L,YACA7L,EAAA9Y,OAAAzjB,EAAAkoC,EAAAjoC,GACAs8B,EAAAoL,OAAA3nC,EAAAC,EAAAioC,GACA3L,EAAAoL,OAAA3nC,EAAAkoC,EAAAjoC,GACAs8B,EAAAoL,OAAA3nC,EAAAC,EAAAioC,GACA3L,EAAA+L,YACA/L,EAAAhC,MACA,MACA,aACAgC,EAAA6L,YACA7L,EAAA9Y,OAAAzjB,EAAAC,EAAAunC,GACAjL,EAAAoL,OAAA3nC,EAAAC,EAAAunC,GACAjL,EAAA9Y,OAAAzjB,EAAAwnC,EAAAvnC,GACAs8B,EAAAoL,OAAA3nC,EAAAwnC,EAAAvnC,GACAs8B,EAAA+L,WACA,MACA,gBACA/L,EAAA6L,YACAJ,EAAApkC,KAAAmiC,IAAAniC,KAAAoiC,GAAA,GAAAwB,EACAS,EAAArkC,KAAAsiC,IAAAtiC,KAAAoiC,GAAA,GAAAwB,EACAjL,EAAA9Y,OAAAzjB,EAAAgoC,EAAA/nC,EAAAgoC,GACA1L,EAAAoL,OAAA3nC,EAAAgoC,EAAA/nC,EAAAgoC,GACA1L,EAAA9Y,OAAAzjB,EAAAgoC,EAAA/nC,EAAAgoC,GACA1L,EAAAoL,OAAA3nC,EAAAgoC,EAAA/nC,EAAAgoC,GACA1L,EAAA+L,WACA,MACA,YACA/L,EAAA6L,YACA7L,EAAA9Y,OAAAzjB,EAAAC,EAAAunC,GACAjL,EAAAoL,OAAA3nC,EAAAC,EAAAunC,GACAjL,EAAA9Y,OAAAzjB,EAAAwnC,EAAAvnC,GACAs8B,EAAAoL,OAAA3nC,EAAAwnC,EAAAvnC,GACA+nC,EAAApkC,KAAAmiC,IAAAniC,KAAAoiC,GAAA,GAAAwB,EACAS,EAAArkC,KAAAsiC,IAAAtiC,KAAAoiC,GAAA,GAAAwB,EACAjL,EAAA9Y,OAAAzjB,EAAAgoC,EAAA/nC,EAAAgoC,GACA1L,EAAAoL,OAAA3nC,EAAAgoC,EAAA/nC,EAAAgoC,GACA1L,EAAA9Y,OAAAzjB,EAAAgoC,EAAA/nC,EAAAgoC,GACA1L,EAAAoL,OAAA3nC,EAAAgoC,EAAA/nC,EAAAgoC,GACA1L,EAAA+L,WACA,MACA,YACA/L,EAAA6L,YACA7L,EAAA9Y,OAAAzjB,EAAAwnC,EAAAvnC,GACAs8B,EAAAoL,OAAA3nC,EAAAwnC,EAAAvnC,GACAs8B,EAAA+L,WACA,MACA,YACA/L,EAAA6L,YACA7L,EAAA9Y,OAAAzjB,EAAAC,GACAs8B,EAAAoL,OAAA3nC,EAAAwnC,EAAAvnC,GACAs8B,EAAA+L,YAIA/L,EAAAsM,WAGAC,SAAA,SAAAvM,EAAAyB,GACAzB,EAAAwM,OACAxM,EAAA6L,YACA7L,EAAAsL,KAAA7J,EAAAr6B,KAAAq6B,EAAA75B,IAAA65B,EAAAh6B,MAAAg6B,EAAAr6B,KAAAq6B,EAAA55B,OAAA45B,EAAA75B,KACAo4B,EAAAyM,QAGAC,WAAA,SAAA1M,GACAA,EAAA2M,WAGAvB,OAAA,SAAApL,EAAA4M,EAAA/qC,EAAAgrC,GACA,MAAAhrC,GAAAirC,aACA,UAAAjrC,EAAAirC,cAAAD,GAAA,UAAAhrC,EAAAirC,aAAAD,EACA7M,EAAAoL,OAAAwB,EAAAnpC,EAAA5B,EAAA6B,GAEAs8B,EAAAoL,OAAAvpC,EAAA4B,EAAAmpC,EAAAlpC,OAEAs8B,GAAAoL,OAAAvpC,EAAA4B,EAAA5B,EAAA6B,IAIA7B,EAAAkrC,YAKA/M,GAAAgN,cACAH,EAAAD,EAAAK,sBAAAL,EAAAM,kBACAL,EAAAD,EAAAO,sBAAAP,EAAAQ,kBACAP,EAAAhrC,EAAAqrC,kBAAArrC,EAAAorC,sBACAJ,EAAAhrC,EAAAurC,kBAAAvrC,EAAAsrC,sBACAtrC,EAAA4B,EACA5B,EAAA6B,OAVAs8B,GAAAoL,OAAAvpC,EAAA4B,EAAA5B,EAAA6B,IAuBA9C,GAAAue,MAAA5e,EAAA4e,MASAve,EAAAysC,qBAAA,SAAArN,GACAA,EAAA6L,YACAtrC,EAAAyqC,YAAAnoC,MAAAtC,EAAAuC,WACAk9B,EAAA+L,c7BknLMuB,KACA,SAAU7tC,EAAQc,EAASZ,GAEjC,Y8Bv0LA,IAAAiB,GAAAjB,EAAA,KAMAF,GAAAc,SASAgtC,aAAA,SAAAptC,EAAAwrC,GACA,GAAA3a,IAAA,GAAA7wB,GAAAkxB,MAAA,uCACA,KAAAL,GAAA,WAAAA,EAAA,GACA,WAAA2a,CAKA,QAFAxrC,GAAA6wB,EAAA,GAEAA,EAAA,IACA,SACA,MAAA7wB,EACA,SACAA,GAAA,IAMA,MAAAwrC,GAAAxrC,GAUAqI,UAAA,SAAArI,GACA,GAAAuoC,GAAA7yB,EAAA/Q,EAAAiR,CAWA,OATAnV,GAAA8K,SAAAvL,IACAuoC,GAAAvoC,EAAAyH,KAAA,EACAiO,GAAA1V,EAAAsH,OAAA,EACA3C,GAAA3E,EAAA0H,QAAA,EACAkO,GAAA5V,EAAAiH,MAAA,GAEAshC,EAAA7yB,EAAA/Q,EAAAiR,GAAA5V,GAAA,GAIAyH,IAAA8gC,EACAjhC,MAAAoO,EACAhO,OAAA/C,EACAsC,KAAA2O,EACA5P,OAAAuiC,EAAA5jC,EACAoB,MAAA6P,EAAAF,IAaA23B,QAAA,SAAAC,EAAAC,EAAA/nC,GACA,GAAAnE,GAAAC,EAAAtB,CAEA,KAAAqB,EAAA,EAAAC,EAAAgsC,EAAAvrC,OAAmCV,EAAAC,IAAUD,EAE7C,OAAAkP,MADAvQ,EAAAstC,EAAAjsC,UAIAkP,KAAAg9B,GAAA,mBAAAvtC,KACAA,IAAAutC,QAEAh9B,KAAA/K,GAAA/E,EAAAqJ,QAAA9J,KACAA,IAAAwF,QAEA+K,KAAAvQ,GACA,MAAAA,M9Bm1LMwtC,KACA,SAAUluC,EAAQc,EAASZ,GAEjC,Y+B76LA,IAAAyC,GAAAzC,EAAA,MACAuF,EAAAvF,EAAA,MACAiB,EAAAjB,EAAA,KAEAF,GAAAc,QAAA,SAAAw5B,GA4ZA,QAAA6T,GAAAC,EAAA5oB,EAAA6oB,GACA,GAAAC,EAYA,OAXA,iBAAAF,IACAE,EAAAxc,SAAAsc,EAAA,KAEA,IAAAA,EAAAjoC,QAAA,OAEAmoC,IAAA,IAAA9oB,EAAA0T,WAAAmV,KAGAC,EAAAF,EAGAE,EAOA,QAAAC,GAAA7tC,GACA,WAAAuQ,KAAAvQ,GAAA,OAAAA,GAAA,SAAAA,EAQA,QAAA8tC,GAAAC,EAAAC,EAAAC,GACA,GAAA/sC,GAAA01B,SAAAsX,YACA1V,EAAAuV,EAAAvV,WACA2V,EAAAjtC,EAAAktC,iBAAAL,GAAAC,GACAK,EAAAntC,EAAAktC,iBAAA5V,GAAAwV,GACAM,EAAAT,EAAAM,GACAI,EAAAV,EAAAQ,GACAG,EAAA1yB,OAAAC,iBAEA,OAAAuyB,IAAAC,EACArnC,KAAAuD,IACA6jC,EAAAb,EAAAU,EAAAJ,EAAAE,GAAAO,EACAD,EAAAd,EAAAY,EAAA7V,EAAAyV,GAAAO,GAGA,OApcA/tC,EAAAguC,YAAA,WACA,MAAAhuC,GAAAI,MAAAJ,EAAAwC,MAAAN,UAAA,OAAAkX,MAAAvO,KAAA3I,UAAA,IACAmK,OAAA,SAAAvL,EAAAG,EAAA0K,EAAA7L,GACA,GAAAkM,GAAA/K,EAAAH,OACAmL,EAAAN,EAAA7K,EAEA,YAAAA,EAEAG,EAAAH,GAAAd,EAAAiuC,WAAAjiC,EAAAC,GACK,UAAAnL,EAELG,EAAAH,GAAAd,EAAAI,MAAA4L,GAAAmtB,EAAA+U,aAAAC,iBAAAliC,EAAA/K,MAAA+K,IAEAjM,EAAA+L,QAAAjL,EAAAG,EAAA0K,EAAA7L,OAMAE,EAAAiuC,WAAA,WACA,MAAAjuC,GAAAI,MAAAJ,EAAAwC,MAAAN,UAAA,OAAAkX,MAAAvO,KAAA3I,UAAA,IACAmK,OAAA,SAAAvL,EAAAG,EAAA0K,EAAA7L,GACA,aAAAgB,GAAA,UAAAA,EAAA,CACA,GACAF,GAAAM,EAAAktC,EADAC,EAAA1iC,EAAA7K,GAAAQ,MAOA,KAJAL,EAAAH,KACAG,EAAAH,OAGAF,EAAA,EAAgBA,EAAAytC,IAAUztC,EAC1BwtC,EAAAziC,EAAA7K,GAAAF,GACAM,EAAAlB,EAAA+K,eAAAqjC,EAAAltC,KAAA,UAAAJ,EAAA,qBAEAF,GAAAK,EAAAH,GAAAQ,QACAL,EAAAH,GAAA8D,UAGA3D,EAAAH,GAAAF,GAAAM,MAAAktC,EAAAltC,MAAAktC,EAAAltC,OAAAD,EAAAH,GAAAF,GAAAM,KAGAlB,EAAAI,MAAAa,EAAAH,GAAAF,IAAAu4B,EAAA+U,aAAAC,iBAAAjtC,GAAAktC,IAGApuC,EAAAI,MAAAa,EAAAH,GAAAF,GAAAwtC,OAIApuC,GAAA+L,QAAAjL,EAAAG,EAAA0K,EAAA7L,OAMAE,EAAA2D,MAAA,SAAA2qC,EAAAC,GACA,GAAAvuC,EAAAqJ,QAAAilC,IAAA3jC,MAAAxI,UAAA+P,OACA,MAAAo8B,GAAAp8B,OAAAq8B,EAEA,IAAAC,KAQA,OANAxuC,GAAAsI,KAAAgmC,EAAA,SAAA7pC,GACA8pC,EAAA9pC,IACA+pC,EAAA5pC,KAAAH,KAIA+pC,GAEAxuC,EAAAyuC,UAAA9jC,MAAAxI,UAAAssC,UACA,SAAAhrC,EAAAyH,EAAAhL,GACA,MAAAuD,GAAAgrC,UAAAvjC,EAAAhL,IAEA,SAAAuD,EAAAyH,EAAAhL,GACAA,MAAA4P,KAAA5P,EAAAuD,EAAAvD,CACA,QAAAU,GAAA,EAAAC,EAAA4C,EAAAnC,OAAuCV,EAAAC,IAAUD,EACjD,GAAAsK,EAAAL,KAAA3K,EAAAuD,EAAA7C,KAAA6C,GACA,MAAA7C,EAGA,WAEAZ,EAAAqG,cAAA,SAAAqoC,EAAAH,EAAAI,GAEA3uC,EAAA0K,cAAAikC,KACAA,GAAA,EAEA,QAAA/tC,GAAA+tC,EAAA,EAA8B/tC,EAAA8tC,EAAAptC,OAA0BV,IAAA,CACxD,GAAAguC,GAAAF,EAAA9tC,EACA,IAAA2tC,EAAAK,GACA,MAAAA,KAIA5uC,EAAA6uC,kBAAA,SAAAH,EAAAH,EAAAI,GAEA3uC,EAAA0K,cAAAikC,KACAA,EAAAD,EAAAptC,OAEA,QAAAV,GAAA+tC,EAAA,EAA8B/tC,GAAA,EAAQA,IAAA,CACtC,GAAAguC,GAAAF,EAAA9tC,EACA,IAAA2tC,EAAAK,GACA,MAAAA,KAMA5uC,EAAAgD,SAAA,SAAAvD,GACA,OAAA+zB,MAAAxf,WAAAvU,KAAAmC,SAAAnC,IAEAO,EAAA8uC,aAAA,SAAAjsC,EAAAC,EAAAisC,GACA,MAAAtoC,MAAAiD,IAAA7G,EAAAC,GAAAisC,GAEA/uC,EAAAgvC,YAAA,SAAAnsC,EAAAksC,GACA,GAAAE,GAAAxoC,KAAAoT,MAAAhX,EACA,OAAAosC,GAAAF,EAAAlsC,GAAAosC,EAAAF,EAAAlsC,GAEA7C,EAAA0G,IAAA,SAAAjD,GACA,MAAAA,GAAAyrC,OAAA,SAAAxoC,EAAAnH,GACA,MAAAi0B,OAAAj0B,GAGAmH,EAFAD,KAAAC,MAAAnH,IAGG8b,OAAA8zB,oBAEHnvC,EAAAgK,IAAA,SAAAvG,GACA,MAAAA,GAAAyrC,OAAA,SAAAllC,EAAAzK,GACA,MAAAi0B,OAAAj0B,GAGAyK,EAFAvD,KAAAuD,MAAAzK,IAGG8b,OAAAC,oBAEHtb,EAAAovC,KAAA3oC,KAAA2oC,KACA,SAAAvsC,GACA,MAAA4D,MAAA2oC,KAAAvsC,IAEA,SAAAA,GAEA,MADAA,MACA,IAAAA,GAAA2wB,MAAA3wB,GACAA,EAEAA,EAAA,QAEA7C,EAAA6J,MAAApD,KAAAoD,MACA,SAAAhH,GACA,MAAA4D,MAAAoD,MAAAhH,IAEA,SAAAA,GACA,GAAAwsC,GAAA5oC,KAAA6oC,IAAAzsC,GAAA4D,KAAA8oC,OAGAC,EAAA/oC,KAAAoT,MAAAw1B,EAGA,OAFAxsC,KAAA4D,KAAA2D,IAAA,GAAAolC,GAEAA,EAAAH,GAEArvC,EAAAyvC,UAAA,SAAA72B,GACA,MAAAA,IAAAnS,KAAAoiC,GAAA,MAEA7oC,EAAA0vC,UAAA,SAAAC,GACA,MAAAA,IAAA,IAAAlpC,KAAAoiC,KAGA7oC,EAAA4vC,kBAAA,SAAAC,EAAAC,GACA,GAAAC,GAAAD,EAAAjtC,EAAAgtC,EAAAhtC,EACAmtC,EAAAF,EAAAhtC,EAAA+sC,EAAA/sC,EACAmtC,EAAAxpC,KAAA0V,KAAA4zB,IAAAC,KAEAE,EAAAzpC,KAAA0pC,MAAAH,EAAAD,EAMA,OAJAG,IAAA,GAAAzpC,KAAAoiC,KACAqH,GAAA,EAAAzpC,KAAAoiC,KAIAqH,QACAx0B,SAAAu0B,IAGAjwC,EAAAowC,sBAAA,SAAAr0B,EAAAC,GACA,MAAAvV,MAAA0V,KAAA1V,KAAA2D,IAAA4R,EAAAnZ,EAAAkZ,EAAAlZ,EAAA,GAAA4D,KAAA2D,IAAA4R,EAAAlZ,EAAAiZ,EAAAjZ,EAAA,KAEA9C,EAAAqwC,WAAA,SAAAC,GACA,MAAAA,GAAA,YAEAtwC,EAAAuwC,YAAA,SAAAC,EAAAC,EAAAC,EAAA5I,GAMA,GAAAkE,GAAAwE,EAAA31B,KAAA41B,EAAAD,EACAG,EAAAF,EACAG,EAAAF,EAAA71B,KAAA41B,EAAAC,EAEAG,EAAApqC,KAAA0V,KAAA1V,KAAA2D,IAAAumC,EAAA9tC,EAAAmpC,EAAAnpC,EAAA,GAAA4D,KAAA2D,IAAAumC,EAAA7tC,EAAAkpC,EAAAlpC,EAAA,IACAguC,EAAArqC,KAAA0V,KAAA1V,KAAA2D,IAAAwmC,EAAA/tC,EAAA8tC,EAAA9tC,EAAA,GAAA4D,KAAA2D,IAAAwmC,EAAA9tC,EAAA6tC,EAAA7tC,EAAA,IAEAiuC,EAAAF,KAAAC,GACAE,EAAAF,GAAAD,EAAAC,EAGAC,GAAAvd,MAAAud,GAAA,EAAAA,EACAC,EAAAxd,MAAAwd,GAAA,EAAAA,CAEA,IAAAC,GAAAnJ,EAAAiJ,EACAG,EAAApJ,EAAAkJ,CAEA,QACAhF,UACAnpC,EAAA8tC,EAAA9tC,EAAAouC,GAAAL,EAAA/tC,EAAAmpC,EAAAnpC,GACAC,EAAA6tC,EAAA7tC,EAAAmuC,GAAAL,EAAA9tC,EAAAkpC,EAAAlpC,IAEA8tC,MACA/tC,EAAA8tC,EAAA9tC,EAAAquC,GAAAN,EAAA/tC,EAAAmpC,EAAAnpC,GACAC,EAAA6tC,EAAA7tC,EAAAouC,GAAAN,EAAA9tC,EAAAkpC,EAAAlpC,MAIA9C,EAAAmxC,QAAA91B,OAAA81B,SAAA,MACAnxC,EAAAoxC,oBAAA,SAAAxT,GAMA,GAUAh9B,GAAAywC,EAAAC,EAAAC,EAVAC,GAAA5T,OAAAhyB,IAAA,SAAAiR,GACA,OACAnc,MAAAmc,EAAApa,OACAgvC,OAAA,EACAC,GAAA,KAKAC,EAAAH,EAAAlwC,MAEA,KAAAV,EAAA,EAAaA,EAAA+wC,IAAe/wC,EAE5B,GADA0wC,EAAAE,EAAA5wC,IACA0wC,EAAA5wC,MAAAma,KAAA,CAMA,GAFAw2B,EAAAzwC,EAAA,EAAA4wC,EAAA5wC,EAAA,SACA2wC,EAAA3wC,EAAA+wC,EAAA,EAAAH,EAAA5wC,EAAA,WACA2wC,EAAA7wC,MAAAma,KAAA,CACA,GAAA+2B,GAAAL,EAAA7wC,MAAAmC,EAAAyuC,EAAA5wC,MAAAmC,CAGAyuC,GAAAG,OAAA,IAAAG,GAAAL,EAAA7wC,MAAAoC,EAAAwuC,EAAA5wC,MAAAoC,GAAA8uC,EAAA,GAGAP,KAAA3wC,MAAAma,KACAy2B,EAAAI,GAAAJ,EAAAG,QACIF,KAAA7wC,MAAAma,KACJy2B,EAAAI,GAAAL,EAAAI,OACIpxC,KAAA+uC,KAAAiC,EAAAI,UAAApxC,KAAA+uC,KAAAkC,EAAAG,QACJH,EAAAI,GAAA,EAEAJ,EAAAI,IAAAL,EAAAI,OAAAH,EAAAG,QAAA,EAKA,GAAAI,GAAAC,EAAAC,EAAAC,CACA,KAAApxC,EAAA,EAAaA,EAAA+wC,EAAA,IAAmB/wC,EAChC0wC,EAAAE,EAAA5wC,GACA2wC,EAAAC,EAAA5wC,EAAA,GACA0wC,EAAA5wC,MAAAma,MAAA02B,EAAA7wC,MAAAma,OAIA7a,EAAA8uC,aAAAwC,EAAAG,OAAA,EAAApxC,KAAA8wC,SACAG,EAAAI,GAAAH,EAAAG,GAAA,GAIAG,EAAAP,EAAAI,GAAAJ,EAAAG,OACAK,EAAAP,EAAAG,GAAAJ,EAAAG,QACAO,EAAAvrC,KAAA2D,IAAAynC,EAAA,GAAAprC,KAAA2D,IAAA0nC,EAAA,KACA,IAIAC,EAAA,EAAAtrC,KAAA0V,KAAA61B,GACAV,EAAAI,GAAAG,EAAAE,EAAAT,EAAAG,OACAF,EAAAG,GAAAI,EAAAC,EAAAT,EAAAG,SAIA,IAAAx1B,EACA,KAAArb,EAAA,EAAaA,EAAA+wC,IAAe/wC,EAC5B0wC,EAAAE,EAAA5wC,GACA0wC,EAAA5wC,MAAAma,OAIAw2B,EAAAzwC,EAAA,EAAA4wC,EAAA5wC,EAAA,QACA2wC,EAAA3wC,EAAA+wC,EAAA,EAAAH,EAAA5wC,EAAA,QACAywC,MAAA3wC,MAAAma,OACAoB,GAAAq1B,EAAA5wC,MAAAmC,EAAAwuC,EAAA3wC,MAAAmC,GAAA,EACAyuC,EAAA5wC,MAAA2rC,sBAAAiF,EAAA5wC,MAAAmC,EAAAoZ,EACAq1B,EAAA5wC,MAAA6rC,sBAAA+E,EAAA5wC,MAAAoC,EAAAmZ,EAAAq1B,EAAAI,IAEAH,MAAA7wC,MAAAma,OACAoB,GAAAs1B,EAAA7wC,MAAAmC,EAAAyuC,EAAA5wC,MAAAmC,GAAA,EACAyuC,EAAA5wC,MAAA4rC,kBAAAgF,EAAA5wC,MAAAmC,EAAAoZ,EACAq1B,EAAA5wC,MAAA8rC,kBAAA8E,EAAA5wC,MAAAoC,EAAAmZ,EAAAq1B,EAAAI,MAIA1xC,EAAAiyC,SAAA,SAAA3D,EAAAvpC,EAAAmtC,GACA,MAAAA,GACAntC,GAAAupC,EAAAhtC,OAAA,EAAAgtC,EAAA,GAAAA,EAAAvpC,EAAA,GAEAA,GAAAupC,EAAAhtC,OAAA,EAAAgtC,IAAAhtC,OAAA,GAAAgtC,EAAAvpC,EAAA,IAEA/E,EAAAmyC,aAAA,SAAA7D,EAAAvpC,EAAAmtC,GACA,MAAAA,GACAntC,GAAA,EAAAupC,IAAAhtC,OAAA,GAAAgtC,EAAAvpC,EAAA,GAEAA,GAAA,EAAAupC,EAAA,GAAAA,EAAAvpC,EAAA,IAGA/E,EAAAoyC,QAAA,SAAAC,EAAAx4B,GACA,GAAAw1B,GAAA5oC,KAAAkD,MAAA3J,EAAA6J,MAAAwoC,IACAC,EAAAD,EAAA5rC,KAAA2D,IAAA,GAAAilC,EAuBA,QApBAx1B,EACAy4B,EAAA,IACA,EACIA,EAAA,EACJ,EACIA,EAAA,EACJ,EAEA,GAEGA,GAAA,EACH,EACGA,GAAA,EACH,EACGA,GAAA,EACH,EAEA,IAGA7rC,KAAA2D,IAAA,GAAAilC,IAGArvC,EAAAuyC,iBAAA,WACA,0BAAAv4B,QACA,SAAA9O,GACAA,KAGA8O,OAAAw4B,uBACAx4B,OAAAy4B,6BACAz4B,OAAA04B,0BACA14B,OAAA24B,wBACA34B,OAAA44B,yBACA,SAAA1nC,GACA,MAAA8O,QAAA64B,WAAA3nC,EAAA,YAIAlL,EAAAka,oBAAA,SAAA44B,EAAAtuC,GACA,GAAAuuC,GAAAC,EACA74B,EAAA24B,EAAAG,eAAAH,EACAjzC,EAAAizC,EAAAI,eAAAJ,EAAAK,WACAC,EAAAvzC,EAAAwzC,wBAEAC,EAAAn5B,EAAAm5B,OACAA,MAAAhyC,OAAA,GACAyxC,EAAAO,EAAA,GAAAC,QACAP,EAAAM,EAAA,GAAAE,UAGAT,EAAA54B,EAAAo5B,QACAP,EAAA74B,EAAAq5B,QAMA,IAAAC,GAAAz/B,WAAAhU,EAAA0zC,SAAA7zC,EAAA,iBACA8zC,EAAA3/B,WAAAhU,EAAA0zC,SAAA7zC,EAAA,gBACA+zC,EAAA5/B,WAAAhU,EAAA0zC,SAAA7zC,EAAA,kBACAg0C,EAAA7/B,WAAAhU,EAAA0zC,SAAA7zC,EAAA,mBACAyF,EAAA8tC,EAAAvsC,MAAAusC,EAAA5sC,KAAAitC,EAAAG,EACAruC,EAAA6tC,EAAAnsC,OAAAmsC,EAAApsC,IAAA2sC,EAAAE,CAOA,OAHAd,GAAAtsC,KAAAoT,OAAAk5B,EAAAK,EAAA5sC,KAAAitC,GAAA,EAAA5zC,EAAAyF,MAAAd,EAAAsvC,yBACAd,EAAAvsC,KAAAoT,OAAAm5B,EAAAI,EAAApsC,IAAA2sC,GAAA,EAAA9zC,EAAA0F,OAAAf,EAAAsvC,0BAGAjxC,EAAAkwC,EACAjwC,EAAAkwC,IAqDAhzC,EAAA+zC,mBAAA,SAAAzG,GACA,MAAAD,GAAAC,EAAA,4BAGAttC,EAAAg0C,oBAAA,SAAA1G,GACA,MAAAD,GAAAC,EAAA,8BAEAttC,EAAAi0C,gBAAA,SAAA3G,GACA,GAAA4G,GAAA5G,EAAAvV,UACA,KAAAmc,EACA,MAAA5G,GAAAxoB,WAGA,IAAA2uB,GAAA9iB,SAAA3wB,EAAA0zC,SAAAQ,EAAA,oBACAN,EAAAjjB,SAAA3wB,EAAA0zC,SAAAQ,EAAA,qBACA7+B,EAAA6+B,EAAApvB,YAAA2uB,EAAAG,EACAO,EAAAn0C,EAAA+zC,mBAAAzG,EACA,OAAA9Z,OAAA2gB,GAAA9+B,EAAA5O,KAAAuD,IAAAqL,EAAA8+B,IAEAn0C,EAAAo0C,iBAAA,SAAA9G,GACA,GAAA4G,GAAA5G,EAAAvV,UACA,KAAAmc,EACA,MAAA5G,GAAA+G,YAGA,IAAAV,GAAAhjB,SAAA3wB,EAAA0zC,SAAAQ,EAAA,mBACAL,EAAAljB,SAAA3wB,EAAA0zC,SAAAQ,EAAA,sBACAI,EAAAJ,EAAAG,aAAAV,EAAAE,EACAU,EAAAv0C,EAAAg0C,oBAAA1G,EACA,OAAA9Z,OAAA+gB,GAAAD,EAAA7tC,KAAAuD,IAAAsqC,EAAAC,IAEAv0C,EAAA0zC,SAAA,SAAAc,EAAAC,GACA,MAAAD,GAAAE,aACAF,EAAAE,aAAAD,GACAte,SAAAsX,YAAAE,iBAAA6G,EAAA,MAAAG,iBAAAF,IAEAz0C,EAAA40C,YAAA,SAAApwC,EAAAqwC,GACA,GAAAC,GAAAtwC,EAAAsvC,wBAAAe,GAAA76B,OAAA+6B,kBAAA,CACA,QAAAD,EAAA,CAIA,GAAAj1C,GAAA2E,EAAA3E,OACA0F,EAAAf,EAAAe,OACAD,EAAAd,EAAAc,KAEAzF,GAAA0F,SAAAuvC,EACAj1C,EAAAyF,QAAAwvC,EACAtwC,EAAA46B,IAAAgP,MAAA0G,KAKAj1C,EAAAsmB,MAAA5gB,QAAA1F,EAAAsmB,MAAA7gB,QACAzF,EAAAsmB,MAAA5gB,SAAA,KACA1F,EAAAsmB,MAAA7gB,QAAA,QAIAtF,EAAAg1C,WAAA,SAAAC,EAAAC,EAAAlmB,GACA,MAAAkmB,GAAA,IAAAD,EAAA,MAAAjmB,GAEAhvB,EAAAm1C,YAAA,SAAA/V,EAAAgW,EAAAC,EAAAr2B,GACAA,OACA,IAAA3R,GAAA2R,EAAA3R,KAAA2R,EAAA3R,SACAioC,EAAAt2B,EAAAu2B,eAAAv2B,EAAAu2B,kBAEAv2B,GAAAo2B,WACA/nC,EAAA2R,EAAA3R,QACAioC,EAAAt2B,EAAAu2B,kBACAv2B,EAAAo2B,QAGAhW,EAAAgW,MACA,IAAAI,GAAA,CACAx1C,GAAAsI,KAAA+sC,EAAA,SAAAI,OAEA3lC,KAAA2lC,GAAA,OAAAA,IAAA,IAAAz1C,EAAAqJ,QAAAosC,GACAD,EAAAx1C,EAAA01C,YAAAtW,EAAA/xB,EAAAioC,EAAAE,EAAAC,GACIz1C,EAAAqJ,QAAAosC,IAGJz1C,EAAAsI,KAAAmtC,EAAA,SAAAE,OAEA7lC,KAAA6lC,GAAA,OAAAA,GAAA31C,EAAAqJ,QAAAssC,KACAH,EAAAx1C,EAAA01C,YAAAtW,EAAA/xB,EAAAioC,EAAAE,EAAAG,OAMA,IAAAC,GAAAN,EAAAh0C,OAAA,CACA,IAAAs0C,EAAAP,EAAA/zC,OAAA,CACA,OAAAV,GAAA,EAAkBA,EAAAg1C,EAAWh1C,UAC7ByM,GAAAioC,EAAA10C,GAEA00C,GAAArwC,OAAA,EAAA2wC,GAEA,MAAAJ,IAEAx1C,EAAA01C,YAAA,SAAAtW,EAAA/xB,EAAAioC,EAAAE,EAAArhC,GACA,GAAA0hC,GAAAxoC,EAAA8G,EAQA,OAPA0hC,KACAA,EAAAxoC,EAAA8G,GAAAirB,EAAAsW,YAAAvhC,GAAA7O,MACAgwC,EAAA1wC,KAAAuP,IAEA0hC,EAAAL,IACAA,EAAAK,GAEAL,GAEAx1C,EAAA81C,mBAAA,SAAAT,GACA,GAAAU,GAAA,CAQA,OAPA/1C,GAAAsI,KAAA+sC,EAAA,SAAAI,GACAz1C,EAAAqJ,QAAAosC,IACAA,EAAAn0C,OAAAy0C,IACAA,EAAAN,EAAAn0C,UAIAy0C,GAGA/1C,EAAAwB,QAKA,SAAAjC,GAMA,MAJAA,aAAAy2C,kBACAz2C,EAAA+E,EAAA8a,OAAAioB,cAGA7lC,EAAAjC,IAVA,SAAAA,GAEA,MADA8Z,SAAAtI,MAAA,uBACAxR,GAWAS,EAAAi2C,cAAA,SAAAC,GAEA,MAAAA,aAAAC,eACAD,EACAl2C,EAAAwB,MAAA00C,GAAA99B,SAAA,IAAAD,OAAA,IAAAxW,e/By7LMy0C,KACA,SAAUv3C,EAAQc,EAASZ,GgC1hNjC,GAAAs3C,GAAAt3C,EAAA,MAEAmV,EAAA,WACA,UAAAoiC,GAGA,QAAAC,KAAAF,GAAA,CAEAniC,EAAAqiC,EAAA,gBAAAA,GAEA,gBAAAC,GAGA,MAFA,gBAAAA,KACAA,EAAA7rC,MAAAxI,UAAAiX,MAAAvO,KAAA3I,YACAm0C,EAAAE,GAAAC,KAEGD,EAEH,IAAAE,GAAA,cAAA5a,KAAA0a,GACAG,EAAAD,EAAA,GACAE,EAAAF,EAAA,EAGAviC,GAAAwiC,GAAAxiC,EAAAwiC,OAEAxiC,EAAAwiC,GAAAC,GAAAziC,EAAAqiC,GAAA,SAAAA,GACA,gBAAAC,GACA,gBAAAA,KACAA,EAAA7rC,MAAAxI,UAAAiX,MAAAvO,KAAA3I,WAEA,IAAAgU,GAAAmgC,EAAAE,GAAAC,EACA,oBAAAtgC,QAAApG,KAAAoG,EACA,MAAAA,EAEA,QAAAtV,GAAA,EAAqBA,EAAAsV,EAAA5U,OAAgBV,IACrCsV,EAAAtV,GAAA6F,KAAAoT,MAAA3D,EAAAtV,GACA,OAAAsV,KAEGqgC,GAKH,GAAAD,GAAA,WACAj2C,KAAAu2C,SAKAN,GAAAn0C,UAAA00C,WAAA,SAAAp9B,EAAArO,GACA,GAAAjL,GAAAiL,EAAA,EACA,YAAA0E,KAAA3P,EAEAE,KAAAmZ,UAAAC,IAGA,gBAAAtZ,KACAA,EAAAwK,MAAAxI,UAAAiX,MAAAvO,KAAAO,IAGA/K,KAAAyU,UAAA2E,EAAAtZ,KAIAm2C,EAAAn0C,UAAA2S,UAAA,SAAA2E,EAAAtZ,GAIA,MAHAE,MAAAoZ,QACApZ,KAAAu2C,SACAv2C,KAAAu2C,MAAAn9B,GAAAtZ,EACAE,MAMAi2C,EAAAn0C,UAAAqX,UAAA,SAAAC,GACA,GAAA7E,GAAAvU,KAAAu2C,MAAAn9B,EACA,KAAA7E,EAAA,CACA,GAAAkiC,GAAAz2C,KAAAoZ,MACAi9B,EAAAr2C,KAAAu2C,MAAAE,EACAliC,GAAAV,EAAA4iC,GAAAr9B,GAAAi9B,GAEAr2C,KAAAu2C,MAAAn9B,GAAA7E,EAEA,MAAAA,KAGA,oCAAA7Q,QAAA,SAAA0V,GACA68B,EAAAn0C,UAAAsX,GAAA,SAAA7E,GACA,MAAAvU,MAAAw2C,WAAAp9B,EAAAvX,cAIArD,EAAAc,QAAAuU,GhCgiNM6iC,KACA,SAAUl4C,EAAQc,GiClkNxB,QAAAq3C,GAAA1iC,GACA,GAMAggC,GAAA1X,EAAAznB,EANAF,EAAAX,EAAA,OACA2iC,EAAA3iC,EAAA,OACApQ,EAAAoQ,EAAA,OACAtK,EAAAvD,KAAAuD,IAAAiL,EAAAgiC,EAAA/yC,GACAwC,EAAAD,KAAAC,IAAAuO,EAAAgiC,EAAA/yC,GACAuF,EAAA/C,EAAAsD,CA0BA,OAvBAtD,IAAAsD,EACAsqC,EAAA,EACAr/B,GAAAvO,EACA4tC,GAAA2C,EAAA/yC,GAAAuF,EACAwtC,GAAAvwC,EACA4tC,EAAA,GAAApwC,EAAA+Q,GAAAxL,EACAvF,GAAAwC,IACA4tC,EAAA,GAAAr/B,EAAAgiC,GAAAxtC,GAEA6qC,EAAA7tC,KAAAuD,IAAA,GAAAsqC,EAAA,KAEAA,EAAA,IACAA,GAAA,KAEAn/B,GAAAnL,EAAAtD,GAAA,EAGAk2B,EADAl2B,GAAAsD,EACA,EACAmL,GAAA,GACA1L,GAAA/C,EAAAsD,GAEAP,GAAA,EAAA/C,EAAAsD,IAEAsqC,EAAA,IAAA1X,EAAA,IAAAznB,GAGA,QAAA+hC,GAAA5iC,GACA,GAMAggC,GAAA1X,EAAAh5B,EANAqR,EAAAX,EAAA,GACA2iC,EAAA3iC,EAAA,GACApQ,EAAAoQ,EAAA,GACAtK,EAAAvD,KAAAuD,IAAAiL,EAAAgiC,EAAA/yC,GACAwC,EAAAD,KAAAC,IAAAuO,EAAAgiC,EAAA/yC,GACAuF,EAAA/C,EAAAsD,CAwBA,OApBA4yB,GADA,GAAAl2B,EACA,EAEA+C,EAAA/C,EAAA,OAEAA,GAAAsD,EACAsqC,EAAA,EACAr/B,GAAAvO,EACA4tC,GAAA2C,EAAA/yC,GAAAuF,EACAwtC,GAAAvwC,EACA4tC,EAAA,GAAApwC,EAAA+Q,GAAAxL,EACAvF,GAAAwC,IACA4tC,EAAA,GAAAr/B,EAAAgiC,GAAAxtC,GAEA6qC,EAAA7tC,KAAAuD,IAAA,GAAAsqC,EAAA,KAEAA,EAAA,IACAA,GAAA,KAEA1wC,EAAA8C,EAAA,YAEA4tC,EAAA1X,EAAAh5B,GAGA,QAAAuzC,GAAA7iC,GACA,GAAAW,GAAAX,EAAA,GACA2iC,EAAA3iC,EAAA,GACApQ,EAAAoQ,EAAA,GACAggC,EAAA0C,EAAA1iC,GAAA,GACAe,EAAA,MAAA5O,KAAAuD,IAAAiL,EAAAxO,KAAAuD,IAAAitC,EAAA/yC,IACAA,EAAA,QAAAuC,KAAAC,IAAAuO,EAAAxO,KAAAC,IAAAuwC,EAAA/yC,GAEA,QAAAowC,EAAA,IAAAj/B,EAAA,IAAAnR,GAGA,QAAAkzC,GAAA9iC,GACA,GAGAiB,GAAA8hC,EAAAv0C,EAAAgJ,EAHAmJ,EAAAX,EAAA,OACA2iC,EAAA3iC,EAAA,OACApQ,EAAAoQ,EAAA,MAOA,OAJAxI,GAAArF,KAAAuD,IAAA,EAAAiL,EAAA,EAAAgiC,EAAA,EAAA/yC,GACAqR,GAAA,EAAAN,EAAAnJ,IAAA,EAAAA,IAAA,EACAurC,GAAA,EAAAJ,EAAAnrC,IAAA,EAAAA,IAAA,EACAhJ,GAAA,EAAAoB,EAAA4H,IAAA,EAAAA,IAAA,GACA,IAAAyJ,EAAA,IAAA8hC,EAAA,IAAAv0C,EAAA,IAAAgJ,GAGA,QAAAwrC,GAAAhjC,GACA,MAAAijC,GAAA1hB,KAAA2hB,UAAAljC,IAGA,QAAAmjC,GAAAnjC,GACA,GAAAW,GAAAX,EAAA,OACA2iC,EAAA3iC,EAAA,OACApQ,EAAAoQ,EAAA,MAWA,OARAW,KAAA,OAAAxO,KAAA2D,KAAA6K,EAAA,iBAAAA,EAAA,MACAgiC,IAAA,OAAAxwC,KAAA2D,KAAA6sC,EAAA,iBAAAA,EAAA,MACA/yC,IAAA,OAAAuC,KAAA2D,KAAAlG,EAAA,iBAAAA,EAAA,OAMA,KAJA,MAAA+Q,EAAA,MAAAgiC,EAAA,MAAA/yC,GAIA,KAHA,MAAA+Q,EAAA,MAAAgiC,EAAA,MAAA/yC,GAGA,KAFA,MAAA+Q,EAAA,MAAAgiC,EAAA,MAAA/yC,IAKA,QAAAwzC,GAAApjC,GACA,GAIAa,GAAAjW,EAAAgF,EAJAyzC,EAAAF,EAAAnjC,GACAzR,EAAA80C,EAAA,GACA70C,EAAA60C,EAAA,GACAC,EAAAD,EAAA,EAeA,OAZA90C,IAAA,OACAC,GAAA,IACA80C,GAAA,QAEA/0C,IAAA,QAAA4D,KAAA2D,IAAAvH,EAAA,WAAAA,EAAA,OACAC,IAAA,QAAA2D,KAAA2D,IAAAtH,EAAA,WAAAA,EAAA,OACA80C,IAAA,QAAAnxC,KAAA2D,IAAAwtC,EAAA,WAAAA,EAAA,OAEAziC,EAAA,IAAArS,EAAA,GACA5D,EAAA,KAAA2D,EAAAC,GACAoB,EAAA,KAAApB,EAAA80C,IAEAziC,EAAAjW,EAAAgF,GAGA,QAAA2zC,GAAAzsC,GACA,MAAA0sC,GAAAJ,EAAAtsC,IAGA,QAAA2sC,GAAAxjC,GACA,GAGAyjC,GAAAC,EAAAC,EAAA5jC,EAAA4B,EAHAo+B,EAAA//B,EAAA,OACAqoB,EAAAroB,EAAA,OACAY,EAAAZ,EAAA,MAGA,OAAAqoB,EAEA,MADA1mB,GAAA,IAAAf,GACAe,MAIA+hC,GADA9iC,EAAA,GACAA,GAAA,EAAAynB,GAEAznB,EAAAynB,EAAAznB,EAAAynB,EACAob,EAAA,EAAA7iC,EAAA8iC,EAEA3jC,GAAA,MACA,QAAA1T,GAAA,EAAiBA,EAAA,EAAOA,IACxBs3C,EAAA5D,EAAA,MAAA1zC,EAAA,GACAs3C,EAAA,GAAAA,IACAA,EAAA,GAAAA,IAGAhiC,EADA,EAAAgiC,EAAA,EACAF,EAAA,GAAAC,EAAAD,GAAAE,EACA,EAAAA,EAAA,EACAD,EACA,EAAAC,EAAA,EACAF,GAAAC,EAAAD,IAAA,IAAAE,GAAA,EAEAF,EAEA1jC,EAAA1T,GAAA,IAAAsV,CAGA,OAAA5B,GAGA,QAAA6jC,GAAA5jC,GACA,GAGA6jC,GAAAx0C,EAHA0wC,EAAA//B,EAAA,GACAqoB,EAAAroB,EAAA,OACAY,EAAAZ,EAAA,MAGA,YAAAY,GAGA,QAGAA,GAAA,EACAynB,GAAAznB,GAAA,EAAAA,EAAA,EAAAA,EACAvR,GAAAuR,EAAAynB,GAAA,EACAwb,EAAA,EAAAxb,GAAAznB,EAAAynB,IACA0X,EAAA,IAAA8D,EAAA,IAAAx0C,IAGA,QAAAy0C,GAAAjtC,GACA,MAAA+rC,GAAAY,EAAA3sC,IAGA,QAAAktC,GAAAltC,GACA,MAAAgsC,GAAAW,EAAA3sC,IAGA,QAAAmtC,GAAAntC,GACA,MAAAksC,GAAAS,EAAA3sC,IAIA,QAAAotC,GAAAhkC,GACA,GAAA8/B,GAAA9/B,EAAA,MACAooB,EAAApoB,EAAA,OACA5Q,EAAA4Q,EAAA,OACAikC,EAAAhyC,KAAAkD,MAAA2qC,GAAA,EAEAoE,EAAApE,EAAA7tC,KAAAkD,MAAA2qC,GACAv7B,EAAA,IAAAnV,GAAA,EAAAg5B,GACA+b,EAAA,IAAA/0C,GAAA,EAAAg5B,EAAA8b,GACA5Q,EAAA,IAAAlkC,GAAA,EAAAg5B,GAAA,EAAA8b,IACA90C,EAAA,IAAAA,CAEA,QAAA60C,GACA,OACA,OAAA70C,EAAAkkC,EAAA/uB,EACA,QACA,OAAA4/B,EAAA/0C,EAAAmV,EACA,QACA,OAAAA,EAAAnV,EAAAkkC,EACA,QACA,OAAA/uB,EAAA4/B,EAAA/0C,EACA,QACA,OAAAkkC,EAAA/uB,EAAAnV,EACA,QACA,OAAAA,EAAAmV,EAAA4/B,IAIA,QAAAC,GAAApkC,GACA,GAGAqkC,GAAA1jC,EAHAm/B,EAAA9/B,EAAA,GACAooB,EAAApoB,EAAA,OACA5Q,EAAA4Q,EAAA,MAQA,OALAW,IAAA,EAAAynB,GAAAh5B,EACAi1C,EAAAjc,EAAAh5B,EACAi1C,GAAA1jC,GAAA,EAAAA,EAAA,EAAAA,EACA0jC,KAAA,EACA1jC,GAAA,GACAm/B,EAAA,IAAAuE,EAAA,IAAA1jC,GAGA,QAAA2jC,GAAA1tC,GACA,MAAA+rC,GAAAqB,EAAAptC,IAGA,QAAA2tC,GAAA3tC,GACA,MAAAgsC,GAAAoB,EAAAptC,IAGA,QAAA4tC,GAAA5tC,GACA,MAAAksC,GAAAkB,EAAAptC,IAIA,QAAA6tC,GAAAxkC,GACA,GAIA7T,GAAAgD,EAAA80C,EAAAj5C,EAJA60C,EAAA7/B,EAAA,OACAykC,EAAAzkC,EAAA,OACA0kC,EAAA1kC,EAAA,OACAyD,EAAAghC,EAAAC,CAiBA,QAbAjhC,EAAA,IACAghC,GAAAhhC,EACAihC,GAAAjhC,GAGAtX,EAAA6F,KAAAkD,MAAA,EAAA2qC,GACA1wC,EAAA,EAAAu1C,EACAT,EAAA,EAAApE,EAAA1zC,EACA,MAAAA,KACA83C,EAAA,EAAAA,GAEAj5C,EAAAy5C,EAAAR,GAAA90C,EAAAs1C,GAEAt4C,GACA,QACA,OACA,OAAAqU,EAAArR,EAAkBqzC,EAAAx3C,EAAOyE,EAAAg1C,CAAQ,MACjC,QAAAjkC,EAAAxV,EAAkBw3C,EAAArzC,EAAOM,EAAAg1C,CAAQ,MACjC,QAAAjkC,EAAAikC,EAAmBjC,EAAArzC,EAAOM,EAAAzE,CAAO,MACjC,QAAAwV,EAAAikC,EAAmBjC,EAAAx3C,EAAOyE,EAAAN,CAAO,MACjC,QAAAqR,EAAAxV,EAAkBw3C,EAAAiC,EAAQh1C,EAAAN,CAAO,MACjC,QAAAqR,EAAArR,EAAkBqzC,EAAAiC,EAAQh1C,EAAAzE,EAG1B,WAAAwV,EAAA,IAAAgiC,EAAA,IAAA/yC,GAGA,QAAAk1C,GAAAhuC,GACA,MAAA4rC,GAAAiC,EAAA7tC,IAGA,QAAAiuC,GAAAjuC,GACA,MAAA8rC,GAAA+B,EAAA7tC,IAGA,QAAAkuC,GAAAluC,GACA,MAAAgsC,GAAA6B,EAAA7tC,IAGA,QAAAmuC,GAAAnuC,GACA,MAAAksC,GAAA2B,EAAA7tC,IAGA,QAAAouC,GAAA9kC,GACA,GAIAO,GAAAgiC,EAAA/yC,EAJAqR,EAAAb,EAAA,OACA2iC,EAAA3iC,EAAA,OACA5R,EAAA4R,EAAA,OACA5I,EAAA4I,EAAA,MAMA,OAHAO,GAAA,EAAAxO,KAAAuD,IAAA,EAAAuL,GAAA,EAAAzJ,MACAmrC,EAAA,EAAAxwC,KAAAuD,IAAA,EAAAqtC,GAAA,EAAAvrC,MACA5H,EAAA,EAAAuC,KAAAuD,IAAA,EAAAlH,GAAA,EAAAgJ,OACA,IAAAmJ,EAAA,IAAAgiC,EAAA,IAAA/yC,GAGA,QAAAu1C,GAAAruC,GACA,MAAA4rC,GAAAwC,EAAApuC,IAGA,QAAAsuC,GAAAtuC,GACA,MAAA8rC,GAAAsC,EAAApuC,IAGA,QAAAuuC,GAAAvuC,GACA,MAAA+rC,GAAAqC,EAAApuC,IAGA,QAAAwuC,GAAAxuC,GACA,MAAAksC,GAAAkC,EAAApuC,IAIA,QAAAyuC,GAAAlC,GACA,GAGA1iC,GAAAgiC,EAAA/yC,EAHArB,EAAA80C,EAAA,OACA70C,EAAA60C,EAAA,OACAC,EAAAD,EAAA,MAqBA,OAlBA1iC,GAAA,OAAApS,GAAA,OAAAC,GAAA,MAAA80C,EACAX,GAAA,MAAAp0C,EAAA,OAAAC,EAAA,MAAA80C,EACA1zC,EAAA,MAAArB,GAAA,KAAAC,EAAA,MAAA80C,EAGA3iC,IAAA,eAAAxO,KAAA2D,IAAA6K,EAAA,YACAA,GAAA,MAEAgiC,IAAA,eAAAxwC,KAAA2D,IAAA6sC,EAAA,YACAA,GAAA,MAEA/yC,IAAA,eAAAuC,KAAA2D,IAAAlG,EAAA,YACAA,GAAA,MAEA+Q,EAAAxO,KAAAuD,IAAAvD,KAAAC,IAAA,EAAAuO,GAAA,GACAgiC,EAAAxwC,KAAAuD,IAAAvD,KAAAC,IAAA,EAAAuwC,GAAA,GACA/yC,EAAAuC,KAAAuD,IAAAvD,KAAAC,IAAA,EAAAxC,GAAA,IAEA,IAAA+Q,EAAA,IAAAgiC,EAAA,IAAA/yC,GAGA,QAAA41C,GAAAnC,GACA,GAGAxiC,GAAAjW,EAAAgF,EAHArB,EAAA80C,EAAA,GACA70C,EAAA60C,EAAA,GACAC,EAAAD,EAAA,EAeA,OAZA90C,IAAA,OACAC,GAAA,IACA80C,GAAA,QAEA/0C,IAAA,QAAA4D,KAAA2D,IAAAvH,EAAA,WAAAA,EAAA,OACAC,IAAA,QAAA2D,KAAA2D,IAAAtH,EAAA,WAAAA,EAAA,OACA80C,IAAA,QAAAnxC,KAAA2D,IAAAwtC,EAAA,WAAAA,EAAA,OAEAziC,EAAA,IAAArS,EAAA,GACA5D,EAAA,KAAA2D,EAAAC,GACAoB,EAAA,KAAApB,EAAA80C,IAEAziC,EAAAjW,EAAAgF,GAGA,QAAA61C,GAAA3uC,GACA,MAAA0sC,GAAAgC,EAAA1uC,IAGA,QAAA4uC,GAAAC,GACA,GAGAp3C,GAAAC,EAAA80C,EAAAsC,EAHA/kC,EAAA8kC,EAAA,GACA/6C,EAAA+6C,EAAA,GACA/1C,EAAA+1C,EAAA,EAeA,OAZA9kC,IAAA,GACArS,EAAA,IAAAqS,EAAA,MACA+kC,EAAAp3C,EAAA,mBAEAA,EAAA,IAAA2D,KAAA2D,KAAA+K,EAAA,WACA+kC,EAAAzzC,KAAA2D,IAAAtH,EAAA,UAGAD,IAAA,gBAAAA,EAAA,QAAA3D,EAAA,IAAAg7C,EAAA,qBAAAzzC,KAAA2D,IAAAlL,EAAA,IAAAg7C,EAAA,GAEAtC,IAAA,iBAAAA,EAAA,SAAAsC,EAAAh2C,EAAA,0BAAAuC,KAAA2D,IAAA8vC,EAAAh2C,EAAA,QAEArB,EAAAC,EAAA80C,GAGA,QAAAE,GAAAmC,GACA,GAGAE,GAAA7F,EAAA/+B,EAHAJ,EAAA8kC,EAAA,GACA/6C,EAAA+6C,EAAA,GACA/1C,EAAA+1C,EAAA,EASA,OANAE,GAAA1zC,KAAA0pC,MAAAjsC,EAAAhF,GACAo1C,EAAA,IAAA6F,EAAA,EAAA1zC,KAAAoiC,GACAyL,EAAA,IACAA,GAAA,KAEA/+B,EAAA9O,KAAA0V,KAAAjd,IAAAgF,MACAiR,EAAAI,EAAA++B,GAGA,QAAA8F,GAAAhvC,GACA,MAAAyuC,GAAAG,EAAA5uC,IAGA,QAAAivC,GAAAC,GACA,GAGAp7C,GAAAgF,EAAAi2C,EAHAhlC,EAAAmlC,EAAA,GACA/kC,EAAA+kC,EAAA,GACAhG,EAAAgG,EAAA,EAMA,OAHAH,GAAA7F,EAAA,MAAA7tC,KAAAoiC,GACA3pC,EAAAqW,EAAA9O,KAAAmiC,IAAAuR,GACAj2C,EAAAqR,EAAA9O,KAAAsiC,IAAAoR,IACAhlC,EAAAjW,EAAAgF,GAGA,QAAAq2C,GAAAnvC,GACA,MAAA4uC,GAAAK,EAAAjvC,IAGA,QAAAovC,GAAApvC,GACA,MAAAgvC,GAAAC,EAAAjvC,IAGA,QAAAqvC,GAAAtjC,GACA,MAAAujC,GAAAvjC,GAGA,QAAAwjC,GAAAvvC,GACA,MAAA4rC,GAAAyD,EAAArvC,IAGA,QAAAwvC,GAAAxvC,GACA,MAAA8rC,GAAAuD,EAAArvC,IAGA,QAAAyvC,GAAAzvC,GACA,MAAA+rC,GAAAsD,EAAArvC,IAGA,QAAA0vC,GAAA1vC,GACA,MAAAgsC,GAAAqD,EAAArvC,IAGA,QAAA2vC,GAAA3vC,GACA,MAAAssC,GAAA+C,EAAArvC,IAGA,QAAA4vC,GAAA5vC,GACA,MAAAqsC,GAAAgD,EAAArvC,IA1hBAvM,EAAAc,SACAq3C,UACAE,UACAC,UACAC,WACAE,cACAG,UACAC,UACAG,UAEAE,UACAI,UACAE,UACAC,WACAC,cAEAC,UACAI,UACAE,UACAC,WACAC,cAEAC,UACAG,UACAC,UACAC,WACAC,cAEAC,WACAC,WACAC,WACAC,WACAC,eAEAa,cACAE,cACAC,cACAC,cACAC,eACAC,cACAC,cAEAnB,UACAC,UACAC,UAEAC,UACAI,UACAtC,UAEAuC,UACAE,UACAC,UAyeA,IAAAE,IACAO,WAAA,aACAC,cAAA,aACAC,MAAA,WACAC,YAAA,aACAC,OAAA,aACAC,OAAA,aACAC,QAAA,aACA3kC,OAAA,OACA4kC,gBAAA,aACAnlC,MAAA,SACAolC,YAAA,YACAC,OAAA,WACAC,WAAA,aACAC,WAAA,YACAC,YAAA,WACAC,WAAA,YACAC,OAAA,YACAC,gBAAA,aACAC,UAAA,aACAC,SAAA,WACA1mC,MAAA,WACA2mC,UAAA,SACAC,UAAA,WACAC,eAAA,YACAC,UAAA,aACAC,WAAA,SACAC,UAAA,aACAC,WAAA,aACAC,aAAA,WACAC,gBAAA,WACAC,YAAA,WACAC,YAAA,YACAC,SAAA,SACAC,YAAA,aACAC,cAAA,aACAC,eAAA,WACAC,eAAA,UACAC,eAAA,UACAC,eAAA,WACAC,YAAA,WACAC,UAAA,YACAC,aAAA,WACAC,SAAA,aACAC,SAAA,aACAC,YAAA,YACAC,WAAA,WACAC,aAAA,aACAC,aAAA,WACAC,SAAA,WACAC,WAAA,aACAC,YAAA,aACAC,MAAA,WACAC,WAAA,YACAC,MAAA,aACA/nC,OAAA,SACAgoC,aAAA,YACAC,MAAA,aACAC,UAAA,aACAC,SAAA,aACAC,WAAA,WACAC,QAAA,UACAC,OAAA,aACAC,OAAA,aACAC,UAAA,aACAC,eAAA,aACAC,WAAA,WACAC,cAAA,aACAC,WAAA,aACAC,YAAA,aACAC,WAAA,aACAC,sBAAA,aACAC,WAAA,aACAC,YAAA,aACAC,WAAA,aACAC,WAAA,aACAC,aAAA,aACAC,eAAA,YACAC,cAAA,aACAC,gBAAA,aACAC,gBAAA,aACAC,gBAAA,aACAC,aAAA,aACAC,MAAA,SACAC,WAAA,WACAC,OAAA,aACAvpC,SAAA,WACAwpC,QAAA,SACAC,kBAAA,aACAC,YAAA,SACAC,cAAA,YACAC,cAAA,aACAC,gBAAA,YACAC,iBAAA,aACAC,mBAAA,WACAC,iBAAA,YACAC,iBAAA,YACAC,cAAA,WACAC,WAAA,aACAC,WAAA,aACAC,UAAA,aACAC,aAAA,aACAC,MAAA,SACAC,SAAA,aACAC,OAAA,WACAC,WAAA,YACAC,QAAA,WACAC,WAAA,UACAC,QAAA,aACAC,eAAA,aACAC,WAAA,aACAC,eAAA,aACAC,eAAA,aACAC,YAAA,aACAC,WAAA,aACAC,MAAA,YACAC,MAAA,aACAC,MAAA,aACAC,YAAA,aACAC,QAAA,WACAC,eAAA,YACAjtC,KAAA,SACAktC,WAAA,aACAC,WAAA,YACAC,aAAA,WACAC,QAAA,aACAC,YAAA,YACAC,UAAA,WACAC,UAAA,aACAC,QAAA,WACAC,QAAA,aACAC,SAAA,aACAC,WAAA,YACAC,WAAA,aACAC,WAAA,aACAC,MAAA,aACAC,aAAA,WACAC,WAAA,YACAC,KAAA,aACAC,MAAA,WACAC,SAAA,aACAC,QAAA,WACAC,WAAA,YACAC,QAAA,aACAC,OAAA,aACAC,OAAA,aACAC,YAAA,aACAjtC,QAAA,WACAktC,aAAA,aAGAtM,IACA,QAAAz2C,KAAA45C,GACAnD,EAAA1hB,KAAA2hB,UAAAkD,EAAA55C,QjCooNMgjD,KACA,SAAUjlD,EAAQc,EAASZ,GkCvyOjC,QAAA8V,GAAAV,GACA,GAAAA,EAAA,CAGA,GAAA4vC,GAAA,uBACApoB,EAAA,uBACAqoB,EAAA,2FACAC,EAAA,6GACA9sC,EAAA,QAEA7C,GAAA,OACApV,EAAA,EACAuxB,EAAAtc,EAAAsc,MAAAszB,EACA,IAAAtzB,EAAA,CACAA,IAAA,EACA,QAAA7vB,GAAA,EAAqBA,EAAA0T,EAAAhT,OAAgBV,IACrC0T,EAAA1T,GAAA+vB,SAAAF,EAAA7vB,GAAA6vB,EAAA7vB,GAAA,QAGA,IAAA6vB,EAAAtc,EAAAsc,MAAAkL,GAAA,CACAlL,IAAA,EACA,QAAA7vB,GAAA,EAAqBA,EAAA0T,EAAAhT,OAAgBV,IACrC0T,EAAA1T,GAAA+vB,SAAAF,EAAArX,MAAA,EAAAxY,EAAA,EAAAA,EAAA,WAGA,IAAA6vB,EAAAtc,EAAAsc,MAAAuzB,GAAA,CACA,OAAApjD,GAAA,EAAqBA,EAAA0T,EAAAhT,OAAgBV,IACrC0T,EAAA1T,GAAA+vB,SAAAF,EAAA7vB,EAAA,GAEA1B,GAAA8U,WAAAyc,EAAA,QAEA,IAAAA,EAAAtc,EAAAsc,MAAAwzB,GAAA,CACA,OAAArjD,GAAA,EAAqBA,EAAA0T,EAAAhT,OAAgBV,IACrC0T,EAAA1T,GAAA6F,KAAAoT,MAAA,KAAA7F,WAAAyc,EAAA7vB,EAAA,IAEA1B,GAAA8U,WAAAyc,EAAA,QAEA,IAAAA,EAAAtc,EAAAsc,MAAAtZ,GAAA,CACA,kBAAAsZ,EAAA,GACA,eAGA,MADAnc,EAAA4vC,EAAAzzB,EAAA,KAEA,OAIA,OAAA7vB,GAAA,EAAkBA,EAAA0T,EAAAhT,OAAgBV,IAClC0T,EAAA1T,GAAAwtC,EAAA95B,EAAA1T,GAAA,MASA,OAHA1B,GAJAA,GAAA,GAAAA,EAIAkvC,EAAAlvC,EAAA,KAHA,EAKAoV,EAAA,GAAApV,EACAoV,GAGA,QAAAS,GAAAZ,GACA,GAAAA,EAAA,CAGA,GAAAI,GAAA,2GACAkc,EAAAtc,EAAAsc,MAAAlc,EACA,IAAAkc,EAAA,CACA,GAAA9b,GAAAX,WAAAyc,EAAA,GAKA,QAJA2d,EAAAzd,SAAAF,EAAA,WACA2d,EAAAp6B,WAAAyc,EAAA,WACA2d,EAAAp6B,WAAAyc,EAAA,WACA2d,EAAA5a,MAAA7e,GAAA,EAAAA,EAAA,QAKA,QAAAK,GAAAb,GACA,GAAAA,EAAA,CAGA,GAAAM,GAAA,yGACAgc,EAAAtc,EAAAsc,MAAAhc,EACA,IAAAgc,EAAA,CACA,GAAA9b,GAAAX,WAAAyc,EAAA,GAKA,QAJA2d,EAAAzd,SAAAF,EAAA,WACA2d,EAAAp6B,WAAAyc,EAAA,WACA2d,EAAAp6B,WAAAyc,EAAA,WACA2d,EAAA5a,MAAA7e,GAAA,EAAAA,EAAA,QAKA,QAAAwvC,GAAAhwC,GACA,GAAA6vC,GAAAnvC,EAAAV,EACA,OAAA6vC,MAAA5qC,MAAA,KAGA,QAAAgrC,GAAAjwC,GACA,GAAAkwC,GAAAtvC,EAAAZ,EACA,OAAAkwC,MAAAjrC,MAAA,KAGA,QAAAkrC,GAAAnwC,GACA,GAAAS,GAAAC,EAAAV,EACA,OAAAS,GACAA,EAAA,IAEAA,EAAAG,EAAAZ,IACAS,EAAA,IAEAA,EAAAI,EAAAb,IACAS,EAAA,OADA,GAMA,QAAAiC,GAAAvC,GACA,UAAAiwC,EAAAjwC,EAAA,IAAAiwC,EAAAjwC,EAAA,IACAiwC,EAAAjwC,EAAA,IAGA,QAAA3S,GAAAqiD,EAAArvC,GACA,MAAAA,GAAA,GAAAqvC,EAAA,IAAAA,EAAA,KACAltC,EAAAktC,EAAArvC,GAEA,OAAAqvC,EAAA,QAAAA,EAAA,QAAAA,EAAA,OAGA,QAAAltC,GAAAktC,EAAArvC,GAIA,WAHA7E,KAAA6E,IACAA,MAAA7E,KAAAk0C,EAAA,GAAAA,EAAA,MAEA,QAAAA,EAAA,QAAAA,EAAA,QAAAA,EAAA,GACA,KAAArvC,EAAA,IAGA,QAAAoC,GAAAitC,EAAArvC,GACA,MAAAA,GAAA,GAAAqvC,EAAA,IAAAA,EAAA,KACAQ,EAAAR,EAAArvC,GAMA,OAJAlO,KAAAoT,MAAAmqC,EAAA,YAIA,MAHAv9C,KAAAoT,MAAAmqC,EAAA,YAGA,MAFAv9C,KAAAoT,MAAAmqC,EAAA,YAEA,KAGA,QAAAQ,GAAAR,EAAArvC,GAIA,cAHAlO,KAAAoT,MAAAmqC,EAAA,YAGA,MAFAv9C,KAAAoT,MAAAmqC,EAAA,YAEA,MADAv9C,KAAAoT,MAAAmqC,EAAA,YACA,OAAArvC,GAAAqvC,EAAA,WAGA,QAAAhtC,GAAAqtC,EAAA1vC,GACA,MAAAA,GAAA,GAAA0vC,EAAA,IAAAA,EAAA,KACAptC,EAAAotC,EAAA1vC,GAEA,OAAA0vC,EAAA,QAAAA,EAAA,SAAAA,EAAA,QAGA,QAAAptC,GAAAotC,EAAA1vC,GAIA,WAHA7E,KAAA6E,IACAA,MAAA7E,KAAAu0C,EAAA,GAAAA,EAAA,MAEA,QAAAA,EAAA,QAAAA,EAAA,SAAAA,EAAA,SACA1vC,EAAA,IAKA,QAAAuC,GAAAzC,EAAAE,GAIA,WAHA7E,KAAA6E,IACAA,MAAA7E,KAAA2E,EAAA,GAAAA,EAAA,MAEA,OAAAA,EAAA,QAAAA,EAAA,SAAAA,EAAA,YACA3E,KAAA6E,GAAA,IAAAA,EAAA,KAAAA,EAAA,QAGA,QAAAwC,GAAA7C,GACA,MAAAmwC,GAAAnwC,EAAA8E,MAAA,MAIA,QAAAg1B,GAAAsW,EAAA16C,EAAAtD,GACA,MAAAD,MAAAuD,IAAAvD,KAAAC,IAAAsD,EAAA06C,GAAAh+C,GAGA,QAAA69C,GAAAG,GACA,GAAAtzB,GAAAszB,EAAA95C,SAAA,IAAA+5C,aACA,OAAAvzB,GAAA9vB,OAAA,MAAA8vB,IAnNA,GAAA8yB,GAAAnlD,EAAA,KAEAF,GAAAc,SACAkV,UACAE,UACAovC,SACAC,SACApvC,SACAsvC,WAEAztC,YACAlV,YACAmV,aACAC,gBACAytC,iBACAxtC,YACAC,aACAC,YACAC,UAsMA,IAAAstC,KACA,QAAA5zC,KAAAqzC,GACAO,EAAAP,EAAArzC,OlCq0OM+zC,KACA,SAAU/lD,EAAQc,EAASZ,GAEjC,YmCjiPAF,GAAAc,SACAs7C,WAAA,aACAC,cAAA,aACAC,MAAA,WACAC,YAAA,aACAC,OAAA,aACAC,OAAA,aACAC,QAAA,aACA3kC,OAAA,OACA4kC,gBAAA,aACAnlC,MAAA,SACAolC,YAAA,YACAC,OAAA,WACAC,WAAA,aACAC,WAAA,YACAC,YAAA,WACAC,WAAA,YACAC,OAAA,YACAC,gBAAA,aACAC,UAAA,aACAC,SAAA,WACA1mC,MAAA,WACA2mC,UAAA,SACAC,UAAA,WACAC,eAAA,YACAC,UAAA,aACAC,WAAA,SACAC,UAAA,aACAC,WAAA,aACAC,aAAA,WACAC,gBAAA,WACAC,YAAA,WACAC,YAAA,YACAC,SAAA,SACAC,YAAA,aACAC,cAAA,aACAC,eAAA,WACAC,eAAA,UACAC,eAAA,UACAC,eAAA,WACAC,YAAA,WACAC,UAAA,YACAC,aAAA,WACAC,SAAA,aACAC,SAAA,aACAC,YAAA,YACAC,WAAA,WACAC,aAAA,aACAC,aAAA,WACAC,SAAA,WACAC,WAAA,aACAC,YAAA,aACAC,MAAA,WACAC,WAAA,YACAC,MAAA,aACA/nC,OAAA,SACAgoC,aAAA,YACAC,MAAA,aACAC,UAAA,aACAC,SAAA,aACAC,WAAA,WACAC,QAAA,UACAC,OAAA,aACAC,OAAA,aACAC,UAAA,aACAC,eAAA,aACAC,WAAA,WACAC,cAAA,aACAC,WAAA,aACAC,YAAA,aACAC,WAAA,aACAC,sBAAA,aACAC,WAAA,aACAC,YAAA,aACAC,WAAA,aACAC,WAAA,aACAC,aAAA,aACAC,eAAA,YACAC,cAAA,aACAC,gBAAA,aACAC,gBAAA,aACAC,gBAAA,aACAC,aAAA,aACAC,MAAA,SACAC,WAAA,WACAC,OAAA,aACAvpC,SAAA,WACAwpC,QAAA,SACAC,kBAAA,aACAC,YAAA,SACAC,cAAA,YACAC,cAAA,aACAC,gBAAA,YACAC,iBAAA,aACAC,mBAAA,WACAC,iBAAA,YACAC,iBAAA,YACAC,cAAA,WACAC,WAAA,aACAC,WAAA,aACAC,UAAA,aACAC,aAAA,aACAC,MAAA,SACAC,SAAA,aACAC,OAAA,WACAC,WAAA,YACAC,QAAA,WACAC,WAAA,UACAC,QAAA,aACAC,eAAA,aACAC,WAAA,aACAC,eAAA,aACAC,eAAA,aACAC,YAAA,aACAC,WAAA,aACAC,MAAA,YACAC,MAAA,aACAC,MAAA,aACAC,YAAA,aACAC,QAAA,WACAC,eAAA,YACAjtC,KAAA,SACAktC,WAAA,aACAC,WAAA,YACAC,aAAA,WACAC,QAAA,aACAC,YAAA,YACAC,UAAA,WACAC,UAAA,aACAC,QAAA,WACAC,QAAA,aACAC,SAAA,aACAC,WAAA,YACAC,WAAA,aACAC,WAAA,aACAC,MAAA,aACAC,aAAA,WACAC,WAAA,YACAC,KAAA,aACAC,MAAA,WACAC,SAAA,aACAC,QAAA,WACAC,WAAA,YACAC,QAAA,aACAC,OAAA,aACAC,OAAA,aACAC,YAAA,aACAjtC,QAAA,WACAktC,aAAA,cnC0iPMgB,KACA,SAAUhmD,EAAQc,EAASZ,GAEjC,YoCjsPA,IAAAuF,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,UACA8a,UACAmwB,KACA/N,gBAAA74B,EAAA8a,OAAAioB,aACAhK,YAAA,OACAG,YAAA,MAKA3+B,EAAAc,QAAAkC,EAAAE,QACA+iD,aAAA,SAAA/R,GACA,GAAAgS,GAAA1kD,KAAAkC,KAEA,SAAAwiD,GACAt+C,KAAA2D,IAAA2oC,EAAAgS,EAAAliD,EAAA,GAAA4D,KAAA2D,IAAA26C,EAAA1a,OAAA0a,EAAAC,YAAA,IAKAhqC,QAAA,SAAAiqC,EAAAC,GACA,GAAAH,GAAA1kD,KAAAkC,KAEA,IAAAwiD,EAAA,CAQA,IAPA,GAAAI,GAAAnlD,EAAA4vC,kBAAAmV,GAA8DliD,EAAAoiD,EAAAniD,EAAAoiD,IAC9DhV,EAAAiV,EAAAjV,MACAx0B,EAAAypC,EAAAzpC,SAGA0pC,EAAAL,EAAAK,WACAC,EAAAN,EAAAM,SACAA,EAAAD,GACAC,GAAA,EAAA5+C,KAAAoiC,EAEA,MAAAqH,EAAAmV,GACAnV,GAAA,EAAAzpC,KAAAoiC,EAEA,MAAAqH,EAAAkV,GACAlV,GAAA,EAAAzpC,KAAAoiC,EAIA,IAAAyc,GAAApV,GAAAkV,GAAAlV,GAAAmV,EACAE,EAAA7pC,GAAAqpC,EAAAS,aAAA9pC,GAAAqpC,EAAAU,WAEA,OAAAH,IAAAC,EAEA,UAGA9pC,eAAA,WACA,GAAAspC,GAAA1kD,KAAAkC,MACAmjD,GAAAX,EAAAK,WAAAL,EAAAM,UAAA,EACAM,GAAAZ,EAAAS,YAAAT,EAAAU,aAAA,CACA,QACA5iD,EAAAkiD,EAAAliD,EAAA4D,KAAAmiC,IAAA8c,GAAAC,EACA7iD,EAAAiiD,EAAAjiD,EAAA2D,KAAAsiC,IAAA2c,GAAAC,IAIA3oC,QAAA,WACA,GAAA+nC,GAAA1kD,KAAAkC,KACA,OAAAkE,MAAAoiC,KAAAkc,EAAAM,SAAAN,EAAAK,aAAA,EAAA3+C,KAAAoiC,MAAApiC,KAAA2D,IAAA26C,EAAAU,YAAA,GAAAh/C,KAAA2D,IAAA26C,EAAAS,YAAA,KAGA5iD,gBAAA,WACA,GAAAmiD,GAAA1kD,KAAAkC,MACAqjD,EAAAb,EAAAK,YAAAL,EAAAM,SAAAN,EAAAK,YAAA,EACAS,GAAAd,EAAAU,YAAAV,EAAAS,aAAA,EAAAT,EAAAS,WAEA,QACA3iD,EAAAkiD,EAAAliD,EAAA4D,KAAAmiC,IAAAgd,GAAAC,EACA/iD,EAAAiiD,EAAAjiD,EAAA2D,KAAAsiC,IAAA6c,GAAAC,IAIAliB,KAAA,WACA,GAAAvE,GAAA/+B,KAAAylD,OAAA1mB,IACA2lB,EAAA1kD,KAAAkC,MACAwjD,EAAAhB,EAAAK,WACAY,EAAAjB,EAAAM,QAEAjmB,GAAA6L,YAEA7L,EAAA8L,IAAA6Z,EAAAliD,EAAAkiD,EAAAjiD,EAAAiiD,EAAAU,YAAAM,EAAAC,GACA5mB,EAAA8L,IAAA6Z,EAAAliD,EAAAkiD,EAAAjiD,EAAAiiD,EAAAS,YAAAQ,EAAAD,GAAA,GAEA3mB,EAAA+L,YACA/L,EAAA6mB,YAAAlB,EAAA1nB,YACA+B,EAAA8mB,UAAAnB,EAAAvnB,YAEA4B,EAAA+mB,UAAApB,EAAA5nB,gBAEAiC,EAAAhC,OACAgC,EAAAgnB,SAAA,QAEArB,EAAAvnB,aACA4B,EAAAsM,apC4sPM2a,KACA,SAAUxnD,EAAQc,EAASZ,GAEjC,YqCpzPA,IAAAuF,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,MACAiB,EAAAjB,EAAA,MAEAunD,EAAAhiD,EAAA8a,MAEA9a,GAAArE,KAAA,UACA8a,UACAwrC,MACApa,QAAA,GACAhP,gBAAAmpB,EAAAjf,aACA7J,YAAA,EACAH,YAAAipB,EAAAjf,aACAmf,eAAA,OACAC,cACAC,iBAAA,EACAC,gBAAA,QACAC,iBAAA,EACAxpB,MAAA,MAKAv+B,EAAAc,QAAAkC,EAAAE,QACA4hC,KAAA,WACA,GAOA5+B,GAAA4rC,EAAA3E,EAAA6a,EAPAvkD,EAAAjC,KACA0kD,EAAAziD,EAAAC,MACA68B,EAAA98B,EAAAwjD,OAAA1mB,IACA0nB,EAAA/B,EAAA+B,SACAlpB,EAAAt7B,EAAAykD,UAAA3tC,QACA4tC,EAAAV,EAAAvrC,SAAAwrC,KACAU,GAAA,CA2BA,KAvBA3kD,EAAA4kD,OAAAtpB,EAAAt8B,QACAs8B,EAAAh5B,KAAAg5B,EAAA,IAGAwB,EAAAwM,OAGAxM,EAAA+nB,QAAApC,EAAAyB,gBAAAQ,EAAAR,eAGApnB,EAAAgoB,aACAhoB,EAAAgoB,YAAArC,EAAA0B,YAAAO,EAAAP,YAGArnB,EAAAioB,eAAAtC,EAAA2B,kBAAAM,EAAAN,iBACAtnB,EAAAgnB,SAAArB,EAAA4B,iBAAAK,EAAAL,gBACAvnB,EAAA8mB,UAAAnB,EAAAvnB,aAAAwpB,EAAAxpB,YACA4B,EAAA6mB,YAAAlB,EAAA1nB,aAAAipB,EAAAjf,aAGAjI,EAAA6L,YACAgc,GAAA,EAEAliD,EAAA,EAAiBA,EAAA64B,EAAAt8B,SAAuByD,EACxC4rC,EAAA/S,EAAA74B,GACAinC,EAAAhsC,EAAAmyC,aAAAvU,EAAA74B,GACA8hD,EAAAlW,EAAApuC,MAGA,IAAAwC,EACA8hD,EAAAhsC,OACAukB,EAAA9Y,OAAAugC,EAAAhkD,EAAAgkD,EAAA/jD,GACAmkD,EAAAliD,IAGAinC,GAAA,IAAAib,EAAAjb,EAAApO,EAAAqpB,GAEAJ,EAAAhsC,OACAosC,IAAAliD,EAAA,IAAA+hD,IAAA,IAAAG,EAEA7nB,EAAA9Y,OAAAugC,EAAAhkD,EAAAgkD,EAAA/jD,GAGA9C,EAAAH,OAAA2qC,OAAApL,EAAA4M,EAAAzpC,MAAAouC,EAAApuC,OAEA0kD,EAAAliD,GAKAq6B,GAAAsM,SACAtM,EAAA2M,crC8zPMub,KACA,SAAUzoD,EAAQc,EAASZ,GAEjC,YsCj4PA,SAAAwoD,GAAAxU,GACA,GAAAgS,GAAA1kD,KAAAkC,KACA,SAAAwiD,GAAAt+C,KAAAiD,IAAAqpC,EAAAgS,EAAAliD,GAAAkiD,EAAA1a,OAAA0a,EAAAyC,UAGA,QAAAC,GAAAzU,GACA,GAAA+R,GAAA1kD,KAAAkC,KACA,SAAAwiD,GAAAt+C,KAAAiD,IAAAspC,EAAA+R,EAAAjiD,GAAAiiD,EAAA1a,OAAA0a,EAAAyC,UA7BA,GAAAljD,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,MACAiB,EAAAjB,EAAA,MAEAsoC,EAAA/iC,EAAA8a,OAAAioB,YAEA/iC,GAAArE,KAAA,UACA8a,UACA8B,OACAwtB,OAAA,EACAqd,WAAA,SACAvqB,gBAAAkK,EACAhK,YAAAgK,EACA7J,YAAA,EAEAgqB,UAAA,EACAxC,YAAA,EACA2C,iBAAA,MAeA9oD,EAAAc,QAAAkC,EAAAE,QACAiZ,QAAA,SAAA+3B,EAAAC,GACA,GAAA+R,GAAA1kD,KAAAkC,KACA,SAAAwiD,GAAAt+C,KAAA2D,IAAA2oC,EAAAgS,EAAAliD,EAAA,GAAA4D,KAAA2D,IAAA4oC,EAAA+R,EAAAjiD,EAAA,GAAA2D,KAAA2D,IAAA26C,EAAAyC,UAAAzC,EAAA1a,OAAA,IAGAya,aAAAyC,EACAnqC,SAAAmqC,EACAlqC,SAAAoqC,EAEAhsC,eAAA,WACA,GAAAspC,GAAA1kD,KAAAkC,KACA,QACAM,EAAAkiD,EAAAliD,EACAC,EAAAiiD,EAAAjiD,IAIAka,QAAA,WACA,MAAAvW,MAAAoiC,GAAApiC,KAAA2D,IAAA/J,KAAAkC,MAAA8nC,OAAA,IAGAznC,gBAAA,WACA,GAAAmiD,GAAA1kD,KAAAkC,KACA,QACAM,EAAAkiD,EAAAliD,EACAC,EAAAiiD,EAAAjiD,EACA6E,QAAAo9C,EAAA1a,OAAA0a,EAAAvnB,cAIAmG,KAAA,SAAAz6B,GACA,GAAA67C,GAAA1kD,KAAAkC,MACA7B,EAAAL,KAAAoC,OACA28B,EAAA/+B,KAAAylD,OAAA1mB,IACAsoB,EAAA3C,EAAA2C,WACArd,EAAA0a,EAAA1a,OACAxnC,EAAAkiD,EAAAliD,EACAC,EAAAiiD,EAAAjiD,EACAtB,EAAAxB,EAAAwB,MAEA0W,EAAA,CAEA6sC,GAAAlqC,OAIAukB,EAAA6mB,YAAAlB,EAAA1nB,aAAAgK,EACAjI,EAAA8mB,UAAAlmD,EAAA+K,eAAAg6C,EAAAvnB,YAAAl5B,EAAA8a,OAAArE,SAAA8B,MAAA2gB,aACA4B,EAAA+mB,UAAApB,EAAA5nB,iBAAAkK,MAIAv3B,KAAA5G,IAAAxI,EAAAmC,EAAAqG,EAAA1C,MAbA,KAaA0C,EAAArC,MAAAnG,EAAAmC,GAAAnC,EAAAoC,EAAAoG,EAAAlC,KAbA,KAaAkC,EAAAjC,OAAAvG,EAAAoC,KAEApC,EAAAmC,EAAAqG,EAAA1C,KACA0R,GAAArV,EAAAnC,EAAAmC,IAAAqG,EAAA1C,KAAA9F,EAAAmC,GAhBA,KAiBIqG,EAAArC,MAAAnG,EAAAmC,EACJqV,GAAAxX,EAAAmC,MAAAnC,EAAAmC,EAAAqG,EAAArC,OACInG,EAAAoC,EAAAoG,EAAAlC,IACJkR,GAAApV,EAAApC,EAAAoC,IAAAoG,EAAAlC,IAAAtG,EAAAoC,GApBA,KAqBIoG,EAAAjC,OAAAvG,EAAAoC,IACJoV,GAAAxX,EAAAoC,MAAApC,EAAAoC,EAAAoG,EAAAjC,SAEAiR,EAAAzR,KAAAoT,MAAA,IAAA3B,GAAA,IACAknB,EAAA6mB,YAAAzkD,EAAA49B,EAAA6mB,aAAAtxC,MAAAuD,GAAAvW,YACAy9B,EAAA+mB,UAAA3kD,EAAA49B,EAAA+mB,WAAAxxC,MAAAuD,GAAAvW,aAGA3B,EAAAH,OAAA8qC,UAAAvL,EAAAsoB,EAAArd,EAAAxnC,EAAAC,QtCi6PM8kD,KACA,SAAU/oD,EAAQc,EAASZ,GAEjC,YuC3/PA,SAAA8oD,GAAAC,GACA,WAAAh4C,KAAAg4C,EAAAvlD,MAAA+C,MASA,QAAAyiD,GAAAD,GACA,GACAE,GAAAC,EAAAC,EAAAhO,EADA6K,EAAA+C,EAAAvlD,KAGA,IAAAslD,EAAAC,GAAA,CAEA,GAAAK,GAAApD,EAAAz/C,MAAA,CACA0iD,GAAAjD,EAAAliD,EAAAslD,EACAF,EAAAlD,EAAAliD,EAAAslD,EACAD,EAAAzhD,KAAAuD,IAAA+6C,EAAAjiD,EAAAiiD,EAAAqD,MACAlO,EAAAzzC,KAAAC,IAAAq+C,EAAAjiD,EAAAiiD,EAAAqD,UACE,CAEF,GAAAC,GAAAtD,EAAAx/C,OAAA,CACAyiD,GAAAvhD,KAAAuD,IAAA+6C,EAAAliD,EAAAkiD,EAAAqD,MACAH,EAAAxhD,KAAAC,IAAAq+C,EAAAliD,EAAAkiD,EAAAqD,MACAF,EAAAnD,EAAAjiD,EAAAulD,EACAnO,EAAA6K,EAAAjiD,EAAAulD,EAGA,OACA7hD,KAAAwhD,EACAhhD,IAAAkhD,EACArhD,MAAAohD,EACAhhD,OAAAizC,GAhDA,GAAA51C,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,KAEAuF,GAAArE,KAAA,UACA8a,UACAutC,WACAnrB,gBAAA74B,EAAA8a,OAAAioB,aACAhK,YAAA/4B,EAAA8a,OAAAioB,aACAkhB,cAAA,SACA/qB,YAAA,MA2CA3+B,EAAAc,QAAAkC,EAAAE,QACA4hC,KAAA,WAwEA,QAAA6kB,GAAAzjD,GACA,MAAA0jD,IAAAC,EAAA3jD,GAAA,GAxEA,GAEAyB,GAAAK,EAAAG,EAAAC,EAAA0hD,EAAAC,EAAAL,EAFAnpB,EAAA/+B,KAAAylD,OAAA1mB,IACA2lB,EAAA1kD,KAAAkC,MAEAi7B,EAAAunB,EAAAvnB,WAwBA,IAtBAunB,EAAA7+C,YAWAM,EAAAu+C,EAAAqD,KACAvhD,EAAAk+C,EAAAliD,EACAmE,EAAA+9C,EAAAjiD,EAAAiiD,EAAAx/C,OAAA,EACA0B,EAAA89C,EAAAjiD,EAAAiiD,EAAAx/C,OAAA,EACAojD,EAAA9hD,EAAAL,EAAA,KACAoiD,EAAA,EACAL,EAAAxD,EAAAwD,eAAA,SAfA/hD,EAAAu+C,EAAAliD,EAAAkiD,EAAAz/C,MAAA,EACAuB,EAAAk+C,EAAAliD,EAAAkiD,EAAAz/C,MAAA,EACA0B,EAAA+9C,EAAAjiD,EACAmE,EAAA89C,EAAAqD,KACAO,EAAA,EACAC,EAAA3hD,EAAAD,EAAA,KACAuhD,EAAAxD,EAAAwD,eAAA,UAcA/qB,EAAA,CAEA,GAAAqrB,GAAApiD,KAAAuD,IAAAvD,KAAAiD,IAAAlD,EAAAK,GAAAJ,KAAAiD,IAAA1C,EAAAC,GACAu2B,KAAAqrB,IAAArrB,CACA,IAAAsrB,GAAAtrB,EAAA,EAEAurB,EAAAviD,GAAA,SAAA+hD,EAAAO,EAAAH,EAAA,GACAK,EAAAniD,GAAA,UAAA0hD,GAAAO,EAAAH,EAAA,GACAM,EAAAjiD,GAAA,QAAAuhD,EAAAO,EAAAF,EAAA,GACAM,EAAAjiD,GAAA,WAAAshD,GAAAO,EAAAF,EAAA,EAEAG,KAAAC,IACAhiD,EAAAiiD,EACAhiD,EAAAiiD,GAGAD,IAAAC,IACA1iD,EAAAuiD,EACAliD,EAAAmiD,GAIA5pB,EAAA6L,YACA7L,EAAA+mB,UAAApB,EAAA5nB,gBACAiC,EAAA6mB,YAAAlB,EAAA1nB,YACA+B,EAAA8mB,UAAA1oB,CAKA,IAAAirB,KACAjiD,EAAAS,IACAT,EAAAQ,IACAH,EAAAG,IACAH,EAAAI,IAIAkiD,GAAA,+BACAT,EAAAS,EAAAnkD,QAAAujD,EAAA,IACA,IAAAG,IACAA,EAAA,EAQA,IAAAU,GAAAZ,EAAA,EACAppB,GAAA9Y,OAAA8iC,EAAA,GAAAA,EAAA,GAEA,QAAAxoD,GAAA,EAAiBA,EAAA,EAAOA,IACxBwoD,EAAAZ,EAAA5nD,GACAw+B,EAAAoL,OAAA4e,EAAA,GAAAA,EAAA,GAGAhqB,GAAAhC,OACAI,GACA4B,EAAAsM,UAIAnmC,OAAA,WACA,GAAAw/C,GAAA1kD,KAAAkC,KACA,OAAAwiD,GAAAqD,KAAArD,EAAAjiD,GAGAkY,QAAA,SAAA+3B,EAAAC,GACA,GAAAh4B,IAAA,CAEA,IAAA3a,KAAAkC,MAAA,CACA,GAAA8mD,GAAAtB,EAAA1nD,KACA2a,GAAA+3B,GAAAsW,EAAA7iD,MAAAusC,GAAAsW,EAAAxiD,OAAAmsC,GAAAqW,EAAAriD,KAAAgsC,GAAAqW,EAAApiD,OAGA,MAAA+T,IAGA8pC,aAAA,SAAA/R,EAAAC,GACA,GAAA1wC,GAAAjC,IACA,KAAAiC,EAAAC,MACA,QAGA,IACA8mD,GAAAtB,EAAAzlD,EAQA,OANAulD,GAAAvlD,GACAywC,GAAAsW,EAAA7iD,MAAAusC,GAAAsW,EAAAxiD,MAEAmsC,GAAAqW,EAAAriD,KAAAgsC,GAAAqW,EAAApiD,QAMAmW,SAAA,SAAA21B,GACA,GAAAsW,GAAAtB,EAAA1nD,KACA,OAAA0yC,IAAAsW,EAAA7iD,MAAAusC,GAAAsW,EAAAxiD,OAGAwW,SAAA,SAAA21B,GACA,GAAAqW,GAAAtB,EAAA1nD,KACA,OAAA2yC,IAAAqW,EAAAriD,KAAAgsC,GAAAqW,EAAApiD,QAGAwU,eAAA,WACA,GACA5Y,GAAAC,EADAiiD,EAAA1kD,KAAAkC,KAUA,OARAslD,GAAAxnD,OACAwC,EAAAkiD,EAAAliD,EACAC,GAAAiiD,EAAAjiD,EAAAiiD,EAAAqD,MAAA,IAEAvlD,GAAAkiD,EAAAliD,EAAAkiD,EAAAqD,MAAA,EACAtlD,EAAAiiD,EAAAjiD,IAGUD,IAAAC,MAGVka,QAAA,WACA,GAAA+nC,GAAA1kD,KAAAkC,KACA,OAAAwiD,GAAAz/C,MAAAmB,KAAAiD,IAAAq7C,EAAAjiD,EAAAiiD,EAAAqD,OAGAxlD,gBAAA,WACA,GAAAmiD,GAAA1kD,KAAAkC,KACA,QACAM,EAAAkiD,EAAAliD,EACAC,EAAAiiD,EAAAjiD,OvCohQMwmD,KACA,SAAUzqD,EAAQc,GwCruQxBd,EAAAc,SACAge,eAAA,SAAAlZ,GAMA,MALAA,MAAA5E,SAEA4E,IAAA5E,QAGA4E,KAAA8kD,WAAA,exCmvQMC,KACA,SAAU3qD,EAAQc,EAASZ,GAEjC,YyC1tQA,SAAA0qD,GAAA/5C,EAAA+kC,GACA,GAAAl1C,GAAAS,EAAA0zC,SAAAhkC,EAAA+kC,GACArkB,EAAA7wB,KAAAkxB,MAAA,oBACA,OAAAL,GAAA/U,OAAA+U,EAAA,QAAAtgB,GAQA,QAAA45C,GAAA7pD,EAAAqf,GACA,GAAAiH,GAAAtmB,EAAAsmB,MAIAwjC,EAAA9pD,EAAA+pD,aAAA,UACAC,EAAAhqD,EAAA+pD,aAAA,QAoBA,IAjBA/pD,EAAAiqD,IACAC,SACAxkD,OAAAokD,EACArkD,MAAAukD,EACA1jC,OACAwH,QAAAxH,EAAAwH,QACApoB,OAAA4gB,EAAA5gB,OACAD,MAAA6gB,EAAA7gB,SAQA6gB,EAAAwH,QAAAxH,EAAAwH,SAAA,QAEA,OAAAk8B,GAAA,KAAAA,EAAA,CACA,GAAAG,GAAAP,EAAA5pD,EAAA,aACAiQ,KAAAk6C,IACAnqD,EAAAyF,MAAA0kD,GAIA,UAAAL,GAAA,KAAAA,EACA,QAAA9pD,EAAAsmB,MAAA5gB,OAIA1F,EAAA0F,OAAA1F,EAAAyF,OAAA4Z,EAAApf,QAAAmqD,aAAA,OACG,CACH,GAAAC,GAAAT,EAAA5pD,EAAA,cACAiQ,KAAAk6C,IACAnqD,EAAA0F,OAAA2kD,GAKA,MAAArqD,GA2BA,QAAAge,GAAAwG,EAAAnjB,EAAAipD,GACA9lC,EAAAxG,iBAAA3c,EAAAipD,EAAAC,GAGA,QAAAtsC,GAAAuG,EAAAnjB,EAAAipD,GACA9lC,EAAAvG,oBAAA5c,EAAAipD,EAAAC,GAGA,QAAAC,GAAAnpD,EAAAsD,EAAA3B,EAAAC,EAAAwnD,GACA,OACAppD,OACAsD,QACA4V,OAAAkwC,GAAA,KACAznD,MAAAiN,KAAAjN,IAAA,KACAC,MAAAgN,KAAAhN,IAAA,MAIA,QAAAynD,GAAAryB,EAAA1zB,GACA,GAAAtD,GAAAspD,EAAAtyB,EAAAh3B,OAAAg3B,EAAAh3B,KACAupD,EAAAzqD,EAAAka,oBAAAge,EAAA1zB,EACA,OAAA6lD,GAAAnpD,EAAAsD,EAAAimD,EAAA5nD,EAAA4nD,EAAA3nD,EAAAo1B,GAGA,QAAAwyB,GAAAv/C,EAAAE,GACA,GAAAs/C,IAAA,EACAv/C,IAEA,mBACAA,EAAAT,MAAAxI,UAAAiX,MAAAvO,KAAA3I,WACAmJ,KAAAhL,KAEAsqD,IACAA,GAAA,EACA3qD,EAAAuyC,iBAAA1nC,KAAAmP,OAAA,WACA2wC,GAAA,EACAx/C,EAAAlJ,MAAAoJ,EAAAD,OAOA,QAAAw/C,GAAAtwC,GACA,GAAAuwC,GAAA10B,SAAAh3B,cAAA,OACA2rD,EAAAC,EAAA,eAEA5kC,EACA,mHAUA0kC,GAAA1kC,MAAA6kC,QAAA7kC,EACA0kC,EAAAtjC,UAAAujC,EACAD,EAAA1rB,UACA,eAAA2rB,EAAA,mBAAA3kC,EAAA,0GASA2kC,EAAA,mBAAA3kC,EAAA,oFAUA,IAAA8kC,GAAAJ,EAAAK,WAAA,GACAC,EAAAN,EAAAK,WAAA,EAEAL,GAAAO,OAAA,WACAH,EAAAI,WAtCA,IAuCAJ,EAAAK,UAvCA,IAwCAH,EAAAE,WAxCA,IAyCAF,EAAAG,UAzCA,IA2CA,IAAAC,GAAA,WACAV,EAAAO,SACA9wC,IAMA,OAHAuD,GAAAotC,EAAA,SAAAM,EAAA9jC,KAAAwjC,EAAA,WACAptC,EAAAstC,EAAA,SAAAI,EAAA9jC,KAAA0jC,EAAA,WAEAN,EAIA,QAAAW,GAAAnnC,EAAA/J,GACA,GAAAmxC,GAAApnC,EAAAylC,KAAAzlC,EAAAylC,OACA4B,EAAAD,EAAAE,YAAA,SAAAxxC,GACAA,EAAAyxC,gBAAAC,GACAvxC,IAIAta,GAAAsI,KAAAwjD,EAAA,SAAA5qD,GACA2c,EAAAwG,EAAAnjB,EAAAwqD,KAQAD,EAAAM,SAAA1nC,EAAA2nC,aAEA3nC,EAAA4nC,UAAAC,IAAAC,GAGA,QAAAC,GAAA/nC,GACA,GAAAonC,GAAApnC,EAAAylC,OACA4B,EAAAD,EAAAE,WAEAD,KACA1rD,EAAAsI,KAAAwjD,EAAA,SAAA5qD,GACA4c,EAAAuG,EAAAnjB,EAAAwqD,WAGAD,GAAAE,aAGAtnC,EAAA4nC,UAAAI,OAAAF,GAGA,QAAAG,GAAAjoC,EAAA8lC,EAAA3lD,GACA,GAAAinD,GAAApnC,EAAAylC,KAAAzlC,EAAAylC,OAGAe,EAAAY,EAAAZ,QAAAD,EAAAF,EAAA,WACA,GAAAe,EAAAZ,QACA,MAAAV,GAAAE,EAAA,SAAA7lD,MAMAgnD,GAAAnnC,EAAA,WACA,GAAAonC,EAAAZ,QAAA,CACA,GAAA3W,GAAA7vB,EAAA0T,UACAmc,QAAA2W,EAAA9yB,YACAmc,EAAAqY,aAAA1B,EAAA3W,EAAAsY,YAIA3B,EAAAO,YAKA,QAAAqB,GAAApoC,GACA,GAAAonC,GAAApnC,EAAAylC,OACAe,EAAAY,EAAAZ,cAEAY,GAAAZ,QACAuB,EAAA/nC,GAEAwmC,KAAA9yB,YACA8yB,EAAA9yB,WAAAC,YAAA6yB,GAIA,QAAA6B,GAAAtmB,EAAAumB,GAEA,GAAAxmC,GAAAigB,EAAAwmB,QAAAz2B,SAAAh3B,cAAA,QACAinC,GAAAwmB,SACAxmB,EAAAwmB,OAAAzmC,EACAwmC,EAAA,mBAAAA,EACAxmC,EAAA0mC,aAAA,mBACA12B,SAAAkJ,qBAAA,WAAAhI,YAAAlR,IAGAA,EAAAkR,YAAAlB,SAAA22B,eAAAH,IAhTA,GAAA3sD,GAAAjB,EAAA,MAEA+qD,EAAA,WACAiB,EAAA,WACAoB,EAAApB,EAAA,iBACAc,EAAAd,EAAA,mBACAe,GAAA,yCAOAtB,GACAuC,WAAA,YACAC,UAAA,YACAC,SAAA,UACAC,aAAA,aACAC,YAAA,YACAC,YAAA,YACAC,UAAA,UACAC,aAAA,WACAC,WAAA,YA8EAC,EAAA,WACA,GAAAC,IAAA,CACA,KACA,GAAA3tD,GAAAT,OAAAC,kBAAwC,WACxC6N,IAAA,WACAsgD,GAAA,IAGAzzC,QAAA6D,iBAAA,SAAA/d,GACE,MAAAqa,IAGF,MAAAszC,MAKArD,IAAAoD,IAA2DE,SAAA,EA8L3D7uD,GAAAc,SAMA+d,SAAA,oBAAA1D,SAAA,oBAAAmc,UAEAn0B,WAAA,WACA,GAAA2rD,GAAA,iCAEAjB,GAAArsD,KAGA,sBAAAwrD,EAAA,IAAoD8B,EAAA,eACpD9B,EAAA,IAA4C8B,EAAA,KAC5CxB,EAAA,sBACAN,EAAA,qBACAA,EAAA,cAKAluC,eAAA,SAAAlZ,EAAAya,GACA,iBAAAza,GACAA,EAAA0xB,SAAAqO,eAAA//B,GACGA,EAAAnD,SAEHmD,IAAA,IAGAA,KAAA5E,SAEA4E,IAAA5E,OAMA,IAAAitC,GAAAroC,KAAA8kD,YAAA9kD,EAAA8kD,WAAA,KASA,OAAAzc,MAAAjtC,SAAA4E,GACAilD,EAAAjlD,EAAAya,GACA4tB,GAGA,MAGAlvB,eAAA,SAAAkvB,GACA,GAAAjtC,GAAAitC,EAAAjtC,MACA,IAAAA,EAAAiqD,GAAA,CAIA,GAAAC,GAAAlqD,EAAAiqD,GAAAC,SACA,kBAAAhmD,QAAA,SAAAoB,GACA,GAAA5F,GAAAwqD,EAAA5kD,EACAnF,GAAA0K,cAAAnL,GACAM,EAAA+tD,gBAAAzoD,GAEAtF,EAAAgtD,aAAA1nD,EAAA5F,KAIAS,EAAAsI,KAAAyhD,EAAA5jC,UAAkC,SAAA5mB,EAAAuB,GAClCjB,EAAAsmB,MAAArlB,GAAAvB,IAOAM,EAAAyF,MAAAzF,EAAAyF,YAEAzF,GAAAiqD,KAGAjsC,iBAAA,SAAArZ,EAAAtD,EAAAipD,GACA,GAAAtqD,GAAA2E,EAAA3E,MACA,eAAAqB,EAGA,WADAorD,GAAAzsD,EAAAsqD,EAAA3lD,EAIA,IAAAinD,GAAAtB,EAAAL,KAAAK,EAAAL,MAMAjsC,GAAAhe,EAAAqB,GALAuqD,EAAAoC,UAAApC,EAAAoC,aACArpD,EAAAiG,GAAA,IAAAvJ,GAAA,SAAAg3B,GACAiyB,EAAAI,EAAAryB,EAAA1zB,OAMAsZ,oBAAA,SAAAtZ,EAAAtD,EAAAipD,GACA,GAAAtqD,GAAA2E,EAAA3E,MACA,eAAAqB,EAGA,WADAurD,GAAA5sD,EAIA,IAAA4rD,GAAAtB,EAAAL,OACA+D,EAAApC,EAAAoC,YACAnC,EAAAmC,EAAArpD,EAAAiG,GAAA,IAAAvJ,EACAwqD,IAIA5tC,EAAAje,EAAAqB,EAAAwqD,KAeA1rD,EAAAw3B,SAAA3Z,EAWA7d,EAAAq4B,YAAAva,GzCwwQMgwC,KACA,SAAUjvD,EAAQc,EAASZ,GAEjC,Y0ChtRA,IAAAuF,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,UACAy6B,WACAqzB,SAAA,IACAnuD,OAAA,eACAouD,WAAAhuD,EAAAuK,KACA0jD,WAAAjuD,EAAAuK,QAIA1L,EAAAc,QAAA,SAAAw5B,GAEAA,EAAA+0B,UAAArsD,EAAAE,QACAyC,MAAA,KACA2pD,YAAA,EACAC,SAAA,GACAxuD,OAAA,GACA+uB,OAAA,KAEA0/B,oBAAA,KACAC,oBAAA,OAGAn1B,EAAAo1B,kBACAC,cAAA,GACAC,cACAC,WAAA,EACAl6B,QAAA,KAQAm6B,aAAA,SAAAnqD,EAAAk2B,EAAAqzB,EAAAa,GACA,GACAhuD,GAAAC,EADA4tD,EAAApuD,KAAAouD,UASA,KANA/zB,EAAAl2B,QAEAoqD,IACApqD,EAAAqqD,WAAA,GAGAjuD,EAAA,EAAAC,EAAA4tD,EAAAntD,OAAwCV,EAAAC,IAAUD,EAClD,GAAA6tD,EAAA7tD,GAAA4D,UAEA,YADAiqD,EAAA7tD,GAAA85B,EAKA+zB,GAAA7pD,KAAA81B,GAGA,IAAA+zB,EAAAntD,QACAjB,KAAAmyC,yBAIAsc,gBAAA,SAAAtqD,GACA,GAAAO,GAAA/E,EAAAyuC,UAAApuC,KAAAouD,WAAA,SAAA/zB,GACA,MAAAA,GAAAl2B,aAGA,IAAAO,IACA1E,KAAAouD,WAAAxpD,OAAAF,EAAA,GACAP,EAAAqqD,WAAA,IAIArc,sBAAA,WACA,GAAAlwC,GAAAjC,IACA,QAAAiC,EAAAkyB,UAIAlyB,EAAAkyB,QAAAx0B,EAAAuyC,iBAAA1nC,KAAAmP,OAAA,WACA1X,EAAAkyB,QAAA,KACAlyB,EAAAysD,kBAQAA,YAAA,WACA,GAAAzsD,GAAAjC,KACA2uD,EAAAnhC,KAAAohC,MACAC,EAAA,CAEA5sD,GAAAosD,WAAA,IACAQ,EAAAzoD,KAAAkD,MAAArH,EAAAosD,YACApsD,EAAAosD,WAAApsD,EAAAosD,WAAA,GAGApsD,EAAA6sD,QAAA,EAAAD,EAEA,IAAAE,GAAAvhC,KAAAohC,KAEA3sD,GAAAosD,aAAAU,EAAAJ,GAAA1sD,EAAAksD,cAGAlsD,EAAAmsD,WAAAntD,OAAA,GACAgB,EAAAkwC,yBAOA2c,QAAA,SAAA3wC,GAKA,IAJA,GACAkc,GAAAl2B,EADAiqD,EAAApuD,KAAAouD,WAEA7tD,EAAA,EAEAA,EAAA6tD,EAAAntD,QACAo5B,EAAA+zB,EAAA7tD,GACA4D,EAAAk2B,EAAAl2B,MAEAk2B,EAAAyzB,aAAAzzB,EAAAyzB,aAAA,GAAA3vC,EACAkc,EAAAyzB,YAAA1nD,KAAAuD,IAAA0wB,EAAAyzB,YAAAzzB,EAAA0zB,UAEApuD,EAAAkL,SAAAwvB,EAAA/L,QAAAnqB,EAAAk2B,GAAAl2B,GACAxE,EAAAkL,SAAAwvB,EAAA2zB,qBAAA3zB,GAAAl2B,GAEAk2B,EAAAyzB,aAAAzzB,EAAA0zB,UACApuD,EAAAkL,SAAAwvB,EAAA4zB,qBAAA5zB,GAAAl2B,GACAA,EAAAqqD,WAAA,EACAJ,EAAAxpD,OAAArE,EAAA,MAEAA,IAYAvB,OAAAC,eAAA65B,EAAA+0B,UAAA/rD,UAAA,mBACAgL,IAAA,WACA,MAAA9M,SAUAhB,OAAAC,eAAA65B,EAAA+0B,UAAA/rD,UAAA,iBACAgL,IAAA,WACA,MAAA9M,MAAAmE,OAEA6qD,IAAA,SAAA9vD,GACAc,KAAAmE,MAAAjF,O1C6tRM+vD,KACA,SAAUzwD,EAAQc,EAASZ,GAEjC,Y2Cr4RA,IAAAuF,GAAAvF,EAAA,MACAiB,EAAAjB,EAAA,MACAmnC,EAAAnnC,EAAA,MACAonC,EAAApnC,EAAA,MACAqnC,EAAArnC,EAAA,MACAif,EAAAjf,EAAA,KAEAF,GAAAc,QAAA,SAAAw5B,GAeA,QAAAo2B,GAAArwC,GACAA,OAIA,IAAA7R,GAAA6R,EAAA7R,KAAA6R,EAAA7R,QASA,OARAA,GAAAqN,SAAArN,EAAAqN,aACArN,EAAA6uB,OAAA7uB,EAAA6uB,WAEAhd,EAAApf,QAAAE,EAAAguC,YACA1pC,EAAA8a,OACA9a,EAAA4a,EAAAhe,MACAge,EAAApf,aAEAof,EAOA,QAAAswC,GAAAhrD,GACA,GAAAirD,GAAAjrD,EAAA1E,OAEAE,GAAAsI,KAAA9D,EAAAs2B,OAAA,SAAAsT,GACAjI,EAAAthC,UAAAL,EAAA4pC,KAGAqhB,EAAAzvD,EAAAguC,YACA7U,EAAA70B,SAAA8a,OACA+Z,EAAA70B,SAAAE,EAAA0a,OAAAhe,MACAuuD,GAEAjrD,EAAA1E,QAAA0E,EAAA0a,OAAApf,QAAA2vD,EACAjrD,EAAAkrD,sBACAlrD,EAAAmrD,sBAEAnrD,EAAAm7B,QAAAiwB,SAAAH,EAAA90B,SACAn2B,EAAAm7B,QAAA39B,aAGA,QAAA6tD,GAAAnsD,GACA,cAAAA,GAAA,WAAAA,EAtDAy1B,EAAA22B,SAIA32B,EAAA42B,aAGA52B,EAAA62B,eAkDAhwD,EAAA+B,OAAAo3B,EAAAh3B,WAIAwlC,UAAA,SAAAljC,EAAAya,GACA,GAAA5c,GAAAjC,IAEA6e,GAAAqwC,EAAArwC,EAEA,IAAA4tB,GAAA1G,EAAAzoB,eAAAlZ,EAAAya,GACArf,EAAAitC,KAAAjtC,OACA0F,EAAA1F,KAAA0F,OACAD,EAAAzF,KAAAyF,KAoCA,IAlCAhD,EAAAmI,GAAAzK,EAAAwK,MACAlI,EAAA88B,IAAA0N,EACAxqC,EAAAzC,SACAyC,EAAA4c,SACA5c,EAAAgD,QACAhD,EAAAiD,SACAjD,EAAA2nD,YAAA1kD,EAAAD,EAAAC,EAAA,KACAjD,EAAAxC,QAAAof,EAAApf,QACAwC,EAAA2tD,iBAAA,EAUA3tD,EAAAkC,MAAAlC,EACAA,EAAA4tD,WAAA5tD,EAGA62B,EAAA42B,UAAAztD,EAAAmI,IAAAnI,EAGAjD,OAAAC,eAAAgD,EAAA,QACA6K,IAAA,WACA,MAAA7K,GAAA4c,OAAA7R,MAEAgiD,IAAA,SAAA9vD,GACA+C,EAAA4c,OAAA7R,KAAA9N,MAIAutC,IAAAjtC,EAMA,WADAwZ,SAAAtI,MAAA,oEAIAzO,GAAAN,aACAM,EAAA+C,UAMArD,WAAA,WACA,GAAAM,GAAAjC,IAsBA,OAnBA2d,GAAAU,OAAApc,EAAA,cAEAtC,EAAA40C,YAAAtyC,IAAAxC,QAAAi1C,kBAEAzyC,EAAA6tD,aAEA7tD,EAAAxC,QAAAgnC,YAEAxkC,EAAAugC,QAAA,GAIAvgC,EAAAotD,sBACAptD,EAAAqtD,sBACArtD,EAAA8tD,cAGApyC,EAAAU,OAAApc,EAAA,aAEAA,GAGAic,MAAA,WAEA,MADAve,GAAAH,OAAA0e,MAAAle,MACAA,MAGAgwD,KAAA,WAGA,MADAl3B,GAAAo1B,iBAAAO,gBAAAzuD,MACAA,MAGAwiC,OAAA,SAAAytB,GACA,GAAAhuD,GAAAjC,KACAP,EAAAwC,EAAAxC,QACAD,EAAAyC,EAAAzC,OACAoqD,EAAAnqD,EAAA26B,qBAAAn4B,EAAA2nD,aAAA,KAMAsG,EAAA9pD,KAAAC,IAAA,EAAAD,KAAAkD,MAAA3J,EAAAi0C,gBAAAp0C,KACA2wD,EAAA/pD,KAAAC,IAAA,EAAAD,KAAAkD,MAAAsgD,EAAAsG,EAAAtG,EAAAjqD,EAAAo0C,iBAAAv0C,IAEA,KAAAyC,EAAAgD,QAAAirD,GAAAjuD,EAAAiD,SAAAirD,KAIA3wD,EAAAyF,MAAAhD,EAAAgD,MAAAirD,EACA1wD,EAAA0F,OAAAjD,EAAAiD,OAAAirD,EACA3wD,EAAAsmB,MAAA7gB,MAAAirD,EAAA,KACA1wD,EAAAsmB,MAAA5gB,OAAAirD,EAAA,KAEAxwD,EAAA40C,YAAAtyC,EAAAxC,EAAAi1C,mBAEAub,GAAA,CAEA,GAAAG,IAAmBnrD,MAAAirD,EAAAhrD,OAAAirD,EACnBxyC,GAAAU,OAAApc,EAAA,UAAAmuD,IAGAnuD,EAAAxC,QAAA4wD,UACApuD,EAAAxC,QAAA4wD,SAAApuD,EAAAmuD,GAGAnuD,EAAA+tD,OACA/tD,EAAA+C,OAAA/C,EAAAxC,QAAAinC,+BAIA2oB,oBAAA,WACA,GAAA5vD,GAAAO,KAAAP,QACA6wD,EAAA7wD,EAAAg7B,WACA81B,EAAA9wD,EAAAsuC,KAEApuC,GAAAsI,KAAAqoD,EAAAz1B,MAAA,SAAA21B,EAAA9rD,GACA8rD,EAAApmD,GAAAomD,EAAApmD,IAAA,UAAA1F,IAGA/E,EAAAsI,KAAAqoD,EAAA51B,MAAA,SAAA+1B,EAAA/rD,GACA+rD,EAAArmD,GAAAqmD,EAAArmD,IAAA,UAAA1F,IAGA6rD,IACAA,EAAAnmD,GAAAmmD,EAAAnmD,IAAA,UAOAklD,oBAAA,WACA,GAAArtD,GAAAjC,KACAP,EAAAwC,EAAAxC,QACAg7B,EAAAx4B,EAAAw4B,WACAzqB,KACA0gD,EAAA1xD,OAAAgC,KAAAy5B,GAAAoU,OAAA,SAAA76B,EAAA5J,GAEA,MADA4J,GAAA5J,IAAA,EACA4J,MAGAvU,GAAAg7B,SACAzqB,IAAA9H,QACAzI,EAAAg7B,OAAAI,WAAAtvB,IAAA,SAAAilD,GACA,OAAc/wD,QAAA+wD,EAAAG,MAAA,WAAAC,UAAA,aAEdnxD,EAAAg7B,OAAAC,WAAAnvB,IAAA,SAAAklD,GACA,OAAchxD,QAAAgxD,EAAAE,MAAA,SAAAC,UAAA,YAKdnxD,EAAAsuC,OACA/9B,EAAAzL,MACA9E,UAAAsuC,MACA4iB,MAAA,eACAE,WAAA,EACAD,UAAA,cAIAjxD,EAAAsI,KAAA+H,EAAA,SAAA5L,GACA,GAAAmsD,GAAAnsD,EAAA3E,QACA2K,EAAAmmD,EAAAnmD,GACA0mD,EAAAnxD,EAAA+K,eAAA6lD,EAAA1vD,KAAAuD,EAAAusD,MAEAnB,GAAAe,EAAAltD,YAAAmsD,EAAAprD,EAAAwsD,aACAL,EAAAltD,SAAAe,EAAAwsD,WAGAF,EAAAtmD,IAAA,CACA,IAAA2jC,GAAA,IACA,IAAA3jC,IAAAqwB,MAAArwB,GAAAvJ,OAAAiwD,EACA/iB,EAAAtT,EAAArwB,GACA2jC,EAAAtuC,QAAA8wD,EACAxiB,EAAAhP,IAAA98B,EAAA88B,IACAgP,EAAA5pC,MAAAlC,MACK,CACL,GAAA8uD,GAAAj4B,EAAA+U,aAAAmjB,oBAAAF,EACA,KAAAC,EACA,MAEAhjB,GAAA,GAAAgjB,IACA3mD,KACAvJ,KAAAiwD,EACArxD,QAAA8wD,EACAxxB,IAAA98B,EAAA88B,IACA56B,MAAAlC,IAEAw4B,EAAAsT,EAAA3jC,IAAA2jC,EAGAA,EAAAkjB,oBAKA7sD,EAAAysD,YACA5uD,EAAA8rC,WAIApuC,EAAAsI,KAAAyoD,EAAA,SAAAQ,EAAA9mD,GACA8mD,SACAz2B,GAAArwB,KAIAnI,EAAAw4B,SAEA3B,EAAA+U,aAAAsjB,kBAAAnxD,OAGAoxD,yBAAA,WACA,GAAAnvD,GAAAjC,KACAyvD,KACA4B,IA4BA,OA1BA1xD,GAAAsI,KAAAhG,EAAA+K,KAAAqN,SAAA,SAAA2B,EAAAC,GACA,GAAA/B,GAAAjY,EAAAsY,eAAA0B,GACApb,EAAAmb,EAAAnb,MAAAoB,EAAA4c,OAAAhe,IAUA,IARAqZ,EAAArZ,MAAAqZ,EAAArZ,WACAoB,EAAAqvD,mBAAAr1C,GACA/B,EAAAjY,EAAAsY,eAAA0B,IAEA/B,EAAArZ,OAEA4uD,EAAAlrD,KAAA2V,EAAArZ,MAEAqZ,EAAA21C,WACA31C,EAAA21C,WAAA0B,YAAAt1C,GACA/B,EAAA21C,WAAA2B,iBACK,CACL,GAAAC,GAAA34B,EAAA62B,YAAAz1C,EAAArZ,KACA,QAAA4O,KAAAgiD,EACA,SAAAh5B,OAAA,IAAAve,EAAArZ,KAAA,yBAGAqZ,GAAA21C,WAAA,GAAA4B,GAAAxvD,EAAAga,GACAo1C,EAAA9sD,KAAA2V,EAAA21C,cAEI5tD,GAEJovD,GAOAK,cAAA,WACA,GAAAzvD,GAAAjC,IACAL,GAAAsI,KAAAhG,EAAA+K,KAAAqN,SAAA,SAAA2B,EAAAC,GACAha,EAAAsY,eAAA0B,GAAA4zC,WAAA8B,SACI1vD,IAMJ0vD,MAAA,WACA3xD,KAAA0xD,gBACA1xD,KAAAs/B,QAAA39B,cAGAqD,OAAA,SAAA6Z,GACA,GAAA5c,GAAAjC,IAgBA,IAdA6e,GAAA,iBAAAA,KAEAA,GACA6uC,SAAA7uC,EACA0vC,KAAA1sD,UAAA,KAIAstD,EAAAltD,GAIA0b,EAAAqB,YAAA/c,IAEA,IAAA0b,EAAAU,OAAApc,EAAA,iBAKAA,EAAAq9B,QAAAsyB,MAAA3vD,EAAA+K,IAGA,IAAAqkD,GAAApvD,EAAAmvD,0BAGAzxD,GAAAsI,KAAAhG,EAAA+K,KAAAqN,SAAA,SAAA2B,EAAAC,GACAha,EAAAsY,eAAA0B,GAAA4zC,WAAAgC,yBACI5vD,GAEJA,EAAA6vD,eAGA7vD,EAAAxC,QAAA46B,WAAAp4B,EAAAxC,QAAA46B,UAAAqzB,UACA/tD,EAAAsI,KAAAopD,EAAA,SAAAxB,GACAA,EAAA8B,UAIA1vD,EAAA8vD,iBAIA9vD,EAAAq9B,QAAA39B,aAIAM,EAAA+vD,cAGAr0C,EAAAU,OAAApc,EAAA,eAEAA,EAAA2tD,gBACA3tD,EAAAgwD,kBACAvE,SAAA7uC,EAAA6uC,SACAnuD,OAAAsf,EAAAtf,OACAgvD,KAAA1vC,EAAA0vC,MAGAtsD,EAAAqsB,OAAAzP,KASAizC,aAAA,WACA,GAAA7vD,GAAAjC,MAEA,IAAA2d,EAAAU,OAAApc,EAAA,kBAIA6jC,EAAA9gC,OAAAhF,UAAAiF,MAAAjF,KAAAkF,QASAyY,EAAAU,OAAApc,EAAA,oBACA0b,EAAAU,OAAApc,EAAA,iBAQA8vD,eAAA,WACA,GAAA9vD,GAAAjC,IAEA,SAAA2d,EAAAU,OAAApc,EAAA,yBAIA,OAAA1B,GAAA,EAAAC,EAAAyB,EAAA+K,KAAAqN,SAAApZ,OAAkDV,EAAAC,IAAUD,EAC5D0B,EAAAiwD,cAAA3xD,EAGAod,GAAAU,OAAApc,EAAA,yBAQAiwD,cAAA,SAAAxtD,GACA,GAAAzC,GAAAjC,KACAka,EAAAjY,EAAAsY,eAAA7V,GACAqG,GACAmP,OACAxV,UAGA,IAAAiZ,EAAAU,OAAApc,EAAA,uBAAA8I,MAIAmP,EAAA21C,WAAA7qD,SAEA2Y,EAAAU,OAAApc,EAAA,sBAAA8I,MAGAujB,OAAA,SAAAzP,GACA,GAAA5c,GAAAjC,IAEA6e,IAAA,iBAAAA,KAEAA,GACA6uC,SAAA7uC,EACA0vC,KAAA1sD,UAAA,IAIA,IAAA6rD,GAAA7uC,EAAA6uC,SACAa,EAAA1vC,EAAA0vC,IAEA,SAAA5wC,EAAAU,OAAApc,EAAA,iBAIA,GAAAkwD,GAAAlwD,EAAAxC,QAAA46B,UACAuzB,EAAA,SAAAvzB,GACA1c,EAAAU,OAAApc,EAAA,eACAtC,EAAAkL,SAAAsnD,KAAAvE,YAAAvzB,GAAAp4B,GAGA,IAAAkwD,IAAA,oBAAAzE,IAAA,IAAAA,GAAA,oBAAAA,IAAA,IAAAyE,EAAAzE,UAAA,CACA,GAAArzB,GAAA,GAAAvB,GAAA+0B,WACAE,UAAAL,GAAAyE,EAAAzE,UAAA,MACAnuD,OAAAsf,EAAAtf,QAAA4yD,EAAA5yD,OAEA+uB,OAAA,SAAAnqB,EAAAiuD,GACA,GAAAC,GAAA1yD,EAAAJ,OAAAioC,QAAA4qB,EAAA7yD,QACAuuD,EAAAsE,EAAAtE,YACAwE,EAAAxE,EAAAsE,EAAArE,QAEA5pD,GAAAm/B,KAAA+uB,EAAAC,KAAAxE,IAGAE,oBAAAmE,EAAAxE,WACAM,oBAAAL,GAGA90B,GAAAo1B,iBAAAI,aAAArsD,EAAAo4B,EAAAqzB,EAAAa,OAEAtsD,GAAAqhC,OAGAsqB,EAAA,GAAA90B,GAAA+0B,WAAoCE,SAAA,EAAA5pD,MAAAlC,IAGpC,OAAAA,KAGAqhC,KAAA,SAAAivB,GACA,GAAAtwD,GAAAjC,IAEAiC,GAAAic,QAEAve,EAAA0K,cAAAkoD,KACAA,EAAA,GAGAtwD,EAAAK,WAAAiwD,IAEA,IAAA50C,EAAAU,OAAApc,EAAA,cAAAswD,MAKA5yD,EAAAsI,KAAAhG,EAAAoC,MAAA,SAAAe,GACAA,EAAAk+B,KAAArhC,EAAA4G,YACI5G,GAEJA,EAAA8rC,OACA9rC,EAAA8rC,MAAAzK,OAGArhC,EAAAuwD,aAAAD,GACAtwD,EAAAwwD,aAAAF,GAEA50C,EAAAU,OAAApc,EAAA,aAAAswD,MAMAjwD,WAAA,SAAAiwD,GAGA,OAFAtwD,GAAAjC,KAEAO,EAAA,EAAAC,GAAAyB,EAAA+K,KAAAqN,cAAApZ,OAA0DV,EAAAC,IAAUD,EACpE0B,EAAAqY,iBAAA/Z,IACA0B,EAAAsY,eAAAha,GAAAsvD,WAAAvtD,WAAAiwD,EAIAtwD,GAAAq9B,QAAAh9B,WAAAiwD,IAQAC,aAAA,SAAAD,GACA,GAAAtwD,GAAAjC,IAEA,SAAA2d,EAAAU,OAAApc,EAAA,sBAAAswD,IAAA,CAKA,OAAAhyD,IAAA0B,EAAA+K,KAAAqN,cAAApZ,OAAA,EAAoDV,GAAA,IAAQA,EAC5D0B,EAAAqY,iBAAA/Z,IACA0B,EAAAywD,YAAAnyD,EAAAgyD,EAIA50C,GAAAU,OAAApc,EAAA,qBAAAswD,MAQAG,YAAA,SAAAhuD,EAAA6tD,GACA,GAAAtwD,GAAAjC,KACAka,EAAAjY,EAAAsY,eAAA7V,GACAqG,GACAmP,OACAxV,QACA6tD,gBAGA,IAAA50C,EAAAU,OAAApc,EAAA,qBAAA8I,MAIAmP,EAAA21C,WAAAvsB,KAAAivB,GAEA50C,EAAAU,OAAApc,EAAA,oBAAA8I,MAQA0nD,aAAA,SAAAF,GACA,GAAAtwD,GAAAjC,KACAs/B,EAAAr9B,EAAAq9B,QACAv0B,GACAu0B,UACAizB,gBAGA,IAAA50C,EAAAU,OAAApc,EAAA,qBAAA8I,MAIAu0B,EAAAgE,OAEA3lB,EAAAU,OAAApc,EAAA,oBAAA8I,MAKA4nD,kBAAA,SAAA74C,GACA,MAAA+rB,GAAA1pB,MAAAC,OAAApc,KAAA8Z,IAGA84C,mBAAA,SAAA94C,GACA,MAAA+rB,GAAA1pB,MAAAE,MAAArc,KAAA8Z,GAA4Ce,WAAA,KAG5Cg4C,mBAAA,SAAA/4C,GACA,MAAA+rB,GAAA1pB,MAAA,UAAAnc,KAAA8Z,GAAgDe,WAAA,KAGhDi4C,0BAAA,SAAAh5C,EAAAgtB,EAAArnC,GACA,GAAAgf,GAAAonB,EAAA1pB,MAAA2qB,EACA,0BAAAroB,GACAA,EAAAze,KAAA8Z,EAAAra,OAMAszD,kBAAA,SAAAj5C,GACA,MAAA+rB,GAAA1pB,MAAAH,QAAAhc,KAAA8Z,GAA8Ce,WAAA,KAG9CN,eAAA,SAAA0B,GACA,GAAAha,GAAAjC,KACAgc,EAAA/Z,EAAA+K,KAAAqN,SAAA4B,EACAD,GAAAg3C,QACAh3C,EAAAg3C,SAGA,IAAA94C,GAAA8B,EAAAg3C,MAAA/wD,EAAAmI,GAaA,OAZA8P,KACAA,EAAA8B,EAAAg3C,MAAA/wD,EAAAmI,KACAvJ,KAAA,KACAmM,QACAgP,QAAA,KACA6zC,WAAA,KACA9tD,OAAA,KACAkxD,QAAA,KACAC,QAAA,OAIAh5C,GAGAi5C,uBAAA,WAEA,OADAh1C,GAAA,EACA5d,EAAA,EAAAC,EAAAR,KAAAgN,KAAAqN,SAAApZ,OAAoDV,EAAAC,IAAUD,EAC9DP,KAAAsa,iBAAA/Z,IACA4d,GAGA,OAAAA,IAGA7D,iBAAA,SAAA2B,GACA,GAAA/B,GAAAla,KAAAua,eAAA0B,EAIA,yBAAA/B,GAAAnY,QAAAmY,EAAAnY,QAAA/B,KAAAgN,KAAAqN,SAAA4B,GAAAla,QAGAqxD,eAAA,WACA,MAAApzD,MAAAP,QAAA4zD,eAAArzD,OAMAsxD,mBAAA,SAAAr1C,GACA,GAAA7R,GAAApK,KAAAoK,GACA4R,EAAAhc,KAAAgN,KAAAqN,SAAA4B,GACA/B,EAAA8B,EAAAg3C,OAAAh3C,EAAAg3C,MAAA5oD,EAEA8P,KACAA,EAAA21C,WAAAhxB,gBACA7iB,GAAAg3C,MAAA5oD,KAIAy0B,QAAA,WACA,GAEAt+B,GAAAC,EAFAyB,EAAAjC,KACAR,EAAAyC,EAAAzC,MAMA,KAHAyC,EAAA+tD,OAGAzvD,EAAA,EAAAC,EAAAyB,EAAA+K,KAAAqN,SAAApZ,OAA8CV,EAAAC,IAAUD,EACxD0B,EAAAqvD,mBAAA/wD,EAGAf,KACAyC,EAAAqxD,eACA3zD,EAAAH,OAAA0e,MAAAjc,GACA8jC,EAAAxoB,eAAAtb,EAAA88B,KACA98B,EAAAzC,OAAA,KACAyC,EAAA88B,IAAA,MAGAphB,EAAAU,OAAApc,EAAA,iBAEA62B,GAAA42B,UAAAztD,EAAAmI,KAGAk7B,cAAA,WACA,MAAAtlC,MAAAR,OAAA+zD,UAAA3xD,MAAA5B,KAAAR,OAAAqC,YAGAkuD,YAAA,WACA,GAAA9tD,GAAAjC,IACAiC,GAAAq9B,QAAA,GAAAxG,GAAA06B,SACA/N,OAAAxjD,EACAwxD,eAAAxxD,EACA2vD,MAAA3vD,EAAA+K,KACAuiD,SAAAttD,EAAAxC,QAAA66B,UACIr4B,IAMJ6tD,WAAA,WACA,GAAA7tD,GAAAjC,KACA0zD,EAAAzxD,EAAA0xD,cACA7J,EAAA,WACA7nD,EAAA2xD,aAAAhyD,MAAAK,EAAAJ,WAGAlC,GAAAsI,KAAAhG,EAAAxC,QAAAknC,OAAA,SAAA9lC,GACAklC,EAAAvoB,iBAAAvb,EAAApB,EAAAipD,GACA4J,EAAA7yD,GAAAipD,IAKA7nD,EAAAxC,QAAAgnC,aACAqjB,EAAA,WACA7nD,EAAAugC,UAGAuD,EAAAvoB,iBAAAvb,EAAA,SAAA6nD,GACA4J,EAAAlxB,OAAAsnB,IAOAwJ,aAAA,WACA,GAAArxD,GAAAjC,KACA0zD,EAAAzxD,EAAA0xD,UACAD,WAIAzxD,GAAA0xD,WACAh0D,EAAAsI,KAAAyrD,EAAA,SAAA5J,EAAAjpD,GACAklC,EAAAtoB,oBAAAxb,EAAApB,EAAAipD,OAIA+J,iBAAA,SAAAn5C,EAAAosB,EAAAzH,GACA,GACAhwB,GAAA9O,EAAAC,EADAie,EAAA4gB,EAAA,kCAGA,KAAA9+B,EAAA,EAAAC,EAAAka,EAAAzZ,OAAsCV,EAAAC,IAAUD,GAChD8O,EAAAqL,EAAAna,KAEAP,KAAAua,eAAAlL,EAAAiN,eAAAuzC,WAAApxC,GAAApP,IAQAukD,aAAA,SAAA95C,GACA,GAAA7X,GAAAjC,KACAs/B,EAAAr9B,EAAAq9B,OAEA,SAAA3hB,EAAAU,OAAApc,EAAA,eAAA6X,IAAA,CAKA7X,EAAA2tD,iBAAA,EACA3tD,EAAAgwD,iBAAA,IAEA,IAAA6B,GAAA7xD,EAAA8xD,YAAAj6C,EAKAwlB,KACAw0B,EAAAx0B,EAAAj9B,OACAi9B,EAAAy0B,YAAAj6C,GACAg6C,EAAAx0B,EAAAy0B,YAAAj6C,IAGA6D,EAAAU,OAAApc,EAAA,cAAA6X,GAEA,IAAAk6C,GAAA/xD,EAAAgwD,gBAgBA,OAfA+B,GAEA/xD,EAAAqsB,OAAA0lC,GACIF,IAAA7xD,EAAAusD,YAEJvsD,EAAA+tD,OAIA/tD,EAAAqsB,OAAArsB,EAAAxC,QAAAmnC,MAAAG,mBAAA,IAGA9kC,EAAA2tD,iBAAA,EACA3tD,EAAAgwD,iBAAA,KAEAhwD,IASA8xD,YAAA,SAAAj6C,GACA,GAAA7X,GAAAjC,KACAP,EAAAwC,EAAAxC,YACAw0D,EAAAx0D,EAAAmnC,MACAktB,GAAA,CAqCA,OAnCA7xD,GAAA+vD,WAAA/vD,EAAA+vD,eAGA,aAAAl4C,EAAAjZ,KACAoB,EAAAiyD,UAEAjyD,EAAAiyD,OAAAjyD,EAAA6wD,0BAAAh5C,EAAAm6C,EAAAntB,KAAAmtB,GAKAt0D,EAAAkL,SAAApL,EAAAonC,SAAApnC,EAAAmnC,MAAAC,SAAA/sB,EAAAC,OAAA9X,EAAAiyD,QAAAjyD,GAEA,YAAA6X,EAAAjZ,MAAA,UAAAiZ,EAAAjZ,MACApB,EAAA0nB,SAEA1nB,EAAA0nB,QAAA3c,KAAAvI,EAAA6X,EAAAC,OAAA9X,EAAAiyD,QAKAjyD,EAAA+vD,WAAA/wD,QACAgB,EAAA4xD,iBAAA5xD,EAAA+vD,WAAAiC,EAAAntB,MAAA,GAIA7kC,EAAAiyD,OAAAjzD,QAAAgzD,EAAAntB,MACA7kC,EAAA4xD,iBAAA5xD,EAAAiyD,OAAAD,EAAAntB,MAAA,GAGAgtB,GAAAn0D,EAAAwL,YAAAlJ,EAAAiyD,OAAAjyD,EAAA+vD,YAGA/vD,EAAA+vD,WAAA/vD,EAAAiyD,OAEAJ,KAWAh7B,EAAAq7B,WAAAr7B,I3C84RMs7B,KACA,SAAU51D,EAAQc,EAASZ,GAEjC,Y4Ch0TA,IAAAiB,GAAAjB,EAAA,KAEAF,GAAAc,QAAA,SAAAw5B,GASA,QAAAu7B,GAAAjxD,EAAA0mD,GACA,GAAA1mD,EAAAkxD,SAEA,WADAlxD,GAAAkxD,SAAAZ,UAAAnvD,KAAAulD,EAIA9qD,QAAAC,eAAAmE,EAAA,YACAof,cAAA,EACAF,YAAA,EACApjB,OACAw0D,WAAA5J,MAIAyK,EAAA7wD,QAAA,SAAAjD,GACA,GAAAge,GAAA,SAAAhe,EAAA4Y,OAAA,GAAAirC,cAAA7jD,EAAAsY,MAAA,GACAgvC,EAAA3kD,EAAA3C,EAEAzB,QAAAC,eAAAmE,EAAA3C,GACA+hB,cAAA,EACAF,YAAA,EACApjB,MAAA,WACA,GAAA6L,GAAAT,MAAAxI,UAAAiX,MAAAvO,KAAA3I,WACA2yD,EAAAzM,EAAAnmD,MAAA5B,KAAA+K,EAQA,OANApL,GAAAsI,KAAA7E,EAAAkxD,SAAAZ,UAAA,SAAAe,GACA,mBAAAA,GAAAh2C,IACAg2C,EAAAh2C,GAAA7c,MAAA6yD,EAAA1pD,KAIAypD,OAUA,QAAAE,GAAAtxD,EAAA0mD,GACA,GAAA6K,GAAAvxD,EAAAkxD,QACA,IAAAK,EAAA,CAIA,GAAAjB,GAAAiB,EAAAjB,UACAhvD,EAAAgvD,EAAA/uD,QAAAmlD,IACA,IAAAplD,GACAgvD,EAAA9uD,OAAAF,EAAA,GAGAgvD,EAAAzyD,OAAA,IAIAszD,EAAA7wD,QAAA,SAAAjD,SACA2C,GAAA3C,WAGA2C,GAAAkxD,WApEA,GAAAC,IAAA,wCAwEAz7B,GAAA87B,kBAAA,SAAAzwD,EAAA8X,GACAjc,KAAA2B,WAAAwC,EAAA8X,IAGAtc,EAAA+B,OAAAo3B,EAAA87B,kBAAA9yD,WAMA+yD,mBAAA,KAMAC,gBAAA,KAEAnzD,WAAA,SAAAwC,EAAA8X,GACA,GAAAha,GAAAjC,IACAiC,GAAAkC,QACAlC,EAAAyC,MAAAuX,EACAha,EAAAuvD,aACAvvD,EAAA8yD,eAGAxD,YAAA,SAAAt1C,GACAjc,KAAA0E,MAAAuX,GAGAu1C,WAAA,WACA,GAAAvvD,GAAAjC,KACAka,EAAAjY,EAAA+yD,UACAh5C,EAAA/Z,EAAAgzD,YAEA,QAAA/6C,EAAA+4C,SAAA/4C,EAAA+4C,UAAAhxD,GAAAkC,MAAAs2B,SACAvgB,EAAA+4C,QAAAj3C,EAAAi3C,SAAAhxD,EAAAkC,MAAA1E,QAAAg7B,OAAAI,MAAA,GAAAzwB,IAEA,OAAA8P,EAAAg5C,SAAAh5C,EAAAg5C,UAAAjxD,GAAAkC,MAAAs2B,SACAvgB,EAAAg5C,QAAAl3C,EAAAk3C,SAAAjxD,EAAAkC,MAAA1E,QAAAg7B,OAAAC,MAAA,GAAAtwB,KAIA6qD,WAAA,WACA,MAAAj1D,MAAAmE,MAAA6I,KAAAqN,SAAAra,KAAA0E,QAGAswD,QAAA,WACA,MAAAh1D,MAAAmE,MAAAoW,eAAAva,KAAA0E,QAGAwwD,cAAA,SAAAC,GACA,MAAAn1D,MAAAmE,MAAAs2B,OAAA06B,IAGAxD,MAAA,WACA3xD,KAAAgF,QAAA,IAMA65B,QAAA,WACA7+B,KAAA4xD,OACA8C,EAAA10D,KAAA4xD,MAAA5xD,OAIAo1D,kBAAA,WACA,GAAAnzD,GAAAjC,KACAa,EAAAoB,EAAA4yD,kBACA,OAAAh0D,IAAA,GAAAA,IACA4kD,OAAAxjD,EAAAkC,MACAmY,cAAAra,EAAAyC,SAIA2wD,eAAA,SAAA3wD,GACA,GAAAzC,GAAAjC,KACAa,EAAAoB,EAAA6yD,eACA,OAAAj0D,IAAA,GAAAA,IACA4kD,OAAAxjD,EAAAkC,MACAmY,cAAAra,EAAAyC,MACAwX,OAAAxX,KAIAqwD,YAAA,WACA,GAIAx0D,GAAAC,EAJAyB,EAAAjC,KACAka,EAAAjY,EAAA+yD,UACAhoD,EAAA/K,EAAAgzD,aAAAjoD,SACAsoD,EAAAp7C,EAAAlN,IAGA,KAAAzM,EAAA,EAAAC,EAAAwM,EAAA/L,OAAkCV,EAAAC,IAAUD,EAC5C+0D,EAAA/0D,GAAA+0D,EAAA/0D,IAAA0B,EAAAozD,eAAA90D,EAGA2Z,GAAA8B,QAAA9B,EAAA8B,SAAA/Z,EAAAmzD,qBAGAG,mBAAA,SAAA7wD,GACA,GAAA2K,GAAArP,KAAAq1D,eAAA3wD,EACA1E,MAAAg1D,UAAAhoD,KAAApI,OAAAF,EAAA,EAAA2K,GACArP,KAAAw1D,cAAAnmD,EAAA3K,GAAA,IAGAmtD,sBAAA,WACA,GAAA5vD,GAAAjC,KACAgc,EAAA/Z,EAAAgzD,aACAjoD,EAAAgP,EAAAhP,OAAAgP,EAAAhP,QAKA/K,GAAA2vD,QAAA5kD,IACA/K,EAAA2vD,OAEA8C,EAAAzyD,EAAA2vD,MAAA3vD,GAGAoyD,EAAArnD,EAAA/K,GACAA,EAAA2vD,MAAA5kD,GAKA/K,EAAAwzD,kBAGAzwD,OAAArF,EAAAuK,KAEA5H,WAAA,SAAAiwD,GAMA,IALA,GAAAr4C,GAAAla,KAAAg1D,UACAt6C,EAAAR,EAAAlN,SACAxM,EAAAka,EAAAzZ,OACAV,EAAA,EAESA,EAAAC,IAAUD,EACnBma,EAAAna,GAAA+B,WAAAiwD,EAGAr4C,GAAA8B,SACA9B,EAAA8B,QAAA1Z,WAAAiwD,IAIAjvB,KAAA,WACA,GAAAppB,GAAAla,KAAAg1D,UACAt6C,EAAAR,EAAAlN,SACAxM,EAAAka,EAAAzZ,OACAV,EAAA,CAMA,KAJA2Z,EAAA8B,SACA9B,EAAA8B,QAAAsnB,OAGS/iC,EAAAC,IAAUD,EACnBma,EAAAna,GAAA+iC,QAIAoyB,iBAAA,SAAArmD,EAAAsmD,GACA,GAAA35C,GAAAhc,KAAAmE,MAAA6I,KAAAqN,SAAAhL,EAAAiN,eACA5X,EAAA2K,EAAA6M,OACA05C,EAAAvmD,EAAAumD,WACAlrD,EAAA/K,EAAAiL,sBACAvK,EAAAgP,EAAAjN,MAEA/B,GAAAy8B,gBAAA84B,EAAA94B,gBAAA84B,EAAA94B,gBAAApyB,EAAAsR,EAAA8gB,gBAAAp4B,EAAAixD,EAAA74B,iBACAz8B,EAAA28B,YAAA44B,EAAA54B,YAAA44B,EAAA54B,YAAAtyB,EAAAsR,EAAAghB,YAAAt4B,EAAAixD,EAAA34B,aACA38B,EAAA88B,YAAAy4B,EAAAz4B,YAAAy4B,EAAAz4B,YAAAzyB,EAAAsR,EAAAmhB,YAAAz4B,EAAAixD,EAAAx4B,cAGA04B,cAAA,SAAAxmD,GACA,GAAA2M,GAAAhc,KAAAmE,MAAA6I,KAAAqN,SAAAhL,EAAAiN,eACA5X,EAAA2K,EAAA6M,OACA05C,EAAAvmD,EAAAumD,WACAlrD,EAAA/K,EAAAiL,sBACAgrC,EAAAj2C,EAAAi2C,cACAv1C,EAAAgP,EAAAjN,MAEA/B,GAAAy8B,gBAAA84B,EAAAE,qBAAAF,EAAAE,qBAAAprD,EAAAsR,EAAA85C,qBAAApxD,EAAAkxC,EAAAv1C,EAAAy8B,kBACAz8B,EAAA28B,YAAA44B,EAAAG,iBAAAH,EAAAG,iBAAArrD,EAAAsR,EAAA+5C,iBAAArxD,EAAAkxC,EAAAv1C,EAAA28B,cACA38B,EAAA88B,YAAAy4B,EAAAtO,iBAAAsO,EAAAtO,iBAAA58C,EAAAsR,EAAAsrC,iBAAA5iD,EAAArE,EAAA88B,cAMAs4B,eAAA,WACA,GAAAxzD,GAAAjC,KACAka,EAAAjY,EAAA+yD,UACAhoD,EAAA/K,EAAAgzD,aAAAjoD,KACAgpD,EAAA97C,EAAAlN,KAAA/L,OACAg1D,EAAAjpD,EAAA/L,MAEAg1D,GAAAD,EACA97C,EAAAlN,KAAApI,OAAAqxD,EAAAD,EAAAC,GACIA,EAAAD,GACJ/zD,EAAAi0D,eAAAF,EAAAC,EAAAD,IAOAE,eAAA,SAAA/1D,EAAAge,GACA,OAAA5d,GAAA,EAAkBA,EAAA4d,IAAW5d,EAC7BP,KAAAu1D,mBAAAp1D,EAAAI,IAOA41D,WAAA,WACAn2D,KAAAk2D,eAAAl2D,KAAAi1D,aAAAjoD,KAAA/L,OAAA,EAAAY,UAAAZ,SAMAm1D,UAAA,WACAp2D,KAAAg1D,UAAAhoD,KAAAqpD,OAMAC,YAAA,WACAt2D,KAAAg1D,UAAAhoD,KAAAonB,SAMAmiC,aAAA,SAAAp2D,EAAAge,GACAne,KAAAg1D,UAAAhoD,KAAApI,OAAAzE,EAAAge,GACAne,KAAAk2D,eAAA/1D,EAAA0B,UAAAZ,OAAA,IAMAu1D,cAAA,WACAx2D,KAAAk2D,eAAA,EAAAr0D,UAAAZ,WAIA63B,EAAA87B,kBAAAlzD,OAAA/B,EAAAiD,W5Cy0TM6zD,KACA,SAAUj4D,EAAQc,EAASZ,GAEjC,Y6ClpUA,IAAAuF,GAAAvF,EAAA,MACAiB,EAAAjB,EAAA,MACAonC,EAAApnC,EAAA,KAEAF,GAAAc,QAAA,SAAAw5B,GAEAA,EAAA+U,cAGA6oB,gBAKAzyD,YACA0yD,kBAAA,SAAA91D,EAAA+1D,EAAAC,GACA72D,KAAA02D,aAAA71D,GAAA+1D,EACA52D,KAAAiE,SAAApD,GAAAlB,EAAAwC,MAAA00D,IAEA7F,oBAAA,SAAAnwD,GACA,MAAAb,MAAA02D,aAAAx1D,eAAAL,GAAAb,KAAA02D,aAAA71D,OAAA4O,IAEAq+B,iBAAA,SAAAjtC,GAEA,MAAAb,MAAAiE,SAAA/C,eAAAL,GAAAlB,EAAAI,UAA+DkE,EAAA8pC,MAAA/tC,KAAAiE,SAAApD,SAE/Di2D,oBAAA,SAAAj2D,EAAAk2D,GACA,GAAA90D,GAAAjC,IACAiC,GAAAgC,SAAA/C,eAAAL,KACAoB,EAAAgC,SAAApD,GAAAlB,EAAA+B,OAAAO,EAAAgC,SAAApD,GAAAk2D,KAGA5F,kBAAA,SAAAhtD,GAEAxE,EAAAsI,KAAA9D,EAAAs2B,OAAA,SAAAsT,GAEAA,EAAAzpC,UAAAypC,EAAAtuC,QAAA6E,UACAypC,EAAA1qC,SAAA0qC,EAAAtuC,QAAA4D,SACA0qC,EAAA/pC,OAAA+pC,EAAAtuC,QAAAuE,OACA8hC,EAAA5hC,OAAAC,EAAA4pC,S7C8pUMipB,KACA,SAAUx4D,EAAQc,EAASZ,GAEjC,Y8CvoUA,SAAAu4D,GAAA9tD,GACA,GACA5I,GAAAC,EADAq7B,IAGA,KAAAt7B,EAAA,EAAAC,EAAA2I,EAAAlI,OAAiCV,EAAAC,IAAUD,EAC3Cs7B,EAAAt3B,KAAA4E,EAAA5I,GAAA8b,MAGA,OAAAwf,GAGA,QAAAq7B,GAAAnpB,EAAArpC,EAAAyyD,GACA,GAAAC,GAAArpB,EAAAspB,gBAAA3yD,EASA,OAPAyyD,KAEAC,GADA,IAAA1yD,GACAqpC,EAAAspB,gBAAA,GAAAD,GAAA,GAEAA,EAAArpB,EAAAspB,gBAAA3yD,EAAA,OAGA0yD,EAtFA,GAAAnzD,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,MACAiB,EAAAjB,EAAA,MACAsnC,EAAAtnC,EAAA,KAEAuF,GAAArE,KAAA,SACA0tB,SAAA,EACAjqB,SAAA,OACA+nB,QAAA,EAGA0P,WACAxN,SAAA,EACAnsB,MAAA,qBACA0kD,UAAA,EACAyR,YAAA,EACAv8B,iBAAA,EACAw8B,WAAA,EACAC,eAAA,GACAC,cAAA,EACAC,cAAA,mBACAC,sBACAC,yBAAA,EACAT,iBAAA,EACA/Q,cACAC,iBAAA,GAIAzrB,YAEAtN,SAAA,EAGA8N,YAAA,GAGA5M,WAAA,IAGAlnB,SACAX,IAAA,EACAC,OAAA,IAKAuC,OACA0uD,aAAA,EACAC,YAAA,EACAC,YAAA,GACAC,QAAA,EACA1wD,QAAA,EACA7D,SAAA,EACA6pB,SAAA,EACA2qC,UAAA,EACAC,gBAAA,EACAC,YAAA,EAEAttD,SAAAm7B,EAAAj9B,WAAAjJ,OACAs4D,SACAC,YA4BA75D,EAAAc,QAAA,SAAAw5B,GAEA,QAAAw/B,GAAA7rB,EAAA8rB,EAAAxjB,GACA,MAAAp1C,GAAAqJ,QAAAuvD,GACA54D,EAAAm1C,YAAArI,EAAAsI,EAAAwjB,GACA9rB,EAAA4I,YAAAkjB,GAAAtzD,MAGA,QAAAuzD,GAAA/4D,GACA,GAAAiL,GAAA/K,EAAA+K,eACAu7C,EAAAhiD,EAAA8a,OACA2rB,EAAAhgC,EAAAjL,EAAAivB,SAAAu3B,EAAA9e,iBACArhB,EAAApb,EAAAjL,EAAAo1C,UAAAoR,EAAA7e,kBACAqxB,EAAA/tD,EAAAjL,EAAAkvB,WAAAs3B,EAAA/e,kBAEA,QACAwD,OACA5kB,QACA2yC,SACA1jB,KAAAp1C,EAAAg1C,WAAAjK,EAAA5kB,EAAA2yC,IAIA,QAAAC,GAAAj5D,GACA,MAAAE,GAAAF,QAAA6sC,aACA3sC,EAAA+K,eAAAjL,EAAA+uB,WAAA,KACA7uB,EAAA+K,eAAAjL,EAAAivB,SAAAzqB,EAAA8a,OAAAooB,kBAGArO,EAAA6/B,MAAAn3D,EAAAE,QAOA4G,WAAA,WACA,GAAArG,GAAAjC,IACA,QACAmG,KAAAlE,EAAAmxC,aAAA,EACAzsC,IAAA1E,EAAAqxC,YAAA,EACA9sC,MAAAvE,EAAAsxC,cAAA,EACA3sC,OAAA3E,EAAAuxC,eAAA,IAQAolB,SAAA,WACA,MAAA54D,MAAA64D,QAOA5H,kBAAA,WACA,GAAA9nD,GAAAnJ,KAAAP,QAAA0J,OACA,IAAAA,EAAAivD,QACAjvD,EAAAivD,OACA9qC,SAAA,KAGA,IAAAnkB,EAAAkvD,QACAlvD,EAAAkvD,OACA/qC,SAAA,GAGA,QAAA7sB,KAAA0I,GACA,UAAA1I,GAAA,UAAAA,IACA,oBAAA0I,GAAAivD,MAAA33D,KACA0I,EAAAivD,MAAA33D,GAAA0I,EAAA1I,IAEA,oBAAA0I,GAAAkvD,MAAA53D,KACA0I,EAAAkvD,MAAA53D,GAAA0I,EAAA1I,MAKAq4D,aAAA,WACAn5D,EAAAkL,SAAA7K,KAAAP,QAAAq5D,cAAA94D,QAEAgF,OAAA,SAAA+zD,EAAAC,EAAAC,GACA,GACA14D,GAAAC,EAAAq7B,EAAAxf,EAAAlT,EAAAovD,EADAt2D,EAAAjC,IAwDA,KApDAiC,EAAA62D,eAGA72D,EAAA82D,WACA92D,EAAA+2D,YACA/2D,EAAAg3D,QAAAt5D,EAAA+B,QACAyE,KAAA,EACAK,MAAA,EACAG,IAAA,EACAC,OAAA,GACIqyD,GACJh3D,EAAAi3D,iBAAAj3D,EAAAi3D,qBAGAj3D,EAAAk3D,sBACAl3D,EAAAm3D,gBACAn3D,EAAAo3D,qBAGAp3D,EAAAq3D,mBACAr3D,EAAAs3D,sBACAt3D,EAAAu3D,kBASAv3D,EAAAw3D,mBAIAtwD,EAAAlH,EAAAy3D,iBAEAz3D,EAAA03D,kBAEA13D,EAAA23D,8BAKA/9B,EAAA55B,EAAA43D,qBAAA1wD,IAAAlH,EAAAkH,MAEAlH,EAAA63D,6BAEA73D,EAAAkH,MAAA0yB,EAKAt7B,EAAA,EAAAC,EAAAq7B,EAAA56B,OAAoCV,EAAAC,IAAUD,EAC9C8b,EAAAwf,EAAAt7B,GACAg4D,EAAApvD,EAAA5I,GACAg4D,EAMAA,EAAAl8C,QALAlT,EAAA5E,KAAAg0D,GACAl8C,QACAg8C,OAAA,GAoBA,OAbAp2D,GAAA42D,OAAA1vD,EAGAlH,EAAA83D,8BACA93D,EAAA+3D,wBACA/3D,EAAAg4D,6BAEAh4D,EAAAi4D,YACAj4D,EAAAk4D,MACAl4D,EAAAm4D,WAEAn4D,EAAAo4D,cAEAp4D,EAAAoD,SAGAg1D,YAAA,WACA16D,EAAAkL,SAAA7K,KAAAP,QAAA46D,aAAAr6D,QAKAm5D,oBAAA,WACAx5D,EAAAkL,SAAA7K,KAAAP,QAAA05D,qBAAAn5D,QAEAo5D,cAAA,WACA,GAAAn3D,GAAAjC,IAEAiC,GAAAqD,gBAEArD,EAAAgD,MAAAhD,EAAA82D,SACA92D,EAAAkE,KAAA,EACAlE,EAAAuE,MAAAvE,EAAAgD,QAEAhD,EAAAiD,OAAAjD,EAAA+2D,UAGA/2D,EAAA0E,IAAA,EACA1E,EAAA2E,OAAA3E,EAAAiD,QAIAjD,EAAAmxC,YAAA,EACAnxC,EAAAqxC,WAAA,EACArxC,EAAAsxC,aAAA,EACAtxC,EAAAuxC,cAAA,GAEA6lB,mBAAA,WACA15D,EAAAkL,SAAA7K,KAAAP,QAAA45D,oBAAAr5D,QAIAs5D,iBAAA,WACA35D,EAAAkL,SAAA7K,KAAAP,QAAA65D,kBAAAt5D,QAEAu5D,oBAAA55D,EAAAuK,KACAsvD,gBAAA,WACA75D,EAAAkL,SAAA7K,KAAAP,QAAA+5D,iBAAAx5D,QAIAy5D,iBAAA,WACA95D,EAAAkL,SAAA7K,KAAAP,QAAAg6D,kBAAAz5D,QAEA05D,WAAA/5D,EAAAuK,KACAyvD,gBAAA,WACAh6D,EAAAkL,SAAA7K,KAAAP,QAAAk6D,iBAAA35D,QAGA45D,4BAAA,WACAj6D,EAAAkL,SAAA7K,KAAAP,QAAAm6D,6BAAA55D,QAEA65D,qBAAA,WACA,GAAA53D,GAAAjC,KAEAs6D,EAAAr4D,EAAAxC,QAAA0J,KACAlH,GAAAkH,MAAAlH,EAAAkH,MAAAoC,IAAA+uD,EAAAC,cAAAD,EAAAzvD,SAAA7K,OAEA85D,2BAAA,WACAn6D,EAAAkL,SAAA7K,KAAAP,QAAAq6D,4BAAA95D,QAKA+5D,4BAAA,WACAp6D,EAAAkL,SAAA7K,KAAAP,QAAAs6D,6BAAA/5D,QAEAg6D,sBAAA,WACA,GAAA/3D,GAAAjC,KACAysC,EAAAxqC,EAAA88B,IACAu7B,EAAAr4D,EAAAxC,QAAA0J,MACA0yB,EAAAo7B,EAAAh1D,EAAA42D,QAIA2B,EAAAhC,EAAA8B,EACA7tB,GAAAsI,KAAAylB,EAAAzlB,IAEA,IAAA0lB,GAAAH,EAAAxC,aAAA,CAEA,IAAAj8B,EAAA56B,QAAAgB,EAAAxC,QAAA6tB,SAAArrB,EAAAqD,eASA,IARA,GAEAo1D,GAFAC,EAAAh7D,EAAAm1C,YAAArI,EAAA+tB,EAAAzlB,KAAAlZ,EAAA55B,EAAAi3D,kBACA0B,EAAAD,EAIAE,EAAA54D,EAAAo1D,gBAAA,GAAAp1D,EAAAo1D,gBAAA,KAGAuD,EAAAC,GAAAJ,EAAAH,EAAAvC,aAAA,CACA,GAAA+C,GAAAn7D,EAAAyvC,UAAAqrB,EAIA,IAHAC,EAAAt0D,KAAAmiC,IAAAuyB,GACA10D,KAAAsiC,IAAAoyB,GAEAH,EAAA14D,EAAA+2D,UAAA,CAEAyB,GACA,OAGAA,IACAG,EAAAF,EAAAC,EAIA14D,EAAAw4D,iBAEAR,2BAAA,WACAt6D,EAAAkL,SAAA7K,KAAAP,QAAAw6D,4BAAAj6D,QAKAk6D,UAAA,WACAv6D,EAAAkL,SAAA7K,KAAAP,QAAAy6D,WAAAl6D,QAEAm6D,IAAA,WACA,GAAAl4D,GAAAjC,KAEAqF,EAAApD,EAAAoD,SACAJ,MAAA,EACAC,OAAA,GAGA22B,EAAAo7B,EAAAh1D,EAAA42D,QAEA/5C,EAAA7c,EAAAxC,QACA66D,EAAAx7C,EAAA3V,MACA4xD,EAAAj8C,EAAA8b,WACAogC,EAAAl8C,EAAAgc,UACAxN,EAAAxO,EAAAwO,QACAhoB,EAAArD,EAAAqD,eAEAk1D,EAAAhC,EAAA8B,GACA9C,EAAA14C,EAAAgc,UAAA08B,cAkBA,IAbAnyD,EAAAJ,MAFAK,EAEArD,EAAAg5D,cAAAh5D,EAAA82D,SAAA92D,EAAAg3D,QAAA9yD,KAAAlE,EAAAg3D,QAAAzyD,MAAAvE,EAAA82D,SAEAzrC,GAAA0tC,EAAAzD,UAAAC,EAAA,EAKAnyD,EAAAH,OADAI,EACAgoB,GAAA0tC,EAAAzD,UAAAC,EAAA,EAEAv1D,EAAA+2D,UAIA+B,EAAAztC,WAAA,CACA,GAAA4tC,GAAAxC,EAAAqC,GACAI,EAAAx7D,EAAAF,QAAA8H,UAAAwzD,EAAAzzD,SACA8zD,EAAAF,EAAAC,EAAAj2D,MAEAI,GACAD,EAAAH,QAAAk2D,EAEA/1D,EAAAJ,OAAAm2D,EAKA,GAAAd,EAAAhtC,WAAA,CACA,GAAA+tC,GAAA17D,EAAAm1C,YAAA7yC,EAAA88B,IAAAy7B,EAAAzlB,KAAAlZ,EAAA55B,EAAAi3D,kBACAoC,EAAA37D,EAAA81C,mBAAA5Z,GACA0/B,EAAA,GAAAf,EAAA9vB,KACA8wB,EAAAv5D,EAAAxC,QAAA0J,MAAA7B,OAEA,IAAAhC,EAAA,CAEArD,EAAAw5D,kBAAAJ,CAEA,IAAAP,GAAAn7D,EAAAyvC,UAAAntC,EAAAw4D,eACAC,EAAAt0D,KAAAmiC,IAAAuyB,GACAY,EAAAt1D,KAAAsiC,IAAAoyB,GAGAa,EAAAD,EAAAL,EACAb,EAAA9vB,KAAA4wB,EACAC,GAAAD,EAAA,GACAC,CAEAl2D,GAAAH,OAAAkB,KAAAuD,IAAA1H,EAAA+2D,UAAA3zD,EAAAH,OAAAy2D,EAAAH,GAEAv5D,EAAA88B,IAAAgW,KAAAylB,EAAAzlB,IACA,IAAA6mB,GAAAtD,EAAAr2D,EAAA88B,IAAAlD,EAAA,GAAA2+B,EAAAzlB,MACA8mB,EAAAvD,EAAAr2D,EAAA88B,IAAAlD,IAAA56B,OAAA,GAAAu5D,EAAAzlB,KAIA,KAAA9yC,EAAAw4D,eACAx4D,EAAAmxC,YAAA,WAAAt0B,EAAAzb,SAAAq3D,EAAAkB,EAAA,EAAAlB,EAAAa,EAAA,EACAt5D,EAAAsxC,aAAA,WAAAz0B,EAAAzb,SAAAq3D,EAAAa,EAAA,EAAAb,EAAAmB,EAAA,IAEA55D,EAAAmxC,YAAAwoB,EAAA,IACA35D,EAAAsxC,aAAAsoB,EAAA,SAKAvB,GAAAtC,OACAqD,EAAA,EAIAA,GAAAG,EAAAD,EAGAl2D,EAAAJ,MAAAmB,KAAAuD,IAAA1H,EAAA82D,SAAA1zD,EAAAJ,MAAAo2D,GAEAp5D,EAAAqxC,WAAAknB,EAAA9vB,KAAA,EACAzoC,EAAAuxC,cAAAgnB,EAAA9vB,KAAA,EAIAzoC,EAAA65D,gBAEA75D,EAAAgD,MAAAI,EAAAJ,MACAhD,EAAAiD,OAAAG,EAAAH,QAOA42D,cAAA,WACA,GAAA75D,GAAAjC,IACAiC,GAAAg3D,UACAh3D,EAAAmxC,YAAAhtC,KAAAC,IAAApE,EAAAmxC,YAAAnxC,EAAAg3D,QAAA9yD,KAAA,GACAlE,EAAAqxC,WAAAltC,KAAAC,IAAApE,EAAAqxC,WAAArxC,EAAAg3D,QAAAtyD,IAAA,GACA1E,EAAAsxC,aAAAntC,KAAAC,IAAApE,EAAAsxC,aAAAtxC,EAAAg3D,QAAAzyD,MAAA,GACAvE,EAAAuxC,cAAAptC,KAAAC,IAAApE,EAAAuxC,cAAAvxC,EAAAg3D,QAAAryD,OAAA,KAIAwzD,SAAA,WACAz6D,EAAAkL,SAAA7K,KAAAP,QAAA26D,UAAAp6D,QAIAsF,aAAA,WACA,cAAAtF,KAAAP,QAAA4D,UAAA,WAAArD,KAAAP,QAAA4D,UAEA43D,YAAA,WACA,MAAAj7D,MAAAP,QAAA,WAIAs8D,cAAA,SAAAC,GAEA,GAAAr8D,EAAA0K,cAAA2xD,GACA,MAAAC,IAGA,qBAAAD,KAAAz6D,SAAAy6D,GACA,MAAAC,IAGA,IAAAD,EACA,GAAAh8D,KAAAsF,gBACA,OAAAmK,KAAAusD,EAAAx5D,EACA,MAAAxC,MAAA+7D,cAAAC,EAAAx5D,OAEK,QAAAiN,KAAAusD,EAAAv5D,EACL,MAAAzC,MAAA+7D,cAAAC,EAAAv5D,EAKA,OAAAu5D,IAQAE,iBAAAv8D,EAAAuK,KASAiyD,iBAAAx8D,EAAAuK,KAOAkyD,iBAAAz8D,EAAAuK,KAMAmtD,gBAAA,SAAA3yD,GACA,GAAAzC,GAAAjC,KACAorB,EAAAnpB,EAAAxC,QAAA2rB,MACA,IAAAnpB,EAAAqD,eAAA,CACA,GAAA+2D,GAAAp6D,EAAAgD,OAAAhD,EAAAmxC,YAAAnxC,EAAAsxC,cACAsnB,EAAAwB,EAAAj2D,KAAAC,IAAApE,EAAA42D,OAAA53D,QAAAmqB,EAAA,QACAkxC,EAAAzB,EAAAn2D,EAAAzC,EAAAmxC,WAEAhoB,KACAkxC,GAAAzB,EAAA,EAGA,IAAA0B,GAAAt6D,EAAAkE,KAAAC,KAAAoT,MAAA8iD,EAEA,OADAC,IAAAt6D,EAAAg5D,cAAAh5D,EAAAg3D,QAAA9yD,KAAA,EAGA,GAAAq2D,GAAAv6D,EAAAiD,QAAAjD,EAAAqxC,WAAArxC,EAAAuxC,cACA,OAAAvxC,GAAA0E,IAAAjC,GAAA83D,GAAAv6D,EAAA42D,OAAA53D,OAAA,KAOAw7D,mBAAA,SAAAjpC,GACA,GAAAvxB,GAAAjC,IACA,IAAAiC,EAAAqD,eAAA,CACA,GAAA+2D,GAAAp6D,EAAAgD,OAAAhD,EAAAmxC,YAAAnxC,EAAAsxC,cACAmpB,EAAAL,EAAA7oC,EAAAvxB,EAAAmxC,YAEAmpB,EAAAt6D,EAAAkE,KAAAC,KAAAoT,MAAAkjD,EAEA,OADAH,IAAAt6D,EAAAg5D,cAAAh5D,EAAAg3D,QAAA9yD,KAAA,EAGA,MAAAlE,GAAA0E,IAAA6sB,EAAAvxB,EAAAiD,QAOAy3D,aAAA,WACA,MAAA38D,MAAAm8D,iBAAAn8D,KAAA48D,iBAGAA,aAAA,WACA,GAAA36D,GAAAjC,KACA2J,EAAA1H,EAAA0H,IACAtD,EAAApE,EAAAoE,GAEA,OAAApE,GAAA41D,YAAA,EACAluD,EAAA,GAAAtD,EAAA,EAAAA,EACAsD,EAAA,GAAAtD,EAAA,EAAAsD,EACA,GAOAkzD,UAAA,SAAA1zD,GACA,GAAA2zD,GASAv8D,EAAAg4D,EAAAwE,EAGAC,EAXA/6D,EAAAjC,KACAsF,EAAArD,EAAAqD,eACA23D,EAAAh7D,EAAAxC,QAAA0J,MAAAivD,MACA8E,EAAA/zD,EAAAlI,OACAk8D,EAAAx9D,EAAAyvC,UAAAntC,EAAAw4D,eACAC,EAAAt0D,KAAAmiC,IAAA40B,GACAC,EAAAn7D,EAAAw5D,kBAAAf,EACA5hD,IAuBA,KAlBAmkD,EAAAtiC,gBACAqiC,EAAAC,EAAAtiC,eAGAr1B,IACAw3D,GAAA,GAEAM,EAAAH,EAAA/E,iBAAAgF,EAAAj7D,EAAAgD,OAAAhD,EAAAmxC,YAAAnxC,EAAAsxC,gBACAupB,EAAA,EAAA12D,KAAAkD,OAAA8zD,EAAAH,EAAA/E,iBAAAgF,GAAAj7D,EAAAgD,OAAAhD,EAAAmxC,YAAAnxC,EAAAsxC,iBAKAypB,GAAAE,EAAAF,IACAF,EAAA12D,KAAAC,IAAAy2D,EAAA12D,KAAAkD,MAAA4zD,EAAAF,MAIAz8D,EAAA,EAAcA,EAAA28D,EAAe38D,IAC7Bg4D,EAAApvD,EAAA5I,GAGAw8D,EAAAD,EAAA,GAAAv8D,EAAAu8D,EAAA,GAAAv8D,EAAAu8D,IAAA,GAAAv8D,EAAAu8D,GAAAI,EACAH,GAAAx8D,IAAA28D,EAAA,SAEA3E,GAAAl8C,MAEAvD,EAAAvU,KAAAg0D,EAEA,OAAAz/C,IAKAwqB,KAAA,SAAAz6B,GACA,GAAA5G,GAAAjC,KACAP,EAAAwC,EAAAxC,OACA,IAAAA,EAAA6tB,QAAA,CAIA,GAAAmf,GAAAxqC,EAAA88B,IACAknB,EAAAhiD,EAAA8a,OACAk+C,EAAAx9D,EAAA0J,MAAAivD,MACAiF,EAAA59D,EAAA0J,MAAAkvD,OAAA4E,EACAniC,EAAAr7B,EAAAq7B,UACAF,EAAAn7B,EAAAm7B,WAEA0iC,EAAA,IAAAr7D,EAAAw4D,cACAn1D,EAAArD,EAAAqD,eAEA6D,EAAA8zD,EAAAhF,SAAAh2D,EAAA46D,UAAA56D,EAAA22D,YAAA32D,EAAA22D,WACA2E,EAAA59D,EAAA+K,eAAAuyD,EAAAvvC,UAAAu4B,EAAAhf,kBACAuzB,EAAAhC,EAAAyE,GACAO,EAAA79D,EAAA+K,eAAA2yD,EAAA3vC,UAAAu4B,EAAAhf,kBACAw2B,EAAAjF,EAAA6E,GAEAK,EAAA5iC,EAAAy8B,UAAAz8B,EAAA08B,eAAA,EAEAmG,EAAAh+D,EAAA+K,eAAAkwB,EAAAlN,UAAAu4B,EAAAhf,kBACA22B,EAAApF,EAAA59B,GACAugC,EAAAx7D,EAAAF,QAAA8H,UAAAqzB,EAAAtzB,SACA61D,EAAAx9D,EAAAyvC,UAAAntC,EAAAw4D,eAEAoD,KAEAC,EAAA77D,EAAAxC,QAAAq7B,UAAA+qB,UACAkY,EAAA,UAAAt+D,EAAA4D,SAAApB,EAAAuE,MAAAvE,EAAAuE,MAAAs3D,EAAAJ,EACAM,EAAA,UAAAv+D,EAAA4D,SAAApB,EAAAuE,MAAAk3D,EAAAz7D,EAAAuE,MACAy3D,EAAA,WAAAx+D,EAAA4D,SAAApB,EAAA0E,IAAAm3D,EAAA77D,EAAA2E,OAAA82D,EAAAI,EACAI,EAAA,WAAAz+D,EAAA4D,SAAApB,EAAA0E,IAAAm3D,EAAAJ,EAAAz7D,EAAA2E,OAAAk3D,CAqKA,IAnKAn+D,EAAAsI,KAAAkB,EAAA,SAAAovD,EAAA7zD,GAEA,IAAA/E,EAAA0K,cAAAkuD,EAAAl8C,OAAA,CAIA,GACAwpC,GAAAsY,EAAA/X,EAAAC,EADAhqC,EAAAk8C,EAAAl8C,KAEA3X,KAAAzC,EAAAm8D,eAAA3+D,EAAA2rB,SAAA0P,EAAAq8B,iBAEAtR,EAAA/qB,EAAA28B,cACA0G,EAAArjC,EAAA48B,cACAtR,EAAAtrB,EAAA68B,mBACAtR,EAAAvrB,EAAA88B,2BAEA/R,EAAAlmD,EAAAiL,sBAAAkwB,EAAA+qB,UAAAnhD,GACAy5D,EAAAx+D,EAAAiL,sBAAAkwB,EAAA35B,MAAAuD,GACA0hD,EAAAzmD,EAAA+K,eAAAowB,EAAAsrB,WAAAH,EAAAG,YACAC,EAAA1mD,EAAA+K,eAAAowB,EAAAurB,iBAAAJ,EAAAI,kBAIA,IAAAgY,GAAAC,EAAAC,EAAAC,EAAA7W,EAAAE,EAAAD,EAAA/N,EAAA4kB,EAAAC,EACAjwC,EAAA,SACAkwC,EAAA,SACAnD,EAAAyB,EAAA31D,OAEA,IAAAhC,EAAA,CACA,GAAAs5D,GAAAlB,EAAAlC,CAEA,YAAA/7D,EAAA4D,UAEAs7D,EAAArB,EAAA,eACA7uC,EAAA6uC,EAAA,iBACAoB,EAAAz8D,EAAA0E,IAAAi4D,IAGAD,EAAArB,EAAA,kBACA7uC,EAAA6uC,EAAA,gBACAoB,EAAAz8D,EAAA2E,OAAAg4D,EAGA,IAAAC,GAAA3H,EAAAj1D,EAAAyC,EAAAo2B,EAAAq8B,iBAAAhuD,EAAAlI,OAAA,EACA49D,GAAA58D,EAAAkE,OACAg4D,EAAA,iBAEAU,GAAAl/D,EAAAqwC,WAAA6V,GAEA4Y,EAAAx8D,EAAAo1D,gBAAA3yD,GAAAu4D,EAAA9E,YAEAkG,EAAAE,EAAA5W,EAAAC,EAAAiX,EACAP,EAAAL,EACAO,EAAAN,EACArW,EAAAh/C,EAAAlC,IACAkzC,EAAAhxC,EAAAjC,OAAAk3D,MACK,CACL,GACAgB,GADAC,EAAA,SAAAt/D,EAAA4D,QAGA45D,GAAAjF,QACAvpC,EAAAswC,EAAA,eACAD,EAAAtD,IAEA/sC,EAAAswC,EAAA,eACAD,EAAApB,EAAAlC,GAGAiD,EAAAM,EAAA98D,EAAAuE,MAAAs4D,EAAA78D,EAAAkE,KAAA24D,CAEA,IAAAE,GAAA9H,EAAAj1D,EAAAyC,EAAAo2B,EAAAq8B,iBAAAhuD,EAAAlI,OAAA,EACA+9D,GAAA/8D,EAAA0E,MACAw3D,EAAA,iBAEAa,GAAAr/D,EAAAqwC,WAAA6V,GAEA6Y,EAAAz8D,EAAAo1D,gBAAA3yD,GAAAu4D,EAAA9E,YAEAkG,EAAAN,EACAQ,EAAAP,EACArW,EAAA9+C,EAAA1C,KACAyhD,EAAA/+C,EAAArC,MAAAs3D,EACAQ,EAAAE,EAAA3W,EAAAhO,EAAAmlB,EAGAnB,EAAAt5D,MACA85D,MACAC,MACAC,MACAC,MACA7W,KACAE,KACAD,KACA/N,KACA4kB,SACAC,SACAO,QAAApZ,EACAqZ,QAAAf,EACAgB,aAAA/Y,EACAgZ,mBAAA/Y,EACAgZ,UAAA,EAAAlC,EACA9gD,QACAg8C,MAAAE,EAAAF,MACAsG,eACAlwC,iBAKA9uB,EAAAsI,KAAA41D,EAAA,SAAAyB,GA0BA,GAzBAxkC,EAAAxN,UACAmf,EAAAlB,OACAkB,EAAAoZ,UAAAyZ,EAAAL,QACAxyB,EAAAmZ,YAAA0Z,EAAAJ,QACAzyB,EAAAsa,cACAta,EAAAsa,YAAAuY,EAAAH,cACA1yB,EAAAua,eAAAsY,EAAAF,oBAGA3yB,EAAA7B,YAEA9P,EAAAy8B,YACA9qB,EAAAxmB,OAAAq5C,EAAAjB,IAAAiB,EAAAhB,KACA7xB,EAAAtC,OAAAm1B,EAAAf,IAAAe,EAAAd,MAGA1jC,EAAAC,kBACA0R,EAAAxmB,OAAAq5C,EAAA3X,GAAA2X,EAAAzX,IACApb,EAAAtC,OAAAm1B,EAAA1X,GAAA0X,EAAAzlB,KAGApN,EAAApB,SACAoB,EAAAf,WAGAuxB,EAAA3vC,QAAA,CAEAmf,EAAAlB,OACAkB,EAAA8yB,UAAAD,EAAAb,OAAAa,EAAAZ,QACAjyB,EAAAn0B,OAAAgnD,EAAAD,UACA5yB,EAAAsI,KAAAuqB,EAAAjH,MAAAoF,EAAA1oB,KAAAylB,EAAAzlB,KACAtI,EAAAqZ,UAAAwZ,EAAAjH,MAAAmF,EAAAD,EACA9wB,EAAAkyB,aAAAW,EAAAX,aACAlyB,EAAAhe,UAAA6wC,EAAA7wC,SAEA,IAAApS,GAAAijD,EAAAjjD,KACA,IAAA1c,EAAAqJ,QAAAqT,GAKA,OAJAmjD,GAAAnjD,EAAApb,OACAutB,EAAA,IAAAgsC,EAAA9vB,KACAjoC,EAAAR,EAAAqD,eAAA,GAAAkpB,GAAAgxC,EAAA,KAEAj/D,EAAA,EAAqBA,EAAAi/D,IAAej/D,EAEpCksC,EAAAgzB,SAAA,GAAApjD,EAAA9b,GAAA,EAAAkC,GAEAA,GAAA+rB,MAGAie,GAAAgzB,SAAApjD,EAAA,IAEAowB,GAAAf,aAIA9Q,EAAAtN,QAAA,CAEA,GAAAoyC,GACAC,EACAN,EAAA,EACAO,EAAAlH,EAAA99B,GAAA,CAEA,IAAAt1B,EACAo6D,EAAAz9D,EAAAkE,MAAAlE,EAAAuE,MAAAvE,EAAAkE,MAAA,EACAw5D,EAAA,WAAAlgE,EAAA4D,SACApB,EAAA2E,OAAAg5D,EAAAzE,EAAAv0D,OACA3E,EAAA0E,IAAAi5D,EAAAzE,EAAAx0D,QACK,CACL,GAAAo4D,GAAA,SAAAt/D,EAAA4D,QACAq8D,GAAAX,EACA98D,EAAAkE,KAAAy5D,EAAAzE,EAAAx0D,IACA1E,EAAAuE,MAAAo5D,EAAAzE,EAAAx0D,IACAg5D,EAAA19D,EAAA0E,KAAA1E,EAAA2E,OAAA3E,EAAA0E,KAAA,EACA04D,EAAAN,GAAA,GAAA34D,KAAAoiC,GAAA,GAAApiC,KAAAoiC,GAGAiE,EAAAlB,OACAkB,EAAA8yB,UAAAG,EAAAC,GACAlzB,EAAAn0B,OAAA+mD,GACA5yB,EAAAhe,UAAA,SACAge,EAAAkyB,aAAA,SACAlyB,EAAAqZ,UAAA6X,EACAlxB,EAAAsI,KAAA6oB,EAAA7oB,KACAtI,EAAAgzB,SAAA7kC,EAAAQ,YAAA,KACAqR,EAAAf,UAGA,GAAA5Q,EAAAw8B,WAAA,CAEA7qB,EAAAoZ,UAAAlmD,EAAAiL,sBAAAkwB,EAAA+qB,UAAA,GACApZ,EAAAmZ,YAAAjmD,EAAAiL,sBAAAkwB,EAAA35B,MAAA,EACA,IAAAwmD,GAAA1lD,EAAAkE,KACAyhD,EAAA3lD,EAAAuE,MAAAs3D,EACAjW,EAAA5lD,EAAA0E,IACAkzC,EAAA53C,EAAA2E,OAAAk3D,EAEA9tB,EAAArwC,EAAAqwC,WAAAvD,EAAAoZ,UACAvgD,IACAuiD,EAAAhO,EAAA,QAAAp6C,EAAA4D,SAAApB,EAAA2E,OAAA3E,EAAA0E,IACAkhD,GAAA7X,EACA6J,GAAA7J,IAEA2X,EAAAC,EAAA,SAAAnoD,EAAA4D,SAAApB,EAAAuE,MAAAvE,EAAAkE,KACAwhD,GAAA3X,EACA4X,GAAA5X,GAGAvD,EAAA7B,YACA6B,EAAAxmB,OAAA0hC,EAAAE,GACApb,EAAAtC,OAAAyd,EAAA/N,GACApN,EAAApB,gB9CotUMw0B,KACA,SAAUrhE,EAAQc,EAASZ,GAEjC,Y+CxnWA,IAAAuF,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,UACA06B,UACA+E,SAAA,EACAu2B,OAAA,KACA9uB,KAAA,UACAzjC,SAAA,UACAwX,WAAA,EACAiiB,gBAAA,kBACAgjC,eAAA,OACAC,aAAA,EACAC,kBAAA,EACAC,eAAA,OACAC,WAAA,OACAC,YAAA,EACAC,cAAA,OACAC,UAAA,OACAC,gBAAA,OACAC,cAAA,EACAC,gBAAA,EACAC,gBAAA,OACAC,YAAA,OACAC,SAAA,EACAC,SAAA,EACAC,aAAA,EACAC,UAAA,EACAC,aAAA,EACAC,mBAAA,OACAzmC,eAAA,EACAyC,YAAA,gBACAG,YAAA,EACA3C,WAEAymC,YAAAthE,EAAAuK,KACAmjB,MAAA,SAAA6zC,EAAAl0D,GAEA,GAAAqgB,GAAA,GACAwO,EAAA7uB,EAAA6uB,OACAslC,EAAAtlC,IAAA56B,OAAA,CAEA,IAAAigE,EAAAjgE,OAAA,GACA,GAAAmD,GAAA88D,EAAA,EAEA98D,GAAAg9D,OACA/zC,EAAAjpB,EAAAg9D,OACMD,EAAA,GAAA/8D,EAAAM,MAAAy8D,IACN9zC,EAAAwO,EAAAz3B,EAAAM,QAIA,MAAA2oB,IAEAg0C,WAAA1hE,EAAAuK,KAGAo3D,WAAA3hE,EAAAuK,KAGAq3D,YAAA5hE,EAAAuK,KACAmS,MAAA,SAAA8f,EAAAnvB,GACA,GAAAqP,GAAArP,EAAAqN,SAAA8hB,EAAAlgB,cAAAI,OAAA,EAMA,OAJAA,KACAA,GAAA,MAEAA,GAAA8f,EAAAqlC,QAGAC,WAAA,SAAAtlC,EAAAh4B,GACA,GAAA+V,GAAA/V,EAAAoW,eAAA4hB,EAAAlgB,cACAylD,EAAAxnD,EAAAlN,KAAAmvB,EAAAz3B,OACAtE,EAAAshE,EAAAx/D,KACA,QACA86B,YAAA58B,EAAA48B,YACAF,gBAAA18B,EAAA08B,kBAGA6kC,eAAA,WACA,MAAA3hE,MAAAuvD,SAAA6Q,eAEAwB,WAAAjiE,EAAAuK,KAGA23D,UAAAliE,EAAAuK,KAGA43D,aAAAniE,EAAAuK,KACA63D,OAAApiE,EAAAuK,KACA83D,YAAAriE,EAAAuK,SAKA1L,EAAAc,QAAA,SAAAw5B,GAKA,QAAAmpC,GAAAC,EAAA3mC,GACA,GAAAp6B,GAAAxB,EAAAwB,MAAA+gE,EACA,OAAA/gE,GAAAmT,MAAAinB,EAAAp6B,EAAAmT,SAAAmC,aAIA,QAAA0rD,GAAApa,EAAAqa,GAUA,MATAA,KACAziE,EAAAqJ,QAAAo5D,GAEA93D,MAAAxI,UAAAyC,KAAA3C,MAAAmmD,EAAAqa,GAEAra,EAAAxjD,KAAA69D,IAIAra,EAMA,QAAAsa,GAAAhzD,GACA,GAAAizD,GAAAjzD,EAAAkzD,QACAC,EAAAnzD,EAAAozD,SAAApzD,EAAAqzD,OACAh+D,EAAA2K,EAAA6M,OACAD,EAAA5M,EAAAiN,aAEA,QACA8kD,OAAAkB,IAAApG,iBAAAx3D,EAAAuX,GAAA,GACAulD,OAAAgB,IAAAtG,iBAAAx3D,EAAAuX,GAAA,GACAvX,QACAuX,eACAzZ,EAAA6M,EAAAjN,OAAAI,EACAC,EAAA4M,EAAAjN,OAAAK,GAQA,QAAAkgE,GAAAC,GACA,GAAA3c,GAAAhiD,EAAA8a,OACArU,EAAA/K,EAAA+K,cAEA,QAEAk2D,SAAAgC,EAAAhC,SACAD,SAAAiC,EAAAjC,SACAkC,OAAAD,EAAAC,OACAC,OAAAF,EAAAE,OAGA1C,cAAAwC,EAAAxC,cACA2C,gBAAAr4D,EAAAk4D,EAAAI,eAAA/c,EAAA/e,mBACA+7B,eAAAv4D,EAAAk4D,EAAAM,cAAAjd,EAAA7e,kBACA+7B,WAAAP,EAAAvC,UACA+C,aAAA14D,EAAAk4D,EAAAQ,aAAAnd,EAAA9e,iBACAg5B,YAAAyC,EAAAzC,YAGAF,eAAA2C,EAAA3C,eACAoD,iBAAA34D,EAAAk4D,EAAAU,gBAAArd,EAAA/e,mBACAq8B,gBAAA74D,EAAAk4D,EAAA9C,eAAA7Z,EAAA7e,kBACAo8B,cAAA94D,EAAAk4D,EAAAY,cAAAvd,EAAA9e,iBACAs8B,YAAAb,EAAA1C,WACAH,aAAA6C,EAAA7C,aACAC,kBAAA4C,EAAA5C,kBAGAS,gBAAAmC,EAAAnC,gBACAiD,kBAAAh5D,EAAAk4D,EAAAe,iBAAA1d,EAAA/e,mBACA08B,iBAAAl5D,EAAAk4D,EAAAtC,gBAAAra,EAAA7e,kBACAy8B,eAAAn5D,EAAAk4D,EAAAiB,eAAA5d,EAAA9e,iBACA28B,aAAAlB,EAAAlC,YACAH,cAAAqC,EAAArC,cACAC,gBAAAoC,EAAApC,gBAGAM,UAAA8B,EAAA9B,UACAC,aAAA6B,EAAA7B,aACAjkC,gBAAA8lC,EAAA9lC,gBACAvB,QAAA,EACAwoC,sBAAAnB,EAAA5B,mBACAzmC,cAAAqoC,EAAAroC,cACAyC,YAAA4lC,EAAA5lC,YACAG,YAAAylC,EAAAzlC,aAOA,QAAA6mC,GAAA1kC,EAAAj/B,GACA,GAAA0+B,GAAAO,EAAAmmB,OAAA1mB,IAEA75B,EAAA,EAAA7E,EAAAsgE,SACA17D,EAAA,EAGA8wB,EAAA11B,EAAA01B,KACAkuC,EAAAluC,EAAA8Y,OAAA,SAAA1wB,EAAA+lD,GACA,MAAA/lD,GAAA+lD,EAAAC,OAAAljE,OAAAijE,EAAAE,MAAAnjE,OAAAijE,EAAAG,MAAApjE,QACG,EACHgjE,IAAA5jE,EAAAihE,WAAArgE,OAAAZ,EAAAwhE,UAAA5gE,MAEA,IAAAqjE,GAAAjkE,EAAAgtB,MAAApsB,OACAsjE,EAAAlkE,EAAA0hE,OAAA9gE,OACAuiE,EAAAnjE,EAAAmjE,cACAJ,EAAA/iE,EAAA+iE,aACAS,EAAAxjE,EAAAwjE,cAEA3+D,IAAAo/D,EAAAd,EACAt+D,GAAAo/D,KAAA,GAAAjkE,EAAA0/D,aAAA,EACA76D,GAAAo/D,EAAAjkE,EAAA2/D,kBAAA,EACA96D,GAAA++D,EAAAb,EACAl+D,GAAA++D,KAAA,GAAA5jE,EAAA8/D,YAAA,EACAj7D,GAAAq/D,EAAAlkE,EAAAmgE,gBAAA,EACAt7D,GAAAq/D,EAAA,EACAr/D,GAAAq/D,KAAA,GAAAlkE,EAAAkgE,cAAA,CAGA,IAAAiE,GAAA,EACAC,EAAA,SAAAve,GACAjhD,EAAAmB,KAAAC,IAAApB,EAAA85B,EAAAsW,YAAA6Q,GAAAjhD,MAAAu/D,GA4BA,OAzBAzlC,GAAAgW,KAAAp1C,EAAAg1C,WAAA6uB,EAAAnjE,EAAAkjE,gBAAAljE,EAAAgjE,kBACA1jE,EAAAsI,KAAA5H,EAAAgtB,MAAAo3C,GAGA1lC,EAAAgW,KAAAp1C,EAAAg1C,WAAAyuB,EAAA/iE,EAAA4iE,eAAA5iE,EAAA0iE,iBACApjE,EAAAsI,KAAA5H,EAAAihE,WAAAp5D,OAAA7H,EAAAwhE,WAAA4C,GAGAD,EAAAnkE,EAAAk6B,cAAA6oC,EAAA,IACAzjE,EAAAsI,KAAA8tB,EAAA,SAAAmuC,GACAvkE,EAAAsI,KAAAi8D,EAAAC,OAAAM,GACA9kE,EAAAsI,KAAAi8D,EAAAE,MAAAK,GACA9kE,EAAAsI,KAAAi8D,EAAAG,MAAAI,KAIAD,EAAA,EAGAzlC,EAAAgW,KAAAp1C,EAAAg1C,WAAAkvB,EAAAxjE,EAAAujE,iBAAAvjE,EAAAqjE,mBACA/jE,EAAAsI,KAAA5H,EAAA0hE,OAAA0C,GAGAx/D,GAAA,EAAA5E,EAAAugE,UAGA37D,QACAC,UAOA,QAAAw/D,GAAAplC,EAAAoL,GACA,GAAArqC,GAAAi/B,EAAAl9B,OACA+B,EAAAm7B,EAAAmmB,OACA58C,EAAAy2B,EAAAmmB,OAAA58C,UACAg6D,EAAA,SACAC,EAAA,QAEAziE,GAAAoC,EAAAioC,EAAAxlC,OACA49D,EAAA,MACGziE,EAAAoC,EAAA0B,EAAAe,OAAAwlC,EAAAxlC,SACH49D,EAAA,SAGA,IAAA6B,GAAAC,EACAC,EAAAC,EACAC,EACAC,GAAAn8D,EAAA1C,KAAA0C,EAAArC,OAAA,EACAy+D,GAAAp8D,EAAAlC,IAAAkC,EAAAjC,QAAA,CAEA,YAAAk8D,GACA6B,EAAA,SAAAniE,GACA,MAAAA,IAAAwiE,GAEAJ,EAAA,SAAApiE,GACA,MAAAA,GAAAwiE,KAGAL,EAAA,SAAAniE,GACA,MAAAA,IAAAkoC,EAAAzlC,MAAA,GAEA2/D,EAAA,SAAApiE,GACA,MAAAA,IAAA2B,EAAAc,MAAAylC,EAAAzlC,MAAA,IAIA4/D,EAAA,SAAAriE,GACA,MAAAA,GAAAkoC,EAAAzlC,MAAA5E,EAAAygE,UAAAzgE,EAAAwgE,aAAA18D,EAAAc,OAEA6/D,EAAA,SAAAtiE,GACA,MAAAA,GAAAkoC,EAAAzlC,MAAA5E,EAAAygE,UAAAzgE,EAAAwgE,aAAA,GAEAkE,EAAA,SAAAtiE,GACA,MAAAA,IAAAwiE,EAAA,gBAGAN,EAAAtkE,EAAAmC,IACAqgE,EAAA,OAGAgC,EAAAxkE,EAAAmC,KACAqgE,EAAA,SACAC,EAAAiC,EAAA1kE,EAAAoC,KAEGmiE,EAAAvkE,EAAAmC,KACHqgE,EAAA,QAGAiC,EAAAzkE,EAAAmC,KACAqgE,EAAA,SACAC,EAAAiC,EAAA1kE,EAAAoC,IAIA,IAAAqc,GAAAwgB,EAAAiwB,QACA,QACAsT,OAAA/jD,EAAA+jD,OAAA/jD,EAAA+jD,SACAC,OAAAhkD,EAAAgkD,OAAAhkD,EAAAgkD,UAOA,QAAAoC,GAAAxgB,EAAAha,EAAAtJ,EAAAj9B,GAEA,GAAA3B,GAAAkiD,EAAAliD,EACAC,EAAAiiD,EAAAjiD,EAEAq+D,EAAApc,EAAAoc,UACAD,EAAAnc,EAAAmc,aACAE,EAAArc,EAAAqc,aACA8B,EAAAzhC,EAAAyhC,OACAC,EAAA1hC,EAAA0hC,OACAqC,EAAArE,EAAAD,EACAuE,EAAArE,EAAAF,CAkCA,OAhCA,UAAAgC,EACArgE,GAAAkoC,EAAAzlC,MACG,WAAA49D,IACHrgE,GAAAkoC,EAAAzlC,MAAA,EACAzC,EAAAkoC,EAAAzlC,MAAAd,EAAAc,QACAzC,EAAA2B,EAAAc,MAAAylC,EAAAzlC,OAEAzC,EAAA,IACAA,EAAA,IAIA,QAAAsgE,EACArgE,GAAA0iE,EAEA1iE,GADG,WAAAqgE,EACHp4B,EAAAxlC,OAAAigE,EAEAz6B,EAAAxlC,OAAA,EAGA,WAAA49D,EACA,SAAAD,EACArgE,GAAA2iE,EACI,UAAAtC,IACJrgE,GAAA2iE,GAEG,SAAAtC,EACHrgE,GAAA4iE,EACG,UAAAvC,IACHrgE,GAAA4iE,IAIA5iE,IACAC,KAIAq2B,EAAA06B,QAAAhyD,EAAAE,QACAC,WAAA,WACA3B,KAAAoC,OAAAugE,EAAA3iE,KAAAuvD,UACAvvD,KAAAqlE,gBAKAC,SAAA,WACA,GAAArjE,GAAAjC,KACA8e,EAAA7c,EAAAstD,SACA/0B,EAAA1b,EAAA0b,UAEAymC,EAAAzmC,EAAAymC,YAAAr/D,MAAAK,EAAAJ,WACAwrB,EAAAmN,EAAAnN,MAAAzrB,MAAAK,EAAAJ,WACAw/D,EAAA7mC,EAAA6mC,WAAAz/D,MAAAK,EAAAJ,WAEAuiE,IAKA,OAJAA,GAAAjC,EAAAiC,EAAAnD,GACAmD,EAAAjC,EAAAiC,EAAA/2C,GACA+2C,EAAAjC,EAAAiC,EAAA/C,IAMAkE,cAAA,WACA,GAAAnB,GAAApkE,KAAAuvD,SAAA/0B,UAAA8mC,WAAA1/D,MAAA5B,KAAA6B,UACA,OAAAlC,GAAAqJ,QAAAo7D,SAAA30D,KAAA20D,UAIAoB,QAAA,SAAAtE,EAAAl0D,GACA,GAAA/K,GAAAjC,KACAw6B,EAAAv4B,EAAAstD,SAAA/0B,UACAirC,IAeA,OAbA9lE,GAAAsI,KAAAi5D,EAAA,SAAA/kC,GACA,GAAA+nC,IACAC,UACAC,SACAC,SAEAlC,GAAA+B,EAAAC,OAAA3pC,EAAA+mC,YAAA/2D,KAAAvI,EAAAk6B,EAAAnvB,IACAm1D,EAAA+B,EAAAE,MAAA5pC,EAAAne,MAAA7R,KAAAvI,EAAAk6B,EAAAnvB,IACAm1D,EAAA+B,EAAAG,MAAA7pC,EAAAonC,WAAAp3D,KAAAvI,EAAAk6B,EAAAnvB,IAEAy4D,EAAAlhE,KAAA2/D,KAGAuB,GAIAC,aAAA,WACA,GAAAtB,GAAApkE,KAAAuvD,SAAA/0B,UAAAqnC,UAAAjgE,MAAA5B,KAAA6B,UACA,OAAAlC,GAAAqJ,QAAAo7D,SAAA30D,KAAA20D,UAKAuB,UAAA,WACA,GAAA1jE,GAAAjC,KACAw6B,EAAAv4B,EAAAstD,SAAA/0B,UAEAsnC,EAAAtnC,EAAAsnC,aAAAlgE,MAAAK,EAAAJ,WACAkgE,EAAAvnC,EAAAunC,OAAAngE,MAAAK,EAAAJ,WACAmgE,EAAAxnC,EAAAwnC,YAAApgE,MAAAK,EAAAJ,WAEAuiE,IAKA,OAJAA,GAAAjC,EAAAiC,EAAAtC,GACAsC,EAAAjC,EAAAiC,EAAArC,GACAqC,EAAAjC,EAAAiC,EAAApC,IAKAh9D,OAAA,SAAA8uD,GACA,GA8BAvzD,GAAA2K,EA9BAjJ,EAAAjC,KACA8e,EAAA7c,EAAAstD,SAKAqW,EAAA3jE,EAAAG,OACA/B,EAAA4B,EAAAG,OAAAugE,EAAA7jD,GACAo1C,EAAAjyD,EAAA4jE,QAEA74D,EAAA/K,EAAA2vD,MAGAxwB,GACAyhC,OAAA+C,EAAA/C,OACAC,OAAA8C,EAAA9C,QAEAgD,GACAtjE,EAAAojE,EAAApjE,EACAC,EAAAmjE,EAAAnjE,GAEAsjE,GACA9gE,MAAA2gE,EAAA3gE,MACAC,OAAA0gE,EAAA1gE,QAEA3C,GACAC,EAAAojE,EAAAI,OACAvjE,EAAAmjE,EAAAK,OAKA,IAAA/R,EAAAjzD,OAAA,CACAZ,EAAAk7B,QAAA,CAEA,IAAA2qC,MACAC,IACA5jE,GAAAu2B,EAAA06B,QAAA4S,YAAAtnD,EAAAzb,UAAAmH,KAAAvI,EAAAiyD,EAAAjyD,EAAAokE,eAEA,IAAAnF,KACA,KAAA3gE,EAAA,EAAA2K,EAAAgpD,EAAAjzD,OAAoCV,EAAA2K,IAAS3K,EAC7C2gE,EAAA38D,KAAA89D,EAAAnO,EAAA3zD,IAIAue,GAAAjN,SACAqvD,IAAArvD,OAAA,SAAAhT,GACA,MAAAigB,GAAAjN,OAAAhT,EAAAmO,MAKA8R,EAAAwnD,WACApF,IAAAt9D,KAAA,SAAA/E,EAAAgF,GACA,MAAAib,GAAAwnD,SAAAznE,EAAAgF,EAAAmJ,MAKArN,EAAAsI,KAAAi5D,EAAA,SAAA/kC,GACA+pC,EAAA3hE,KAAAua,EAAA0b,UAAAinC,WAAAj3D,KAAAvI,EAAAk6B,EAAAl6B,EAAAwjD,SACA0gB,EAAA5hE,KAAAua,EAAA0b,UAAAmnC,eAAAn3D,KAAAvI,EAAAk6B,EAAAl6B,EAAAwjD,WAKAplD,EAAAgtB,MAAAprB,EAAAqjE,SAAApE,EAAAl0D,GACA3M,EAAAihE,WAAAr/D,EAAAsjE,cAAArE,EAAAl0D,GACA3M,EAAA01B,KAAA9zB,EAAAujE,QAAAtE,EAAAl0D,GACA3M,EAAAwhE,UAAA5/D,EAAAyjE,aAAAxE,EAAAl0D,GACA3M,EAAA0hE,OAAA9/D,EAAA0jE,UAAAzE,EAAAl0D,GAGA3M,EAAAmC,EAAA4D,KAAAoT,MAAAjX,EAAAC,GACAnC,EAAAoC,EAAA2D,KAAAoT,MAAAjX,EAAAE,GACApC,EAAAwgE,aAAA/hD,EAAA+hD,aACAxgE,EAAA6lE,cACA7lE,EAAA8lE,kBAGA9lE,EAAAkmE,WAAArF,EAGA6E,EAAA/B,EAAAhkE,KAAAK,GACA+gC,EAAAsjC,EAAA1kE,KAAA+lE,GAEAD,EAAAZ,EAAA7kE,EAAA0lE,EAAA3kC,EAAAn/B,EAAAwjD,YAEAplD,GAAAk7B,QAAA,CAoBA,OAjBAl7B,GAAAwiE,OAAAzhC,EAAAyhC,OACAxiE,EAAAyiE,OAAA1hC,EAAA0hC,OACAziE,EAAAmC,EAAAsjE,EAAAtjE,EACAnC,EAAAoC,EAAAqjE,EAAArjE,EACApC,EAAA4E,MAAA8gE,EAAA9gE,MACA5E,EAAA6E,OAAA6gE,EAAA7gE,OAGA7E,EAAA2lE,OAAAzjE,EAAAC,EACAnC,EAAA4lE,OAAA1jE,EAAAE,EAEAR,EAAAG,OAAA/B,EAEAyzD,GAAAh1C,EAAA82C,QACA92C,EAAA82C,OAAAprD,KAAAvI,EAAA5B,GAGA4B,GAEAukE,UAAA,SAAAC,EAAA/7B,GACA,GAAA3L,GAAA/+B,KAAAylD,OAAA1mB,IACA2lB,EAAA1kD,KAAAkC,MACAwkE,EAAA1mE,KAAA2mE,iBAAAF,EAAA/7B,EAAAga,EAEA3lB,GAAAoL,OAAAu8B,EAAA/e,GAAA+e,EAAA7e,IACA9oB,EAAAoL,OAAAu8B,EAAA9e,GAAA8e,EAAA7sB,IACA9a,EAAAoL,OAAAu8B,EAAAE,GAAAF,EAAAG,KAEAF,iBAAA,SAAAF,EAAA/7B,EAAAga,GACA,GAAAiD,GAAAC,EAAAgf,EAAA/e,EAAAhO,EAAAgtB,EACA/F,EAAApc,EAAAoc,UACAC,EAAArc,EAAAqc,aACA8B,EAAAne,EAAAme,OACAC,EAAApe,EAAAoe,OACAgE,EAAAL,EAAAjkE,EACAukE,EAAAN,EAAAhkE,EACAwC,EAAAylC,EAAAzlC,MACAC,EAAAwlC,EAAAxlC,MAEA,eAAA49D,EACAjpB,EAAAktB,EAAA7hE,EAAA,EAEA,SAAA29D,GACAlb,EAAAmf,EACAlf,EAAAD,EAAAmZ,EACA8F,EAAAjf,EAEAE,EAAAhO,EAAAinB,EACA+F,EAAAhtB,EAAAinB,IAEAnZ,EAAAmf,EAAA7hE,EACA2iD,EAAAD,EAAAmZ,EACA8F,EAAAjf,EAEAE,EAAAhO,EAAAinB,EACA+F,EAAAhtB,EAAAinB,OAgBA,IAbA,SAAA+B,GACAjb,EAAAkf,EAAA/F,EAAA,EACApZ,EAAAC,EAAAkZ,EACA8F,EAAAhf,EAAAkZ,GACK,UAAA+B,GACLjb,EAAAkf,EAAA7hE,EAAA87D,EAAAD,EACAnZ,EAAAC,EAAAkZ,EACA8F,EAAAhf,EAAAkZ,IAEAlZ,EAAAlD,EAAAshB,OACAre,EAAAC,EAAAkZ,EACA8F,EAAAhf,EAAAkZ,GAEA,QAAAgC,EACAjb,EAAAkf,EACAltB,EAAAgO,EAAAiZ,EACA+F,EAAAhf,MACK,CACLA,EAAAkf,EAAA7hE,EACA20C,EAAAgO,EAAAiZ,EACA+F,EAAAhf,CAEA,IAAAmf,GAAAJ,CACAA,GAAAjf,EACAA,EAAAqf,EAGA,OAAWrf,KAAAC,KAAAgf,KAAA/e,KAAAhO,KAAAgtB,OAEXI,UAAA,SAAAC,EAAAxiB,EAAA3lB,EAAAxD,GACA,GAAAlO,GAAAq3B,EAAAr3B,KAEA,IAAAA,EAAApsB,OAAA,CACA89B,EAAAtQ,UAAAi2B,EAAA+e,YACA1kC,EAAA4/B,aAAA,KAEA,IAAA6E,GAAA9e,EAAA8e,cACAzD,EAAArb,EAAAqb,YAEAhhC,GAAA+mB,UAAAmc,EAAAvd,EAAAub,eAAA1kC,GACAwD,EAAAgW,KAAAp1C,EAAAg1C,WAAA6uB,EAAA9e,EAAA6e,gBAAA7e,EAAA2e,iBAEA,IAAA9iE,GAAA2K,CACA,KAAA3K,EAAA,EAAA2K,EAAAmiB,EAAApsB,OAAmCV,EAAA2K,IAAS3K,EAC5Cw+B,EAAA0gC,SAAApyC,EAAA9sB,GAAA2mE,EAAA1kE,EAAA0kE,EAAAzkE,GACAykE,EAAAzkE,GAAA+gE,EAAAzD,EAEAx/D,EAAA,IAAA8sB,EAAApsB,SACAimE,EAAAzkE,GAAAiiD,EAAAsb,kBAAAD,KAKAoH,SAAA,SAAAD,EAAAxiB,EAAA3lB,EAAAxD,GACA,GAAA6nC,GAAA1e,EAAA0e,aACAjD,EAAAzb,EAAAyb,YACApqC,EAAA2uB,EAAA3uB,IAEAgJ,GAAAtQ,UAAAi2B,EAAAye,WACApkC,EAAA4/B,aAAA,MACA5/B,EAAAgW,KAAAp1C,EAAAg1C,WAAAyuB,EAAA1e,EAAAue,eAAAve,EAAAqe,gBAGA,IAAAqE,GAAA,EACAC,EAAA,SAAAnhB,GACAnnB,EAAA0gC,SAAAvZ,EAAAghB,EAAA1kE,EAAA4kE,EAAAF,EAAAzkE,GACAykE,EAAAzkE,GAAA2gE,EAAAjD,EAIAphC,GAAA+mB,UAAAmc,EAAAvd,EAAA0b,cAAA7kC,GACA57B,EAAAsI,KAAAy8C,EAAA4c,WAAA+F,EAEA,IAAAC,GAAA5iB,EAAAnqB,aACA6sC,GAAAE,EAAAlE,EAAA,IAGAzjE,EAAAsI,KAAA8tB,EAAA,SAAAmuC,EAAA3jE,GACA,GAAAgnE,GAAAtF,EAAAvd,EAAAyhB,gBAAA5lE,GAAAg7B,EACAwD,GAAA+mB,UAAAyhB,EACA5nE,EAAAsI,KAAAi8D,EAAAC,OAAAkD,GAEA1nE,EAAAsI,KAAAi8D,EAAAE,MAAA,SAAAle,GAEAohB,IAEAvoC,EAAA+mB,UAAAmc,EAAAvd,EAAAqf,sBAAAxoC,GACAwD,EAAAiM,SAAAk8B,EAAA1kE,EAAA0kE,EAAAzkE,EAAA2gE,KAGArkC,EAAA8mB,UAAA,EACA9mB,EAAA6mB,YAAAqc,EAAAvd,EAAAwhB,YAAA3lE,GAAAy8B,YAAAzB,GACAwD,EAAAkM,WAAAi8B,EAAA1kE,EAAA0kE,EAAAzkE,EAAA2gE,KAGArkC,EAAA+mB,UAAAmc,EAAAvd,EAAAwhB,YAAA3lE,GAAAu8B,gBAAAvB,GACAwD,EAAAiM,SAAAk8B,EAAA1kE,EAAA,EAAA0kE,EAAAzkE,EAAA,EAAA2gE,EAAA,EAAAA,EAAA,GACArkC,EAAA+mB,UAAAyhB,GAGAF,EAAAnhB,KAGAvmD,EAAAsI,KAAAi8D,EAAAG,MAAAgD,KAIAD,EAAA,EAGAznE,EAAAsI,KAAAy8C,EAAAmd,UAAAwF,GACAH,EAAAzkE,GAAA09D,GAEAqH,WAAA,SAAAN,EAAAxiB,EAAA3lB,EAAAxD,GACA,GAAAwmC,GAAArd,EAAAqd,MAEAA,GAAA9gE,SACAimE,EAAAzkE,GAAAiiD,EAAA8b,gBAEAzhC,EAAAtQ,UAAAi2B,EAAAof,aACA/kC,EAAA4/B,aAAA,MAEA5/B,EAAA+mB,UAAAmc,EAAAvd,EAAA+b,gBAAAllC,GACAwD,EAAAgW,KAAAp1C,EAAAg1C,WAAA+P,EAAAmf,eAAAnf,EAAAkf,iBAAAlf,EAAAgf,mBAEA/jE,EAAAsI,KAAA85D,EAAA,SAAA7b,GACAnnB,EAAA0gC,SAAAvZ,EAAAghB,EAAA1kE,EAAA0kE,EAAAzkE,GACAykE,EAAAzkE,GAAAiiD,EAAAmf,eAAAnf,EAAA6b,kBAIAkH,eAAA,SAAAP,EAAAxiB,EAAA3lB,EAAAgnC,EAAAxqC,GACAwD,EAAA+mB,UAAAmc,EAAAvd,EAAA5nB,gBAAAvB,GACAwD,EAAA6mB,YAAAqc,EAAAvd,EAAA1nB,YAAAzB,GACAwD,EAAA8mB,UAAAnB,EAAAvnB,WACA,IAAA0lC,GAAAne,EAAAme,OACAC,EAAApe,EAAAoe,OACAtgE,EAAA0kE,EAAA1kE,EACAC,EAAAykE,EAAAzkE,EACAwC,EAAA8gE,EAAA9gE,MACAC,EAAA6gE,EAAA7gE,OACA8kC,EAAA0a,EAAAqc,YAEAhiC,GAAA6L,YACA7L,EAAA9Y,OAAAzjB,EAAAwnC,EAAAvnC,GACA,QAAAqgE,GACA9iE,KAAAwmE,UAAAU,EAAAnB,GAEAhnC,EAAAoL,OAAA3nC,EAAAyC,EAAA+kC,EAAAvnC,GACAs8B,EAAAqL,iBAAA5nC,EAAAyC,EAAAxC,EAAAD,EAAAyC,EAAAxC,EAAAunC,GACA,WAAA84B,GAAA,UAAAD,GACA7iE,KAAAwmE,UAAAU,EAAAnB,GAEAhnC,EAAAoL,OAAA3nC,EAAAyC,EAAAxC,EAAAyC,EAAA8kC,GACAjL,EAAAqL,iBAAA5nC,EAAAyC,EAAAxC,EAAAyC,EAAA1C,EAAAyC,EAAA+kC,EAAAvnC,EAAAyC,GACA,WAAA49D,GACA9iE,KAAAwmE,UAAAU,EAAAnB,GAEAhnC,EAAAoL,OAAA3nC,EAAAwnC,EAAAvnC,EAAAyC,GACA65B,EAAAqL,iBAAA5nC,EAAAC,EAAAyC,EAAA1C,EAAAC,EAAAyC,EAAA8kC,GACA,WAAA84B,GAAA,SAAAD,GACA7iE,KAAAwmE,UAAAU,EAAAnB,GAEAhnC,EAAAoL,OAAA3nC,EAAAC,EAAAunC,GACAjL,EAAAqL,iBAAA5nC,EAAAC,EAAAD,EAAAwnC,EAAAvnC,GACAs8B,EAAA+L,YAEA/L,EAAAhC,OAEA2nB,EAAAvnB,YAAA,GACA4B,EAAAsM,UAGA/H,KAAA,WACA,GAAAvE,GAAA/+B,KAAAylD,OAAA1mB,IACA2lB,EAAA1kD,KAAAkC,KAEA,QAAAwiD,EAAAnpB,QAAA,CAIA,GAAAwqC,IACA9gE,MAAAy/C,EAAAz/C,MACAC,OAAAw/C,EAAAx/C,QAEAgiE,GACA1kE,EAAAkiD,EAAAliD,EACAC,EAAAiiD,EAAAjiD,GAIA84B,EAAAn1B,KAAAiD,IAAAq7C,EAAAnpB,QAAA,QAAAmpB,EAAAnpB,QAGAmsC,EAAAhjB,EAAAr3B,MAAApsB,QAAAyjD,EAAA4c,WAAArgE,QAAAyjD,EAAA3uB,KAAA90B,QAAAyjD,EAAAmd,UAAA5gE,QAAAyjD,EAAAqd,OAAA9gE,MAEAjB,MAAAuvD,SAAAlwB,SAAAqoC,IAEA1nE,KAAAynE,eAAAP,EAAAxiB,EAAA3lB,EAAAgnC,EAAAxqC,GAGA2rC,EAAA1kE,GAAAkiD,EAAAkc,SACAsG,EAAAzkE,GAAAiiD,EAAAic,SAGA3gE,KAAAinE,UAAAC,EAAAxiB,EAAA3lB,EAAAxD,GAGAv7B,KAAAmnE,SAAAD,EAAAxiB,EAAA3lB,EAAAxD,GAGAv7B,KAAAwnE,WAAAN,EAAAxiB,EAAA3lB,EAAAxD,MAUAw4B,YAAA,SAAAj6C,GACA,GAAA7X,GAAAjC,KACAP,EAAAwC,EAAAstD,SACAuE,GAAA,CA6BA,OA3BA7xD,GAAAojE,YAAApjE,EAAAojE,gBAGA,aAAAvrD,EAAAjZ,KACAoB,EAAA4jE,WAEA5jE,EAAA4jE,QAAA5jE,EAAAwjD,OAAAqN,0BAAAh5C,EAAAra,EAAAqnC,KAAArnC,GAIAq0D,GAAAn0D,EAAAwL,YAAAlJ,EAAA4jE,QAAA5jE,EAAAojE,aAGAvR,IACA7xD,EAAAojE,YAAApjE,EAAA4jE,SAEApmE,EAAA4/B,SAAA5/B,EAAAm2D,UACA3zD,EAAAokE,gBACA7jE,EAAAsX,EAAAtX,EACAC,EAAAqX,EAAArX,GAGAR,EAAA+C,QAAA,GACA/C,EAAAD,UAIA8xD,KAOAh7B,EAAA06B,QAAA4S,aAOAuB,QAAA,SAAAjtD,GACA,IAAAA,EAAAzZ,OACA,QAGA,IAAAV,GAAA2K,EACA1I,EAAA,EACAC,EAAA,EACA0b,EAAA,CAEA,KAAA5d,EAAA,EAAA2K,EAAAwP,EAAAzZ,OAAqCV,EAAA2K,IAAS3K,EAAA,CAC9C,GAAA4zC,GAAAz5B,EAAAna,EACA,IAAA4zC,KAAAzxC,WAAA,CACA,GAAA0nD,GAAAjW,EAAA5xC,iBACAC,IAAA4nD,EAAA5nD,EACAC,GAAA2nD,EAAA3nD,IACA0b,GAIA,OACA3b,EAAA4D,KAAAoT,MAAAhX,EAAA2b,GACA1b,EAAA2D,KAAAoT,MAAA/W,EAAA0b,KAWA1B,QAAA,SAAA/B,EAAAktD,GACA,GAGArnE,GAAA2K,EAAA28D,EAHArlE,EAAAolE,EAAAplE,EACAC,EAAAmlE,EAAAnlE,EACAsY,EAAAC,OAAAC,iBAGA,KAAA1a,EAAA,EAAA2K,EAAAwP,EAAAzZ,OAAqCV,EAAA2K,IAAS3K,EAAA,CAC9C,GAAA4zC,GAAAz5B,EAAAna,EACA,IAAA4zC,KAAAzxC,WAAA,CACA,GAAAyY,GAAAg5B,EAAA/4B,iBACAlO,EAAAvN,EAAAowC,sBAAA63B,EAAAzsD,EAEAjO,GAAA6N,IACAA,EAAA7N,EACA26D,EAAA1zB,IAKA,GAAA0zB,EAAA,CACA,GAAAC,GAAAD,EAAAtlE,iBACAC,GAAAslE,EAAAtlE,EACAC,EAAAqlE,EAAArlE,EAGA,OACAD,IACAC,S/CooWMslE,KACA,SAAUvpE,EAAQc,EAASZ,GAEjC,YgD5iYA,SAAAspE,GAAAC,EAAAC,GACA,GAKAC,GALAh/D,IAMA,IAAA8+D,EAAAG,UAAAH,EAAAG,SAAA,EACAD,EAAAF,EAAAG,aACE,CACF,GAAAC,GAAA1oE,EAAAoyC,QAAAm2B,EAAA7hE,IAAA6hE,EAAAv+D,KAAA,EACAw+D,GAAAxoE,EAAAoyC,QAAAs2B,GAAAJ,EAAAjL,SAAA,OAEA,GAAAsL,GAAAliE,KAAAkD,MAAA4+D,EAAAv+D,IAAAw+D,KACAI,EAAAniE,KAAAu1B,KAAAusC,EAAA7hE,IAAA8hE,IAGAF,GAAAt+D,KAAAs+D,EAAA5hE,KAAA4hE,EAAAG,UAEAzoE,EAAAgvC,aAAAs5B,EAAA5hE,IAAA4hE,EAAAt+D,KAAAs+D,EAAAG,SAAAD,EAAA,OACAG,EAAAL,EAAAt+D,IACA4+D,EAAAN,EAAA5hE,IAIA,IAAAmiE,IAAAD,EAAAD,GAAAH,CAGAK,GADA7oE,EAAA8uC,aAAA+5B,EAAApiE,KAAAoT,MAAAgvD,GAAAL,EAAA,KACA/hE,KAAAoT,MAAAgvD,GAEApiE,KAAAu1B,KAAA6sC,EAGA,IAAAC,GAAA,CACAN,GAAA,IACAM,EAAAriE,KAAA2D,IAAA,GAAAo+D,EAAA59D,WAAAtJ,OAAA,GACAqnE,EAAAliE,KAAAoT,MAAA8uD,EAAAG,KACAF,EAAAniE,KAAAoT,MAAA+uD,EAAAE,MAEAt/D,EAAA5E,SAAAkL,KAAAw4D,EAAAt+D,IAAAs+D,EAAAt+D,IAAA2+D,EACA,QAAAnuD,GAAA,EAAgBA,EAAAquD,IAAeruD,EAC/BhR,EAAA5E,KAAA6B,KAAAoT,OAAA8uD,EAAAnuD,EAAAguD,GAAAM,KAIA,OAFAt/D,GAAA5E,SAAAkL,KAAAw4D,EAAA5hE,IAAA4hE,EAAA5hE,IAAAkiE,GAEAp/D,EArDA,GAAAxJ,GAAAjB,EAAA,KAyDAF,GAAAc,QAAA,SAAAw5B,GAEA,GAAA5uB,GAAAvK,EAAAuK,IAEA4uB,GAAA4vC,gBAAA5vC,EAAA6/B,MAAAj3D,QACAq6D,cAAA,SAAA78D,GACA,uBAAAA,IACAA,EAEA45B,EAAA6/B,MAAA72D,UAAAi6D,cAAAvxD,KAAAxK,KAAAd,IAGAypE,uBAAA,WACA,GAAA1mE,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACA66D,EAAAx7C,EAAA3V,KAKA,IAAAmxD,EAAAzC,YAAA,CACA,GAAA+Q,GAAAjpE,EAAAovC,KAAA9sC,EAAA0H,KACAk/D,EAAAlpE,EAAAovC,KAAA9sC,EAAAoE,IAEAuiE,GAAA,GAAAC,EAAA,EAEA5mE,EAAAoE,IAAA,EACKuiE,EAAA,GAAAC,EAAA,IAEL5mE,EAAA0H,IAAA,GAIA,GAAA4nB,OAAA9hB,KAAA6qD,EAAA3wD,SAAA8F,KAAA6qD,EAAAwO,aACAt3C,MAAA/hB,KAAA6qD,EAAAj0D,SAAAoJ,KAAA6qD,EAAAyO,iBAEAt5D,KAAA6qD,EAAA3wD,IACA1H,EAAA0H,IAAA2wD,EAAA3wD,QACI8F,KAAA6qD,EAAAwO,eACJ,OAAA7mE,EAAA0H,IACA1H,EAAA0H,IAAA2wD,EAAAwO,aAEA7mE,EAAA0H,IAAAvD,KAAAuD,IAAA1H,EAAA0H,IAAA2wD,EAAAwO,mBAIAr5D,KAAA6qD,EAAAj0D,IACApE,EAAAoE,IAAAi0D,EAAAj0D,QACIoJ,KAAA6qD,EAAAyO,eACJ,OAAA9mE,EAAAoE,IACApE,EAAAoE,IAAAi0D,EAAAyO,aAEA9mE,EAAAoE,IAAAD,KAAAC,IAAApE,EAAAoE,IAAAi0D,EAAAyO,eAIAx3C,IAAAC,GAKAvvB,EAAA0H,KAAA1H,EAAAoE,MACAkrB,EACAtvB,EAAAoE,IAAApE,EAAA0H,IAAA,EAEA1H,EAAA0H,IAAA1H,EAAAoE,IAAA,GAKApE,EAAA0H,MAAA1H,EAAAoE,MACApE,EAAAoE,MAEAi0D,EAAAzC,aACA51D,EAAA0H,QAIAq/D,aAAA9+D,EACA++D,yBAAA/+D,EAEAwvD,WAAA,WACA,GAAAz3D,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACA66D,EAAAx7C,EAAA3V,MAMA6zD,EAAA/6D,EAAA+mE,cACAhM,GAAA52D,KAAAC,IAAA,EAAA22D,EAEA,IAAAkM,IACAlM,WACArzD,IAAA2wD,EAAA3wD,IACAtD,IAAAi0D,EAAAj0D,IACA+hE,SAAAzoE,EAAA+K,eAAA4vD,EAAA6O,cAAA7O,EAAA8N,WAEAj/D,EAAAlH,EAAAkH,MAAA6+D,EAAAkB,EAAAjnE,EAEAA,GAAAgnE,2BAIAhnE,EAAAoE,IAAA1G,EAAA0G,IAAA8C,GACAlH,EAAA0H,IAAAhK,EAAAgK,IAAAR,GAEAmxD,EAAA72D,SACA0F,EAAA1F,UAEAxB,EAAA9B,MAAA8B,EAAAoE,IACApE,EAAAmnE,IAAAnnE,EAAA0H,MAEA1H,EAAA9B,MAAA8B,EAAA0H,IACA1H,EAAAmnE,IAAAnnE,EAAAoE,MAGAwzD,qBAAA,WACA,GAAA53D,GAAAjC,IACAiC,GAAAonE,eAAApnE,EAAAkH,MAAA4P,QACA9W,EAAAm8D,cAAAn8D,EAAAkH,MAAAxE,QAAA,GAEAm0B,EAAA6/B,MAAA72D,UAAA+3D,qBAAArvD,KAAAvI,QhD+jYMqnE,KACA,SAAU9qE,EAAQc,EAASZ,GAEjC,YiDtvYAF,GAAAc,QAAA,SAAAw5B,GAGA,GAAAywC,IACAlmE,SAAA,UAGAmmE,EAAA1wC,EAAA6/B,MAAAj3D,QAMA+nE,UAAA,WACA,GAAAz8D,GAAAhN,KAAAmE,MAAA6I,IACA,OAAAhN,MAAAP,QAAAo8B,SAAA77B,KAAAsF,eAAA0H,EAAA08D,QAAA18D,EAAA28D,UAAA38D,EAAA6uB,QAGA09B,oBAAA,WACA,GAAAt3D,GAAAjC,KACA67B,EAAA55B,EAAAwnE,WACAxnE,GAAA2nE,SAAA,EACA3nE,EAAA4nE,SAAAhuC,EAAA56B,OAAA,CACA,IAAAmtC,OAEA3+B,KAAAxN,EAAAxC,QAAA0J,MAAAQ,MAEAykC,EAAAvS,EAAAl3B,QAAA1C,EAAAxC,QAAA0J,MAAAQ,KACA1H,EAAA2nE,UAAA,IAAAx7B,IAAAnsC,EAAA2nE,cAGAn6D,KAAAxN,EAAAxC,QAAA0J,MAAA9C,MAEA+nC,EAAAvS,EAAAl3B,QAAA1C,EAAAxC,QAAA0J,MAAA9C,KACApE,EAAA4nE,UAAA,IAAAz7B,IAAAnsC,EAAA4nE,UAGA5nE,EAAA0H,IAAAkyB,EAAA55B,EAAA2nE,UACA3nE,EAAAoE,IAAAw1B,EAAA55B,EAAA4nE,WAGAnQ,WAAA,WACA,GAAAz3D,GAAAjC,KACA67B,EAAA55B,EAAAwnE,WAEAxnE,GAAAkH,MAAA,IAAAlH,EAAA2nE,UAAA3nE,EAAA4nE,WAAAhuC,EAAA56B,OAAA,EAAA46B,IAAA9iB,MAAA9W,EAAA2nE,SAAA3nE,EAAA4nE,SAAA,IAGA3N,iBAAA,SAAAx3D,EAAAuX,GACA,GAAAha,GAAAjC,KACAgN,EAAA/K,EAAAkC,MAAA6I,KACA1H,EAAArD,EAAAqD,cAEA,OAAA0H,GAAA28D,UAAArkE,EACArD,EAAA85D,cAAA/uD,EAAAqN,SAAA4B,GAAAjP,KAAAtI,IAEAzC,EAAAkH,MAAAzE,EAAAzC,EAAA2nE,WAIAzN,iBAAA,SAAAj9D,EAAAwF,GACA,GAOAolE,GAPA7nE,EAAAjC,KACAorB,EAAAnpB,EAAAxC,QAAA2rB,OAEA2+C,EAAA3jE,KAAAC,IAAApE,EAAA4nE,SAAA,EAAA5nE,EAAA2nE,UAAAx+C,EAAA,OAQA,QAHA3b,KAAAvQ,GAAA,OAAAA,IACA4qE,EAAA7nE,EAAAqD,eAAApG,EAAAsD,EAAAtD,EAAAuD,OAEAgN,KAAAq6D,OAAAr6D,KAAAvQ,GAAAi0B,MAAAzuB,GAAA,CACA,GAAAm3B,GAAA55B,EAAAwnE,WACAvqE,GAAA4qE,GAAA5qE,CACA,IAAA+e,GAAA4d,EAAAl3B,QAAAzF,EACAwF,IAAA,IAAAuZ,IAAAvZ,EAGA,GAAAzC,EAAAqD,eAAA,CACA,GAAA0kE,GAAA/nE,EAAAgD,MAAA8kE,EACAE,EAAAD,GAAAtlE,EAAAzC,EAAA2nE,SAMA,OAJAx+C,KACA6+C,GAAAD,EAAA,GAGA/nE,EAAAkE,KAAAC,KAAAoT,MAAAywD,GAEA,GAAAC,GAAAjoE,EAAAiD,OAAA6kE,EACAI,EAAAD,GAAAxlE,EAAAzC,EAAA2nE,SAMA,OAJAx+C,KACA++C,GAAAD,EAAA,GAGAjoE,EAAA0E,IAAAP,KAAAoT,MAAA2wD,IAEA9S,gBAAA,SAAA3yD,GACA,MAAA1E,MAAAm8D,iBAAAn8D,KAAAmJ,MAAAzE,KAAA1E,KAAA4pE,SAAA,OAEAxN,iBAAA,SAAAE,GACA,GAAAr6D,GAAAjC,KACAorB,EAAAnpB,EAAAxC,QAAA2rB,OAEA2+C,EAAA3jE,KAAAC,IAAApE,EAAA42D,OAAA53D,QAAAmqB,EAAA,QACAg/C,EAAAnoE,EAAAqD,eACA+kE,GAAAD,EAAAnoE,EAAAgD,MAAAhD,EAAAiD,QAAA6kE,CAcA,OAZAzN,IAAA8N,EAAAnoE,EAAAkE,KAAAlE,EAAA0E,IAEAykB,IACAkxC,GAAA+N,EAAA,IAGA/N,GAAA,EACA,EAEAl2D,KAAAoT,MAAA8iD,EAAA+N,IAGApoE,EAAA2nE,UAEAjN,aAAA,WACA,MAAA38D,MAAA4G,SAIAkyB,GAAA+U,aAAA8oB,kBAAA,WAAA6S,EAAAD,KjDgwYMe,KACA,SAAU9rE,EAAQc,EAASZ,GAEjC,YkDn4YA,IAAAuF,GAAAvF,EAAA,MACAiB,EAAAjB,EAAA,MACAsnC,EAAAtnC,EAAA,KAEAF,GAAAc,QAAA,SAAAw5B,GAEA,GAAAywC,IACAlmE,SAAA,OACA8F,OACA0B,SAAAm7B,EAAAj9B,WAAAE,SAIAshE,EAAAzxC,EAAA4vC,gBAAAhnE,QAEA63D,oBAAA,WAUA,QAAAiR,GAAAtwD,GACA,MAAA5U,GAAA4U,EAAA+4C,UAAAhxD,EAAAmI,GAAA8P,EAAAg5C,UAAAjxD,EAAAmI,GAVA,GAAAnI,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACA0E,EAAAlC,EAAAkC,MACA6I,EAAA7I,EAAA6I,KACAqN,EAAArN,EAAAqN,SACA/U,EAAArD,EAAAqD,cASArD,GAAA0H,IAAA,KACA1H,EAAAoE,IAAA,IAEA,IAAAokE,GAAA3rD,EAAA+S,OAeA,QAdApiB,KAAAg7D,GACA9qE,EAAAsI,KAAAoS,EAAA,SAAA2B,EAAAC,GACA,IAAAwuD,EAAA,CAIA,GAAAvwD,GAAA/V,EAAAoW,eAAA0B,EACA9X,GAAAmW,iBAAA2B,IAAAuuD,EAAAtwD,QACAzK,KAAAyK,EAAAkjB,QACAqtC,GAAA,MAKA3rD,EAAA+S,SAAA44C,EAAA,CACA,GAAAC,KAEA/qE,GAAAsI,KAAAoS,EAAA,SAAA2B,EAAAC,GACA,GAAA/B,GAAA/V,EAAAoW,eAAA0B,GACAxb,GACAyZ,EAAArZ,SAEA4O,KAAAqP,EAAA+S,aAAApiB,KAAAyK,EAAAkjB,MAAAnhB,EAAA,GACA/B,EAAAkjB,OACAnc,KAAA,SAEAxR,KAAAi7D,EAAAjqE,KACAiqE,EAAAjqE,IACAkqE,kBACAl6C,mBAKA,IAAAk6C,GAAAD,EAAAjqE,GAAAkqE,eACAl6C,EAAAi6C,EAAAjqE,GAAAgwB,cAEAtsB,GAAAmW,iBAAA2B,IAAAuuD,EAAAtwD,IACAva,EAAAsI,KAAA+T,EAAAhP,KAAA,SAAAgvD,EAAAt3D,GACA,GAAAxF,IAAA+C,EAAA85D,cAAAC,EACA7oC,OAAAj0B,IAAAgb,EAAAlN,KAAAtI,GAAA3C,SAIA4oE,EAAAjmE,GAAAimE,EAAAjmE,IAAA,EACA+rB,EAAA/rB,GAAA+rB,EAAA/rB,IAAA,EAEAoa,EAAA8rD,eACAD,EAAAjmE,GAAA,IACQxF,EAAA,EACRuxB,EAAA/rB,IAAAxF,EAEAyrE,EAAAjmE,IAAAxF,OAMAS,EAAAsI,KAAAyiE,EAAA,SAAAG,GACA,GAAA/qE,GAAA+qE,EAAAF,eAAAziE,OAAA2iE,EAAAp6C,gBACAq6C,EAAAnrE,EAAAgK,IAAA7J,GACAirE,EAAAprE,EAAA0G,IAAAvG,EACAmC,GAAA0H,IAAA,OAAA1H,EAAA0H,IAAAmhE,EAAA1kE,KAAAuD,IAAA1H,EAAA0H,IAAAmhE,GACA7oE,EAAAoE,IAAA,OAAApE,EAAAoE,IAAA0kE,EAAA3kE,KAAAC,IAAApE,EAAAoE,IAAA0kE,SAIAprE,GAAAsI,KAAAoS,EAAA,SAAA2B,EAAAC,GACA,GAAA/B,GAAA/V,EAAAoW,eAAA0B,EACA9X,GAAAmW,iBAAA2B,IAAAuuD,EAAAtwD,IACAva,EAAAsI,KAAA+T,EAAAhP,KAAA,SAAAgvD,EAAAt3D,GACA,GAAAxF,IAAA+C,EAAA85D,cAAAC,EACA7oC,OAAAj0B,IAAAgb,EAAAlN,KAAAtI,GAAA3C,SAIA,OAAAE,EAAA0H,IACA1H,EAAA0H,IAAAzK,EACQA,EAAA+C,EAAA0H,MACR1H,EAAA0H,IAAAzK,GAGA,OAAA+C,EAAAoE,IACApE,EAAAoE,IAAAnH,EACQA,EAAA+C,EAAAoE,MACRpE,EAAAoE,IAAAnH,OAOA+C,GAAA0H,IAAApI,SAAAU,EAAA0H,OAAAwpB,MAAAlxB,EAAA0H,KAAA1H,EAAA0H,IAxGA,EAyGA1H,EAAAoE,IAAA9E,SAAAU,EAAAoE,OAAA8sB,MAAAlxB,EAAAoE,KAAApE,EAAAoE,IAxGA,EA2GArG,KAAA2oE,0BAEAK,aAAA,WACA,GAAAhM,GACA/6D,EAAAjC,KACAs6D,EAAAr4D,EAAAxC,QAAA0J,KAEA,IAAAlH,EAAAqD,eACA03D,EAAA52D,KAAAuD,IAAA2wD,EAAA3/B,cAAA2/B,EAAA3/B,cAAA,GAAAv0B,KAAAu1B,KAAA15B,EAAAgD,MAAA,SACI,CAEJ,GAAA+lE,GAAArrE,EAAA+K,eAAA4vD,EAAA5rC,SAAAzqB,EAAA8a,OAAAooB,gBACA61B,GAAA52D,KAAAuD,IAAA2wD,EAAA3/B,cAAA2/B,EAAA3/B,cAAA,GAAAv0B,KAAAu1B,KAAA15B,EAAAiD,QAAA,EAAA8lE,KAGA,MAAAhO,IAGAiM,yBAAA,WACAjpE,KAAAsF,gBAEAtF,KAAAmJ,MAAA1F,WAGAy4D,iBAAA,SAAAx3D,EAAAuX,GACA,OAAAjc,KAAA+7D,cAAA/7D,KAAAmE,MAAA6I,KAAAqN,SAAA4B,GAAAjP,KAAAtI,KAGAy3D,iBAAA,SAAAj9D,GAGA,GAAA+C,GAAAjC,KACAG,EAAA8B,EAAA9B,MAEA8qE,GAAAhpE,EAAA85D,cAAA78D,GAEA8yC,EAAA/vC,EAAAmnE,IAAAjpE,CAOA,OALA8B,GAAAqD,eACArD,EAAAkE,KAAAlE,EAAAgD,MAAA+sC,GAAAi5B,EAAA9qE,GAEA8B,EAAA2E,OAAA3E,EAAAiD,OAAA8sC,GAAAi5B,EAAA9qE,IAIAi8D,iBAAA,SAAAE,GACA,GAAAr6D,GAAAjC,KACAsF,EAAArD,EAAAqD,eACA4lE,EAAA5lE,EAAArD,EAAAgD,MAAAhD,EAAAiD,OACAkmB,GAAA9lB,EAAAg3D,EAAAr6D,EAAAkE,KAAAlE,EAAA2E,OAAA01D,GAAA4O,CACA,OAAAjpE,GAAA9B,OAAA8B,EAAAmnE,IAAAnnE,EAAA9B,OAAAirB,GAEAisC,gBAAA,SAAA3yD,GACA,MAAA1E,MAAAm8D,iBAAAn8D,KAAAqpE,eAAA3kE,MAGAo0B,GAAA+U,aAAA8oB,kBAAA,SAAA4T,EAAAhB,KlD64YM4B,KACA,SAAU3sE,EAAQc,EAASZ,GAEjC,YmDjkZA,SAAAspE,GAAAC,EAAAC,GACA,GAWAkD,GAAAC,EAXAliE,KACAuB,EAAA/K,EAAA+K,eAMA4gE,EAAA5gE,EAAAu9D,EAAAt+D,IAAAvD,KAAA2D,IAAA,GAAA3D,KAAAkD,MAAA3J,EAAA6J,MAAA0+D,EAAAv+D,QAEA4hE,EAAAnlE,KAAAkD,MAAA3J,EAAA6J,MAAA0+D,EAAA7hE,MACAmlE,EAAAplE,KAAAu1B,KAAAusC,EAAA7hE,IAAAD,KAAA2D,IAAA,GAAAwhE,GAGA,KAAAD,GACAF,EAAAhlE,KAAAkD,MAAA3J,EAAA6J,MAAA0+D,EAAAuD,aACAJ,EAAAjlE,KAAAkD,MAAA4+D,EAAAuD,WAAArlE,KAAA2D,IAAA,GAAAqhE,IAEAjiE,EAAA5E,KAAA+mE,GACAA,EAAAD,EAAAjlE,KAAA2D,IAAA,GAAAqhE,KAEAA,EAAAhlE,KAAAkD,MAAA3J,EAAA6J,MAAA8hE,IACAD,EAAAjlE,KAAAkD,MAAAgiE,EAAAllE,KAAA2D,IAAA,GAAAqhE,IAEA,IAAA3C,GAAA2C,EAAA,EAAAhlE,KAAA2D,IAAA,GAAA3D,KAAAiD,IAAA+hE,IAAA,CAEA,IACAjiE,EAAA5E,KAAA+mE,KAEAD,EACA,KAAAA,IACAA,EAAA,IACAD,EACA3C,EAAA2C,GAAA,IAAA3C,GAGA6C,EAAAllE,KAAAoT,MAAA6xD,EAAAjlE,KAAA2D,IAAA,GAAAqhE,GAAA3C,WACE2C,EAAAG,GAAAH,IAAAG,GAAAF,EAAAG,EAEF,IAAAE,GAAAhhE,EAAAu9D,EAAA5hE,IAAAilE,EAGA,OAFAniE,GAAA5E,KAAAmnE,GAEAviE,EAnDA,GAAAxJ,GAAAjB,EAAA,MACAsnC,EAAAtnC,EAAA,KAsDAF,GAAAc,QAAA,SAAAw5B,GAEA,GAAAywC,IACAlmE,SAAA,OAGA8F,OACA0B,SAAAm7B,EAAAj9B,WAAAc,cAIA8hE,EAAA7yC,EAAA6/B,MAAAj3D,QACA63D,oBAAA,WAOA,QAAAiR,GAAAtwD,GACA,MAAA5U,GAAA4U,EAAA+4C,UAAAhxD,EAAAmI,GAAA8P,EAAAg5C,UAAAjxD,EAAAmI,GAPA,GAAAnI,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACA0E,EAAAlC,EAAAkC,MACA6I,EAAA7I,EAAA6I,KACAqN,EAAArN,EAAAqN,SACA/U,EAAArD,EAAAqD,cAMArD,GAAA0H,IAAA,KACA1H,EAAAoE,IAAA,KACApE,EAAAwpE,WAAA,IAEA,IAAAhB,GAAA3rD,EAAA+S,OAeA,QAdApiB,KAAAg7D,GACA9qE,EAAAsI,KAAAoS,EAAA,SAAA2B,EAAAC,GACA,IAAAwuD,EAAA,CAIA,GAAAvwD,GAAA/V,EAAAoW,eAAA0B,EACA9X,GAAAmW,iBAAA2B,IAAAuuD,EAAAtwD,QACAzK,KAAAyK,EAAAkjB,QACAqtC,GAAA,MAKA3rD,EAAA+S,SAAA44C,EAAA,CACA,GAAAC,KAEA/qE,GAAAsI,KAAAoS,EAAA,SAAA2B,EAAAC,GACA,GAAA/B,GAAA/V,EAAAoW,eAAA0B,GACAxb,GACAyZ,EAAArZ,SAEA4O,KAAAqP,EAAA+S,aAAApiB,KAAAyK,EAAAkjB,MAAAnhB,EAAA,GACA/B,EAAAkjB,OACAnc,KAAA,IAEA9c,GAAAmW,iBAAA2B,IAAAuuD,EAAAtwD,SACAzK,KAAAi7D,EAAAjqE,KACAiqE,EAAAjqE,OAGAd,EAAAsI,KAAA+T,EAAAhP,KAAA,SAAAgvD,EAAAt3D,GACA,GAAA5E,GAAA4qE,EAAAjqE,GACAvB,GAAA+C,EAAA85D,cAAAC,EAEA7oC,OAAAj0B,IAAAgb,EAAAlN,KAAAtI,GAAA3C,QAAA7C,EAAA,IAGAY,EAAA4E,GAAA5E,EAAA4E,IAAA,EACA5E,EAAA4E,IAAAxF,QAKAS,EAAAsI,KAAAyiE,EAAA,SAAAG,GACA,GAAAA,EAAA5pE,OAAA,GACA,GAAA6pE,GAAAnrE,EAAAgK,IAAAkhE,GACAE,EAAAprE,EAAA0G,IAAAwkE,EACA5oE,GAAA0H,IAAA,OAAA1H,EAAA0H,IAAAmhE,EAAA1kE,KAAAuD,IAAA1H,EAAA0H,IAAAmhE,GACA7oE,EAAAoE,IAAA,OAAApE,EAAAoE,IAAA0kE,EAAA3kE,KAAAC,IAAApE,EAAAoE,IAAA0kE,UAKAprE,GAAAsI,KAAAoS,EAAA,SAAA2B,EAAAC,GACA,GAAA/B,GAAA/V,EAAAoW,eAAA0B,EACA9X,GAAAmW,iBAAA2B,IAAAuuD,EAAAtwD,IACAva,EAAAsI,KAAA+T,EAAAhP,KAAA,SAAAgvD,EAAAt3D,GACA,GAAAxF,IAAA+C,EAAA85D,cAAAC,EAEA7oC,OAAAj0B,IAAAgb,EAAAlN,KAAAtI,GAAA3C,QAAA7C,EAAA,IAIA,OAAA+C,EAAA0H,IACA1H,EAAA0H,IAAAzK,EACQA,EAAA+C,EAAA0H,MACR1H,EAAA0H,IAAAzK,GAGA,OAAA+C,EAAAoE,IACApE,EAAAoE,IAAAnH,EACQA,EAAA+C,EAAAoE,MACRpE,EAAAoE,IAAAnH,GAGA,IAAAA,IAAA,OAAA+C,EAAAwpE,YAAAvsE,EAAA+C,EAAAwpE,cACAxpE,EAAAwpE,WAAAvsE,OAQAc,MAAA2oE,0BAEAA,uBAAA,WACA,GAAA1mE,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACA66D,EAAAx7C,EAAA3V,MACAuB,EAAA/K,EAAA+K,cAIAzI,GAAA0H,IAAAe,EAAA4vD,EAAA3wD,IAAA1H,EAAA0H,KACA1H,EAAAoE,IAAAqE,EAAA4vD,EAAAj0D,IAAApE,EAAAoE,KAEApE,EAAA0H,MAAA1H,EAAAoE,MACA,IAAApE,EAAA0H,KAAA,OAAA1H,EAAA0H,KACA1H,EAAA0H,IAAAvD,KAAA2D,IAAA,GAAA3D,KAAAkD,MAAA3J,EAAA6J,MAAAvH,EAAA0H,MAAA,GACA1H,EAAAoE,IAAAD,KAAA2D,IAAA,GAAA3D,KAAAkD,MAAA3J,EAAA6J,MAAAvH,EAAAoE,MAAA,KAEApE,EAAA0H,IAXA,EAYA1H,EAAAoE,IAXA,KAcA,OAAApE,EAAA0H,MACA1H,EAAA0H,IAAAvD,KAAA2D,IAAA,GAAA3D,KAAAkD,MAAA3J,EAAA6J,MAAAvH,EAAAoE,MAAA,IAEA,OAAApE,EAAAoE,MACApE,EAAAoE,IAAA,IAAApE,EAAA0H,IACAvD,KAAA2D,IAAA,GAAA3D,KAAAkD,MAAA3J,EAAA6J,MAAAvH,EAAA0H,MAAA,GAnBA,IAsBA,OAAA1H,EAAAwpE,aACAxpE,EAAA0H,IAAA,EACA1H,EAAAwpE,WAAAxpE,EAAA0H,IACK1H,EAAAoE,IAAA,EACLpE,EAAAwpE,WAAArlE,KAAA2D,IAAA,GAAA3D,KAAAkD,MAAA3J,EAAA6J,MAAAvH,EAAAoE,OAEApE,EAAAwpE,WA7BA,IAiCA/R,WAAA,WACA,GAAAz3D,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACA66D,EAAAx7C,EAAA3V,MACA1F,GAAAxB,EAAAqD,eAEA2iE,GACAt+D,IAAA2wD,EAAA3wD,IACAtD,IAAAi0D,EAAAj0D,KAEA8C,EAAAlH,EAAAkH,MAAA6+D,EAAAC,EAAAhmE,EAIAA,GAAAoE,IAAA1G,EAAA0G,IAAA8C,GACAlH,EAAA0H,IAAAhK,EAAAgK,IAAAR,GAEAmxD,EAAA72D,SACAA,KACAxB,EAAA9B,MAAA8B,EAAAoE,IACApE,EAAAmnE,IAAAnnE,EAAA0H,MAEA1H,EAAA9B,MAAA8B,EAAA0H,IACA1H,EAAAmnE,IAAAnnE,EAAAoE,KAEA5C,GACA0F,EAAA1F,WAGAo2D,qBAAA,WACA75D,KAAA4rE,WAAA5rE,KAAAmJ,MAAA4P,QAEA+f,EAAA6/B,MAAA72D,UAAA+3D,qBAAArvD,KAAAxK,OAGAk8D,iBAAA,SAAAx3D,EAAAuX,GACA,OAAAjc,KAAA+7D,cAAA/7D,KAAAmE,MAAA6I,KAAAqN,SAAA4B,GAAAjP,KAAAtI,KAEA2yD,gBAAA,SAAA3yD,GACA,MAAA1E,MAAAm8D,iBAAAn8D,KAAA4rE,WAAAlnE,KAQAmnE,mBAAA,SAAA3sE,GACA,GAAAksE,GAAAhlE,KAAAkD,MAAA3J,EAAA6J,MAAAtK,GAGA,OAFAkH,MAAAkD,MAAApK,EAAAkH,KAAA2D,IAAA,GAAAqhE,IAEAhlE,KAAA2D,IAAA,GAAAqhE,IAEAjP,iBAAA,SAAAj9D,GACA,GAKAgsE,GAAA5O,EAAAn8D,EAAAipE,EAAAr6B,EALA9sC,EAAAjC,KACAyD,EAAAxB,EAAAxC,QAAA0J,MAAA1F,QACA+F,EAAA7J,EAAA6J,MACAsiE,EAAA7pE,EAAA4pE,mBAAA5pE,EAAAwpE,YACArgD,EAAA,CAmCA,OAhCAlsB,IAAA+C,EAAA85D,cAAA78D,GACAuE,GACAtD,EAAA8B,EAAAmnE,IACAA,EAAAnnE,EAAA9B,MACA4uC,GAAA,IAEA5uC,EAAA8B,EAAA9B,MACAipE,EAAAnnE,EAAAmnE,IACAr6B,EAAA,GAEA9sC,EAAAqD,gBACA4lE,EAAAjpE,EAAAgD,MACAq3D,EAAA74D,EAAAxB,EAAAuE,MAAAvE,EAAAkE,OAEA+kE,EAAAjpE,EAAAiD,OACA6pC,IAAA,EACAutB,EAAA74D,EAAAxB,EAAA0E,IAAA1E,EAAA2E,QAEA1H,IAAAiB,IACA,IAAAA,IACAirB,EAAAzrB,EAAA8M,kBACAxK,EAAAxC,QAAA0J,MAAAulB,SACAoK,EAAA70B,SAAA8a,OAAAooB,iBAEA+jC,GAAA9/C,EACAjrB,EAAA2rE,GAEA,IAAA5sE,IACAksB,GAAA8/C,GAAA1hE,EAAA4/D,GAAA5/D,EAAArJ,KAAAqJ,EAAAtK,GAAAsK,EAAArJ,KAEAm8D,GAAAvtB,EAAA3jB,GAEAkxC,GAEAF,iBAAA,SAAAE,GACA,GAIA4O,GAAA/qE,EAAAipE,EAAAlqE,EAJA+C,EAAAjC,KACAyD,EAAAxB,EAAAxC,QAAA0J,MAAA1F,QACA+F,EAAA7J,EAAA6J,MACAsiE,EAAA7pE,EAAA4pE,mBAAA5pE,EAAAwpE,WAiBA,IAdAhoE,GACAtD,EAAA8B,EAAAmnE,IACAA,EAAAnnE,EAAA9B,QAEAA,EAAA8B,EAAA9B,MACAipE,EAAAnnE,EAAAmnE,KAEAnnE,EAAAqD,gBACA4lE,EAAAjpE,EAAAgD,MACA/F,EAAAuE,EAAAxB,EAAAuE,MAAA81D,IAAAr6D,EAAAkE,OAEA+kE,EAAAjpE,EAAAiD,OACAhG,EAAAuE,EAAA64D,EAAAr6D,EAAA0E,IAAA1E,EAAA2E,OAAA01D,GAEAp9D,IAAAiB,EAAA,CACA,OAAAA,EAAA,CACA,GAAAirB,GAAAzrB,EAAA8M,kBACAxK,EAAAxC,QAAA0J,MAAAulB,SACAoK,EAAA70B,SAAA8a,OAAAooB,gBAEAjoC,IAAAksB,EACA8/C,GAAA9/C,EACAjrB,EAAA2rE,EAEA5sE,GAAAsK,EAAA4/D,GAAA5/D,EAAArJ,GACAjB,GAAAgsE,EACAhsE,EAAAkH,KAAA2D,IAAA,GAAAP,EAAArJ,GAAAjB,GAEA,MAAAA,KAGA45B,GAAA+U,aAAA8oB,kBAAA,cAAAgV,EAAApC,KnDolZMwC,KACA,SAAUvtE,EAAQc,EAASZ,GAEjC,YoD76ZA,IAAAuF,GAAAvF,EAAA,MACAiB,EAAAjB,EAAA,MACAsnC,EAAAtnC,EAAA,KAEAF,GAAAc,QAAA,SAAAw5B,GAoDA,QAAAkzC,GAAAj+B,GACA,GAAAjvB,GAAAivB,EAAAtuC,OACA,OAAAqf,GAAAmtD,WAAA3+C,SAAAxO,EAAAotD,YAAA5+C,QAAAygB,EAAA5pC,MAAA6I,KAAA6uB,OAAA56B,OAAA,EAGA,QAAAkrE,GAAAp+B,GACA,GAAAq+B,GAAAr+B,EAAAtuC,QAAAysE,YACAx9C,EAAA/uB,EAAA+K,eAAA0hE,EAAA19C,SAAAu3B,EAAA9e,iBACA0N,EAAAl1C,EAAA+K,eAAA0hE,EAAAv3B,UAAAoR,EAAA7e,kBACAzY,EAAAhvB,EAAA+K,eAAA0hE,EAAAz9C,WAAAs3B,EAAA/e,kBAGA,QACAwD,KAAAhc,EACA5I,MAAA+uB,EACA4jB,OAAA9pC,EACAomB,KANAp1C,EAAAg1C,WAAAjmB,EAAAmmB,EAAAlmB,IAUA,QAAA09C,GAAAttC,EAAArQ,EAAArS,GACA,MAAA1c,GAAAqJ,QAAAqT,IAEArH,EAAArV,EAAAm1C,YAAA/V,IAAAgW,KAAA14B,GACA43B,EAAA53B,EAAApb,OAAAytB,EAAA,KAAArS,EAAApb,OAAA,GAAAytB,IAKA1Z,EAAA+pB,EAAAsW,YAAAh5B,GAAApX,MACAgvC,EAAAvlB,GAIA,QAAA49C,GAAAz8B,EAAAua,EAAA1f,EAAA/gC,EAAAtD,GACA,MAAAwpC,KAAAlmC,GAAAkmC,IAAAxpC,GAEAlG,MAAAiqD,EAAA1f,EAAA,EACA0+B,IAAAhf,EAAA1f,EAAA,GAEGmF,EAAAlmC,GAAAkmC,EAAAxpC,GAEHlG,MAAAiqD,EAAA1f,EAAA,EACA0+B,IAAAhf,IAKAjqD,MAAAiqD,EACAgf,IAAAhf,EAAA1f,EAAA,GAOA,QAAA6hC,GAAAx+B,GA6BA,GAYAxtC,GAAAisE,EAAAC,EAZAC,EAAAP,EAAAp+B,GAIA4+B,EAAAvmE,KAAAuD,IAAAokC,EAAA7oC,OAAA,EAAA6oC,EAAA9oC,MAAA,GACA2nE,GACAh4D,EAAAm5B,EAAA9oC,MACA6P,EAAA,EACA2yB,EAAAsG,EAAA7oC,OACArB,EAAA,GAEAgpE,IAGA9+B,GAAAhP,IAAAgW,KAAA23B,EAAA33B,KACAhH,EAAA++B,mBAEA,IAAAC,GAAAf,EAAAj+B,EACA,KAAAxtC,EAAA,EAAaA,EAAAwsE,EAAgBxsE,IAAA,CAC7BksE,EAAA1+B,EAAAi/B,iBAAAzsE,EAAAosE,GACAH,EAAAH,EAAAt+B,EAAAhP,IAAA2tC,EAAAhiC,KAAAqD,EAAAm+B,YAAA3rE,IAAA,IACAwtC,EAAA++B,iBAAAvsE,GAAAisE,CAGA,IAAA1R,GAAA/sB,EAAAk/B,cAAA1sE,GACAsvC,EAAAlwC,EAAA0vC,UAAAyrB,GAAA,IACAoS,EAAAZ,EAAAz8B,EAAA48B,EAAAjqE,EAAAgqE,EAAAx3D,EAAA,OACAm4D,EAAAb,EAAAz8B,EAAA48B,EAAAhqE,EAAA+pE,EAAAv4B,EAAA,OAEAi5B,GAAA/sE,MAAAysE,EAAA93D,IACA83D,EAAA93D,EAAAo4D,EAAA/sE,MACA0sE,EAAA/3D,EAAAgmD,GAGAoS,EAAA9D,IAAAwD,EAAAh4D,IACAg4D,EAAAh4D,EAAAs4D,EAAA9D,IACAyD,EAAAj4D,EAAAkmD,GAGAqS,EAAAhtE,MAAAysE,EAAAnlC,IACAmlC,EAAAnlC,EAAA0lC,EAAAhtE,MACA0sE,EAAAplC,EAAAqzB,GAGAqS,EAAA/D,IAAAwD,EAAA/oE,IACA+oE,EAAA/oE,EAAAspE,EAAA/D,IACAyD,EAAAhpE,EAAAi3D,GAIA/sB,EAAAq/B,cAAAT,EAAAC,EAAAC,GAMA,QAAA1S,GAAApsB,GACA,GAAA4+B,GAAAvmE,KAAAuD,IAAAokC,EAAA7oC,OAAA,EAAA6oC,EAAA9oC,MAAA,EACA8oC,GAAAs/B,YAAAjnE,KAAAoT,MAAAmzD,GACA5+B,EAAAu/B,eAAA,SAGA,QAAAC,GAAA19B,GACA,WAAAA,GAAA,MAAAA,EACA,SACGA,EAAA,IACH,OAGA,QAGA,QAAA4vB,GAAA1gC,EAAAxR,EAAAlqB,EAAAqrB,GACA,GAAA/uB,EAAAqJ,QAAAukB,GAIA,OAHA9qB,GAAAY,EAAAZ,EACA0lE,EAAA,IAAAz5C,EAEAnuB,EAAA,EAAkBA,EAAAgtB,EAAAtsB,SAAiBV,EACnCw+B,EAAA0gC,SAAAlyC,EAAAhtB,GAAA8C,EAAAb,EAAAC,GACAA,GAAA0lE,MAGAppC,GAAA0gC,SAAAlyC,EAAAlqB,EAAAb,EAAAa,EAAAZ,GAIA,QAAA+qE,GAAA39B,EAAA28B,EAAAnpE,GACA,KAAAwsC,GAAA,MAAAA,EACAxsC,EAAAZ,GAAA+pE,EAAAv4B,EAAA,GACGpE,EAAA,KAAAA,EAAA,MACHxsC,EAAAZ,GAAA+pE,EAAAv4B,GAIA,QAAAw5B,GAAA1/B,GACA,GAAAhP,GAAAgP,EAAAhP,IACAjgB,EAAAivB,EAAAtuC,QACAiuE,EAAA5uD,EAAAmtD,WACA0B,EAAA7uD,EAAAotD,WAEAntC,GAAA8mB,UAAA6nB,EAAA7nB,UACA9mB,EAAA6mB,YAAA8nB,EAAAvsE,KAEA,IAAAysE,GAAA7/B,EAAA8/B,8BAAA/uD,EAAA3V,MAAA1F,QAAAsqC,EAAApkC,IAAAokC,EAAA1nC,KAGAqmE,EAAAP,EAAAp+B,EAEAhP,GAAA4/B,aAAA,KAEA,QAAAp+D,GAAAyrE,EAAAj+B,GAAA,EAAwCxtC,GAAA,EAAQA,IAAA,CAChD,GAAAmtE,EAAApgD,QAAA,CACA,GAAAwgD,GAAA//B,EAAAi/B,iBAAAzsE,EAAAqtE,EACA7uC,GAAA6L,YACA7L,EAAA9Y,OAAA8nB,EAAAggC,QAAAhgC,EAAAigC,SACAjvC,EAAAoL,OAAA2jC,EAAAtrE,EAAAsrE,EAAArrE,GACAs8B,EAAAsM,SACAtM,EAAA+L,YAGA,GAAA6iC,EAAArgD,QAAA,CAEA,GAAA2gD,GAAAlgC,EAAAi/B,iBAAAzsE,EAAAqtE,EAAA,GAGAM,EAAAvuE,EAAAiL,sBAAA+iE,EAAAjgD,UAAAntB,EAAA0lD,EAAAhf,iBACAlI,GAAAgW,KAAA23B,EAAA33B,KACAhW,EAAA+mB,UAAAooB,CAEA,IAAApT,GAAA/sB,EAAAk/B,cAAA1sE,GACAsvC,EAAAlwC,EAAA0vC,UAAAyrB,EACA/7B,GAAAtQ,UAAA8+C,EAAA19B,GACA29B,EAAA39B,EAAA9B,EAAA++B,iBAAAvsE,GAAA0tE,GACAxO,EAAA1gC,EAAAgP,EAAAm+B,YAAA3rE,IAAA,GAAA0tE,EAAAvB,EAAAhiC,QAKA,QAAAyjC,GAAApgC,EAAAitB,EAAAhxB,EAAAtlC,GACA,GAAAq6B,GAAAgP,EAAAhP,GAIA,IAHAA,EAAA6mB,YAAAjmD,EAAAiL,sBAAAowD,EAAA75D,MAAAuD,EAAA,GACAq6B,EAAA8mB,UAAAlmD,EAAAiL,sBAAAowD,EAAAnV,UAAAnhD,EAAA,GAEAqpC,EAAAtuC,QAAAq7B,UAAAszC,SAEArvC,EAAA6L,YACA7L,EAAA8L,IAAAkD,EAAAggC,QAAAhgC,EAAAigC,QAAAhkC,EAAA,IAAA5jC,KAAAoiC,IACAzJ,EAAA+L,YACA/L,EAAAsM,aACG,CAEH,GAAA0hC,GAAAf,EAAAj+B,EAEA,QAAAg/B,EACA,MAGAhuC,GAAA6L,WACA,IAAA6hC,GAAA1+B,EAAAi/B,iBAAA,EAAAhjC,EACAjL,GAAA9Y,OAAAwmD,EAAAjqE,EAAAiqE,EAAAhqE,EAEA,QAAAlC,GAAA,EAAkBA,EAAAwsE,EAAgBxsE,IAClCksE,EAAA1+B,EAAAi/B,iBAAAzsE,EAAAypC,GACAjL,EAAAoL,OAAAsiC,EAAAjqE,EAAAiqE,EAAAhqE,EAGAs8B,GAAA+L,YACA/L,EAAAsM,UAIA,QAAAgjC,GAAAC,GACA,MAAA3uE,GAAAgD,SAAA2rE,KAAA,EAnTA,GAAAroB,GAAAhiD,EAAA8a,OAEAwqD,GACAj8C,SAAA,EAGAihD,SAAA,EACAlrE,SAAA,YAEA4oE,YACA3+C,SAAA,EACAnsB,MAAA,qBACA0kD,UAAA,GAGA/qB,WACAszC,UAAA,GAIAjlE,OAEAqlE,mBAAA,EAGAC,cAAA,yBAGAC,iBAAA,EAGAC,iBAAA,EAEA9jE,SAAAm7B,EAAAj9B,WAAAE,QAGAijE,aAEA5+C,SAAA,EAGAoB,SAAA,GAGA7jB,SAAA,SAAAwR,GACA,MAAAA,MAyQAuyD,EAAA91C,EAAA4vC,gBAAAhnE,QACA03D,cAAA,WACA,GAAAn3D,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACA66D,EAAAx7C,EAAA3V,KAEAlH,GAAAgD,MAAAhD,EAAA82D,SACA92D,EAAAiD,OAAAjD,EAAA+2D,UACA/2D,EAAA8rE,QAAA3nE,KAAAoT,MAAAvX,EAAAgD,MAAA,GACAhD,EAAA+rE,QAAA5nE,KAAAoT,MAAAvX,EAAAiD,OAAA,EAEA,IAAAG,GAAA1F,EAAAgK,KAAA1H,EAAAiD,OAAAjD,EAAAgD,QACA+lE,EAAArrE,EAAA+K,eAAA4vD,EAAA5rC,SAAAu3B,EAAA9e,gBACAllC,GAAAorE,YAAAvuD,EAAAwO,QAAAjoB,EAAA,GAAA2lE,EAAA,EAAA1Q,EAAAoU,kBAAArpE,EAAA,GAEAk0D,oBAAA,WACA,GAAAt3D,GAAAjC,KACAmE,EAAAlC,EAAAkC,MACAwF,EAAAqR,OAAAC,kBACA5U,EAAA2U,OAAA8zB,iBAEAnvC,GAAAsI,KAAA9D,EAAA6I,KAAAqN,SAAA,SAAA2B,EAAAC,GACA,GAAA9X,EAAAmW,iBAAA2B,GAAA,CACA,GAAA/B,GAAA/V,EAAAoW,eAAA0B,EAEAtc,GAAAsI,KAAA+T,EAAAhP,KAAA,SAAAgvD,EAAAt3D,GACA,GAAAxF,IAAA+C,EAAA85D,cAAAC,EACA7oC,OAAAj0B,IAAAgb,EAAAlN,KAAAtI,GAAA3C,SAIA4H,EAAAvD,KAAAuD,IAAAzK,EAAAyK,GACAtD,EAAAD,KAAAC,IAAAnH,EAAAmH,SAKApE,EAAA0H,QAAAqR,OAAAC,kBAAA,EAAAtR,EACA1H,EAAAoE,QAAA2U,OAAA8zB,kBAAA,EAAAzoC,EAGApE,EAAA0mE,0BAEAK,aAAA,WACA,GAAA1O,GAAAt6D,KAAAP,QAAA0J,MACA6hE,EAAArrE,EAAA+K,eAAA4vD,EAAA5rC,SAAAu3B,EAAA9e,gBACA,OAAA/gC,MAAAuD,IAAA2wD,EAAA3/B,cAAA2/B,EAAA3/B,cAAA,GAAAv0B,KAAAu1B,KAAA37B,KAAAqtE,aAAA,IAAArC,MAEAnR,qBAAA,WACA,GAAA53D,GAAAjC,IAEA84B,GAAA4vC,gBAAA5mE,UAAA+3D,qBAAArvD,KAAAvI,GAGAA,EAAAiqE,YAAAjqE,EAAAkC,MAAA6I,KAAA6uB,OAAAtwB,IAAAtJ,EAAAxC,QAAAysE,YAAArhE,SAAA5I,IAEAi6D,iBAAA,SAAAx3D,EAAAuX,GACA,OAAAjc,KAAA+7D,cAAA/7D,KAAAmE,MAAA6I,KAAAqN,SAAA4B,GAAAjP,KAAAtI,KAEAy1D,IAAA,WACAn6D,KAAAP,QAAAysE,YAAA5+C,QACAi/C,EAAAvsE,MAEAm6D,EAAAn6D,OAOAotE,cAAA,SAAAT,EAAAC,EAAAC,GACA,GAAA5qE,GAAAjC,KACA6uE,EAAAjC,EAAA93D,EAAA1O,KAAAsiC,IAAAmkC,EAAA/3D,GACAg6D,EAAA1oE,KAAAC,IAAAumE,EAAAh4D,EAAA3S,EAAAgD,MAAA,GAAAmB,KAAAsiC,IAAAmkC,EAAAj4D,GACAm6D,GAAAnC,EAAAnlC,EAAArhC,KAAAmiC,IAAAskC,EAAAplC,GACAunC,GAAA5oE,KAAAC,IAAAumE,EAAA/oE,EAAA5B,EAAAiD,OAAA,GAAAkB,KAAAmiC,IAAAskC,EAAAhpE,EAEAgrE,GAAAR,EAAAQ,GACAC,EAAAT,EAAAS,GACAC,EAAAV,EAAAU,GACAC,EAAAX,EAAAW,GAEA/sE,EAAAorE,YAAAjnE,KAAAuD,IACAvD,KAAAoT,MAAAmzD,GAAAkC,EAAAC,GAAA,GACA1oE,KAAAoT,MAAAmzD,GAAAoC,EAAAC,GAAA,IACA/sE,EAAAqrE,eAAAuB,EAAAC,EAAAC,EAAAC,IAEA1B,eAAA,SAAA2B,EAAAC,EAAAC,EAAAC,GACA,GAAAntE,GAAAjC,KACAqvE,EAAAptE,EAAAgD,MAAAiqE,EAAAjtE,EAAAorE,YACAiC,EAAAL,EAAAhtE,EAAAorE,YACAkC,EAAAJ,EAAAltE,EAAAorE,YACAmC,EAAAvtE,EAAAiD,OAAAkqE,EAAAntE,EAAAorE,WAEAprE,GAAA8rE,QAAA3nE,KAAAoT,OAAA81D,EAAAD,GAAA,EAAAptE,EAAAkE,MACAlE,EAAA+rE,QAAA5nE,KAAAoT,OAAA+1D,EAAAC,GAAA,EAAAvtE,EAAA0E,MAGAsmE,cAAA,SAAAvoE,GASA,MAAAA,IARA,EAAA0B,KAAAoiC,GAAAwjC,EAAAhsE,QACAA,KAAAmE,MAAA1E,SAAAO,KAAAmE,MAAA1E,QAAAslD,WACA/kD,KAAAmE,MAAA1E,QAAAslD,WACA,GAEA3+C,KAAAoiC,GAAA,OAKAqlC,8BAAA,SAAA3uE,GACA,GAAA+C,GAAAjC,IAEA,WAAAd,EACA,QAIA,IAAAuwE,GAAAxtE,EAAAorE,aAAAprE,EAAAoE,IAAApE,EAAA0H,IACA,OAAA1H,GAAAxC,QAAA0J,MAAA1F,SACAxB,EAAAoE,IAAAnH,GAAAuwE,GAEAvwE,EAAA+C,EAAA0H,KAAA8lE,GAEAzC,iBAAA,SAAAtoE,EAAAgrE,GACA,GAAAztE,GAAAjC,KACA2vE,EAAA1tE,EAAAgrE,cAAAvoE,GAAA0B,KAAAoiC,GAAA,CACA,QACAhmC,EAAA4D,KAAAoT,MAAApT,KAAAmiC,IAAAonC,GAAAD,GAAAztE,EAAA8rE,QACAtrE,EAAA2D,KAAAoT,MAAApT,KAAAsiC,IAAAinC,GAAAD,GAAAztE,EAAA+rE,UAGA4B,yBAAA,SAAAlrE,EAAAxF,GACA,MAAAc,MAAAgtE,iBAAAtoE,EAAA1E,KAAA6tE,8BAAA3uE,KAGA2wE,gBAAA,WACA,GAAA5tE,GAAAjC,KACA2J,EAAA1H,EAAA0H,IACAtD,EAAApE,EAAAoE,GAEA,OAAApE,GAAA2tE,yBAAA,EACA3tE,EAAA41D,YAAA,EACAluD,EAAA,GAAAtD,EAAA,EAAAA,EACAsD,EAAA,GAAAtD,EAAA,EAAAsD,EACA,IAGA25B,KAAA,WACA,GAAArhC,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACAu7D,EAAAl8C,EAAAgc,UACAw/B,EAAAx7C,EAAA3V,MACAuB,EAAA/K,EAAA+K,cAEA,IAAAoU,EAAAwO,QAAA,CACA,GAAAyR,GAAA98B,EAAA88B,IACAgmB,EAAA/kD,KAAAitE,cAAA,GAGAjC,EAAAtgE,EAAA4vD,EAAA5rC,SAAAu3B,EAAA9e,iBACA2oC,EAAAplE,EAAA4vD,EAAAzlB,UAAAoR,EAAA7e,kBACA2oC,EAAArlE,EAAA4vD,EAAA3rC,WAAAs3B,EAAA/e,mBACA8oC,EAAArwE,EAAAg1C,WAAAq2B,EAAA8E,EAAAC,EAEApwE,GAAAsI,KAAAhG,EAAAkH,MAAA,SAAAkT,EAAA3X,GAEA,GAAAA,EAAA,GAAA41D,EAAA72D,QAAA,CACA,GAAAwsE,GAAAhuE,EAAA4rE,8BAAA5rE,EAAAonE,eAAA3kE,GAOA,IAJAs2D,EAAA1tC,SAAA,IAAA5oB,GACAypE,EAAAlsE,EAAA+4D,EAAAiV,EAAAvrE,GAGA41D,EAAAhtC,QAAA,CACA,GAAAiwC,GAAA7yD,EAAA4vD,EAAA5sC,UAAAu4B,EAAAhf,iBAOA,IANAlI,EAAAgW,KAAAi7B,EAEAjxC,EAAAwM,OACAxM,EAAAwgC,UAAAt9D,EAAA8rE,QAAA9rE,EAAA+rE,SACAjvC,EAAAzmB,OAAAysC,GAEAuV,EAAAkU,kBAAA,CACA,GAAA5T,GAAA77B,EAAAsW,YAAAh5B,GAAApX,KACA85B,GAAA+mB,UAAAwU,EAAAmU,cACA1vC,EAAAiM,UACA4vB,EAAA,EAAAN,EAAAqU,kBACAsB,EAAAjF,EAAA,EAAA1Q,EAAAoU,iBACA9T,EAAA,EAAAN,EAAAqU,iBACA3D,EAAA,EAAA1Q,EAAAoU,kBAIA3vC,EAAAtQ,UAAA,SACAsQ,EAAA4/B,aAAA,SACA5/B,EAAA+mB,UAAAyX,EACAx+B,EAAA0gC,SAAApjD,EAAA,GAAA4zD,GACAlxC,EAAA2M,eAKA5sB,EAAAmtD,WAAA3+C,SAAAxO,EAAAotD,YAAA5+C,UACAmgD,EAAAxrE,MAKA62B,GAAA+U,aAAA8oB,kBAAA,eAAAiY,EAAArF,KpDu7ZM2G,KACA,SAAU1xE,EAAQc,EAASZ,GAEjC,YqD14aA,SAAAyxE,GAAAtxE,EAAAgF,GACA,MAAAhF,GAAAgF,EAGA,QAAAusE,GAAApgE,GACA,GAEAzP,GAAAC,EAAA4D,EAFAisE,KACAC,IAGA,KAAA/vE,EAAA,EAAAC,EAAAwP,EAAA/O,OAAiCV,EAAAC,IAAUD,EAC3C6D,EAAA4L,EAAAzP,GACA8vE,EAAAjsE,KACAisE,EAAAjsE,IAAA,EACAksE,EAAA/rE,KAAAH,GAIA,OAAAksE,GAkBA,QAAAC,GAAAC,EAAA7mE,EAAAtD,EAAAoqE,GACA,cAAAA,IAAAD,EAAAvvE,OACA,QACI+5B,KAAArxB,EAAAygD,IAAA,IACApvB,KAAA30B,EAAA+jD,IAAA,GAIJ,IAEA7pD,GAAAC,EAAAkwE,EAAAC,EAAApgC,EAFAqgC,KACA5gE,GAAArG,EAGA,KAAApJ,EAAA,EAAAC,EAAAgwE,EAAAvvE,OAAsCV,EAAAC,IAAUD,GAChDowE,EAAAH,EAAAjwE,IACAoJ,GAAAgnE,EAAAtqE,GACA2J,EAAAzL,KAAAosE,EAMA,KAFA3gE,EAAAzL,KAAA8B,GAEA9F,EAAA,EAAAC,EAAAwP,EAAA/O,OAAiCV,EAAAC,IAAUD,EAC3CgwC,EAAAvgC,EAAAzP,EAAA,GACAmwE,EAAA1gE,EAAAzP,EAAA,GACAowE,EAAA3gE,EAAAzP,OAGAkP,KAAAihE,OAAAjhE,KAAA8gC,GAAAnqC,KAAAoT,OAAA+2B,EAAAmgC,GAAA,KAAAC,GACAC,EAAArsE,MAAey2B,KAAA21C,EAAAvmB,IAAA7pD,GAAAC,EAAA,IAIf,OAAAowE,GAIA,QAAAC,GAAAD,EAAAnwE,EAAAvB,GAKA,IAJA,GAEA4xE,GAAAC,EAAAC,EAFAC,EAAA,EACA74B,EAAAw4B,EAAA3vE,OAAA,EAGAgwE,GAAA,GAAAA,GAAA74B,GAAA,CAKA,GAJA04B,EAAAG,EAAA74B,GAAA,EACA24B,EAAAH,EAAAE,EAAA,SACAE,EAAAJ,EAAAE,IAEAC,EAEA,OAAWE,GAAA,KAAA74B,GAAA44B,EACR,IAAAA,EAAAvwE,GAAAvB,EACH+xE,EAAAH,EAAA,MACG,MAAAC,EAAAtwE,GAAAvB,GAGH,OAAW+xE,GAAAF,EAAA34B,GAAA44B,EAFX54B,GAAA04B,EAAA,GAOA,OAASG,GAAAD,EAAA54B,GAAA,MAST,QAAAl4C,GAAA0wE,EAAAM,EAAAtlE,EAAAulE,GACA,GAAAn/B,GAAA6+B,EAAAD,EAAAM,EAAAtlE,GAGA8kE,EAAA1+B,EAAAi/B,GAAAj/B,EAAAoG,GAAApG,EAAAi/B,GAAAL,IAAA3vE,OAAA,GAAA2vE,EAAA,GACArgC,EAAAyB,EAAAi/B,GAAAj/B,EAAAoG,GAAApG,EAAAoG,GAAAw4B,IAAA3vE,OAAA,GAAA2vE,EAAA,GAEAzlD,EAAAolB,EAAA2gC,GAAAR,EAAAQ,GACAr5D,EAAAsT,GAAAvf,EAAA8kE,EAAAQ,IAAA/lD,EAAA,EACAC,GAAAmlB,EAAA4gC,GAAAT,EAAAS,IAAAt5D,CAEA,OAAA64D,GAAAS,GAAA/lD,EAOA,QAAAgmD,GAAAlyE,EAAAO,GACA,GAAA4xE,GAAA5xE,EAAA4xE,OACAC,EAAA7xE,EAAA4xE,QAAA5xE,EAAA6xE,MAEA,0BAAAD,GACAA,EAAAnyE,GAGA,iBAAAA,IAAA,iBAAAoyE,GACAC,EAAAryE,EAAAoyE,IAGApyE,YAAAqyE,KACAryE,EAAAqyE,EAAAryE,IAGAA,EAAAkW,UACAlW,EAKA,mBAAAoyE,GACAA,EAAApyE,GAGAA,GAGA,QAAAu2B,GAAA7F,EAAAme,GACA,GAAApuC,EAAA0K,cAAAulB,GACA,WAGA,IAAAnwB,GAAAsuC,EAAAtuC,QAAAu7B,KACA97B,EAAAkyE,EAAArjC,EAAAguB,cAAAnsC,GAAAnwB,EACA,OAAAP,GAAAkW,WAIA3V,EAAA+Z,OACAta,EAAAsyE,QAAA/xE,EAAA+Z,OAGAta,EAAAuyE,WAPA,KAcA,QAAAC,GAAA/nE,EAAAtD,EAAAw3B,EAAA8zC,GACA,GAIApxE,GAAAC,EAAAoxE,EAJA5/B,EAAA3rC,EAAAsD,EACAkoE,EAAAC,EAAAj0C,GACA7N,EAAA6hD,EAAAnnC,KACAqnC,EAAAF,EAAAE,KAGA,KAAAA,EACA,MAAA3rE,MAAAu1B,KAAAqW,GAAA2/B,EAAA3hD,GAGA,KAAAzvB,EAAA,EAAAC,EAAAuxE,EAAA9wE,OAAiCV,EAAAC,IACjCoxE,EAAAG,EAAAxxE,KACA6F,KAAAu1B,KAAAqW,GAAAhiB,EAAA4hD,KAAAD,MAF2CpxE,GAO3C,MAAAqxE,GAMA,QAAAI,GAAAC,EAAAtoE,EAAAtD,EAAAsrE,GACA,GACApxE,GAAAsxE,EAAAD,EADApxE,EAAA0xE,EAAAjxE,MAGA,KAAAV,EAAA2xE,EAAAvtE,QAAAstE,GAAiC1xE,EAAAC,EAAA,IAAcD,EAI/C,GAHAsxE,EAAAC,EAAAI,EAAA3xE,IACAqxE,EAAAC,EAAAE,MAAAF,EAAAE,MAAAF,EAAAE,MAAA9wE,OAAA,GAAAkxE,EAEAN,EAAAO,QAAAhsE,KAAAu1B,MAAAt1B,EAAAsD,IAAAioE,EAAAC,EAAAnnC,QAAAinC,EACA,MAAAO,GAAA3xE,EAIA,OAAA2xE,GAAA1xE,EAAA,GAMA,QAAA6xE,GAAAlpE,EAAA8oE,EAAAtoE,EAAAtD,GACA,GAEA9F,GAAAs9B,EAFA6vB,EAAA6jB,EAAA7jB,SAAA6jB,EAAAlrE,GAAAisE,KAAAf,EAAA5nE,KACAnJ,EAAA0xE,EAAAjxE,MAGA,KAAAV,EAAAC,EAAA,EAAmBD,GAAA2xE,EAAAvtE,QAAAstE,GAA6B1xE,IAEhD,GADAs9B,EAAAq0C,EAAA3xE,GACAuxE,EAAAj0C,GAAAu0C,QAAA1kB,EAAA6kB,GAAA10C,IAAA10B,EAAAlI,OACA,MAAA48B,EAIA,OAAAq0C,GAAAD,EAAAC,EAAAvtE,QAAAstE,GAAA,GAGA,QAAAO,GAAA30C,GACA,OAAAt9B,GAAA2xE,EAAAvtE,QAAAk5B,GAAA,EAAAr9B,EAAA0xE,EAAAjxE,OAA2DV,EAAAC,IAAUD,EACrE,GAAAuxE,EAAAI,EAAA3xE,IAAA6xE,OACA,MAAAF,GAAA3xE,GAWA,QAAAkyE,GAAA9oE,EAAAtD,EAAAsrE,EAAAlyE,GACA,GAUAu7B,GAVA03C,EAAAjzE,EAAAu7B,KACAo9B,EAAAsa,EAAA70C,MAAAm0C,EAAAU,EAAAT,QAAAtoE,EAAAtD,EAAAsrE,GACAtZ,EAAAma,EAAApa,GACAgQ,EAAAzoE,EAAA+K,eAAAgoE,EAAAtK,SAAAsK,EAAA10C,cACA20C,EAAA,SAAAva,GAAAsa,EAAAE,WACAC,EAAApzE,EAAA0J,MAAAkvD,MAAAh5B,QACAwyC,EAAAC,EAAA1Z,GACA0a,EAAAvB,EAAA5nE,GACAopE,EAAAxB,EAAAlrE,GACA8C,IAgCA,KA7BAi/D,IACAA,EAAAsJ,EAAA/nE,EAAAtD,EAAA+xD,EAAAuZ,IAIAgB,IACAG,IAAAF,WAAAD,GACAI,IAAAH,WAAAD,IAIAG,IAAAtB,QAAAmB,EAAA,MAAAva,GACA2a,IAAAvB,QAAAmB,EAAA,MAAAva,GAGA2a,EAAA1sE,GACA0sE,EAAAlnB,IAAA,EAAAuM,GAGAp9B,EAAAu2C,EAAAuB,GAEAD,GAAAxa,IAAAsa,IAAAD,EAAAl5D,QAIAwhB,EAAAw2C,QAAAnZ,GACAr9B,EAAA6wB,QAAAinB,EAAA93C,IAAA62C,EAAAnnC,KAAA09B,MAAAhQ,IAGOp9B,EAAA+3C,EAAa/3C,EAAA6wB,IAAAuc,EAAAhQ,GACpBjvD,EAAA5E,MAAAy2B,EAKA,OAFA7xB,GAAA5E,MAAAy2B,GAEA7xB,EAOA,QAAA6pE,GAAApC,EAAAznE,EAAAQ,EAAAtD,EAAA5G,GACA,GAEAwzE,GAAAC,EAFA/sE,EAAA,EACAK,EAAA,CAsBA,OAnBA/G,GAAA2rB,QAAAjiB,EAAAlI,SACAxB,EAAAu7B,KAAArxB,MACAspE,EAAA9pE,EAAAlI,OAAA,EAAAkI,EAAA,GAAA9C,EACA6sE,EAAA/pE,EAAA,GACAhD,GACAjG,EAAA0wE,EAAA,OAAAqC,EAAA,OACA/yE,EAAA0wE,EAAA,OAAAsC,EAAA,QACA,GAEAzzE,EAAAu7B,KAAA30B,MACA4sE,EAAA9pE,IAAAlI,OAAA,GACAiyE,EAAA/pE,EAAAlI,OAAA,EAAAkI,IAAAlI,OAAA,GAAA0I,EACAnD,GACAtG,EAAA0wE,EAAA,OAAAqC,EAAA,OACA/yE,EAAA0wE,EAAA,OAAAsC,EAAA,QACA,KAIS/sE,OAAAK,SAGT,QAAA2sE,GAAArzE,EAAAszE,GACA,GACA7yE,GAAAC,EAAAtB,EAAAm5D,EADAlvD,IAGA,KAAA5I,EAAA,EAAAC,EAAAV,EAAAmB,OAAkCV,EAAAC,IAAUD,EAC5CrB,EAAAY,EAAAS,GACA83D,IAAA+a,GAAAl0E,KAAAqyE,EAAAryE,GAAAsyE,QAAA4B,GAEAjqE,EAAA5E,MACArF,QACAm5D,SAIA,OAAAlvD,GAGA,QAAAkqE,GAAArmE,EAAA0lE,GACA,GAAAnyE,GAAA+yE,EAAAC,EACA/yE,EAAAwM,EAAA/L,MAIA,KAAAV,EAAA,EAAYA,EAAAC,EAAUD,IAAA,CAEtB,GADA+yE,EAAAlC,EAAApkE,EAAAzM,GAAAmyE,GACA,IAAAY,EAAAE,cACA,iCAEA,KAAAF,EAAAG,UAAA,IAAAH,EAAA72C,UAAA,IAAA62C,EAAAxjD,SACAyjD,GAAA,GAGA,MAAAA,GACA,wBAEA,cApaA,GAAAhC,GAAA7yE,EAAA,GACA6yE,GAAA,mBAAAA,KAAA53D,OAAA43D,MAEA,IAAAttE,GAAAvF,EAAA,MACAiB,EAAAjB,EAAA,MAGAg1E,EAAA14D,OAAA24D,mBAAA,iBACAxB,EAAAn3D,OAAA44D,kBAAA,iBAEA9B,GACA0B,aACApB,QAAA,EACA1nC,KAAA,EACAqnC,OAAA,6BAEA0B,QACArB,QAAA,EACA1nC,KAAA,IACAqnC,OAAA,cAEAt1C,QACA21C,QAAA,EACA1nC,KAAA,IACAqnC,OAAA,cAEAjiD,MACAsiD,QAAA,EACA1nC,KAAA,KACAqnC,OAAA,aAEAliD,KACAuiD,QAAA,EACA1nC,KAAA,MACAqnC,OAAA,QAEAv1C,MACA41C,QAAA,EACA1nC,KAAA,OACAqnC,OAAA,UAEA7hD,OACAkiD,QAAA,EACA1nC,KAAA,OACAqnC,OAAA,QAEA8B,SACAzB,QAAA,EACA1nC,KAAA,OACAqnC,OAAA,UAEAviE,MACA4iE,QAAA,EACA1nC,KAAA,SAIAwnC,EAAAlzE,OAAAgC,KAAA8wE,EA8WAtzE,GAAAc,QAAA,SAAAw5B,GAEA,GAAAywC,IACAlmE,SAAA,SASAotE,aAAA,SASAznB,OAAA,OAEAhuB,MACAq2C,QAAA,EACAC,QAAA,EACAzzC,MAAA,EACArkB,OAAA,EACAs6D,eAAA,EACAlB,YAAA,EACAX,QAAA,cAGAl0C,gBACAy1C,YAAA,gBACAC,OAAA,YACAh3C,OAAA,SACA3M,KAAA,KACAD,IAAA,QACA2M,KAAA,KACAtM,MAAA,WACA2jD,QAAA,cACArkE,KAAA,SAGArG,OACA8uD,UAAA,EAUA3sD,OAAA,OAEA+sD,OACAh5B,SAAA,KAKA00C,EAAAj7C,EAAA6/B,MAAAj3D,QACAC,WAAA,WACA,IAAA4vE,EACA,SAAA94C,OAAA,uIAGAz4B,MAAAixD,oBAEAn4B,EAAA6/B,MAAA72D,UAAAH,WAAA6I,KAAAxK,OAGAgF,OAAA,WACA,GAAA/C,GAAAjC,KACAP,EAAAwC,EAAAxC,OAOA,OAJAA,GAAAu7B,MAAAv7B,EAAAu7B,KAAAs2C,QACAt4D,QAAA6N,KAAA,0EAGAiS,EAAA6/B,MAAA72D,UAAAkD,OAAApD,MAAAK,EAAAJ,YAMAk6D,cAAA,SAAAC,GAIA,MAHAA,QAAAvsD,KAAAusD,EAAAv0B,IACAu0B,IAAAv0B,GAEA3O,EAAA6/B,MAAA72D,UAAAi6D,cAAAvxD,KAAAxK,KAAAg8D,IAGAzC,oBAAA,WACA,GASAh5D,GAAA4Z,EAAA3Z,EAAA4Z,EAAApN,EAAAgnE,EATA/xE,EAAAjC,KACAmE,EAAAlC,EAAAkC,MACAuuE,EAAAzwE,EAAAxC,QAAAu7B,KACA6C,EAAA60C,EAAA70C,MAAA,MACAl0B,EAAAwoE,EACA9rE,EAAAqtE,EACAlD,KACAn2D,KACAwhB,IAIA,KAAAt7B,EAAA,EAAAC,EAAA2D,EAAA6I,KAAA6uB,OAAA56B,OAA+CV,EAAAC,IAAUD,EACzDs7B,EAAAt3B,KAAAkxB,EAAAtxB,EAAA6I,KAAA6uB,OAAAt7B,GAAA0B,GAIA,KAAA1B,EAAA,EAAAC,GAAA2D,EAAA6I,KAAAqN,cAAApZ,OAAyDV,EAAAC,IAAUD,EACnE,GAAA4D,EAAAmW,iBAAA/Z,GAIA,GAHAyM,EAAA7I,EAAA6I,KAAAqN,SAAA9Z,GAAAyM,KAGArN,EAAA8K,SAAAuC,EAAA,IAGA,IAFAqN,EAAA9Z,MAEA4Z,EAAA,EAAAC,EAAApN,EAAA/L,OAAqCkZ,EAAAC,IAAUD,EAC/C65D,EAAAv+C,EAAAzoB,EAAAmN,GAAAlY,GACAuuE,EAAAjsE,KAAAyvE,GACA35D,EAAA9Z,GAAA4Z,GAAA65D,MAGAxD,GAAAjsE,KAAA3C,MAAA4uE,EAAA30C,GACAxhB,EAAA9Z,GAAAs7B,EAAA9iB,MAAA,OAGAsB,GAAA9Z,KAIAs7B,GAAA56B,SAEA46B,EAAAu0C,EAAAv0C,GAAAj4B,KAAAusE,GACAxmE,EAAAvD,KAAAuD,MAAAkyB,EAAA,IACAx1B,EAAAD,KAAAC,MAAAw1B,IAAA56B,OAAA,KAGAuvE,EAAAvvE,SACAuvE,EAAAJ,EAAAI,GAAA5sE,KAAAusE,GACAxmE,EAAAvD,KAAAuD,MAAA6mE,EAAA,IACAnqE,EAAAD,KAAAC,MAAAmqE,IAAAvvE,OAAA,KAGA0I,EAAA8rB,EAAAi9C,EAAA/oE,IAAA1H,IAAA0H,EACAtD,EAAAovB,EAAAi9C,EAAArsE,IAAApE,IAAAoE,EAGAsD,MAAAwoE,GAAAZ,IAAAC,QAAA3zC,GAAAl0B,EACAtD,MAAAqtE,GAAAnC,IAAA0C,MAAAp2C,GAAA,EAAAx3B,EAGApE,EAAA0H,IAAAvD,KAAAuD,MAAAtD,GACApE,EAAAoE,IAAAD,KAAAC,IAAAsD,EAAA,EAAAtD,GAGApE,EAAAiyE,YAAAjyE,EAAAqD,eACArD,EAAAkyE,UACAlyE,EAAAmyE,aACApnE,KAAAwjE,EACAn2D,WACAwhB,WAIA69B,WAAA,WACA,GAOAn5D,GAAAC,EAAAwzE,EAPA/xE,EAAAjC,KACA2J,EAAA1H,EAAA0H,IACAtD,EAAApE,EAAAoE,IACA5G,EAAAwC,EAAAxC,QACAizE,EAAAjzE,EAAAu7B,KACAw1C,KACArnE,IAGA,QAAA1J,EAAA0J,MAAAmC,QACA,WACAklE,EAAAvuE,EAAAmyE,YAAApnE,IACA,MACA,cACAwjE,EAAAvuE,EAAAmyE,YAAAv4C,MACA,MACA,YACA,QACA20C,EAAAiC,EAAA9oE,EAAAtD,EAAApE,EAAAoyE,iBAAA1qE,GAAAlK,GAaA,IAVA,UAAAA,EAAAupD,QAAAwnB,EAAAvvE,SACA0I,EAAA6mE,EAAA,GACAnqE,EAAAmqE,IAAAvvE,OAAA,IAIA0I,EAAA8rB,EAAAi9C,EAAA/oE,IAAA1H,IAAA0H,EACAtD,EAAAovB,EAAAi9C,EAAArsE,IAAApE,IAAAoE,EAGA9F,EAAA,EAAAC,EAAAgwE,EAAAvvE,OAAwCV,EAAAC,IAAUD,GAClDyzE,EAAAxD,EAAAjwE,KACAoJ,GAAAqqE,GAAA3tE,GACA8C,EAAA5E,KAAAyvE,EAcA,OAVA/xE,GAAA0H,MACA1H,EAAAoE,MAGApE,EAAAqyE,MAAA5B,EAAA70C,MAAAw0C,EAAAlpE,EAAAupE,EAAAT,QAAAhwE,EAAA0H,IAAA1H,EAAAoE,KACApE,EAAAsyE,WAAA/B,EAAAvwE,EAAAqyE,OACAryE,EAAAkyE,OAAA5D,EAAAtuE,EAAAmyE,YAAApnE,KAAArD,EAAAtD,EAAA5G,EAAAgxE,cACAxuE,EAAAuyE,SAAAxB,EAAA/wE,EAAAkyE,OAAAhrE,EAAAQ,EAAAtD,EAAA5G,GACAwC,EAAAwyE,aAAApB,EAAApxE,EAAAmyE,YAAApnE,KAAA0lE,GAEAS,EAAAhqE,EAAAlH,EAAAsyE,aAGArY,iBAAA,SAAAx3D,EAAAuX,GACA,GAAAha,GAAAjC,KACAgN,EAAA/K,EAAAkC,MAAA6I,KACA0lE,EAAAzwE,EAAAxC,QAAAu7B,KACA3e,EAAArP,EAAA6uB,QAAAn3B,EAAAsI,EAAA6uB,OAAA56B,OAAA+L,EAAA6uB,OAAAn3B,GAAA,GACAxF,EAAA8N,EAAAqN,SAAA4B,GAAAjP,KAAAtI,EAKA,OAHA/E,GAAA8K,SAAAvL,KACAmd,EAAApa,EAAA85D,cAAA78D,IAEAwzE,EAAAz0C,cACAmzC,EAAA/0D,EAAAq2D,GAAApB,OAAAoB,EAAAz0C,eAEA,iBAAA5hB,GACAA,EAGA+0D,EAAA/0D,EAAAq2D,GAAApB,OAAArvE,EAAAwyE,eAOAC,mBAAA,SAAAnc,EAAA7zD,EAAAyE,EAAAwrE,GACA,GAAA1yE,GAAAjC,KACAP,EAAAwC,EAAAxC,QACAu7B,EAAAu9B,EAAAkZ,UACAmD,EAAAn1E,EAAAu7B,KAAA+C,eACA82C,EAAAD,EAAA3yE,EAAAqyE,OACAlB,EAAAnxE,EAAAsyE,WACAO,EAAAF,EAAAxB,GACA2B,EAAAxc,EAAAp2D,QAAAqvE,QAAA4B,GAAA3B,UACAuD,EAAAv1E,EAAA0J,MAAAkvD,MACAA,EAAA2c,EAAA31C,SAAA+zC,GAAA0B,GAAA95C,IAAA+5C,EACA14D,EAAAk8C,EAAA+Y,OAAAqD,IAAAtc,EAAAyc,EAAAD,IACAva,EAAAjC,EAAA2c,EAAAv1E,EAAA0J,MAAAivD,MACA93B,EAAA3gC,EAAA+K,eAAA4vD,EAAAzvD,SAAAyvD,EAAAC,aAEA,OAAAj6B,KAAAjkB,EAAA3X,EAAAyE,GAAAkT,GAGAw9C,qBAAA,SAAA1wD,GACA,GACA5I,GAAAC,EADAq7B,IAGA,KAAAt7B,EAAA,EAAAC,EAAA2I,EAAAlI,OAAmCV,EAAAC,IAAUD,EAC7Cs7B,EAAAt3B,KAAAvE,KAAA00E,mBAAAnD,EAAApoE,EAAA5I,GAAArB,OAAAqB,EAAA4I,GAGA,OAAA0yB,IAMAo5C,kBAAA,SAAAj6C,GACA,GAAA/4B,GAAAjC,KACA0qC,EAAAzoC,EAAAiyE,YAAAjyE,EAAAgD,MAAAhD,EAAAiD,OACA/E,EAAA8B,EAAAiyE,YAAAjyE,EAAAkE,KAAAlE,EAAA0E,IACAyjD,EAAAlqD,EAAA+B,EAAAkyE,OAAA,OAAAn5C,EAAA,MAEA,OAAA76B,GAAAuqC,GAAAzoC,EAAAuyE,SAAAruE,KAAAikD,IAAAnoD,EAAAuyE,SAAAruE,KAAA,EAAAlE,EAAAuyE,SAAAhuE,QAGA21D,iBAAA,SAAAj9D,EAAAwF,EAAAuX,GACA,GAAAha,GAAAjC,KACAg7B,EAAA,IAUA,QARAvrB,KAAA/K,OAAA+K,KAAAwM,IACA+e,EAAA/4B,EAAAmyE,YAAA/5D,SAAA4B,GAAAvX,IAGA,OAAAs2B,IACAA,EAAAvF,EAAAv2B,EAAA+C,IAGA,OAAA+4B,EACA,MAAA/4B,GAAAgzE,kBAAAj6C,IAIAq8B,gBAAA,SAAA3yD,GACA,GAAAyE,GAAAnJ,KAAA44D,UACA,OAAAl0D,IAAA,GAAAA,EAAAyE,EAAAlI,OACAjB,KAAAi1E,kBAAA9rE,EAAAzE,GAAAxF,OACA,MAGAk9D,iBAAA,SAAAE,GACA,GAAAr6D,GAAAjC,KACA0qC,EAAAzoC,EAAAiyE,YAAAjyE,EAAAgD,MAAAhD,EAAAiD,OACA/E,EAAA8B,EAAAiyE,YAAAjyE,EAAAkE,KAAAlE,EAAA0E,IACAyjD,GAAA1f,GAAA4xB,EAAAn8D,GAAAuqC,EAAA,IAAAzoC,EAAAuyE,SAAAruE,KAAA,EAAAlE,EAAAuyE,SAAAruE,MAAAlE,EAAAuyE,SAAAhuE,MACAw0B,EAAA96B,EAAA+B,EAAAkyE,OAAA,MAAA/pB,EAAA,OAEA,OAAAmnB,GAAAv2C,IAOAk6C,cAAA,SAAA74D,GACA,GAAApa,GAAAjC,KACAm1E,EAAAlzE,EAAAxC,QAAA0J,MACAisE,EAAAnzE,EAAA88B,IAAAsW,YAAAh5B,GAAApX,MACA4qC,EAAAlwC,EAAAyvC,UAAA+lC,EAAApd,aACA2C,EAAAt0D,KAAAmiC,IAAAsH,GACA6rB,EAAAt1D,KAAAsiC,IAAAmH,EAGA,OAAAulC,GAAA1a,EAFA/6D,EAAA+K,eAAAyqE,EAAAzmD,SAAAzqB,EAAA8a,OAAAooB,iBAEAu0B,GAMA2Y,iBAAA,SAAAgB,GACA,GAAApzE,GAAAjC,KAEA20E,EAAA1yE,EAAAxC,QAAAu7B,KAAA+C,eAAAy1C,YAEA8B,EAAArzE,EAAAyyE,mBAAAnD,EAAA8D,GAAA,KAAAV,GACAS,EAAAnzE,EAAAizE,cAAAI,GACAjZ,EAAAp6D,EAAAqD,eAAArD,EAAAgD,MAAAhD,EAAAiD,OAEAysE,EAAAvrE,KAAAkD,MAAA+yD,EAAA+Y,EACA,OAAAzD,GAAA,EAAAA,EAAA,IAIA74C,GAAA+U,aAAA8oB,kBAAA,OAAAod,EAAAxK,KrD+8aMgM,KACA,SAAU/2E,EAAQc,EAASZ,GAEjC,YsD1ncA,SAAA82E,GAAAznC,EAAA0nC,GACA,GAEA/E,GAAAC,EAAApwE,EAAAC,EAFAmJ,EAAAokC,EAAAzoC,eAAAyoC,EAAA9oC,MAAA8oC,EAAA7oC,OACAiE,EAAA4kC,EAAA6qB,UAGA,KAAAr4D,EAAA,EAAAC,EAAAi1E,EAAAx0E,OAAkCV,EAAAC,IAAUD,EAC5CoJ,EAAAvD,KAAAuD,MAAA8rE,EAAAl1E,GAAAk1E,EAAAl1E,EAAA,GAGA,KAAAA,EAAA,EAAAC,EAAA2I,EAAAlI,OAAiCV,EAAAC,IAAUD,EAC3CowE,EAAA5iC,EAAAspB,gBAAA92D,GACAoJ,EAAApJ,EAAA,EAAA6F,KAAAuD,MAAAgnE,EAAAD,GAAA/mE,EACA+mE,EAAAC,CAGA,OAAAhnE,GASA,QAAA+rE,GAAAhxE,EAAAixE,EAAAl2E,GACA,GAGAirC,GAAA7yB,EAHA+9D,EAAAn2E,EAAAo2E,aACA13D,EAAAw3D,EAAAG,WACAnF,EAAAgF,EAAAF,OAAA/wE,EAcA,OAXA/E,GAAA0K,cAAAurE,IACAlrC,EAAAirC,EAAAhsE,IAAAlK,EAAAs2E,mBACAl+D,EAAApY,EAAAu2E,gBAKAtrC,EAAAkrC,EAAAz3D,EACAtG,EAAA,IAIAo+D,MAAAvrC,EAAAvsB,EACAtG,QACA1X,MAAAwwE,EAAAjmC,EAAA,GAUA,QAAAwrC,GAAAxxE,EAAAixE,EAAAl2E,GACA,GAKAU,GAAAuqC,EALA+qC,EAAAE,EAAAF,OACA9E,EAAA8E,EAAA/wE,GACAgsE,EAAAhsE,EAAA,EAAA+wE,EAAA/wE,EAAA,QACA6rC,EAAA7rC,EAAA+wE,EAAAx0E,OAAA,EAAAw0E,EAAA/wE,EAAA,QACAyxE,EAAA12E,EAAAs2E,kBAiBA,OAdA,QAAArF,IAGAA,EAAAC,GAAA,OAAApgC,EAAAolC,EAAAvM,IAAAuH,EAAApgC,EAAAogC,IAGA,OAAApgC,IAEAA,EAAAogC,IAAAD,GAGAvwE,EAAAwwE,KAAAD,GAAA,EAAAyF,EACAzrC,GAAA6F,EAAAmgC,GAAA,EAAAyF,GAGAF,MAAAvrC,EAAAirC,EAAAG,WACAj+D,MAAApY,EAAAu2E,cACA71E,SAlLA,GAAA8D,GAAAvF,EAAA,MACAgc,EAAAhc,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,OACAgnC,OACAE,KAAA,SAGArM,QACAI,QACAh6B,KAAA,WAGAk1E,mBAAA,GACAC,cAAA,GAGA5qD,QAAA,EAGA0P,WACAq8B,iBAAA,KAIAz8B,QACA75B,KAAA,cAKAoD,EAAArE,KAAA,iBACAgnC,OACAE,KAAA,QACAvrB,KAAA,KAGAkf,QACAI,QACAh6B,KAAA,SACAwC,SAAA,WAGAq3B,QACAr3B,SAAA,OACAxC,KAAA,WAGAk1E,mBAAA,GACAC,cAAA,GAGA5qD,QAAA,EAGA0P,WACAq8B,iBAAA,MAKAz8C,UACAutC,WACAC,cAAA,SAIA5tB,UACAE,WACAnN,MAAA,SAAAjpB,EAAA4I,GAEA,GAAAqgB,GAAA,EAUA,OARAjpB,GAAAnD,OAAA,IACAmD,EAAA,GAAAo9D,OACAn0C,EAAAjpB,EAAA,GAAAo9D,OACMx0D,EAAA6uB,OAAA56B,OAAA,GAAAmD,EAAA,GAAAM,MAAAsI,EAAA6uB,OAAA56B,SACNosB,EAAArgB,EAAA6uB,OAAAz3B,EAAA,GAAAM,SAIA2oB,GAGAhR,MAAA,SAAAjY,EAAA4I,GAEA,OADAA,EAAAqN,SAAAjW,EAAA6X,cAAAI,OAAA,IACA,KAAAjY,EAAAg9D,SAGAt6B,KAAA,QACAvrB,KAAA,OA2FA/c,EAAAc,QAAA,SAAAw5B,GAEAA,EAAA62B,YAAAlI,IAAA3uB,EAAA87B,kBAAAlzD,QAEAozD,gBAAAp6C,EAAAzX,UAEAtB,WAAA,WACA,GACAuY,GADAjY,EAAAjC,IAGA84B,GAAA87B,kBAAA9yD,UAAAH,WAAAC,MAAAK,EAAAJ,WAEAqY,EAAAjY,EAAA+yD,UACA96C,EAAAkjB,MAAAn7B,EAAAgzD,aAAA73B,MACAljB,EAAAutC,KAAA,GAGAziD,OAAA,SAAA2sD,GACA,GAEApxD,GAAAC,EAFAyB,EAAAjC,KACAo2E,EAAAn0E,EAAA+yD,UAAAhoD,IAKA,KAFA/K,EAAAo0E,OAAAp0E,EAAAq0E,WAEA/1E,EAAA,EAAAC,EAAA41E,EAAAn1E,OAAmCV,EAAAC,IAAUD,EAC7C0B,EAAAuzD,cAAA4gB,EAAA71E,KAAAoxD,IAIA6D,cAAA,SAAAvN,EAAAvjD,EAAAitD,GACA,GAAA1vD,GAAAjC,KACAmE,EAAAlC,EAAAkC,MACA+V,EAAAjY,EAAA+yD,UACAh5C,EAAA/Z,EAAAgzD,aACAW,EAAA3N,EAAA2N,WACA2gB,EAAApyE,EAAA1E,QAAAib,SAAAutC,SAEAA,GAAAsa,QAAAtgE,EAAAizD,cAAAh7C,EAAA+4C,SACAhL,EAAAwa,QAAAxgE,EAAAizD,cAAAh7C,EAAAg5C,SACAjL,EAAA3rC,cAAAra,EAAAyC,MACAujD,EAAA/rC,OAAAxX,EAEAujD,EAAA7lD,QACAo0E,aAAAx6D,EAAAK,MACAA,MAAAlY,EAAA6I,KAAA6uB,OAAAn3B,GACAwjD,cAAA0N,EAAA1N,cAAA0N,EAAA1N,cAAAquB,EAAAruB,cACAprB,gBAAA84B,EAAA94B,gBAAA84B,EAAA94B,gBAAAn9B,EAAAiL,sBAAAoR,EAAA8gB,gBAAAp4B,EAAA6xE,EAAAz5C,iBACAE,YAAA44B,EAAA54B,YAAA44B,EAAA54B,YAAAr9B,EAAAiL,sBAAAoR,EAAAghB,YAAAt4B,EAAA6xE,EAAAv5C,aACAG,YAAAy4B,EAAAz4B,YAAAy4B,EAAAz4B,YAAAx9B,EAAAiL,sBAAAoR,EAAAmhB,YAAAz4B,EAAA6xE,EAAAp5C,cAGAl7B,EAAAw0E,sBAAAxuB,EAAAvjD,EAAAitD,GAEA1J,EAAAjmD,SAMAy0E,sBAAA,SAAAxuB,EAAAvjD,EAAAitD,GACA,GAAA1vD,GAAAjC,KACAK,EAAA4nD,EAAA7lD,OACAs0E,EAAAz0E,EAAA00E,gBACA5uB,EAAA2uB,EAAA/Z,eACA92D,EAAA6wE,EAAApxE,eACAqwE,EAAA1zE,EAAAo0E,QAAAp0E,EAAAq0E,WACAM,EAAA30E,EAAA40E,wBAAA50E,EAAAyC,SACAoyE,EAAA70E,EAAA80E,wBAAA90E,EAAAyC,QAAAixE,EAEAt1E,GAAAwF,aACAxF,EAAA0nD,KAAA4J,EAAA5J,EAAA6uB,EAAA7uB,KACA1nD,EAAAmC,EAAAqD,EAAA8rD,EAAA5J,EAAA6uB,EAAAI,KAAAF,EAAA37D,OACA9a,EAAAoC,EAAAoD,EAAAixE,EAAA37D,OAAAw2C,EAAA5J,EAAA6uB,EAAAI,KACA32E,EAAA6E,OAAAW,EAAAixE,EAAApsC,SAAAj7B,GACApP,EAAA4E,MAAAY,MAAA4J,GAAAqnE,EAAApsC,MAMAusC,gBAAA,WACA,MAAAj3E,MAAAg1D,UAAA9B,SAMAgkB,gBAAA,WACA,MAAAl3E,MAAAg1D,UAAA/B,SAMA0jB,cAAA,WACA,MAAA32E,MAAAk1D,cAAAl1D,KAAAi3E,oBAMAE,cAAA,WACA,MAAAn3E,MAAAk1D,cAAAl1D,KAAAk3E,oBASAE,WAAA,SAAArE,GACA,GAMAxyE,GAAA2Z,EANAjY,EAAAjC,KACAmE,EAAAlC,EAAAkC,MACA4pC,EAAA9rC,EAAAk1E,gBACAtlD,EAAAkc,EAAAtuC,QAAAoyB,QACArxB,MAAAiP,KAAAsjE,EAAA5uE,EAAA6I,KAAAqN,SAAApZ,OAAA8xE,EAAA,EACAsE,IAGA,KAAA92E,EAAA,EAAcA,EAAAC,IAAUD,EACxB2Z,EAAA/V,EAAAoW,eAAAha,GACA2Z,EAAAutC,KAAAtjD,EAAAmW,iBAAA/Z,MACA,IAAAsxB,IACA,IAAAA,IAAA,IAAAwlD,EAAA1yE,QAAAuV,EAAAkjB,YACA3tB,KAAAoiB,QAAApiB,KAAAyK,EAAAkjB,QAAA,IAAAi6C,EAAA1yE,QAAAuV,EAAAkjB,UACAi6C,EAAA9yE,KAAA2V,EAAAkjB,MAIA,OAAAi6C,IAOAC,cAAA,WACA,MAAAt3E,MAAAo3E,aAAAn2E,QAUAs2E,cAAA,SAAAt7D,EAAAzL,GACA,GAAA6mE,GAAAr3E,KAAAo3E,WAAAn7D,GACAvX,MAAA+K,KAAAe,EACA6mE,EAAA1yE,QAAA6L,IACA,CAEA,YAAA9L,EACA2yE,EAAAp2E,OAAA,EACAyD,GAMA4xE,SAAA,WACA,GAQA/1E,GAAAC,EAAAmJ,EARA1H,EAAAjC,KACA+tC,EAAA9rC,EAAAk1E,gBACArB,EAAA7zE,EAAAq1E,gBACAr7D,EAAAha,EAAAyC,MACAY,EAAAyoC,EAAAzoC,eACAnF,EAAAmF,EAAAyoC,EAAA5nC,KAAA4nC,EAAApnC,IACAyiE,EAAAjpE,GAAAmF,EAAAyoC,EAAA9oC,MAAA8oC,EAAA7oC,QACAuwE,IAGA,KAAAl1E,EAAA,EAAAC,EAAAyB,EAAA+yD,UAAAhoD,KAAA/L,OAA+CV,EAAAC,IAAUD,EACzDk1E,EAAAlxE,KAAAwpC,EAAAouB,iBAAA,KAAA57D,EAAA0b,GAOA,OAJAtS,GAAAhK,EAAA0K,cAAA0jC,EAAAtuC,QAAAo2E,cACAL,EAAAznC,EAAA0nC,IACA,GAGA9rE,MACA8rE,SACAt1E,QACAipE,MACA0M,aACA/nC,UAQA8oC,wBAAA,SAAA56D,EAAAvX,GACA,GASAnE,GAAAi3E,EAAAC,EAAA1vB,EAAAivB,EAAAtsC,EATAzoC,EAAAjC,KACAmE,EAAAlC,EAAAkC,MACA+V,EAAAjY,EAAA+yD,UACAjnB,EAAA9rC,EAAA00E,gBACAt8D,EAAAlW,EAAA6I,KAAAqN,SACAnb,EAAA6uC,EAAAguB,cAAA1hD,EAAA4B,GAAAjP,KAAAtI,IACAmtB,EAAAkc,EAAAtuC,QAAAoyB,QACAuL,EAAAljB,EAAAkjB,MACAj9B,EAAA,CAGA,IAAA0xB,OAAApiB,KAAAoiB,OAAApiB,KAAA2tB,EACA,IAAA78B,EAAA,EAAeA,EAAA0b,IAAkB1b,EACjCi3E,EAAArzE,EAAAoW,eAAAha,GAEAi3E,EAAA/vB,KACA+vB,EAAAp6C,WACAo6C,EAAA3nB,WAAAonB,oBAAAlpC,EAAA3jC,IACAjG,EAAAmW,iBAAA/Z,KAEAk3E,EAAA1pC,EAAAguB,cAAA1hD,EAAA9Z,GAAAyM,KAAAtI,KACAxF,EAAA,GAAAu4E,EAAA,GAAAv4E,GAAA,GAAAu4E,EAAA,KACAt3E,GAAAs3E,GAUA,OAJA1vB,GAAAha,EAAAouB,iBAAAh8D,GACA62E,EAAAjpC,EAAAouB,iBAAAh8D,EAAAjB,GACAwrC,GAAAssC,EAAAjvB,GAAA,GAGArd,OACAqd,OACAivB,OACA77D,OAAA67D,EAAAtsC,EAAA,IAOAqsC,wBAAA,SAAA96D,EAAAvX,EAAAixE,GACA,GAAA1zE,GAAAjC,KACAP,EAAAk2E,EAAA5nC,MAAAtuC,QACAuyC,EAAA,SAAAvyC,EAAAo2E,aACAK,EAAAxxE,EAAAixE,EAAAl2E,GACAi2E,EAAAhxE,EAAAixE,EAAAl2E,GAEAi4E,EAAAz1E,EAAAs1E,cAAAt7D,EAAAha,EAAA+yD,UAAA53B,OACAjiB,EAAA62B,EAAA7xC,MAAA6xC,EAAAikC,MAAAyB,EAAA1lC,EAAAikC,MAAA,EACAvrC,EAAAtkC,KAAAuD,IACAhK,EAAA+K,eAAAjL,EAAAk4E,gBAAAC,KACA5lC,EAAAikC,MAAAjkC,EAAAn6B,MAEA,QACAkwC,KAAA5sC,EAAAuvB,EAAA,EACAssC,KAAA77D,EAAAuvB,EAAA,EACAvvB,SACAuvB,SAIApH,KAAA,WACA,GAAArhC,GAAAjC,KACAmE,EAAAlC,EAAAkC,MACA4pC,EAAA9rC,EAAA00E,gBACAP,EAAAn0E,EAAA+yD,UAAAhoD,KACAgP,EAAA/Z,EAAAgzD,aACAz0D,EAAA41E,EAAAn1E,OACAV,EAAA,CAIA,KAFAZ,EAAAH,OAAA8rC,SAAAnnC,EAAA46B,IAAA56B,EAAA0E,WAEStI,EAAAC,IAAUD,EACnB4yB,MAAA4a,EAAAguB,cAAA//C,EAAAhP,KAAAzM,MACA61E,EAAA71E,GAAA+iC,MAIA3jC,GAAAH,OAAAisC,WAAAtnC,EAAA46B,MAGA82B,cAAA,SAAA5N,GACA,GAAAjsC,GAAAhc,KAAAmE,MAAA6I,KAAAqN,SAAA4tC,EAAA3rC,eACA5X,EAAAujD,EAAA/rC,OACA05C,EAAA3N,EAAA2N,WACAv1D,EAAA4nD,EAAA7lD,MAEA/B,GAAAy8B,gBAAA84B,EAAAE,qBAAAF,EAAAE,qBAAAn2D,EAAAiL,sBAAAoR,EAAA85C,qBAAApxD,EAAA/E,EAAAi2C,cAAAv1C,EAAAy8B,kBACAz8B,EAAA28B,YAAA44B,EAAAG,iBAAAH,EAAAG,iBAAAp2D,EAAAiL,sBAAAoR,EAAA+5C,iBAAArxD,EAAA/E,EAAAi2C,cAAAv1C,EAAA28B,cACA38B,EAAA88B,YAAAy4B,EAAAtO,iBAAAsO,EAAAtO,iBAAA3nD,EAAAiL,sBAAAoR,EAAAsrC,iBAAA5iD,EAAArE,EAAA88B,cAGAu4B,iBAAA,SAAAzN,GACA,GAAAjsC,GAAAhc,KAAAmE,MAAA6I,KAAAqN,SAAA4tC,EAAA3rC,eACA5X,EAAAujD,EAAA/rC,OACA05C,EAAA3N,EAAA2N,WACAv1D,EAAA4nD,EAAA7lD,OACAy1E,EAAA73E,KAAAmE,MAAA1E,QAAAib,SAAAutC,SAEA5nD,GAAAy8B,gBAAA84B,EAAA94B,gBAAA84B,EAAA94B,gBAAAn9B,EAAAiL,sBAAAoR,EAAA8gB,gBAAAp4B,EAAAmzE,EAAA/6C,iBACAz8B,EAAA28B,YAAA44B,EAAA54B,YAAA44B,EAAA54B,YAAAr9B,EAAAiL,sBAAAoR,EAAAghB,YAAAt4B,EAAAmzE,EAAA76C,aACA38B,EAAA88B,YAAAy4B,EAAAz4B,YAAAy4B,EAAAz4B,YAAAx9B,EAAAiL,sBAAAoR,EAAAmhB,YAAAz4B,EAAAmzE,EAAA16C,gBAIArE,EAAA62B,YAAAmoB,cAAAh/C,EAAA62B,YAAAlI,IAAA/lD,QAIAu1E,gBAAA,WACA,MAAAj3E,MAAAg1D,UAAA/B,SAMAikB,gBAAA,WACA,MAAAl3E,MAAAg1D,UAAA9B,atDwucM6kB,KACA,SAAUv5E,EAAQc,EAASZ,GAEjC,YuD7tdA,IAAAuF,GAAAvF,EAAA,MACAgc,EAAAhc,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,UACAgnC,OACAE,KAAA,UAGArM,QACAI,QACAh6B,KAAA,SACAwC,SAAA,SACA+G,GAAA,aAEAswB,QACA75B,KAAA,SACAwC,SAAA,OACA+G,GAAA,cAIAkwB,UACAE,WACAnN,MAAA,WAEA,UAEAhR,MAAA,SAAAjY,EAAA4I,GACA,GAAAwpE,GAAAxpE,EAAAqN,SAAAjW,EAAA6X,cAAAI,OAAA,GACA27D,EAAAhrE,EAAAqN,SAAAjW,EAAA6X,cAAAjP,KAAA5I,EAAAM,MACA,OAAA8xE,GAAA,MAAApyE,EAAAg9D,OAAA,KAAAh9D,EAAAo9D,OAAA,KAAAwW,EAAApjE,EAAA,SAOApW,EAAAc,QAAA,SAAAw5B,GAEAA,EAAA62B,YAAAsoB,OAAAn/C,EAAA87B,kBAAAlzD,QAIAozD,gBAAAp6C,EAAA1X,MAKAgC,OAAA,SAAA2sD,GACA,GAAA1vD,GAAAjC,KACAka,EAAAjY,EAAA+yD,UACAz3B,EAAArjB,EAAAlN,IAGArN,GAAAsI,KAAAs1B,EAAA,SAAA/gB,EAAA9X,GACAzC,EAAAuzD,cAAAh5C,EAAA9X,EAAAitD,MAOA6D,cAAA,SAAAh5C,EAAA9X,EAAAitD,GACA,GAAA1vD,GAAAjC,KACAka,EAAAjY,EAAA+yD,UACAY,EAAAp5C,EAAAo5C,WACA0M,EAAArgE,EAAAizD,cAAAh7C,EAAA+4C,SACAuP,EAAAvgE,EAAAizD,cAAAh7C,EAAAg5C,SACAzzD,EAAAwC,EAAAi2E,uBAAA17D,EAAA9X,GACAsI,EAAA/K,EAAAgzD,aAAAjoD,KAAAtI,GACAyzE,EAAAl2E,EAAAyC,MAEAlC,EAAAmvD,EAAA2Q,EAAA7F,mBAAA,IAAA6F,EAAAnG,iBAAA,iBAAAnvD,KAAAivD,IAAAv3D,EAAAyzE,GACA11E,EAAAkvD,EAAA6Q,EAAA7F,eAAA6F,EAAArG,iBAAAnvD,EAAAtI,EAAAyzE,EAEA37D,GAAA+lD,QAAAD,EACA9lD,EAAAimD,QAAAD,EACAhmD,EAAA+yC,SAAA9vD,EACA+c,EAAAF,cAAA67D,EACA37D,EAAAN,OAAAxX,EACA8X,EAAApa,QACA06B,gBAAAr9B,EAAAq9B,gBACAE,YAAAv9B,EAAAu9B,YACAG,YAAA19B,EAAA09B,YACAgqB,UAAA1nD,EAAA0nD,UACAE,WAAA5nD,EAAA4nD,WACArd,OAAA2nB,EAAA,EAAAlyD,EAAAuqC,OACAxvB,KAAAo7C,EAAAp7C,MAAA2Y,MAAA3wB,IAAA2wB,MAAA1wB,GACAD,IACAC,KAGA+Z,EAAAxa,SAMA6zD,cAAA,SAAAr5C,GACA,GAAAnc,GAAAmc,EAAApa,OACA3C,EAAA+c,EAAA+yC,QAEAlvD,GAAAy8B,gBAAAn9B,EAAA+K,eAAAjL,EAAAq2D,qBAAAn2D,EAAAi2C,cAAAn2C,EAAAq9B,kBACAz8B,EAAA28B,YAAAr9B,EAAA+K,eAAAjL,EAAAs2D,iBAAAp2D,EAAAi2C,cAAAn2C,EAAAu9B,cACA38B,EAAA88B,YAAAx9B,EAAA+K,eAAAjL,EAAA6nD,iBAAA7nD,EAAA09B,aACA98B,EAAA2pC,OAAAvqC,EAAAuqC,OAAAvqC,EAAAklD,aAMA+Q,iBAAA,SAAAl5C,GACA,GAAAnc,GAAAmc,EAAApa,OACA3C,EAAA+c,EAAA+yC,QAEAlvD,GAAAy8B,gBAAAr9B,EAAAq9B,gBACAz8B,EAAA28B,YAAAv9B,EAAAu9B,YACA38B,EAAA88B,YAAA19B,EAAA09B,YACA98B,EAAA2pC,OAAAvqC,EAAAuqC,QAMAkuC,uBAAA,SAAA17D,EAAA9X,GACA,GASAnE,GAAAC,EAAAC,EATAwB,EAAAjC,KACAmE,EAAAlC,EAAAkC,MACAkW,EAAAlW,EAAA6I,KAAAqN,SACA2B,EAAA3B,EAAApY,EAAAyC,OACAkxD,EAAAp5C,EAAAo5C,WACAn2D,EAAA0E,EAAA1E,QAAAib,SAAA8B,MACA+vB,EAAA5sC,EAAAF,QAAA8sC,QACAv/B,EAAAgP,EAAAhP,KAAAtI,GACA5E,KAIA2sC,GACAtoC,QACAi0E,UAAA1zE,EACAsX,UACAC,aAAAha,EAAAyC,OAGA1D,GACA,kBACA,cACA,cACA,uBACA,mBACA,mBACA,cACA,YACA,aAGA,KAAAT,EAAA,EAAAC,EAAAQ,EAAAC,OAAkCV,EAAAC,IAAUD,EAC5CE,EAAAO,EAAAT,GACAT,EAAAW,GAAA8rC,GACAqpB,EAAAn1D,GACAub,EAAAvb,GACAhB,EAAAgB,IACAgsC,EAAA/nC,EAWA,OAPA5E,GAAAkqC,OAAAuC,GACAqpB,EAAA5rB,OACAh9B,IAAA4H,MAAAnF,GACAuM,EAAAguB,OACAvqC,EAAAuqC,QACAyC,EAAA/nC,GAEA5E,OvDwudMu4E,KACA,SAAU75E,EAAQc,EAASZ,GAEjC,YwDz5dA,IAAAuF,GAAAvF,EAAA,MACAgc,EAAAhc,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,YACAy6B,WAEAi+C,eAAA,EAEAC,cAAA,GAEA3xC,OACAE,KAAA,UAEAusB,eAAA,SAAAlvD,GACA,GAAAopB,KACAA,GAAAhpB,KAAA,cAAAJ,EAAAiG,GAAA,YAEA,IAAA4C,GAAA7I,EAAA6I,KACAqN,EAAArN,EAAAqN,SACAwhB,EAAA7uB,EAAA6uB,MAEA,IAAAxhB,EAAApZ,OACA,OAAAV,GAAA,EAAkBA,EAAA8Z,EAAA,GAAArN,KAAA/L,SAA6BV,EAC/CgtB,EAAAhpB,KAAA,qCAAA8V,EAAA,GAAAyiB,gBAAAv8B,GAAA,aACAs7B,EAAAt7B,IACAgtB,EAAAhpB,KAAAs3B,EAAAt7B,IAEAgtB,EAAAhpB,KAAA,QAKA,OADAgpB,GAAAhpB,KAAA,SACAgpB,EAAAtM,KAAA,KAEA8L,QACA8O,QACA28C,eAAA,SAAAr0E,GACA,GAAA6I,GAAA7I,EAAA6I,IACA,OAAAA,GAAA6uB,OAAA56B,QAAA+L,EAAAqN,SAAApZ,OACA+L,EAAA6uB,OAAAtwB,IAAA,SAAA8Q,EAAA9b,GACA,GAAA2Z,GAAA/V,EAAAoW,eAAA,GACAk+D,EAAAzrE,EAAAqN,SAAA,GACAwwB,EAAA3wB,EAAAlN,KAAAzM,GACAq1D,EAAA/qB,KAAA+qB,WACAhrD,EAAAjL,EAAAiL,sBACA8tE,EAAAv0E,EAAA1E,QAAAib,SAAAmwB,GAKA,QACAtd,KAAAlR,EACAypC,UANA8P,EAAA94B,gBAAA84B,EAAA94B,gBAAAlyB,EAAA6tE,EAAA37C,gBAAAv8B,EAAAm4E,EAAA57C,iBAOA8oB,YANAgQ,EAAA54B,YAAA44B,EAAA54B,YAAApyB,EAAA6tE,EAAAz7C,YAAAz8B,EAAAm4E,EAAA17C,aAOA6oB,UANA+P,EAAAz4B,YAAAy4B,EAAAz4B,YAAAvyB,EAAA6tE,EAAAt7C,YAAA58B,EAAAm4E,EAAAv7C,aAOAp7B,OAAAoxB,MAAAslD,EAAAzrE,KAAAzM,KAAA2Z,EAAAlN,KAAAzM,GAAAwB,OAGA2C,MAAAnE,UAQA4mB,QAAA,SAAArN,EAAA6+D,GACA,GAEAp4E,GAAAC,EAAA0Z,EAFAxV,EAAAi0E,EAAAj0E,MACAP,EAAAnE,KAAAmE,KAGA,KAAA5D,EAAA,EAAAC,GAAA2D,EAAA6I,KAAAqN,cAAApZ,OAAyDV,EAAAC,IAAUD,EACnE2Z,EAAA/V,EAAAoW,eAAAha,GAEA2Z,EAAAlN,KAAAtI,KACAwV,EAAAlN,KAAAtI,GAAA3C,QAAAmY,EAAAlN,KAAAtI,GAAA3C,OAIAoC,GAAAa,WAKAs5B,iBAAA,GAGA+gC,UAAA,GAAAj5D,KAAAoiC,GAGAowC,cAAA,EAAAxyE,KAAAoiC,GAGAlO,UACAE,WACAnN,MAAA,WACA,UAEAhR,MAAA,SAAA8f,EAAAnvB,GACA,GAAAovB,GAAApvB,EAAA6uB,OAAAM,EAAAz3B,OACAxF,EAAA,KAAA8N,EAAAqN,SAAA8hB,EAAAlgB,cAAAjP,KAAAmvB,EAAAz3B,MAWA,OATA/E,GAAAqJ,QAAAozB,IAGAA,IAAArjB,QACAqjB,EAAA,IAAAl9B,GAEAk9B,GAAAl9B,EAGAk9B,OAMAn4B,EAAArE,KAAA,MAAAD,EAAAwC,MAAA8B,EAAA40E,WACA50E,EAAArE,KAAA,OACA0+B,iBAAA,IAGA9/B,EAAAc,QAAA,SAAAw5B,GAEAA,EAAA62B,YAAAkpB,SAAA//C,EAAA62B,YAAAjvB,IAAA5H,EAAA87B,kBAAAlzD,QAEAozD,gBAAAp6C,EAAA5X,IAEA0uD,WAAA7xD,EAAAuK,KAGA4uE,aAAA,SAAA78D,GAGA,OAFA88D,GAAA,EAEA5+D,EAAA,EAAkBA,EAAA8B,IAAkB9B,EACpCna,KAAAmE,MAAAmW,iBAAAH,MACA4+D,CAIA,OAAAA,IAGA/zE,OAAA,SAAA2sD,GACA,GAAA1vD,GAAAjC,KACAmE,EAAAlC,EAAAkC,MACA0E,EAAA1E,EAAA0E,UACAiW,EAAA3a,EAAA1E,QACAi5E,EAAA55D,EAAApE,SAAAmwB,IACAmuC,EAAAnwE,EAAArC,MAAAqC,EAAA1C,KAAAuyE,EAAAv7C,YACA87C,EAAApwE,EAAAjC,OAAAiC,EAAAlC,IAAA+xE,EAAAv7C,YACA93B,EAAAe,KAAAuD,IAAAqvE,EAAAC,GACA7tD,GAAiB5oB,EAAA,EAAAC,EAAA,GACjByX,EAAAjY,EAAA+yD,UACA12B,EAAAxf,EAAAwf,iBACAs6C,EAAA95D,EAAA85D,aAGA,IAAAA,EAAA,EAAAxyE,KAAAoiC,GAAA,CACA,GAAAuc,GAAAjmC,EAAAugD,UAAA,EAAAj5D,KAAAoiC,GACAuc,IAAA,EAAA3+C,KAAAoiC,IAAAuc,GAAA3+C,KAAAoiC,IAAA,EAAAuc,GAAA3+C,KAAAoiC,GAAA,IACA,IAAAwc,GAAAD,EAAA6zB,EACAz4E,GAAiBqC,EAAA4D,KAAAmiC,IAAAwc,GAAAtiD,EAAA2D,KAAAsiC,IAAAqc,IACjBqkB,GAAe5mE,EAAA4D,KAAAmiC,IAAAyc,GAAAviD,EAAA2D,KAAAsiC,IAAAsc,IACfk0B,EAAAn0B,GAAA,GAAAC,GAAA,GAAAD,GAAA,EAAA3+C,KAAAoiC,IAAA,EAAApiC,KAAAoiC,IAAAwc,EACAm0B,EAAAp0B,GAAA,GAAA3+C,KAAAoiC,IAAA,GAAApiC,KAAAoiC,IAAAwc,GAAAD,GAAA,IAAA3+C,KAAAoiC,IAAA,IAAApiC,KAAAoiC,IAAAwc,EACAo0B,EAAAr0B,IAAA3+C,KAAAoiC,KAAApiC,KAAAoiC,IAAAwc,GAAAD,GAAA3+C,KAAAoiC,IAAApiC,KAAAoiC,IAAAwc,EACAq0B,EAAAt0B,GAAA,IAAA3+C,KAAAoiC,IAAA,IAAApiC,KAAAoiC,IAAAwc,GAAAD,GAAA,IAAA3+C,KAAAoiC,IAAA,IAAApiC,KAAAoiC,IAAAwc,EACAs0B,EAAAh7C,EAAA,IACA30B,GAAenH,EAAA42E,GAAA,EAAAhzE,KAAAuD,IAAAxJ,EAAAqC,GAAArC,EAAAqC,EAAA,IAAA82E,GAAAlQ,EAAA5mE,GAAA4mE,EAAA5mE,EAAA,IAAA82E,IAAA72E,EAAA42E,GAAA,EAAAjzE,KAAAuD,IAAAxJ,EAAAsC,GAAAtC,EAAAsC,EAAA,IAAA62E,GAAAlQ,EAAA3mE,GAAA2mE,EAAA3mE,EAAA,IAAA62E,KACfjzE,GAAe7D,EAAA02E,EAAA,EAAA9yE,KAAAC,IAAAlG,EAAAqC,GAAArC,EAAAqC,EAAA,IAAA82E,GAAAlQ,EAAA5mE,GAAA4mE,EAAA5mE,EAAA,IAAA82E,IAAA72E,EAAA02E,EAAA,EAAA/yE,KAAAC,IAAAlG,EAAAsC,GAAAtC,EAAAsC,EAAA,IAAA62E,GAAAlQ,EAAA3mE,GAAA2mE,EAAA3mE,EAAA,IAAA62E,KACf5uC,GAAgBzlC,MAAA,IAAAoB,EAAA7D,EAAAmH,EAAAnH,GAAA0C,OAAA,IAAAmB,EAAA5D,EAAAkH,EAAAlH,GAChB4C,GAAAe,KAAAuD,IAAAqvE,EAAAtuC,EAAAzlC,MAAAg0E,EAAAvuC,EAAAxlC,QACAkmB,GAAc5oB,GAAA,IAAA6D,EAAA7D,EAAAmH,EAAAnH,GAAAC,GAAA,IAAA4D,EAAA5D,EAAAkH,EAAAlH,IAGd0B,EAAAg5B,YAAAl7B,EAAAs3E,kBAAAr/D,EAAAlN,MACA7I,EAAAihD,YAAAh/C,KAAAC,KAAAhB,EAAAlB,EAAAg5B,aAAA,KACAh5B,EAAAghD,YAAA/+C,KAAAC,IAAAi4B,EAAAn6B,EAAAihD,YAAA,WACAjhD,EAAAq1E,cAAAr1E,EAAAihD,YAAAjhD,EAAAghD,aAAAhhD,EAAAgvD,yBACAhvD,EAAAs1E,QAAAruD,EAAA5oB,EAAA2B,EAAAihD,YACAjhD,EAAAu1E,QAAAtuD,EAAA3oB,EAAA0B,EAAAihD,YAEAlrC,EAAA3I,MAAAtP,EAAAiM,iBAEAjM,EAAAmjD,YAAAjhD,EAAAihD,YAAAjhD,EAAAq1E,aAAAv3E,EAAA62E,aAAA72E,EAAAyC,OACAzC,EAAAkjD,YAAA/+C,KAAAC,IAAApE,EAAAmjD,YAAAjhD,EAAAq1E,aAAA,GAEA75E,EAAAsI,KAAAiS,EAAAlN,KAAA,SAAA69B,EAAAnmC,GACAzC,EAAAuzD,cAAA3qB,EAAAnmC,EAAAitD,MAIA6D,cAAA,SAAA3qB,EAAAnmC,EAAAitD,GACA,GAAA1vD,GAAAjC,KACAmE,EAAAlC,EAAAkC,MACA0E,EAAA1E,EAAA0E,UACAiW,EAAA3a,EAAA1E,QACAk6E,EAAA76D,EAAAub,UACAu/C,GAAA/wE,EAAA1C,KAAA0C,EAAArC,OAAA,EACAqzE,GAAAhxE,EAAAlC,IAAAkC,EAAAjC,QAAA,EACAm+C,EAAAjmC,EAAAugD,SACAra,EAAAlmC,EAAAugD,SACArjD,EAAA/Z,EAAAgzD,aACA2jB,EAAAjnB,GAAAgoB,EAAArB,cAAA,EAAAztC,EAAA9oC,OAAA,EAAAE,EAAA63E,uBAAA99D,EAAAhP,KAAAtI,KAAAoa,EAAA85D,eAAA,EAAAxyE,KAAAoiC,KACA2c,EAAAwM,GAAAgoB,EAAApB,aAAA,EAAAt2E,EAAAkjD,YACAC,EAAAuM,GAAAgoB,EAAApB,aAAA,EAAAt2E,EAAAmjD,YACAx6C,EAAAjL,EAAAiL,qBAEAjL,GAAA+B,OAAAmpC,GAEAvuB,cAAAra,EAAAyC,MACAwX,OAAAxX,EAGAtC,QACAI,EAAAo3E,EAAAz1E,EAAAs1E,QACAh3E,EAAAo3E,EAAA11E,EAAAu1E,QACA30B,aACAC,WACA4zB,gBACAxzB,cACAD,cACA9oC,MAAAzR,EAAAoR,EAAAK,MAAA3X,EAAAP,EAAA6I,KAAA6uB,OAAAn3B,MAIA,IAAArE,GAAAwqC,EAAAzoC,MAEApC,MAAA01D,iBAAA7qB,GAGA8mB,GAAAgoB,EAAArB,gBAEAj4E,EAAA0kD,WADA,IAAArgD,EACAoa,EAAAugD,SAEAp9D,EAAA+yD,UAAAhoD,KAAAtI,EAAA,GAAAtC,OAAA4iD,SAGA3kD,EAAA2kD,SAAA3kD,EAAA0kD,WAAA1kD,EAAAu4E,eAGA/tC,EAAA7oC,SAGA0zD,iBAAA,SAAA7qB,GACA/R,EAAA87B,kBAAA9yD,UAAA4zD,iBAAAlrD,KAAAxK,KAAA6qC,EAAA7qC,KAAAmE,MAAA1E,QAAAib,SAAAmwB,MAGA38B,eAAA,WACA,GAGAhP,GAHA8c,EAAAhc,KAAAi1D,aACA/6C,EAAAla,KAAAg1D,UACAzjD,EAAA,CAcA,OAXA5R,GAAAsI,KAAAiS,EAAAlN,KAAA,SAAAqC,EAAA3K,GACAxF,EAAA8c,EAAAhP,KAAAtI,GACAyuB,MAAAj0B,IAAAmQ,EAAAtN,SACAwP,GAAAnL,KAAAiD,IAAAnK,MAQAqS,GAGAuoE,uBAAA,SAAA56E,GACA,GAAAqS,GAAAvR,KAAAg1D,UAAAzjD,KACA,OAAAA,GAAA,IAAA4hB,MAAAj0B,GACA,EAAAkH,KAAAoiC,IAAApiC,KAAAiD,IAAAnK,GAAAqS,GAEA,GAIAgoE,kBAAA,SAAAQ,GAOA,OAHA58C,GACA68C,EAJA3zE,EAAA,EACA3B,EAAA1E,KAAA0E,MACAzD,EAAA84E,EAAA94E,OAIAV,EAAA,EAAkBA,EAAAU,EAAYV,IAC9B48B,EAAA48C,EAAAx5E,GAAA6B,OAAA23E,EAAAx5E,GAAA6B,OAAA+6B,YAAA,EACA68C,EAAAD,EAAAx5E,GAAAklD,OAAAs0B,EAAAx5E,GAAAklD,OAAA5mC,OAAA7R,KAAAqN,SAAA3V,GAAA4iD,iBAAA,EAEAjhD,EAAA82B,EAAA92B,EAAA82B,EAAA92B,EACAA,EAAA2zE,EAAA3zE,EAAA2zE,EAAA3zE,CAEA,OAAAA,QxDo6dM4zE,KACA,SAAUz7E,EAAQc,EAASZ,GAEjC,YyD5seA,IAAAuF,GAAAvF,EAAA,MACAgc,EAAAhc,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,QACAynC,WAAA,EACAof,UAAA,EAEA7f,OACAE,KAAA,SAGArM,QACAI,QACAh6B,KAAA,WACAuJ,GAAA,aAEAswB,QACA75B,KAAA,SACAuJ,GAAA,gBAKA5L,EAAAc,QAAA,SAAAw5B,GAEA,QAAAohD,GAAAl+D,EAAAvc,GACA,MAAAE,GAAA+K,eAAAsR,EAAA2iB,SAAAl/B,EAAA4nC,WAGAvO,EAAA62B,YAAAzJ,KAAAptB,EAAA87B,kBAAAlzD,QAEAmzD,mBAAAn6C,EAAA3X,KAEA+xD,gBAAAp6C,EAAA1X,MAEAgC,OAAA,SAAA2sD,GACA,GAOApxD,GAAAC,EAAAo1D,EAPA3zD,EAAAjC,KACAka,EAAAjY,EAAA+yD,UACA9O,EAAAhsC,EAAA8B,QACAuhB,EAAArjB,EAAAlN,SACAvN,EAAAwC,EAAAkC,MAAA1E,QACA06E,EAAA16E,EAAAib,SAAAwrC,KACAnY,EAAA9rC,EAAAizD,cAAAh7C,EAAAg5C,SAEAl3C,EAAA/Z,EAAAgzD,aACAt2B,EAAAu7C,EAAAl+D,EAAAvc,EAwCA,KArCAk/B,IACAi3B,EAAA1P,EAAA0P,eAGAnmD,KAAAuM,EAAA8vB,aAAAr8B,KAAAuM,EAAAshB,cACAthB,EAAAshB,YAAAthB,EAAA8vB,SAIAoa,EAAAwc,OAAA30B,EACAmY,EAAA5pC,cAAAra,EAAAyC,MAEAwhD,EAAAQ,UAAAnpB,EAEA2oB,EAAA9jD,QAKAqkD,SAAAzqC,EAAAyqC,SAAAzqC,EAAAyqC,SAAAhnD,EAAAgnD,SACA3a,QAAA8pB,EAAA9pB,QAAA8pB,EAAA9pB,QAAAnsC,EAAA+K,eAAAsR,EAAAshB,YAAA68C,EAAAruC,SACAhP,gBAAA84B,EAAA94B,gBAAA84B,EAAA94B,gBAAA9gB,EAAA8gB,iBAAAq9C,EAAAr9C,gBACAK,YAAAy4B,EAAAz4B,YAAAy4B,EAAAz4B,YAAAnhB,EAAAmhB,aAAAg9C,EAAAh9C,YACAH,YAAA44B,EAAA54B,YAAA44B,EAAA54B,YAAAhhB,EAAAghB,aAAAm9C,EAAAn9C,YACAmpB,eAAAyP,EAAAzP,eAAAyP,EAAAzP,eAAAnqC,EAAAmqC,gBAAAg0B,EAAAh0B,eACAC,WAAAwP,EAAAxP,WAAAwP,EAAAxP,WAAApqC,EAAAoqC,YAAA+zB,EAAA/zB,WACAC,iBAAAuP,EAAAvP,iBAAAuP,EAAAvP,iBAAArqC,EAAAqqC,kBAAA8zB,EAAA9zB,iBACAC,gBAAAsP,EAAAtP,gBAAAsP,EAAAtP,gBAAAtqC,EAAAsqC,iBAAA6zB,EAAA7zB,gBACAvpB,KAAA64B,EAAA74B,KAAA64B,EAAA74B,SAAAttB,KAAAuM,EAAA+gB,KAAA/gB,EAAA+gB,KAAAo9C,EAAAp9C,KACA8O,YAAA+pB,EAAA/pB,YAAA+pB,EAAA/pB,YAAAlsC,EAAA+K,eAAAsR,EAAA6vB,YAAAsuC,EAAAC,SACAC,uBAAAzkB,EAAAykB,uBAAAzkB,EAAAykB,uBAAA16E,EAAA+K,eAAAsR,EAAAq+D,uBAAAF,EAAAE,yBAGAn0B,EAAAlkD,SAIAzB,EAAA,EAAAC,EAAA+8B,EAAAt8B,OAAoCV,EAAAC,IAAUD,EAC9C0B,EAAAuzD,cAAAj4B,EAAAh9B,KAAAoxD,EAQA,KALAhzB,GAAA,IAAAunB,EAAA9jD,OAAA0pC,SACA7pC,EAAAq4E,4BAIA/5E,EAAA,EAAAC,EAAA+8B,EAAAt8B,OAAoCV,EAAAC,IAAUD,EAC9Cg9B,EAAAh9B,GAAAyB,SAIAu4E,wBAAA,SAAA/9D,EAAA9X,GACA,GAAAo4B,GAAA98B,KAAAmE,MAAA1E,QAAAib,SAAA8B,MAAAsgB,gBACA9gB,EAAAhc,KAAAi1D,aACAW,EAAAp5C,EAAAo5C,UAUA,OARAA,GAAA94B,gBACAA,EAAA84B,EAAA94B,gBACI9gB,EAAAihB,qBACJH,EAAAn9B,EAAAiL,sBAAAoR,EAAAihB,qBAAAv4B,EAAAo4B,GACI9gB,EAAA8gB,kBACJA,EAAA9gB,EAAA8gB,iBAGAA,GAGA09C,oBAAA,SAAAh+D,EAAA9X,GACA,GAAAs4B,GAAAh9B,KAAAmE,MAAA1E,QAAAib,SAAA8B,MAAAwgB,YACAhhB,EAAAhc,KAAAi1D,aACAW,EAAAp5C,EAAAo5C,UAUA,OARAA,GAAA54B,YACAA,EAAA44B,EAAA54B,YACIhhB,EAAAy+D,iBACJz9C,EAAAr9B,EAAAiL,sBAAAoR,EAAAy+D,iBAAA/1E,EAAAs4B,GACIhhB,EAAAghB,cACJA,EAAAhhB,EAAAghB,aAGAA,GAGA09C,oBAAA,SAAAl+D,EAAA9X,GACA,GAAAy4B,GAAAn9B,KAAAmE,MAAA1E,QAAAib,SAAA8B,MAAA2gB,YACAnhB,EAAAhc,KAAAi1D,aACAW,EAAAp5C,EAAAo5C,UAUA,OARAziC,OAAAyiC,EAAAz4B,cAEIhK,MAAAnX,EAAA2+D,mBAAAh7E,EAAAqJ,QAAAgT,EAAA2+D,kBACJx9C,EAAAx9B,EAAAiL,sBAAAoR,EAAA2+D,iBAAAj2E,EAAAy4B,GACIhK,MAAAnX,EAAAmhB,eACJA,EAAAnhB,EAAAmhB,aAJAA,EAAAy4B,EAAAz4B,YAOAA,GAGAq4B,cAAA,SAAAh5C,EAAA9X,EAAAitD,GACA,GASAnvD,GAAAC,EATAR,EAAAjC,KACAka,EAAAjY,EAAA+yD,UACAY,EAAAp5C,EAAAo5C,WACA55C,EAAA/Z,EAAAgzD,aACAh5C,EAAAha,EAAAyC,MACAxF,EAAA8c,EAAAhP,KAAAtI,GACA89D,EAAAvgE,EAAAizD,cAAAh7C,EAAAg5C,SACAoP,EAAArgE,EAAAizD,cAAAh7C,EAAA+4C,SACA2nB,EAAA34E,EAAAkC,MAAA1E,QAAAib,SAAA8B,UAIA/M,KAAAuM,EAAAguB,YAAAv6B,KAAAuM,EAAAwhB,cACAxhB,EAAAwhB,YAAAxhB,EAAAguB,YAEAv6B,KAAAuM,EAAAmrC,eAAA13C,KAAAuM,EAAAyhB,iBACAzhB,EAAAyhB,eAAAzhB,EAAAmrC,WAGA3kD,EAAA8/D,EAAAnG,iBAAA,iBAAAj9D,KAAA+8D,IAAAv3D,EAAAuX,GACAxZ,EAAAkvD,EAAA6Q,EAAA7F,eAAA16D,EAAA44E,gBAAA37E,EAAAwF,EAAAuX,GAGAO,EAAA+lD,QAAAD,EACA9lD,EAAAimD,QAAAD,EACAhmD,EAAAF,cAAAL,EACAO,EAAAN,OAAAxX,EAGA8X,EAAApa,QACAI,IACAC,IACA+X,KAAAo7C,EAAAp7C,MAAA2Y,MAAA3wB,IAAA2wB,MAAA1wB,GAEAunC,OAAA4rB,EAAA5rB,QAAArqC,EAAAiL,sBAAAoR,EAAAwhB,YAAA94B,EAAAk2E,EAAA5wC,QACAqd,WAAAuO,EAAAvO,YAAA1nD,EAAAiL,sBAAAoR,EAAAqrC,WAAA3iD,EAAAk2E,EAAAvzB,YACAvqB,gBAAA76B,EAAAs4E,wBAAA/9D,EAAA9X,GACAs4B,YAAA/6B,EAAAu4E,oBAAAh+D,EAAA9X,GACAy4B,YAAAl7B,EAAAy4E,oBAAAl+D,EAAA9X,GACAonC,QAAA5xB,EAAA8B,QAAA5Z,OAAA8X,EAAA8B,QAAA5Z,OAAA0pC,QAAA,EACAD,cAAA3xB,EAAA8B,QAAA5Z,QAAA8X,EAAA8B,QAAA5Z,OAAAypC,YAEAsb,UAAAyO,EAAAzO,WAAAxnD,EAAAiL,sBAAAoR,EAAAyhB,eAAA/4B,EAAAk2E,EAAAzzB,aAIA0zB,gBAAA,SAAA37E,EAAAwF,EAAAuX,GACA,GAMA1b,GAAAk4E,EAAAqC,EANA74E,EAAAjC,KACAmE,EAAAlC,EAAAkC,MACA+V,EAAAjY,EAAA+yD,UACAwN,EAAAvgE,EAAAizD,cAAAh7C,EAAAg5C,SACA6nB,EAAA,EACAC,EAAA,CAGA,IAAAxY,EAAA/iE,QAAAoyB,QAAA,CACA,IAAAtxB,EAAA,EAAeA,EAAA0b,EAAkB1b,IAGjC,GAFAk4E,EAAAt0E,EAAA6I,KAAAqN,SAAA9Z,GACAu6E,EAAA32E,EAAAoW,eAAAha,GACA,SAAAu6E,EAAAj6E,MAAAi6E,EAAA5nB,UAAAsP,EAAAp4D,IAAAjG,EAAAmW,iBAAA/Z,GAAA,CACA,GAAA06E,GAAAjgE,OAAAwnD,EAAAzG,cAAA0c,EAAAzrE,KAAAtI,IACAu2E,GAAA,EACAD,GAAAC,GAAA,EAEAF,GAAAE,GAAA,EAKA,GAAAhQ,GAAAjwD,OAAAwnD,EAAAzG,cAAA78D,GACA,OAAA+rE,GAAA,EACAzI,EAAArG,iBAAA6e,EAAA/P,GAEAzI,EAAArG,iBAAA4e,EAAA9P,GAGA,MAAAzI,GAAArG,iBAAAj9D,IAGAo7E,0BAAA,WAcA,QAAAY,GAAAhU,EAAAv9D,EAAAtD,GACA,MAAAD,MAAAC,IAAAD,KAAAuD,IAAAu9D,EAAA7gE,GAAAsD,GAdA,GAIApJ,GAAAC,EAAAgc,EAAAnc,EAAA86E,EAJAl5E,EAAAjC,KACAka,EAAAjY,EAAA+yD,UACAx0B,EAAAv+B,EAAAkC,MAAA0E,UACA00B,EAAArjB,EAAAlN,QAcA,IAVAkN,EAAA8B,QAAA5Z,OAAAqkD,WACAlpB,IAAA1rB,OAAA,SAAAq1D,GACA,OAAAA,EAAA9kE,OAAAoY,QAQA,aAAAN,EAAA8B,QAAA5Z,OAAAi4E,uBACA16E,EAAAoxC,oBAAAxT,OAEA,KAAAh9B,EAAA,EAAAC,EAAA+8B,EAAAt8B,OAAqCV,EAAAC,IAAUD,EAC/Cic,EAAA+gB,EAAAh9B,GACAF,EAAAmc,EAAApa,OACA+4E,EAAAx7E,EAAAuwC,YACAvwC,EAAAmyC,aAAAvU,EAAAh9B,GAAA6B,OACA/B,EACAV,EAAAiyC,SAAArU,EAAAh9B,GAAA6B,OACA8X,EAAA8B,QAAA5Z,OAAA0pC,SAEAzrC,EAAA2rC,sBAAAmvC,EAAAxvC,SAAAnpC,EACAnC,EAAA6rC,sBAAAivC,EAAAxvC,SAAAlpC,EACApC,EAAA4rC,kBAAAkvC,EAAA5qC,KAAA/tC,EACAnC,EAAA8rC,kBAAAgvC,EAAA5qC,KAAA9tC,CAIA,IAAAR,EAAAkC,MAAA1E,QAAAib,SAAAwrC,KAAAK,gBACA,IAAAhmD,EAAA,EAAAC,EAAA+8B,EAAAt8B,OAAqCV,EAAAC,IAAUD,EAC/CF,EAAAk9B,EAAAh9B,GAAA6B,OACA/B,EAAA2rC,sBAAAkvC,EAAA76E,EAAA2rC,sBAAAxL,EAAAr6B,KAAAq6B,EAAAh6B,OACAnG,EAAA6rC,sBAAAgvC,EAAA76E,EAAA6rC,sBAAA1L,EAAA75B,IAAA65B,EAAA55B,QACAvG,EAAA4rC,kBAAAivC,EAAA76E,EAAA4rC,kBAAAzL,EAAAr6B,KAAAq6B,EAAAh6B,OACAnG,EAAA8rC,kBAAA+uC,EAAA76E,EAAA8rC,kBAAA3L,EAAA75B,IAAA65B,EAAA55B,SAKA08B,KAAA,WACA,GAAArhC,GAAAjC,KACAmE,EAAAlC,EAAAkC,MACA+V,EAAAjY,EAAA+yD,UACAz3B,EAAArjB,EAAAlN,SACAwzB,EAAAr8B,EAAA0E,UACArI,EAAA+8B,EAAAt8B,OACAV,EAAA,CAWA,KATAZ,EAAAH,OAAA8rC,SAAAnnC,EAAA46B,IAAAyB,GAEA05C,EAAAj4E,EAAAgzD,aAAA9wD,EAAA1E,UACAya,EAAA8B,QAAAsnB,OAGA3jC,EAAAH,OAAAisC,WAAAtnC,EAAA46B,KAGSx+B,EAAAC,IAAUD,EACnBg9B,EAAAh9B,GAAA+iC,KAAA9C,IAIAq1B,cAAA,SAAAr5C,GAEA,GAAAR,GAAAhc,KAAAmE,MAAA6I,KAAAqN,SAAAmC,EAAAF,eACA5X,EAAA8X,EAAAN,OACA05C,EAAAp5C,EAAAo5C,WACAv1D,EAAAmc,EAAApa,MAEA/B,GAAA2pC,OAAA4rB,EAAAjR,aAAAhlD,EAAAiL,sBAAAoR,EAAAo/D,iBAAA12E,EAAA1E,KAAAmE,MAAA1E,QAAAib,SAAA8B,MAAAmoC,aACAtkD,EAAAy8B,gBAAA84B,EAAAE,sBAAAn2D,EAAAiL,sBAAAoR,EAAAkhB,0BAAAx4B,EAAA/E,EAAAi2C,cAAAv1C,EAAAy8B,kBACAz8B,EAAA28B,YAAA44B,EAAAG,kBAAAp2D,EAAAiL,sBAAAoR,EAAAq/D,sBAAA32E,EAAA/E,EAAAi2C,cAAAv1C,EAAA28B,cACA38B,EAAA88B,YAAAy4B,EAAAtO,kBAAA3nD,EAAAiL,sBAAAoR,EAAAs/D,sBAAA52E,EAAArE,EAAA88B,cAGAu4B,iBAAA,SAAAl5C,GACA,GAAAva,GAAAjC,KACAgc,EAAA/Z,EAAAkC,MAAA6I,KAAAqN,SAAAmC,EAAAF,eACA5X,EAAA8X,EAAAN,OACA05C,EAAAp5C,EAAAo5C,WACAv1D,EAAAmc,EAAApa,WAGAqN,KAAAuM,EAAAguB,YAAAv6B,KAAAuM,EAAAwhB,cACAxhB,EAAAwhB,YAAAxhB,EAAAguB,QAGA3pC,EAAA2pC,OAAA4rB,EAAA5rB,QAAArqC,EAAAiL,sBAAAoR,EAAAwhB,YAAA94B,EAAAzC,EAAAkC,MAAA1E,QAAAib,SAAA8B,MAAAwtB,QACA3pC,EAAAy8B,gBAAA76B,EAAAs4E,wBAAA/9D,EAAA9X,GACArE,EAAA28B,YAAA/6B,EAAAu4E,oBAAAh+D,EAAA9X,GACArE,EAAA88B,YAAAl7B,EAAAy4E,oBAAAl+D,EAAA9X,QzDuteM62E,KACA,SAAU/8E,EAAQc,EAASZ,GAEjC,Y0DjifA,IAAAuF,GAAAvF,EAAA,MACAgc,EAAAhc,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,aACAmuC,OACAltC,KAAA,eACAorE,YACA3+C,SAAA,GAEAwN,WACAszC,UAAA,GAEAlC,aACA5+C,SAAA,GAEAnkB,OACA0uD,aAAA,IAKAx9B,WACAi+C,eAAA,EACAC,cAAA,GAGAxzB,YAAA,GAAA3+C,KAAAoiC,GACA6qB,eAAA,SAAAlvD,GACA,GAAAopB,KACAA,GAAAhpB,KAAA,cAAAJ,EAAAiG,GAAA,YAEA,IAAA4C,GAAA7I,EAAA6I,KACAqN,EAAArN,EAAAqN,SACAwhB,EAAA7uB,EAAA6uB,MAEA,IAAAxhB,EAAApZ,OACA,OAAAV,GAAA,EAAkBA,EAAA8Z,EAAA,GAAArN,KAAA/L,SAA6BV,EAC/CgtB,EAAAhpB,KAAA,qCAAA8V,EAAA,GAAAyiB,gBAAAv8B,GAAA,aACAs7B,EAAAt7B,IACAgtB,EAAAhpB,KAAAs3B,EAAAt7B,IAEAgtB,EAAAhpB,KAAA,QAKA,OADAgpB,GAAAhpB,KAAA,SACAgpB,EAAAtM,KAAA,KAEA8L,QACA8O,QACA28C,eAAA,SAAAr0E,GACA,GAAA6I,GAAA7I,EAAA6I,IACA,OAAAA,GAAA6uB,OAAA56B,QAAA+L,EAAAqN,SAAApZ,OACA+L,EAAA6uB,OAAAtwB,IAAA,SAAA8Q,EAAA9b,GACA,GAAA2Z,GAAA/V,EAAAoW,eAAA,GACAk+D,EAAAzrE,EAAAqN,SAAA,GACAwwB,EAAA3wB,EAAAlN,KAAAzM,GACAq1D,EAAA/qB,EAAA+qB,WACAhrD,EAAAjL,EAAAiL,sBACA8tE,EAAAv0E,EAAA1E,QAAAib,SAAAmwB,GAKA,QACAtd,KAAAlR,EACAypC,UANA8P,EAAA94B,gBAAA84B,EAAA94B,gBAAAlyB,EAAA6tE,EAAA37C,gBAAAv8B,EAAAm4E,EAAA57C,iBAOA8oB,YANAgQ,EAAA54B,YAAA44B,EAAA54B,YAAApyB,EAAA6tE,EAAAz7C,YAAAz8B,EAAAm4E,EAAA17C,aAOA6oB,UANA+P,EAAAz4B,YAAAy4B,EAAAz4B,YAAAvyB,EAAA6tE,EAAAt7C,YAAA58B,EAAAm4E,EAAAv7C,aAOAp7B,OAAAoxB,MAAAslD,EAAAzrE,KAAAzM,KAAA2Z,EAAAlN,KAAAzM,GAAAwB,OAGA2C,MAAAnE,UAQA4mB,QAAA,SAAArN,EAAA6+D,GACA,GAEAp4E,GAAAC,EAAA0Z,EAFAxV,EAAAi0E,EAAAj0E,MACAP,EAAAnE,KAAAmE,KAGA,KAAA5D,EAAA,EAAAC,GAAA2D,EAAA6I,KAAAqN,cAAApZ,OAAyDV,EAAAC,IAAUD,EACnE2Z,EAAA/V,EAAAoW,eAAAha,GACA2Z,EAAAlN,KAAAtI,GAAA3C,QAAAmY,EAAAlN,KAAAtI,GAAA3C,MAGAoC,GAAAa,WAKAs1B,UACAE,WACAnN,MAAA,WACA,UAEAhR,MAAA,SAAAjY,EAAA4I,GACA,MAAAA,GAAA6uB,OAAAz3B,EAAAM,OAAA,KAAAN,EAAAo9D,YAMAhjE,EAAAc,QAAA,SAAAw5B,GAEAA,EAAA62B,YAAA6rB,UAAA1iD,EAAA87B,kBAAAlzD,QAEAozD,gBAAAp6C,EAAA5X,IAEA0uD,WAAA7xD,EAAAuK,KAEAlF,OAAA,SAAA2sD,GACA,GAAA1vD,GAAAjC,KACAmE,EAAAlC,EAAAkC,MACA0E,EAAA1E,EAAA0E,UACAqR,EAAAjY,EAAA+yD,UACAl2C,EAAA3a,EAAA1E,QACAi5E,EAAA55D,EAAApE,SAAAmwB,IACAxlC,EAAAe,KAAAuD,IAAAd,EAAArC,MAAAqC,EAAA1C,KAAA0C,EAAAjC,OAAAiC,EAAAlC,IACAxC,GAAAihD,YAAAh/C,KAAAC,KAAAhB,EAAAqzE,EAAAv7C,YAAA,QACAh5B,EAAAghD,YAAA/+C,KAAAC,IAAAyY,EAAAwf,iBAAAn6B,EAAAihD,YAAA,IAAAtmC,EAAA,sBACA3a,EAAAq1E,cAAAr1E,EAAAihD,YAAAjhD,EAAAghD,aAAAhhD,EAAAgvD,yBAEAlxD,EAAAmjD,YAAAjhD,EAAAihD,YAAAjhD,EAAAq1E,aAAAv3E,EAAAyC,MACAzC,EAAAkjD,YAAAljD,EAAAmjD,YAAAjhD,EAAAq1E,aAEAt/D,EAAAiE,MAAAlc,EAAAw5E,uBAEA97E,EAAAsI,KAAAiS,EAAAlN,KAAA,SAAA69B,EAAAnmC,GACAzC,EAAAuzD,cAAA3qB,EAAAnmC,EAAAitD,MAIA6D,cAAA,SAAA3qB,EAAAnmC,EAAAitD,GAiBA,OAhBA1vD,GAAAjC,KACAmE,EAAAlC,EAAAkC,MACA6X,EAAA/Z,EAAAgzD,aACAn2C,EAAA3a,EAAA1E,QACAk6E,EAAA76D,EAAAub,UACA0T,EAAA5pC,EAAA4pC,MACAlS,EAAA13B,EAAA6I,KAAA6uB,OAEA+8C,EAAA32E,EAAA63E,uBAAA99D,EAAAhP,KAAAtI,IACAk1E,EAAA7rC,EAAAggC,QACA8L,EAAA9rC,EAAAigC,QAIA0N,EAAA,EACAxhE,EAAAjY,EAAA+yD,UACAz0D,EAAA,EAAkBA,EAAAmE,IAAWnE,EAC7B4yB,MAAAnX,EAAAhP,KAAAzM,KAAA2Z,EAAAlN,KAAAzM,GAAAwB,UACA25E,CAKA,IAAAC,GAAA78D,EAAAimC,WACA1pC,EAAAwvB,EAAA9oC,OAAA,EAAAgsC,EAAA8/B,8BAAA7xD,EAAAhP,KAAAtI,IACAqgD,EAAA42B,EAAA/C,EAAA8C,EACA12B,EAAAD,GAAAla,EAAA9oC,OAAA,EAAA62E,GAEAgD,EAAAjC,EAAApB,aAAA,EAAAxqC,EAAA8/B,8BAAA7xD,EAAAhP,KAAAtI,GAEA/E,GAAA+B,OAAAmpC,GAEAvuB,cAAAra,EAAAyC,MACAwX,OAAAxX,EACAg+D,OAAA30B,EAGA3rC,QACAI,EAAAo3E,EACAn3E,EAAAo3E,EACA10B,YAAA,EACAC,YAAAuM,EAAAiqB,EAAAvgE,EACA0pC,WAAA4M,GAAAgoB,EAAArB,cAAAqD,EAAA52B,EACAC,SAAA2M,GAAAgoB,EAAArB,cAAAqD,EAAA32B,EACA3oC,MAAA1c,EAAAiL,sBAAAixB,EAAAn3B,EAAAm3B,EAAAn3B,OAKAzC,EAAAyzD,iBAAA7qB,GAEAA,EAAA7oC,SAGA0zD,iBAAA,SAAA7qB,GACA/R,EAAA87B,kBAAA9yD,UAAA4zD,iBAAAlrD,KAAAxK,KAAA6qC,EAAA7qC,KAAAmE,MAAA1E,QAAAib,SAAAmwB,MAGA4wC,qBAAA,WACA,GAAAz/D,GAAAhc,KAAAi1D,aACA/6C,EAAAla,KAAAg1D,UACA72C,EAAA,CAQA,OANAxe,GAAAsI,KAAAiS,EAAAlN,KAAA,SAAAqC,EAAA3K,GACAyuB,MAAAnX,EAAAhP,KAAAtI,KAAA2K,EAAAtN,QACAoc,MAIAA,GAGA27D,uBAAA,SAAA56E,GACA,GAAAif,GAAAne,KAAAg1D,UAAA72C,KACA,OAAAA,GAAA,IAAAgV,MAAAj0B,GACA,EAAAkH,KAAAoiC,GAAArqB,EAEA,O1D4ifM09D,KACA,SAAUr9E,EAAQc,EAASZ,GAEjC,Y2DvwfA,IAAAuF,GAAAvF,EAAA,MACAgc,EAAAhc,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,SACAmuC,OACAltC,KAAA,gBAEA6Z,UACAwrC,MACApa,QAAA,MAKAttC,EAAAc,QAAA,SAAAw5B,GAEAA,EAAA62B,YAAAmsB,MAAAhjD,EAAA87B,kBAAAlzD,QAEAmzD,mBAAAn6C,EAAA3X,KAEA+xD,gBAAAp6C,EAAA1X,MAEAwuD,WAAA7xD,EAAAuK,KAEAlF,OAAA,SAAA2sD,GACA,GAAA1vD,GAAAjC,KACAka,EAAAjY,EAAA+yD,UACA9O,EAAAhsC,EAAA8B,QACAuhB,EAAArjB,EAAAlN,KACA4oD,EAAA1P,EAAA0P,WACA55C,EAAA/Z,EAAAgzD,aACAklB,EAAAl4E,EAAAkC,MAAA1E,QAAAib,SAAAwrC,KACAnY,EAAA9rC,EAAAkC,MAAA4pC,UAGAt+B,KAAAuM,EAAA8vB,aAAAr8B,KAAAuM,EAAAshB,cACAthB,EAAAshB,YAAAthB,EAAA8vB,SAGAnsC,EAAA+B,OAAAwY,EAAA8B,SAEAM,cAAAra,EAAAyC,MACAg+D,OAAA30B,EAEA2Y,UAAAnpB,EACAspB,OAAA,EAEAzkD,QAEA0pC,QAAA8pB,EAAA9pB,QAAA8pB,EAAA9pB,QAAAnsC,EAAA+K,eAAAsR,EAAAshB,YAAA68C,EAAAruC,SACAhP,gBAAA84B,EAAA94B,gBAAA84B,EAAA94B,gBAAA9gB,EAAA8gB,iBAAAq9C,EAAAr9C,gBACAK,YAAAy4B,EAAAz4B,YAAAy4B,EAAAz4B,YAAAnhB,EAAAmhB,aAAAg9C,EAAAh9C,YACAH,YAAA44B,EAAA54B,YAAA44B,EAAA54B,YAAAhhB,EAAAghB,aAAAm9C,EAAAn9C,YACAD,KAAA64B,EAAA74B,KAAA64B,EAAA74B,SAAAttB,KAAAuM,EAAA+gB,KAAA/gB,EAAA+gB,KAAAo9C,EAAAp9C,KACAopB,eAAAyP,EAAAzP,eAAAyP,EAAAzP,eAAAnqC,EAAAmqC,gBAAAg0B,EAAAh0B,eACAC,WAAAwP,EAAAxP,WAAAwP,EAAAxP,WAAApqC,EAAAoqC,YAAA+zB,EAAA/zB,WACAC,iBAAAuP,EAAAvP,iBAAAuP,EAAAvP,iBAAArqC,EAAAqqC,kBAAA8zB,EAAA9zB,iBACAC,gBAAAsP,EAAAtP,gBAAAsP,EAAAtP,gBAAAtqC,EAAAsqC,iBAAA6zB,EAAA7zB,mBAIApsC,EAAA8B,QAAAha,QAGArC,EAAAsI,KAAAs1B,EAAA,SAAA/gB,EAAA9X,GACAzC,EAAAuzD,cAAAh5C,EAAA9X,EAAAitD,IACI1vD,GAGJA,EAAAq4E,6BAEA9kB,cAAA,SAAAh5C,EAAA9X,EAAAitD,GACA,GAAA1vD,GAAAjC,KACA41D,EAAAp5C,EAAAo5C,WACA55C,EAAA/Z,EAAAgzD,aACAlnB,EAAA9rC,EAAAkC,MAAA4pC,MACAguC,EAAA95E,EAAAkC,MAAA1E,QAAAib,SAAA8B,MACAiwD,EAAA1+B,EAAA6hC,yBAAAlrE,EAAAsX,EAAAhP,KAAAtI,QAGA+K,KAAAuM,EAAAguB,YAAAv6B,KAAAuM,EAAAwhB,cACAxhB,EAAAwhB,YAAAxhB,EAAAguB,YAEAv6B,KAAAuM,EAAAmrC,eAAA13C,KAAAuM,EAAAyhB,iBACAzhB,EAAAyhB,eAAAzhB,EAAAmrC,WAGAxnD,EAAA+B,OAAA8a,GAEAF,cAAAra,EAAAyC,MACAwX,OAAAxX,EACAg+D,OAAA30B,EAGA3rC,QACAI,EAAAmvD,EAAA5jB,EAAAggC,QAAAtB,EAAAjqE,EACAC,EAAAkvD,EAAA5jB,EAAAigC,QAAAvB,EAAAhqE,EAGAqpC,QAAA8pB,EAAA9pB,QAAA8pB,EAAA9pB,QAAAnsC,EAAA+K,eAAAsR,EAAAshB,YAAAr7B,EAAAkC,MAAA1E,QAAAib,SAAAwrC,KAAApa,SACA9B,OAAA4rB,EAAA5rB,OAAA4rB,EAAA5rB,OAAArqC,EAAAiL,sBAAAoR,EAAAwhB,YAAA94B,EAAAq3E,EAAA/xC,QACAlN,gBAAA84B,EAAA94B,gBAAA84B,EAAA94B,gBAAAn9B,EAAAiL,sBAAAoR,EAAAihB,qBAAAv4B,EAAAq3E,EAAAj/C,iBACAE,YAAA44B,EAAA54B,YAAA44B,EAAA54B,YAAAr9B,EAAAiL,sBAAAoR,EAAAy+D,iBAAA/1E,EAAAq3E,EAAA/+C,aACAG,YAAAy4B,EAAAz4B,YAAAy4B,EAAAz4B,YAAAx9B,EAAAiL,sBAAAoR,EAAA2+D,iBAAAj2E,EAAAq3E,EAAA5+C,aACAkqB,WAAAuO,EAAAvO,WAAAuO,EAAAvO,WAAA1nD,EAAAiL,sBAAAoR,EAAAqrC,WAAA3iD,EAAAq3E,EAAA10B,YAGAF,UAAAyO,EAAAzO,UAAAyO,EAAAzO,UAAAxnD,EAAAiL,sBAAAoR,EAAAyhB,eAAA/4B,EAAAq3E,EAAA50B,cAIA3qC,EAAApa,OAAAoY,KAAAo7C,EAAAp7C,KAAAo7C,EAAAp7C,KAAA2Y,MAAA3W,EAAApa,OAAAI,IAAA2wB,MAAA3W,EAAApa,OAAAK,IAEA63E,0BAAA,WACA,GAAAzxE,GAAA7I,KAAAmE,MAAA0E,UACAqR,EAAAla,KAAAg1D,SAEAr1D,GAAAsI,KAAAiS,EAAAlN,KAAA,SAAAwP,EAAA9X,GACA,GAAArE,GAAAmc,EAAApa,OACA+4E,EAAAx7E,EAAAuwC,YACAvwC,EAAAmyC,aAAA53B,EAAAlN,KAAAtI,GAAA,GAAAtC,OACA/B,EACAV,EAAAiyC,SAAA13B,EAAAlN,KAAAtI,GAAA,GAAAtC,OACA/B,EAAAyrC,QAIAzrC,GAAA2rC,sBAAA5lC,KAAAC,IAAAD,KAAAuD,IAAAwxE,EAAAxvC,SAAAnpC,EAAAqG,EAAArC,OAAAqC,EAAA1C,MACA9F,EAAA6rC,sBAAA9lC,KAAAC,IAAAD,KAAAuD,IAAAwxE,EAAAxvC,SAAAlpC,EAAAoG,EAAAjC,QAAAiC,EAAAlC,KAEAtG,EAAA4rC,kBAAA7lC,KAAAC,IAAAD,KAAAuD,IAAAwxE,EAAA5qC,KAAA/tC,EAAAqG,EAAArC,OAAAqC,EAAA1C,MACA9F,EAAA8rC,kBAAA/lC,KAAAC,IAAAD,KAAAuD,IAAAwxE,EAAA5qC,KAAA9tC,EAAAoG,EAAAjC,QAAAiC,EAAAlC,KAGA6V,EAAAxa,WAIA6zD,cAAA,SAAAr5C,GAEA,GAAAR,GAAAhc,KAAAmE,MAAA6I,KAAAqN,SAAAmC,EAAAF,eACAs5C,EAAAp5C,EAAAo5C,WACAlxD,EAAA8X,EAAAN,OACA7b,EAAAmc,EAAApa,MAEA/B,GAAA2pC,OAAA4rB,EAAAjR,YAAAiR,EAAAjR,YAAAhlD,EAAAiL,sBAAAoR,EAAAo/D,iBAAA12E,EAAA1E,KAAAmE,MAAA1E,QAAAib,SAAA8B,MAAAmoC,aACAtkD,EAAAy8B,gBAAA84B,EAAAE,qBAAAF,EAAAE,qBAAAn2D,EAAAiL,sBAAAoR,EAAAkhB,0BAAAx4B,EAAA/E,EAAAi2C,cAAAv1C,EAAAy8B,kBACAz8B,EAAA28B,YAAA44B,EAAAG,iBAAAH,EAAAG,iBAAAp2D,EAAAiL,sBAAAoR,EAAAq/D,sBAAA32E,EAAA/E,EAAAi2C,cAAAv1C,EAAA28B,cACA38B,EAAA88B,YAAAy4B,EAAAtO,iBAAAsO,EAAAtO,iBAAA3nD,EAAAiL,sBAAAoR,EAAAs/D,sBAAA52E,EAAArE,EAAA88B,cAGAu4B,iBAAA,SAAAl5C,GACA,GAAAR,GAAAhc,KAAAmE,MAAA6I,KAAAqN,SAAAmC,EAAAF,eACAs5C,EAAAp5C,EAAAo5C,WACAlxD,EAAA8X,EAAAN,OACA7b,EAAAmc,EAAApa,OACA25E,EAAA/7E,KAAAmE,MAAA1E,QAAAib,SAAA8B,KAEAnc,GAAA2pC,OAAA4rB,EAAA5rB,OAAA4rB,EAAA5rB,OAAArqC,EAAAiL,sBAAAoR,EAAAwhB,YAAA94B,EAAAq3E,EAAA/xC,QACA3pC,EAAAy8B,gBAAA84B,EAAA94B,gBAAA84B,EAAA94B,gBAAAn9B,EAAAiL,sBAAAoR,EAAAihB,qBAAAv4B,EAAAq3E,EAAAj/C,iBACAz8B,EAAA28B,YAAA44B,EAAA54B,YAAA44B,EAAA54B,YAAAr9B,EAAAiL,sBAAAoR,EAAAy+D,iBAAA/1E,EAAAq3E,EAAA/+C,aACA38B,EAAA88B,YAAAy4B,EAAAz4B,YAAAy4B,EAAAz4B,YAAAx9B,EAAAiL,sBAAAoR,EAAA2+D,iBAAAj2E,EAAAq3E,EAAA5+C,kB3DkxfM6+C,KACA,SAAUx9E,EAAQc,EAASZ,GAEjC,Y4Dv7fAA,GAAA,MAEAkB,KAAA,WACAgnC,OACAE,KAAA,UAGArM,QACAI,QACAzwB,GAAA,WACAvJ,KAAA,SACAwC,SAAA,WAEAq3B,QACAtwB,GAAA,WACAvJ,KAAA,SACAwC,SAAA,UAIAgkC,WAAA,EAEA/M,UACAE,WACAnN,MAAA,WACA,UAEAhR,MAAA,SAAAjY,GACA,UAAAA,EAAAg9D,OAAA,KAAAh9D,EAAAo9D,OAAA,SAMAhjE,EAAAc,QAAA,SAAAw5B,GAGAA,EAAA62B,YAAAssB,QAAAnjD,EAAA62B,YAAAzJ,O5Di8fMg2B,KACA,SAAU19E,EAAQc,EAASZ,GAEjC,Y6Dz+fAF,GAAAc,QAAA,SAAAw5B,GAEAA,EAAAqjD,IAAA,SAAA1vC,EAAA5tB,GAGA,MAFAA,GAAAhe,KAAA,MAEA,GAAAi4B,GAAA2T,EAAA5tB,M7Do/fMu9D,KACA,SAAU59E,EAAQc,EAASZ,GAEjC,Y8D5/fAF,GAAAc,QAAA,SAAAw5B,GAEAA,EAAAujD,OAAA,SAAA5vC,EAAA5tB,GAEA,MADAA,GAAAhe,KAAA,SACA,GAAAi4B,GAAA2T,EAAA5tB,M9DuggBMy9D,KACA,SAAU99E,EAAQc,EAASZ,GAEjC,Y+D9ggBAF,GAAAc,QAAA,SAAAw5B,GAEAA,EAAApM,SAAA,SAAA+f,EAAA5tB,GAGA,MAFAA,GAAAhe,KAAA,WAEA,GAAAi4B,GAAA2T,EAAA5tB,M/DyhgBM09D,KACA,SAAU/9E,EAAQc,EAASZ,GAEjC,YgEjigBAF,GAAAc,QAAA,SAAAw5B,GAEAA,EAAA/1B,KAAA,SAAA0pC,EAAA5tB,GAGA,MAFAA,GAAAhe,KAAA,OAEA,GAAAi4B,GAAA2T,EAAA5tB,MhE4igBM29D,KACA,SAAUh+E,EAAQc,EAASZ,GAEjC,YiEpjgBAF,GAAAc,QAAA,SAAAw5B,GAEAA,EAAA2jD,UAAA,SAAAhwC,EAAA5tB,GAGA,MAFAA,GAAAhe,KAAA,YAEA,GAAAi4B,GAAA2T,EAAA5tB,MjE+jgBM69D,KACA,SAAUl+E,EAAQc,EAASZ,GAEjC,YkEvkgBAF,GAAAc,QAAA,SAAAw5B,GAEAA,EAAA6jD,MAAA,SAAAlwC,EAAA5tB,GAGA,MAFAA,GAAAhe,KAAA,QAEA,GAAAi4B,GAAA2T,EAAA5tB,MlEklgBM+9D,KACA,SAAUp+E,EAAQc,EAASZ,GAEjC,YmE1lgBAF,GAAAc,QAAA,SAAAw5B,GACAA,EAAA+jD,QAAA,SAAApwC,EAAA5tB,GAEA,MADAA,GAAAhe,KAAA,UACA,GAAAi4B,GAAA2T,EAAA5tB,MnEomgBMi+D,KACA,SAAUt+E,EAAQc,EAASZ,GAEjC,YoE1mgBAF,GAAAc,WACAd,EAAAc,QAAAy9E,OAAAr+E,EAAA,MACAF,EAAAc,QAAAytB,OAAAruB,EAAA,MACAF,EAAAc,QAAA+tB,MAAA3uB,EAAA,OpEkngBMs+E,KACA,SAAUx+E,EAAQc,EAASZ,GAEjC,YqEzkgBA,SAAAu+E,GAAA9oC,EAAAzvC,EAAAyZ,GACA,GAEAvd,GAFAP,EAAA8zC,EAAA/xC,WACA26B,EAAA18B,EAAA08B,IAOA,QAJAttB,KAAAstB,IACAA,IAAA18B,EAAAy8B,kBAGA,IAAAC,GAAA,OAAAA,EACA,QAGA,SAAAA,EACA,cAIA,IADAn8B,EAAA+S,WAAAopB,EAAA,IACAx7B,SAAAX,IAAAwF,KAAAkD,MAAA1I,OAKA,MAJA,MAAAm8B,EAAA,UAAAA,EAAA,KACAn8B,EAAA8D,EAAA9D,KAGAA,IAAA8D,GAAA9D,EAAA,GAAAA,GAAAud,IAIAvd,CAGA,QAAAm8B,GAEA,aACA,aACA,WACA,WACA,YACA,cAEA,cACA,YACA,UACA,MAAAA,EAEA,SACA,UAIA,QAAAmgD,GAAA5xE,GACA,GAIAzF,GAJAxF,EAAAiL,EAAA6oC,GAAA/xC,WACA2rC,EAAAziC,EAAA6oC,GAAAuuB,WACA3lC,EAAAzxB,EAAAyxB,KACAn8B,EAAA,IAGA,IAAAW,SAAAw7B,GACA,WAmBA,IAZA,UAAAA,EACAn8B,MAAA6O,KAAApP,EAAA88E,YAAApvC,EAAAnnC,OAAAvG,EAAA88E,YACE,QAAApgD,EACFn8B,MAAA6O,KAAApP,EAAA+8E,SAAArvC,EAAApnC,IAAAtG,EAAA+8E,aACE3tE,KAAApP,EAAAg9E,UACFz8E,EAAAP,EAAAg9E,UACEtvC,EAAA8hC,gBACFjvE,EAAAmtC,EAAA8hC,kBACE9hC,EAAA4uB,eACF/7D,EAAAmtC,EAAA4uB,oBAGAltD,KAAA7O,GAAA,OAAAA,EAAA,CACA,OAAA6O,KAAA7O,EAAA4B,OAAAiN,KAAA7O,EAAA6B,EACA,MAAA7B,EAGA,qBAAAA,IAAAW,SAAAX,GAEA,MADAiF,GAAAkoC,EAAAzoC,gBAEA9C,EAAAqD,EAAAjF,EAAA,KACA6B,EAAAoD,EAAA,KAAAjF,GAKA,YAGA,QAAA08E,GAAAvxE,EAAArH,EAAA64E,GACA,GAGA38E,GAHA0K,EAAAS,EAAArH,GACAq4B,EAAAzxB,EAAAyxB,KACAygD,GAAA94E,EAGA,KAAA64E,EACA,MAAAxgD,EAGA,WAAAA,IAAA,IAAAygD,EAAA74E,QAAAo4B,IAAA,CACA,IAAAx7B,SAAAw7B,GACA,MAAAA,EAIA,MADAn8B,EAAAmL,EAAAgxB,IAEA,QAGA,IAAAn8B,EAAA0Q,QACA,MAAAyrB,EAGAygD,GAAAj5E,KAAAw4B,GACAA,EAAAn8B,EAAAm8B,KAGA,SAGA,QAAA0gD,GAAAnyE,GACA,GAAAyxB,GAAAzxB,EAAAyxB,KACAl8B,EAAA,SAEA,YAAAk8B,EACA,MAGAx7B,SAAAw7B,KACAl8B,EAAA,YAGA68E,EAAA78E,GAAAyK,IAGA,QAAAqyE,GAAAnhE,GACA,MAAAA,OAAAhC,KAGA,QAAAojE,GAAA7+C,EAAA8+C,EAAAC,EAAAC,EAAAC,GACA,GAAAz9E,EAEA,IAAAw9E,GAAAC,EAAA,CAMA,IADAj/C,EAAA9Y,OAAA43D,EAAA,GAAAr7E,EAAAq7E,EAAA,GAAAp7E,GACAlC,EAAA,EAAYA,EAAAw9E,IAAUx9E,EACtBZ,EAAAH,OAAA2qC,OAAApL,EAAA8+C,EAAAt9E,EAAA,GAAAs9E,EAAAt9E,GAOA,KAHAw+B,EAAAoL,OAAA2zC,EAAAE,EAAA,GAAAx7E,EAAAs7E,EAAAE,EAAA,GAAAv7E,GAGAlC,EAAAy9E,EAAA,EAAmBz9E,EAAA,IAAOA,EAC1BZ,EAAAH,OAAA2qC,OAAApL,EAAA++C,EAAAv9E,GAAAu9E,EAAAv9E,EAAA,QAIA,QAAA09E,GAAAl/C,EAAAxB,EAAA2gD,EAAA99E,EAAAe,EAAA0wC,GACA,GAMAtxC,GAAAC,EAAAkE,EAAAy5E,EAAAC,EAAAC,EAAAC,EANAngE,EAAAof,EAAAt8B,OACAkqB,EAAA/qB,EAAAqmD,SACAo3B,KACAC,KACAC,EAAA,EACAC,EAAA,CAKA,KAFAj/C,EAAA6L,YAEArqC,EAAA,EAAAC,EAAA2d,IAAA0zB,EAAqCtxC,EAAAC,IAAUD,EAC/CmE,EAAAnE,EAAA4d,EACAggE,EAAA5gD,EAAA74B,GAAAxC,MACAk8E,EAAAF,EAAAC,EAAAz5E,EAAAtE,GACAi+E,EAAAV,EAAAQ,GACAG,EAAAX,EAAAS,GAEAC,GAAAC,GACAP,EAAAF,EAAAt5E,KAAA45E,GACAH,EAAAF,EAAAv5E,KAAA65E,IACGL,GAAAC,IACH7yD,GAMAkzD,GACAR,EAAAt5E,KAAA45E,GAEAG,GACAR,EAAAv5E,KAAA65E,KATAR,EAAA7+C,EAAA8+C,EAAAC,EAAAC,EAAAC,GACAD,EAAAC,EAAA,EACAH,KACAC,MAYAF,GAAA7+C,EAAA8+C,EAAAC,EAAAC,EAAAC,GAEAj/C,EAAA+L,YACA/L,EAAA+mB,UAAA3kD,EACA49B,EAAAhC,OAxPA,GAAA94B,GAAAvF,EAAA,MACAgc,EAAAhc,EAAA,MACAiB,EAAAjB,EAAA,KAEAuF,GAAArE,KAAA,UACA+d,SACAo/D,QACAQ,WAAA,KAKA,IAAAG,IACA1hE,QAAA,SAAA1Q,GACA,GAAA5G,GAAA4G,EAAAyxB,KACA54B,EAAAmH,EAAAnH,MACA+V,EAAA/V,EAAAoW,eAAA7V,GACA4M,EAAA4I,GAAA/V,EAAAmW,iBAAA5V,GACA64B,EAAAjsB,GAAA4I,EAAA8B,QAAA0qC,cACAzlD,EAAAs8B,EAAAt8B,QAAA,CAEA,OAAAA,GAAA,SAAAub,EAAAjc,GACA,MAAAA,GAAAU,GAAAs8B,EAAAh9B,GAAA2B,OAAA,MADA,MAKAq8E,SAAA,SAAAjzE,GACA,GAAAizE,GAAAjzE,EAAAizE,SACA/7E,EAAA+7E,IAAA/7E,EAAA,KACAC,EAAA87E,IAAA97E,EAAA,IAEA,iBAAA+Z,GACA,OACAha,EAAA,OAAAA,EAAAga,EAAAha,IACAC,EAAA,OAAAA,EAAA+Z,EAAA/Z,OAyNAjE,GAAAc,SACA8K,GAAA,SAEAo0E,oBAAA,SAAAr6E,EAAA1E,GACA,GAGAya,GAAA3Z,EAAA4zC,EAAA7oC,EAHA6S,GAAAha,EAAA6I,KAAAqN,cAAApZ,OACAs8E,EAAA99E,EAAA89E,UACAxxE,IAGA,KAAAxL,EAAA,EAAaA,EAAA4d,IAAW5d,EACxB2Z,EAAA/V,EAAAoW,eAAAha,GACA4zC,EAAAj6B,EAAA8B,QACA1Q,EAAA,KAEA6oC,KAAA/xC,QAAA+xC,YAAAz5B,GAAA3X,OACAuI,GACAgG,QAAAnN,EAAAmW,iBAAA/Z,GACAw8B,KAAAkgD,EAAA9oC,EAAA5zC,EAAA4d,GACAha,QACAgwC,OAIAj6B,EAAAukE,QAAAnzE,EACAS,EAAAxH,KAAA+G,EAGA,KAAA/K,EAAA,EAAaA,EAAA4d,IAAW5d,GACxB+K,EAAAS,EAAAxL,MAKA+K,EAAAyxB,KAAAugD,EAAAvxE,EAAAxL,EAAAg9E,GACAjyE,EAAAizE,SAAArB,EAAA5xE,GACAA,EAAA4yE,OAAAT,EAAAnyE,KAIAozE,kBAAA,SAAAv6E,EAAA4G,GACA,GAAAmP,GAAAnP,EAAAmP,KAAAukE,OACA,IAAAvkE,EAAA,CAIA,GAAA6kB,GAAA56B,EAAA46B,IACAoV,EAAAj6B,EAAAi6B,GACA/zC,EAAA+zC,EAAAjyC,MACAq7B,EAAA4W,EAAAuS,cACAw3B,EAAAhkE,EAAAgkE,OACA/8E,EAAAf,EAAA08B,iBAAA74B,EAAA8a,OAAAioB,YAEAk3C,IAAA/8E,GAAAo8B,EAAAt8B,SACAtB,EAAAH,OAAA8rC,SAAAvM,EAAA56B,EAAA0E,WACAo1E,EAAAl/C,EAAAxB,EAAA2gD,EAAA99E,EAAAe,EAAAgzC,EAAA0S,OACAlnD,EAAAH,OAAAisC,WAAA1M,QrEmogBM4/C,KACA,SAAUngF,EAAQc,EAASZ,GAEjC,YsEt2gBA,SAAAkgF,GAAAC,EAAAnwD,GACA,MAAAmwD,GAAAC,cACApwD,EAAAtoB,KAAA2kC,MACA8zC,EAAAE,SAyaA,QAAAC,GAAA76E,EAAA86E,GACA,GAAAlyD,GAAA,GAAAkZ,IACAlH,IAAA56B,EAAA46B,IACAt/B,QAAAw/E,EACA96E,SAGA2hC,GAAAjhC,UAAAV,EAAA4oB,EAAAkyD,GACAn5C,EAAA5hC,OAAAC,EAAA4oB,GACA5oB,EAAA4oB,SA7gBA,GAAA9oB,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,MACAiB,EAAAjB,EAAA,MACAonC,EAAApnC,EAAA,MAEAwL,EAAAvK,EAAAuK,IAEAjG,GAAArE,KAAA,UACAmtB,QACAO,SAAA,EACAjqB,SAAA,MACAiB,WAAA,EACAb,SAAA,EACAO,OAAA,IAGAmjB,QAAA,SAAArN,EAAA6+D,GACA,GAAAj0E,GAAAi0E,EAAA18D,aACAijE,EAAAl/E,KAAAmE,MACA+V,EAAAglE,EAAA3kE,eAAA7V,EAGAwV,GAAAnY,OAAA,OAAAmY,EAAAnY,QAAAm9E,EAAAlyE,KAAAqN,SAAA3V,GAAA3C,OAAA,KAGAm9E,EAAAl6E,UAGA6hC,QAAA,KAEAhL,QACAkjD,SAAA,GACAz3E,QAAA,GAYAkxE,eAAA,SAAAr0E,GACA,GAAA6I,GAAA7I,EAAA6I,IACA,OAAArN,GAAAqJ,QAAAgE,EAAAqN,UAAArN,EAAAqN,SAAA9O,IAAA,SAAAyQ,EAAAzb,GACA,OACAgtB,KAAAvR,EAAAK,MACAypC,UAAAnmD,EAAAqJ,QAAAgT,EAAA8gB,iBAAA9gB,EAAA8gB,gBAAA,GAAA9gB,EAAA8gB,gBACA/6B,QAAAoC,EAAAmW,iBAAA/Z,GACAumD,QAAA9qC,EAAAmqC,eACAg5B,SAAAnjE,EAAAoqC,WACAY,eAAAhrC,EAAAqqC,iBACAN,SAAA/pC,EAAAsqC,gBACAT,UAAA7pC,EAAAmhB,YACAyoB,YAAA5pC,EAAAghB,YACAqqB,WAAArrC,EAAAqrC,WAGAprC,aAAA1b,IAEKP,YAKLqzD,eAAA,SAAAlvD,GACA,GAAAopB,KACAA,GAAAhpB,KAAA,cAAAJ,EAAAiG,GAAA,YACA,QAAA7J,GAAA,EAAiBA,EAAA4D,EAAA6I,KAAAqN,SAAApZ,OAAgCV,IACjDgtB,EAAAhpB,KAAA,qCAAAJ,EAAA6I,KAAAqN,SAAA9Z,GAAAu8B,gBAAA,aACA34B,EAAA6I,KAAAqN,SAAA9Z,GAAA8b,OACAkR,EAAAhpB,KAAAJ,EAAA6I,KAAAqN,SAAA9Z,GAAA8b,OAEAkR,EAAAhpB,KAAA,QAGA,OADAgpB,GAAAhpB,KAAA,SACAgpB,EAAAtM,KAAA,MAmBA,IAAAglB,GAAAzkC,EAAAE,QAEAC,WAAA,SAAAkd,GACAlf,EAAA+B,OAAA1B,KAAA6e,GAGA7e,KAAAo/E,kBAGAp/E,KAAAq/E,cAAA,GAOAvmB,aAAA5uD,EACAlF,OAAA,SAAA+zD,EAAAC,EAAAC,GACA,GAAAh3D,GAAAjC,IA0BA,OAvBAiC,GAAA62D,eAGA72D,EAAA82D,WACA92D,EAAA+2D,YACA/2D,EAAAg3D,UAGAh3D,EAAAk3D,sBACAl3D,EAAAm3D,gBACAn3D,EAAAo3D,qBAEAp3D,EAAAq9E,oBACAr9E,EAAAs9E,cACAt9E,EAAAu9E,mBAGAv9E,EAAAi4D,YACAj4D,EAAAk4D,MACAl4D,EAAAm4D,WAEAn4D,EAAAo4D,cAEAp4D,EAAAoD,SAEAg1D,YAAAnwD,EAIAivD,oBAAAjvD,EACAkvD,cAAA,WACA,GAAAn3D,GAAAjC,IAEAiC,GAAAqD,gBAEArD,EAAAgD,MAAAhD,EAAA82D,SACA92D,EAAAkE,KAAA,EACAlE,EAAAuE,MAAAvE,EAAAgD,QAEAhD,EAAAiD,OAAAjD,EAAA+2D,UAGA/2D,EAAA0E,IAAA,EACA1E,EAAA2E,OAAA3E,EAAAiD,QAIAjD,EAAAmxC,YAAA,EACAnxC,EAAAqxC,WAAA,EACArxC,EAAAsxC,aAAA,EACAtxC,EAAAuxC,cAAA,EAGAvxC,EAAAoD,SACAJ,MAAA,EACAC,OAAA,IAGAm0D,mBAAAnvD,EAIAo1E,kBAAAp1E,EACAq1E,YAAA,WACA,GAAAt9E,GAAAjC,KACA6+E,EAAA58E,EAAAxC,QAAAo8B,WACA4jD,EAAA9/E,EAAAkL,SAAAg0E,EAAArG,gBAAAv2E,EAAAkC,OAAAlC,MAEA48E,GAAAhtE,SACA4tE,IAAA5tE,OAAA,SAAAzN,GACA,MAAAy6E,GAAAhtE,OAAAzN,EAAAnC,EAAAkC,MAAA6I,SAIA/K,EAAAxC,QAAAgE,SACAg8E,EAAAh8E,UAGAxB,EAAAw9E,eAEAD,iBAAAt1E,EAIAgwD,UAAAhwD,EACAiwD,IAAA,WACA,GAAAl4D,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACAo/E,EAAA//D,EAAA+c,OACAvO,EAAAxO,EAAAwO,QAEAyR,EAAA98B,EAAA88B,IAEA2gD,EAAAz7E,EAAA8a,OACArU,EAAA/K,EAAA+K,eACAgkB,EAAAhkB,EAAAm0E,EAAAnwD,SAAAgxD,EAAAv4C,iBACA0N,EAAAnqC,EAAAm0E,EAAAhqC,UAAA6qC,EAAAt4C,kBACAzY,EAAAjkB,EAAAm0E,EAAAlwD,WAAA+wD,EAAAx4C,mBACAy4C,EAAAhgF,EAAAg1C,WAAAjmB,EAAAmmB,EAAAlmB,GAGAixD,EAAA39E,EAAAm9E,kBAEA/5E,EAAApD,EAAAoD,QACAC,EAAArD,EAAAqD,cAWA,IATAA,GACAD,EAAAJ,MAAAhD,EAAA82D,SACA1zD,EAAAH,OAAAooB,EAAA,OAEAjoB,EAAAJ,MAAAqoB,EAAA,KACAjoB,EAAAH,OAAAjD,EAAA+2D,WAIA1rC,EAGA,GAFAyR,EAAAgW,KAAA4qC,EAEAr6E,EAAA,CAIA,GAAAu6E,GAAA59E,EAAA49E,YAAA,GACAC,EAAA79E,EAAAw9E,YAAAx+E,OAAAytB,EAAAmwD,EAAA,SAEA9/C,GAAAtQ,UAAA,OACAsQ,EAAA4/B,aAAA,MAEAh/D,EAAAsI,KAAAhG,EAAAw9E,YAAA,SAAA9G,EAAAp4E,GACA,GAAAw+E,GAAAH,EAAAC,EAAAnwD,GACAzpB,EAAA85E,EAAArwD,EAAA,EAAAqQ,EAAAsW,YAAAsjC,EAAAprD,MAAAtoB,KAEA46E,KAAA5+E,OAAA,GAAAgE,EAAA45E,EAAAv3E,SAAArF,EAAAgD,QACA66E,GAAApxD,EAAAmwD,EAAA,QACAgB,IAAA5+E,QAAAgB,EAAAkE,MAIAy5E,EAAAr/E,IACA4F,KAAA,EACAQ,IAAA,EACA1B,QACAC,OAAAwpB,GAGAmxD,IAAA5+E,OAAA,IAAAgE,EAAA45E,EAAAv3E,UAGAjC,EAAAH,QAAA46E,MAEI,CACJ,GAAAC,GAAAlB,EAAAv3E,QACA04E,EAAA/9E,EAAA+9E,gBACAC,EAAApB,EAAAv3E,QACA44E,EAAA,EACAC,EAAA,EACAC,EAAA1xD,EAAAqxD,CAEApgF,GAAAsI,KAAAhG,EAAAw9E,YAAA,SAAA9G,EAAAp4E,GACA,GAAAw+E,GAAAH,EAAAC,EAAAnwD,GACA2xD,EAAAtB,EAAArwD,EAAA,EAAAqQ,EAAAsW,YAAAsjC,EAAAprD,MAAAtoB,KAGAk7E,GAAAC,EAAA/6E,EAAAH,SACA+6E,GAAAC,EAAArB,EAAAv3E,QACA04E,EAAAz7E,KAAA27E,GAEAA,EAAA,EACAC,EAAA,GAIAD,EAAA95E,KAAAC,IAAA65E,EAAAG,GACAF,GAAAC,EAGAR,EAAAr/E,IACA4F,KAAA,EACAQ,IAAA,EACA1B,MAAAo7E,EACAn7E,OAAAwpB,KAIAuxD,GAAAC,EACAF,EAAAz7E,KAAA27E,GACA76E,EAAAJ,OAAAg7E,EAIAh+E,EAAAgD,MAAAI,EAAAJ,MACAhD,EAAAiD,OAAAG,EAAAH,QAEAk1D,SAAAlwD,EAGA5E,aAAA,WACA,cAAAtF,KAAAP,QAAA4D,UAAA,WAAArD,KAAAP,QAAA4D,UAIAigC,KAAA,WACA,GAAArhC,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACAo/E,EAAA//D,EAAA+c,OACA6jD,EAAAz7E,EAAA8a,OACAuhE,EAAAZ,EAAAhlE,SAAAwrC,KACAq6B,EAAAt+E,EAAAgD,MACA46E,EAAA59E,EAAA49E,UAEA,IAAA/gE,EAAAwO,QAAA,CACA,GAOAkzD,GAPAzhD,EAAA98B,EAAA88B,IACAr0B,EAAA/K,EAAA+K,eACAgjB,EAAAhjB,EAAAm0E,EAAAnxD,UAAAgyD,EAAAz4C,kBACAvY,EAAAhkB,EAAAm0E,EAAAnwD,SAAAgxD,EAAAv4C,iBACA0N,EAAAnqC,EAAAm0E,EAAAhqC,UAAA6qC,EAAAt4C,kBACAzY,EAAAjkB,EAAAm0E,EAAAlwD,WAAA+wD,EAAAx4C,mBACAy4C,EAAAhgF,EAAAg1C,WAAAjmB,EAAAmmB,EAAAlmB,EAIAoQ,GAAAtQ,UAAA,OACAsQ,EAAA4/B,aAAA,SACA5/B,EAAA8mB,UAAA,GACA9mB,EAAA6mB,YAAAl4B,EACAqR,EAAA+mB,UAAAp4B,EACAqR,EAAAgW,KAAA4qC,CAEA,IAAAZ,GAAAH,EAAAC,EAAAnwD,GACAkxD,EAAA39E,EAAAm9E,eAGAqB,EAAA,SAAAj+E,EAAAC,EAAAk2E,GACA,KAAAxlD,MAAA4rD,OAAA,IAKAhgD,EAAAwM,OAEAxM,EAAA+mB,UAAAp7C,EAAAiuE,EAAA7yB,UAAA45B,EAAA14C,cACAjI,EAAA+nB,QAAAp8C,EAAAiuE,EAAA7xB,QAAAw5B,EAAAn6B,gBACApnB,EAAAioB,eAAAt8C,EAAAiuE,EAAA3xB,eAAAs5B,EAAAj6B,kBACAtnB,EAAAgnB,SAAAr7C,EAAAiuE,EAAA5yB,SAAAu6B,EAAAh6B,iBACAvnB,EAAA8mB,UAAAn7C,EAAAiuE,EAAA9yB,UAAAy6B,EAAAnjD,aACA4B,EAAA6mB,YAAAl7C,EAAAiuE,EAAA/yB,YAAA85B,EAAA14C,aACA,IAAA05C,GAAA,IAAAh2E,EAAAiuE,EAAA9yB,UAAAy6B,EAAAnjD,YAOA,IALA4B,EAAAgoB,aAEAhoB,EAAAgoB,YAAAr8C,EAAAiuE,EAAAwG,SAAAmB,EAAAl6B,aAGAtnC,EAAA+c,QAAA/c,EAAA+c,OAAAijD,cAAA,CAGA,GAAA90C,GAAAtb,EAAAtoB,KAAA2kC,MAAA,EACA41C,EAAA32C,EAAA5jC,KAAA2kC,MACA6uC,EAAAp3E,EAAAm+E,EACA9G,EAAAp3E,EAAAk+E,CAGAhhF,GAAAH,OAAA8qC,UAAAvL,EAAA45C,EAAAtxB,WAAArd,EAAA4vC,EAAAC,OAGA6G,IACA3hD,EAAAkM,WAAAzoC,EAAAC,EAAAs8E,EAAArwD,GAEAqQ,EAAAiM,SAAAxoC,EAAAC,EAAAs8E,EAAArwD,EAGAqQ,GAAA2M,YAEA+zB,EAAA,SAAAj9D,EAAAC,EAAAk2E,EAAAnjC,GACA,GAAAorC,GAAAlyD,EAAA,EACAmyD,EAAA9B,EAAA6B,EAAAp+E,EACAs+E,EAAAr+E,EAAAm+E,CAEA7hD,GAAA0gC,SAAAkZ,EAAAprD,KAAAszD,EAAAC,GAEAnI,EAAA52E,SAEAg9B,EAAA6L,YACA7L,EAAA8mB,UAAA,EACA9mB,EAAA9Y,OAAA46D,EAAAC,GACA/hD,EAAAoL,OAAA02C,EAAArrC,EAAAsrC,GACA/hD,EAAAsM,WAKA/lC,EAAArD,EAAAqD,cAEAk7E,GADAl7E,GAEA9C,EAAAP,EAAAkE,MAAAo6E,EAAAV,EAAA,MACAp9E,EAAAR,EAAA0E,IAAAk4E,EAAAv3E,QACA4+C,KAAA,IAIA1jD,EAAAP,EAAAkE,KAAA04E,EAAAv3E,QACA7E,EAAAR,EAAA0E,IAAAk4E,EAAAv3E,QACA4+C,KAAA,EAIA,IAAAk6B,GAAA1xD,EAAAmwD,EAAAv3E,OACA3H,GAAAsI,KAAAhG,EAAAw9E,YAAA,SAAA9G,EAAAp4E,GACA,GAAAi1C,GAAAzW,EAAAsW,YAAAsjC,EAAAprD,MAAAtoB,MACAA,EAAA85E,EAAArwD,EAAA,EAAA8mB,EACAhzC,EAAAg+E,EAAAh+E,EACAC,EAAA+9E,EAAA/9E,CAEA6C,GACA9C,EAAAyC,GAAAs7E,IACA99E,EAAA+9E,EAAA/9E,GAAA29E,EACAI,EAAAt6B,OACA1jD,EAAAg+E,EAAAh+E,EAAAP,EAAAkE,MAAAo6E,EAAAV,EAAAW,EAAAt6B,OAAA,GAEKzjD,EAAA29E,EAAAn+E,EAAA2E,SACLpE,EAAAg+E,EAAAh+E,IAAAP,EAAA+9E,aAAAQ,EAAAt6B,MAAA24B,EAAAv3E,QACA7E,EAAA+9E,EAAA/9E,EAAAR,EAAA0E,IAAAk4E,EAAAv3E,QACAk5E,EAAAt6B,QAGAu6B,EAAAj+E,EAAAC,EAAAk2E,GAEAiH,EAAAr/E,GAAA4F,KAAA3D,EACAo9E,EAAAr/E,GAAAoG,IAAAlE,EAGAg9D,EAAAj9D,EAAAC,EAAAk2E,EAAAnjC,GAEAlwC,EACAk7E,EAAAh+E,GAAAyC,EAAA45E,EAAA,QAEA2B,EAAA/9E,GAAA29E,MAaArsB,YAAA,SAAAj6C,GACA,GAAA7X,GAAAjC,KACA8e,EAAA7c,EAAAxC,QACAoB,EAAA,YAAAiZ,EAAAjZ,KAAA,QAAAiZ,EAAAjZ,KACAizD,GAAA,CAEA,kBAAAjzD,GACA,IAAAie,EAAA+nB,QACA,WAEG,cAAAhmC,EAKH,MAJA,KAAAie,EAAAqI,QACA,OAOA,GAAA3kB,GAAAsX,EAAAtX,EACAC,EAAAqX,EAAArX,CAEA,IAAAD,GAAAP,EAAAkE,MAAA3D,GAAAP,EAAAuE,OAAA/D,GAAAR,EAAA0E,KAAAlE,GAAAR,EAAA2E,OAGA,OADAm6E,GAAA9+E,EAAAm9E,eACA7+E,EAAA,EAAkBA,EAAAwgF,EAAA9/E,SAAeV,EAAA,CACjC,GAAAygF,GAAAD,EAAAxgF,EAEA,IAAAiC,GAAAw+E,EAAA76E,MAAA3D,GAAAw+E,EAAA76E,KAAA66E,EAAA/7E,OAAAxC,GAAAu+E,EAAAr6E,KAAAlE,GAAAu+E,EAAAr6E,IAAAq6E,EAAA97E,OAAA,CAEA,aAAArE,EAAA,CAEAie,EAAAqI,QAAA3c,KAAAvI,EAAA6X,EAAAC,OAAA9X,EAAAw9E,YAAAl/E,IACAuzD,GAAA,CACA,OACM,iBAAAjzD,EAAA,CAENie,EAAA+nB,QAAAr8B,KAAAvI,EAAA6X,EAAAC,OAAA9X,EAAAw9E,YAAAl/E,IACAuzD,GAAA,CACA,SAMA,MAAAA,KAgBAt1D,GAAAc,SACA8K,GAAA,SASA87B,SAAAD,EAEAg7C,WAAA,SAAA98E,GACA,GAAA86E,GAAA96E,EAAA1E,QAAAstB,MAEAkyD,IACAD,EAAA76E,EAAA86E,IAIAnmB,aAAA,SAAA30D,GACA,GAAA86E,GAAA96E,EAAA1E,QAAAstB,OACAA,EAAA5oB,EAAA4oB,MAEAkyD,IACAt/E,EAAAmM,QAAAmzE,EAAAh7E,EAAA8a,OAAAgO,QAEAA,GACA+Y,EAAAjhC,UAAAV,EAAA4oB,EAAAkyD,GACAlyD,EAAAttB,QAAAw/E,GAEAD,EAAA76E,EAAA86E,IAEGlyD,IACH+Y,EAAAthC,UAAAL,EAAA4oB,SACA5oB,GAAA4oB,SAIAm0D,WAAA,SAAA/8E,EAAA2V,GACA,GAAAiT,GAAA5oB,EAAA4oB,MACAA,IACAA,EAAAgnC,YAAAj6C,MtEy8gBMqnE,KACA,SAAU3iF,EAAQc,EAASZ,GAEjC,YuE/zhBA,SAAA0iF,GAAAj9E,EAAAk9E,GACA,GAAAh0D,GAAA,GAAA8Y,IACApH,IAAA56B,EAAA46B,IACAt/B,QAAA4hF,EACAl9E,SAGA2hC,GAAAjhC,UAAAV,EAAAkpB,EAAAg0D,GACAv7C,EAAA5hC,OAAAC,EAAAkpB,GACAlpB,EAAAm9E,WAAAj0D,EAhNA,GAAAppB,GAAAvF,EAAA,MACA8C,EAAA9C,EAAA,MACAiB,EAAAjB,EAAA,MACAonC,EAAApnC,EAAA,MAEAwL,EAAAvK,EAAAuK,IAEAjG,GAAArE,KAAA,UACAytB,OACAC,SAAA,EACAunB,UAAA,OACAvwC,WAAA,EACAkqB,WAAA,IACAlnB,QAAA,GACAjE,SAAA,MACAkqB,KAAA,GACAvpB,OAAA,MAOA,IAAAmiC,GAAA3kC,EAAAE,QACAC,WAAA,SAAAkd,GACA,GAAA5c,GAAAjC,IACAL,GAAA+B,OAAAO,EAAA4c,GAGA5c,EAAAm9E,mBAKAtmB,aAAA5uD,EACAlF,OAAA,SAAA+zD,EAAAC,EAAAC,GACA,GAAAh3D,GAAAjC,IA0BA,OAvBAiC,GAAA62D,eAGA72D,EAAA82D,WACA92D,EAAA+2D,YACA/2D,EAAAg3D,UAGAh3D,EAAAk3D,sBACAl3D,EAAAm3D,gBACAn3D,EAAAo3D,qBAEAp3D,EAAAq9E,oBACAr9E,EAAAs9E,cACAt9E,EAAAu9E,mBAGAv9E,EAAAi4D,YACAj4D,EAAAk4D,MACAl4D,EAAAm4D,WAEAn4D,EAAAo4D,cAEAp4D,EAAAoD,SAGAg1D,YAAAnwD,EAIAivD,oBAAAjvD,EACAkvD,cAAA,WACA,GAAAn3D,GAAAjC,IAEAiC,GAAAqD,gBAEArD,EAAAgD,MAAAhD,EAAA82D,SACA92D,EAAAkE,KAAA,EACAlE,EAAAuE,MAAAvE,EAAAgD,QAEAhD,EAAAiD,OAAAjD,EAAA+2D,UAGA/2D,EAAA0E,IAAA,EACA1E,EAAA2E,OAAA3E,EAAAiD,QAIAjD,EAAAmxC,YAAA,EACAnxC,EAAAqxC,WAAA,EACArxC,EAAAsxC,aAAA,EACAtxC,EAAAuxC,cAAA,EAGAvxC,EAAAoD,SACAJ,MAAA,EACAC,OAAA,IAGAm0D,mBAAAnvD,EAIAo1E,kBAAAp1E,EACAq1E,YAAAr1E,EACAs1E,iBAAAt1E,EAIAgwD,UAAAhwD,EACAiwD,IAAA,WACA,GAAAl4D,GAAAjC,KACA0K,EAAA/K,EAAA+K,eACAoU,EAAA7c,EAAAxC,QACA6tB,EAAAxO,EAAAwO,QACAoB,EAAAhkB,EAAAoU,EAAA4P,SAAAzqB,EAAA8a,OAAAooB,iBACA9hC,EAAApD,EAAAoD,QACAm6D,EAAA7/D,EAAAqJ,QAAA8V,EAAAyO,MAAAzO,EAAAyO,KAAAtsB,OAAA,EACAutB,EAAA7uB,EAAAF,QAAA6sC,aAAAxtB,EAAA0P,WAAAE,GACA89C,EAAAl/C,EAAAkyC,EAAAhxC,EAAA,EAAA1P,EAAAxX,QAAA,CAEArF,GAAAqD,gBACAD,EAAAJ,MAAAhD,EAAA82D,SACA1zD,EAAAH,OAAAsnE,IAEAnnE,EAAAJ,MAAAunE,EACAnnE,EAAAH,OAAAjD,EAAA+2D,WAGA/2D,EAAAgD,MAAAI,EAAAJ,MACAhD,EAAAiD,OAAAG,EAAAH,QAGAk1D,SAAAlwD,EAGA5E,aAAA,WACA,GAAA8kD,GAAApqD,KAAAP,QAAA4D,QACA,eAAA+mD,GAAA,WAAAA,GAIA9mB,KAAA,WACA,GAAArhC,GAAAjC,KACA++B,EAAA98B,EAAA88B,IACAr0B,EAAA/K,EAAA+K,eACAoU,EAAA7c,EAAAxC,QACAwmD,EAAAhiD,EAAA8a,MAEA,IAAAD,EAAAwO,QAAA,CACA,GAWAyrC,GAAAwoB,EAAAC,EAXA9yD,EAAAhkB,EAAAoU,EAAA4P,SAAAu3B,EAAA9e,iBACA0N,EAAAnqC,EAAAoU,EAAA+1B,UAAAoR,EAAA7e,kBACAzY,EAAAjkB,EAAAoU,EAAA6P,WAAAs3B,EAAA/e,mBACAu6C,EAAA9hF,EAAAg1C,WAAAjmB,EAAAmmB,EAAAlmB,GACAH,EAAA7uB,EAAAF,QAAA6sC,aAAAxtB,EAAA0P,WAAAE,GACAtD,EAAAoD,EAAA,EAAA1P,EAAAxX,QACA+3D,EAAA,EACA14D,EAAA1E,EAAA0E,IACAR,EAAAlE,EAAAkE,KACAS,EAAA3E,EAAA2E,OACAJ,EAAAvE,EAAAuE,KAGAu4B,GAAA+mB,UAAAp7C,EAAAoU,EAAA4O,UAAAu4B,EAAAhf,kBACAlI,EAAAgW,KAAA0sC,EAGAx/E,EAAAqD,gBACAi8E,EAAAp7E,GAAAK,EAAAL,GAAA,EACAq7E,EAAA76E,EAAAykB,EACA2tC,EAAAvyD,EAAAL,IAEAo7E,EAAA,SAAAziE,EAAAzb,SAAA8C,EAAAilB,EAAA5kB,EAAA4kB,EACAo2D,EAAA76E,GAAAC,EAAAD,GAAA,EACAoyD,EAAAnyD,EAAAD,EACA04D,EAAAj5D,KAAAoiC,IAAA,SAAA1pB,EAAAzb,UAAA,QAGA07B,EAAAwM,OACAxM,EAAAwgC,UAAAgiB,EAAAC,GACAziD,EAAAzmB,OAAA+mD,GACAtgC,EAAAtQ,UAAA,SACAsQ,EAAA4/B,aAAA,QAEA,IAAApxC,GAAAzO,EAAAyO,IACA,IAAA5tB,EAAAqJ,QAAAukB,GAEA,OADA9qB,GAAA,EACAlC,EAAA,EAAmBA,EAAAgtB,EAAAtsB,SAAiBV,EACpCw+B,EAAA0gC,SAAAlyC,EAAAhtB,GAAA,EAAAkC,EAAAs2D,GACAt2D,GAAA+rB,MAGAuQ,GAAA0gC,SAAAlyC,EAAA,IAAAwrC,EAGAh6B,GAAA2M,aAiBAltC,GAAAc,SACA8K,GAAA,QASA87B,SAAAC,EAEA86C,WAAA,SAAA98E,GACA,GAAAk9E,GAAAl9E,EAAA1E,QAAA4tB,KAEAg0D,IACAD,EAAAj9E,EAAAk9E,IAIAvoB,aAAA,SAAA30D,GACA,GAAAk9E,GAAAl9E,EAAA1E,QAAA4tB,MACAi0D,EAAAn9E,EAAAm9E,UAEAD,IACA1hF,EAAAmM,QAAAu1E,EAAAp9E,EAAA8a,OAAAsO,OAEAi0D,GACAx7C,EAAAjhC,UAAAV,EAAAm9E,EAAAD,GACAC,EAAA7hF,QAAA4hF,GAEAD,EAAAj9E,EAAAk9E,IAEGC,IACHx7C,EAAAthC,UAAAL,EAAAm9E,SACAn9E,GAAAm9E,evEihiBMI,KACA,SAAUljF,EAAQC,EAAqBC,GAE7C,YAMuvB,SAASyqB,GAAuBC,EAAQC,GAAK,MAAOrqB,QAAOsqB,OAAOtqB,OAAO4jB,iBAAiBwG,GAASC,KAAKnqB,MAAMF,OAAOsqB,OAAOD,OwErviBn3B,QAASs4D,GAATp3D,GAA4B,GAARvd,GAAQud,EAARvd,IAClB,OACEpO,GAAAC,EAAAC,cAAA,WACGkO,EAAK8oB,UAAqC,IAAzB9oB,EAAK8oB,SAAS70B,OAC9BrC,EAAAC,EAAAC,cAAA,gDACE,KACJF,EAAAC,EAAAC,cAAC8iF,GACC78D,YAAY,EACZ88D,UAAA,EACAC,cAAA,EACAC,aAAA,EACAlQ,SAA8B,IAApB7kE,EAAKg1E,aACfC,YAAY,GAGVj1E,EAAK8oB,UAAY9oB,EAAK8oB,SAASvqB,IAAI,SAAA8D,GAAA,MACjCzQ,GAAAC,EAAAC,cAACojF,GAAOzhF,IAAK4O,EAAQjF,IACnBxL,EAAAC,EAAAC,cAAA,OAAKi4B,IAAK1nB,EAAQwkB,IAAKgD,IAAKxnB,EAAQmB,OACpC5R,EAAAC,EAAAC,cAAA,OAAKooB,UAAU,UACbtoB,EAAAC,EAAAC,cAAA,YACGkO,EAAKqgB,OAERzuB,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAAA,SAAIkO,EAAKm1E,gBxEytiBN,GAAIhjF,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GACpEijF,EAA0D1jF,EAAoB,MAE9E8qB,GADkE9qB,EAAoBU,EAAEgjF,GACtC1jF,EAAoB,KAC3FmrB,EAAgBV,GAAwB,+QAA+Q,+QAA+QW,EAAiBX,GAAwB,kEAAkE,kEwE9wiB/qBy4D,EAA0B5iF,OAAAwqB,EAAA,GAAO44D,EAAA,UAAjCv4D,GAmBAq4D,EAAS14D,EAAA,EAAOa,IAAhBP,EAwCNrrB,GAAA,KxEutiBM4jF,KACA,SAAU7jF,EAAQc,EAASZ,GAEjC,YyE1wiBA,SAAAgjB,GAAA1N,GAAsC,MAAAA,MAAAoL,WAAApL,GAAuCqL,QAAArL,GAb7EhV,OAAAC,eAAAK,EAAA,cACAJ,OAAA,IAEAI,EAAAqkB,OAAArkB,EAAAqiF,aAAAlyE,EAEA,IAAA6yE,GAAA5jF,EAAA,MAEA6jF,EAAA7gE,EAAA4gE,GAEAE,EAAA9jF,EAAA,MAEA+jF,EAAA/gE,EAAA8gE,EAIAljF,GAAAqiF,SAAAY,EAAAljE,QACA/f,EAAAqkB,OAAA8+D,EAAApjE,SzE8xiBMqjE,KACA,SAAUlkF,EAAQc,EAASZ,GAEjC,Y0EvwiBA,SAAAgjB,GAAA1N,GAAsC,MAAAA,MAAAoL,WAAApL,GAAuCqL,QAAArL,GAE7E,QAAA2N,GAAAC,EAAAC,GAAiD,KAAAD,YAAAC,IAA0C,SAAAC,WAAA,qCAE3F,QAAAC,GAAAC,EAAAxX,GAAiD,IAAAwX,EAAa,SAAAC,gBAAA,4DAAyF,QAAAzX,GAAA,iBAAAA,IAAA,mBAAAA,GAAAwX,EAAAxX,EAEvJ,QAAA0X,GAAAC,EAAAC,GAA0C,sBAAAA,IAAA,OAAAA,EAA+D,SAAAN,WAAA,iEAAAM,GAAuGD,GAAArgB,UAAA9C,OAAAqjB,OAAAD,KAAAtgB,WAAyEsK,aAAelN,MAAAijB,EAAAG,YAAA,EAAAC,UAAA,EAAAC,cAAA,KAA6EJ,IAAApjB,OAAAyjB,eAAAzjB,OAAAyjB,eAAAN,EAAAC,GAAAD,EAAAO,UAAAN,GAhDrXpjB,OAAAC,eAAAK,EAAA,cACAJ,OAAA,GAGA,IAAAyjF,GAAA3jF,OAAA4S,QAAA,SAAAhR,GAAmD,OAAAL,GAAA,EAAgBA,EAAAsB,UAAAZ,OAAsBV,IAAA,CAAO,GAAA+K,GAAAzJ,UAAAtB,EAA2B,QAAAE,KAAA6K,GAA0BtM,OAAA8C,UAAAZ,eAAAsJ,KAAAc,EAAA7K,KAAyDG,EAAAH,GAAA6K,EAAA7K,IAAiC,MAAAG,IAE/O+hB,EAAA,WAAgC,QAAAC,GAAAhiB,EAAAmE,GAA2C,OAAAxE,GAAA,EAAgBA,EAAAwE,EAAA9D,OAAkBV,IAAA,CAAO,GAAAge,GAAAxZ,EAAAxE,EAA2Bge,GAAA+D,WAAA/D,EAAA+D,aAAA,EAAwD/D,EAAAiE,cAAA,EAAgC,SAAAjE,OAAAgE,UAAA,GAAuDvjB,OAAAC,eAAA2B,EAAA2d,EAAA9d,IAAA8d,IAA+D,gBAAAsD,EAAAgB,EAAAC,GAA2L,MAAlID,IAAAD,EAAAf,EAAA/f,UAAA+gB,GAAqEC,GAAAF,EAAAf,EAAAiB,GAA6DjB,MAExhBkB,EAAArkB,EAAA,GAEAskB,EAAAtB,EAAAqB,GAEAE,EAAAvkB,EAAA,GAEAkkF,EAAAlhE,EAAAuB,GAEAC,EAAAxkB,EAAA,GAEAykB,EAAAzB,EAAAwB,GAEAE,EAAA1kB,EAAA,MAEA2kB,EAAA3B,EAAA0B,GAEAG,EAAA7kB,EAAA,MAEA8kB,EAAA9B,EAAA6B,GAEAE,EAAA/kB,EAAA,MAEAglB,EAAAhC,EAAA+B,GAEA++D,EAAA9jF,EAAA,MAEA+jF,EAAA/gE,EAAA8gE,GAEAK,EAAAnkF,EAAA,MAEAokF,EAEA,SAAA9uE,GAAuC,GAAAA,KAAAoL,WAA6B,MAAApL,EAAqB,IAAA+uE,KAAiB,UAAA/uE,EAAmB,OAAAvT,KAAAuT,GAAuBhV,OAAA8C,UAAAZ,eAAAsJ,KAAAwJ,EAAAvT,KAAAsiF,EAAAtiF,GAAAuT,EAAAvT,GAAsG,OAAtBsiF,GAAA1jE,QAAArL,EAAsB+uE,GAF1PF,GAYA34E,EAAA,aAEA84E,EAAA,SAAA1yC,EAAA/+B,GACA,MAAA++B,GAAA,OAAA/+B,GAGAowE,EAAA,SAAA/9D,GAGA,QAAA+9D,GAAA58E,GACA4c,EAAA3hB,KAAA2hF,EAEA,IAAA99D,GAAA9B,EAAA/hB,MAAA2hF,EAAAj/D,WAAA1jB,OAAA8kB,eAAA69D,IAAAn3E,KAAAxK,KAAA+E,GA8RA,OA5RA8e,GAAAO,aAAA,SAAAJ,GACAH,EAAAQ,UAAAL,GAGAH,EAAAo/D,sBAAA,SAAAj/D,GACAH,EAAAq/D,mBAAAl/D,GAGAH,EAAAs/D,WAAA,SAAAn/D,GACAH,EAAAu/D,QAAAp/D,GAGAH,EAAAE,mBAAA,SAAAC,GACAH,EAAAI,gBAAAD,GAGAH,EAAAw/D,YAAA,SAAAr/D,EAAAtf,GACAmf,EAAAy/D,WACAz/D,EAAAy/D,aAEAz/D,EAAAy/D,SAAA5+E,GAAAsf,GAGAH,EAAAg+D,SAAA,YACAh+D,EAAA9e,MAAA88E,UAAA9+D,EAAA0D,SAAAtI,MAAA0F,EAAA9e,MAAAwf,WAAA,IAIAg/D,aAAA1/D,EAAA2/D,OACA3/D,EAAA2/D,MAAAhxC,WAAA,WACA3uB,EAAA4/D,aACa5/D,EAAA9e,MAAA8sE,YAGbhuD,EAAA6/D,cAAA,WACA7/D,EAAA9e,MAAA88E,UAIA0B,aAAA1/D,EAAA2/D,QAGA3/D,EAAA8/D,cAAA,WACA9/D,EAAA6/D,gBACA7/D,EAAAg+D,YAGAh+D,EAAAk+D,YAAA,WACAl+D,EAAAmB,UAA4B4+D,gBAAA,IAC5B//D,EAAA6/D,iBAGA7/D,EAAAggE,aAAA,WACAhgE,EAAAmB,UAA4B4+D,gBAAA,IAC5B//D,EAAAg+D,YAGAh+D,EAAAigE,qBAAA,SAAAhqE,GACA,GAAAyB,GAAAsI,EAAA9e,MAAAwW,KAEAjW,EAAA,eAAAiW,EACAwoE,GACAC,QAAA,GACAC,WAAA,GACAC,UAAA,GACAC,UAAA,IAGAC,EAAA9+E,EAAAy+E,EAAAE,WAAAF,EAAAG,UACAG,EAAA/+E,EAAAy+E,EAAAI,UAAAJ,EAAAC,OAEAI,KAAAtqE,EAAAwqE,QACAzgE,EAAA4/D,YACaY,IAAAvqE,EAAAwqE,SACbzgE,EAAA0gE,aAIA1gE,EAAAS,YAAA,WACA,GAAAT,EAAA9S,MAAAyzE,YAAA,CAIA,GAAAl/E,GAAA,eAAAue,EAAA9e,MAAAwW,KACA0J,EAAApB,EAAAy/D,SAAA,GACA5+D,EAAApf,EAAA2f,EAAAR,YAAAQ,EAAA+uB,YAEAnwB,GAAAmB,UACAN,WACAF,YAAAlf,EAAAof,EAAA3B,EAAA0D,SAAAtI,MAAA0F,EAAA9e,MAAAwf,UAAAG,IAGAb,EAAAQ,WACAR,EAAAQ,UAAAC,gBAIAT,EAAAuB,cAAA,WACAvB,EAAAmB,UAA4BK,UAAA,IAC5BxB,EAAAS,eAGAT,EAAAyB,gBAAA,SAAA5gB,EAAAN,GACA,KAAA2e,EAAA0D,SAAAtI,MAAA0F,EAAA9e,MAAAwf,WAAA,IAIA,GAAAV,EAAA9S,MAAA0zE,YAKA,WAJA5gE,GAAAmB,UACAy/D,aAAA,GAMA5gE,GAAA9e,MAAA2/E,YAAAhgF,EAAAN,GAEAM,IAAAmf,EAAA9S,MAAAoU,cACAtB,EAAAmB,UACAG,aAAAzgB,MAKAmf,EAAA8gE,eAAA,SAAAjgF,EAAAN,GACA2e,EAAA0D,SAAAtI,MAAA0F,EAAA9e,MAAAwf,WAAA,GAIAV,EAAA9e,MAAA4nB,SAAAjoB,EAAAN,IAGAyf,EAAA+gE,iBAAA,SAAAlgF,EAAAN,GACAyf,EAAA9e,MAAA8/E,aAAAngF,EAAAN,GAEAyf,EAAAihE,YACA3/D,aAAAzgB,KAIAmf,EAAA2B,aAAA,WACA3B,EAAAmB,UACAS,SAAA,IAEA5B,EAAA6/D,iBAGA7/D,EAAA6B,WAAA,WACA7B,EAAAkhE,gBACAlhE,EAAAmB,UACAS,SAAA,IAEA5B,EAAAg+D,YAGAh+D,EAAA8B,YAAA,SAAAvc,GACA,GAAA9D,GAAA,eAAAue,EAAA9e,MAAAwW,KAIAqK,EAAA/B,EAAAmhE,YAAAnhE,EAAA9S,MAAAoU,cACA8/D,EAAAphE,EAAAmhE,YAAAjiE,EAAA0D,SAAAtI,MAAA0F,EAAA9e,MAAAwf,UAAA,GAEA2gE,EAAA5/E,EAAA8D,EAAA5G,EAAA4G,EAAA3G,EACA0iF,EAAAD,CANA,KASAt/D,GAAAs/D,EAAA,IACAC,EAAA,GAIAv/D,IAAAq/D,GAAAC,EAAA,IACAC,EAAA,EAGA,IAAA9hF,GAAAuiB,EAAA,KAAA/B,EAAA9S,MAAA2T,SAAAygE,GAAA,GAEAthE,GAAAuhE,YAAA/hF,EAGA,IAAAgiF,GAAAj/E,KAAAiD,IAAA67E,GAAArhE,EAAA9e,MAAAugF,oBAQA,OANAD,KAAAxhE,EAAA9S,MAAA0zE,aACA5gE,EAAAmB,UACAy/D,aAAA,IAIAY,GAGAxhE,EAAAkhE,cAAA,WACA,GAAAn/D,GAAA/B,EAAAmhE,YAAAnhE,EAAA9S,MAAAoU,cAAA,GACAtB,GAAAuhE,YAAAx/D,IAGA/B,EAAAuhE,YAAA,SAAA/hF,GACA,GAAAkiF,GAAA3C,EAAAvjE,QAAAmmE,YAAA3hE,EAAAu/D,UACA,uFAAA1/E,QAAA,SAAAoB,GACAygF,EAAAz/D,MAAAhhB,IAAA,EAAA0e,EAAAnE,SAAAhc,EAAAwgB,EAAA9e,MAAAwW,SAIAsI,EAAA0gE,UAAA,SAAAv+D,GACAnC,EAAAoC,OAAApC,EAAA9S,MAAAoU,cAAA,iBAAAa,KAAA,KAGAnC,EAAA4/D,UAAA,SAAAz9D,GACAnC,EAAAoC,OAAApC,EAAA9S,MAAAoU,cAAA,iBAAAa,KAAA,KAGAnC,EAAAoC,OAAA,SAAA5iB,GACA,GAAAyhB,GAAA/B,EAAA0D,SAAAtI,MAAA0F,EAAA9e,MAAAwf,UAAA,CAEAlhB,GAAA,IACAA,EAAAwgB,EAAA9e,MAAA+8E,aAAAh9D,EAAA,GAGAzhB,EAAAyhB,IACAzhB,EAAAwgB,EAAA9e,MAAA+8E,aAAA,EAAAh9D,GAGAjB,EAAAihE,YAEA3/D,aAAA9hB,IAKAwgB,EAAA9e,MAAA88E,WAAA,IAAAh+D,EAAA9S,MAAA6yE,gBACA//D,EAAA8/D,iBAIA9/D,EAAA4hE,WAAA,SAAA3rE,GACA,GAAA4rE,GAAA5rE,EAAAlZ,OAAA1B,KAEA2kB,GAAAihE,YACA3/D,aAAAugE,KAIA7hE,EAAAihE,WAAA,SAAA/zE,GACA8S,EAAAmB,SAAAjU,GACA8S,EAAA8gE,eAAA5zE,EAAAoU,aAAApC,EAAA0D,SAAAE,QAAA9C,EAAA9e,MAAAwf,UAAAxT,EAAAoU,gBAGAtB,EAAA8hE,gBAAA,WACA,GAAAxgE,GAAAtB,EAAA9e,MAAAogB,aACA/gB,EAAAyf,EAAAy/D,UAAAz/D,EAAAy/D,SAAAn+D,GACAgB,EAAA/hB,KAAA46B,qBAAA,MACA,OAAA7Y,MAAAhB,IAGAtB,EAAA+hE,uBAAA,SAAAviF,GACA,GAAAe,GAAAyf,EAAAy/D,UAAAz/D,EAAAy/D,SAAAjgF,GACA8iB,EAAA/hB,KAAA46B,qBAAA,MACA,IAAAnb,EAAA9S,MAAAsU,UAAAc,EAAAllB,OAAA,GACA,GAAA2lB,GAAAT,EAAA,EAEA,KAAAS,EAAAqO,SAAA,CAEA,GAAA4wD,GAAA,QAAAA,KACAhiE,EAAAiiE,cACAl/D,EAAAnJ,oBAAA,OAAAooE,GAGAj/D,GAAApJ,iBAAA,OAAAqoE,GAGA,GAAA3gF,GAAA0hB,EAAAotB,YACA,OAAA9uC,GAAA,EAAAA,EAAA,KAGA,aAGA2e,EAAA9S,OACAyzE,aAAA,EACAr/D,aAAApgB,EAAAogB,aACAE,UAAA,EACAu+D,gBAAA,GAEA//D,EA+TA,MAlmBA3B,GAAAy/D,EAAA/9D,GAsSAjB,EAAAg/D,IACAlhF,IAAA,oBACAvB,MAAA,WACAc,KAAA+E,MAAAwf,UAIAvkB,KAAA+lF,mBAGAtlF,IAAA,4BACAvB,MAAA,SAAAmnB,GACAA,EAAAlB,eAAAnlB,KAAA+Q,MAAAoU,eACAnlB,KAAAskB,cACAtkB,KAAAimB,OAAAI,EAAAlB,eAGAkB,EAAAw7D,WAAA7hF,KAAA+E,MAAA88E,WACAx7D,EAAAw7D,SACA7hF,KAAAgmF,gBAEAhmF,KAAAimF,sBAKAxlF,IAAA,qBACAvB,MAAA,SAAAqnB,GACAA,EAAAhC,WAAAvkB,KAAA+E,MAAAwf,UAAAvkB,KAAA+Q,MAAAyzE,aACAxkF,KAAA+lF,mBAIAtlF,IAAA,uBACAvB,MAAA,WACAc,KAAAkmF,qBAGAzlF,IAAA,gBACAvB,MAAA,WACAc,KAAA8vD,aAEA9vD,KAAA+E,MAAA88E,UAAA9+D,EAAA0D,SAAAtI,MAAAne,KAAA+E,MAAAwf,UAAA,GACAvkB,KAAAgmF,gBAGAhmF,KAAAglB,UACAw/D,aAAA,GAGA,IAAA2B,GAAAnmF,KAAA2lF,iBACAQ,GAEAA,EAAA3oE,iBAAA,OAAAxd,KAAAolB,eAEAplB,KAAAolB,mBAIA3kB,IAAA,kBACAvB,MAAA,WACAc,KAAA+Q,MAAAyzE,cACAxkF,KAAAszD,eACAtzD,KAAAimF,sBAIAxlF,IAAA,gBACAvB,MAAA,WACAc,KAAA6hF,UACA,IAAAuE,GAAApmF,KAAAkjF,kBAEAljF,MAAA+E,MAAAg9E,aAAAqE,IACAA,EAAA5oE,iBAAA,aAAAxd,KAAA+hF,aACAqE,EAAA5oE,iBAAA,aAAAxd,KAAA6jF,kBAIApjF,IAAA,kBACAvB,MAAA,WACAc,KAAA0jF,eACA,IAAA0C,GAAApmF,KAAAkjF,kBAEAljF,MAAA+E,MAAAg9E,aAAAqE,IACAA,EAAA3oE,oBAAA,aAAAzd,KAAA+hF,aACAqE,EAAA3oE,oBAAA,aAAAzd,KAAA6jF,kBAIApjF,IAAA,aACAvB,MAAA,WAGAya,OAAA6D,iBAAA,SAAAxd,KAAAskB,aAEA3K,OAAA6D,iBAAA,mBAAAxd,KAAAskB,aAEAtkB,KAAA+E,MAAAshF,mBACAvwD,SAAAtY,iBAAA,UAAAxd,KAAA8jF,yBAIArjF,IAAA,eACAvB,MAAA,WAEAya,OAAA8D,oBAAA,SAAAzd,KAAAskB,aACA3K,OAAA8D,oBAAA,mBAAAzd,KAAAskB,YAEA,IAAA6hE,GAAAnmF,KAAA2lF,iBACAQ,IACAA,EAAA1oE,oBAAA,OAAAzd,KAAAolB,eAGAplB,KAAA+E,MAAAshF,mBACAvwD,SAAArY,oBAAA,UAAAzd,KAAA8jF,yBAIArjF,IAAA,cACAvB,MAAA,SAAAwF,GACA,GAAA1E,KAAA+E,MAAAuhF,YAAA,eAAAtmF,KAAA+E,MAAAwW,KAAA,CACA,GAAAqK,IAAAlhB,EAAA1E,KAAA+E,MAAAwhF,sBACAzhE,EAAA/B,EAAA0D,SAAAtI,MAAAne,KAAA+E,MAAAwf,UAAA,CAQA,OANA7f,QAAAogB,EACAc,IAAA,IAAA5lB,KAAA+E,MAAAwhF,uBAAA,EACiB7hF,IAAAogB,IACjBc,GAAA,IAAA5lB,KAAA+E,MAAAwhF,uBAGA3gE,EAGA,YAAAlhB,KAGAjE,IAAA,cACAvB,MAAA,WACA,GAAA4nB,GAAA9mB,IAEA,OAAA+iB,GAAA0D,SAAAlb,IAAAvL,KAAA+E,MAAAwf,SAAA,SAAAngB,EAAAM,GACA,GACA8hF,IADAnjE,EAAAhE,QAAAe,MAAA,EAAA1b,IAAAoiB,EAAA/V,MAAAoU,eAEA8B,IAAA,SAAAnN,GACA,MAAAgN,GAAAu8D,YAAAvpE,EAAApV,IAEAjE,IAAA,UAAAiE,EACAwiB,UAAA7D,EAAAhE,QAAAe,MAAA,EAAA1b,IAAAoiB,EAAA/V,MAAAoU,cACAgC,QAAAL,EAAAxB,gBAAA8B,KAAAN,EAAApiB,EAAAN,IASA,OANA0iB,GAAA/hB,MAAAuhF,YAAA,eAAAx/D,EAAA/hB,MAAAwW,OACAirE,EAAA1gE,OACA2gE,SAAA3/D,EAAA/hB,MAAAwhF,sBAAA,MAIAvjE,EAAA3D,QAAAvgB,cACA,KACA0nF,EACApiF,QAKA3D,IAAA,iBACAvB,MAAA,WACA,GAAAwnF,GAAA1mF,IAEA,OAAAA,MAAA+E,MAAA4hF,eAIA3jE,EAAA3D,QAAAvgB,cACA,MACiBooB,UAAA,gBACjBnE,EAAA0D,SAAAlb,IAAAvL,KAAA+E,MAAAwf,SAAA,SAAAngB,EAAAM,GACA,MAAAse,GAAA3D,QAAAvgB,cAAA,MAAgEooB,UAAA7D,EAAAhE,QAAAyB,IAAApc,IAAAgiF,EAAA31E,MAAAoU,cAAAgC,QAAAu/D,EAAAjB,WAAAvmF,MAAAwF,EAAAjE,IAAAiE,OAPhE,QAYAjE,IAAA,eACAvB,MAAA,WACA,MAAAc,MAAA+E,MAAAk9E,WAIAj/D,EAAA3D,QAAAvgB,cACA,KACiBooB,UAAA,mBACjBlnB,KAAA+E,MAAA6hF,gBAAA5mF,KAAA+Q,MAAAoU,aAAA,EAAApC,EAAA0D,SAAAtI,MAAAne,KAAA+E,MAAAwf,YANA,QAUA9jB,IAAA,eACAvB,MAAA,WACA,MAAAc,MAAA+E,MAAA8hF,YAAA,IAAA9jE,EAAA0D,SAAAtI,MAAAne,KAAA+E,MAAAwf,UAIAvB,EAAA3D,QAAAvgB,cACA2jF,EAAApjE,SACiB4H,IAAAjnB,KAAAokB,aAAAmB,aAAAvlB,KAAA4kF,iBAAAz/D,aAAAnlB,KAAA+Q,MAAAoU,aAAAwC,eAAA3nB,KAAA+E,MAAA4iB,eAAAhD,WAAA3kB,KAAA+E,MAAA4f,YACjB3kB,KAAA+E,MAAAwf,UANA,QAUA9jB,IAAA,SACAvB,MAAA,WACA,IAAAc,KAAA+E,MAAAwf,UAAA,IAAAxB,EAAA0D,SAAAtI,MAAAne,KAAA+E,MAAAwf,UACA,WAGA,IAAAuiE,GAAA/jE,EAAA0D,SAAAtI,MAAAne,KAAA+E,MAAAwf,UAEAjf,EAAA,eAAAtF,KAAA+E,MAAAwW,KAEAwrE,EAAA/mF,KAAA+E,MAAAggB,YAAA+hE,EAAA,EAGAv/D,EAAAw/D,IAAA/mF,KAAA+Q,MAAAoU,aAAA,GAAAnlB,KAAA+E,MAAA+8E,cAEAt6D,EAAAu/D,IAAA/mF,KAAA+Q,MAAAoU,aAAA2hE,EAAA,GAAA9mF,KAAA+E,MAAA+8E,cAEAr6D,KAEA7B,EAAA5lB,KAAAglF,YAAAhlF,KAAA+Q,MAAAoU,cAGAuC,GAAA,EAAAlE,EAAAnE,SAAAuG,EAAA,IAAA5lB,KAAA+E,MAAAwW,MAEAoM,EAAA3nB,KAAA+E,MAAA4iB,eAAA,IAEAF,IACAG,gBAAAF,EACAG,aAAAH,EACAI,YAAAJ,EACAK,WAAAL,EACAM,UAAAN,EACAO,YAAAP,GAGA1nB,KAAA+Q,MAAA0U,UACAgC,EAAAk7D,KAA4Cl7D,GAC5CS,yBAAAP,EACAQ,sBAAAR,EACAS,qBAAAT,EACAU,oBAAAV,EACAW,mBAAAX,EACAY,qBAAAZ,IAIA,IAAAq/D,IACA7hE,aAAAnlB,KAAA+Q,MAAAoU,aACA+B,UAAA7D,EAAAhE,QAAAU,QAAA,EAAA/f,KAAA+Q,MAAA0U,SACAE,YAAA3lB,KAAA2lB,YACAH,aAAAxlB,KAAAwlB,aACAE,WAAA1lB,KAAA0lB,WACAI,MAAA2B,EACAw/D,UAAAjnF,KAAA+E,MAAAugF,sBAGA4B,IAEA,IAAA5hF,GAIA,GAHA0hF,EAAAv+D,YAAAzoB,KAAAyjF,UACAuD,EAAAt+D,aAAA1oB,KAAAukF,UAEAvkF,KAAA+E,MAAAoiF,cAAA,CACA,GAAA/G,GAAApgF,KAAA4lF,uBAAA5lF,KAAA+Q,MAAAoU,aACA6hE,GAAAlhE,MAAA5gB,OAAAk7E,GAAA,OACA8G,EAAAhiF,OAAAk7E,GAAA,YAGA4G,GAAAI,UAAA,YAAApnF,KAAA+E,MAAAsiF,cAAArnF,KAAAyjF,UAAAzjF,KAAAukF,UACAyC,EAAAM,YAAA,YAAAtnF,KAAA+E,MAAAsiF,cAAArnF,KAAAukF,UAAAvkF,KAAAyjF,UACAuD,EAAAlhE,MAAA5gB,OAAAlF,KAAA+Q,MAAA2T,SACAwiE,EAAAhiF,OAAAlF,KAAA+Q,MAAA2T,QAEA,OAAA1B,GAAA3D,QAAAvgB,cACA,OACiBooB,UAAAlnB,KAAA+E,MAAAmiB,UAAAD,IAAAjnB,KAAAijF,uBACjBjgE,EAAA3D,QAAAvgB,cACA,OACqBooB,UAAA7D,EAAAhE,QAAAC,UAAA,GAAAwG,OAAyD7gB,MAAAjF,KAAA+E,MAAAE,QAC9E+d,EAAA3D,QAAAvgB,cAAA,UAA6D+B,KAAA,SAAAqmB,UAAA7D,EAAAhE,QAAAmB,YAAA+G,GAAAJ,QAAAnnB,KAAAukF,YAC7DvhE,EAAA3D,QAAAvgB,cACA,OACyBooB,UAAA7D,EAAAhE,QAAAK,SAAA,EAAA1f,KAAA+E,MAAAwW,MAAAuK,MAAAohE,EAAAjgE,IAAAjnB,KAAA+jB,oBACzB/jB,KAAA+E,MAAAwiF,UAAAvkE,EAAA3D,QAAAvgB,cACA4kB,EAAArE,QACAsjE,GACAn6D,QAAA,KACAvB,IAAAjnB,KAAAmjF,YAC6B6D,GAC7BQ,iBAAAxnF,KAAA+E,MAAA0iF,eACAznF,KAAA2oB,eACA3F,EAAA3D,QAAAvgB,cACA,MAEAooB,UAAA7D,EAAAhE,QAAAU,QAAA,EAAA/f,KAAA+Q,MAAA0U,SACAK,MAAA2B,GACAznB,KAAA2oB,gBAGA3F,EAAA3D,QAAAvgB,cAAA,UAA6D+B,KAAA,SAAAqmB,UAAA7D,EAAAhE,QAAAuB,YAAA4G,GAAAL,QAAAnnB,KAAAyjF,YAC7DzjF,KAAA0nF,iBACA1nF,KAAA2nF,gBAEA3nF,KAAA4nF,oBAKAjG,GACC5+D,EAAA6F,UAED+4D,GAAA94D,YAAA,WACA84D,EAAAkG,WACA3gE,UAAA/D,EAAA9D,QAAAvL,OACAyQ,SAAApB,EAAA9D,QAAA2E,KACAe,WAAA5B,EAAA9D,QAAAyoE,KACA7F,WAAA9+D,EAAA9D,QAAAyoE,KACAnB,eAAAxjE,EAAA9D,QAAAyoE,KACAhG,aAAA3+D,EAAA9D,QAAAyoE,KACAjB,WAAA1jE,EAAA9D,QAAAyoE,KACAnjE,WAAAxB,EAAA9D,QAAA2J,OACA7D,aAAAhC,EAAA9D,QAAA2J,OACA07D,YAAAvhE,EAAA9D,QAAA62B,KAAAntB,WACA87D,aAAA1hE,EAAA9D,QAAA62B,KAAAntB,WACA4D,SAAAxJ,EAAA9D,QAAA62B,KAAAntB,WACAxN,KAAA4H,EAAA9D,QAAA0oE,OAAA,0BACAV,cAAAlkE,EAAA9D,QAAA0oE,OAAA,uBACA9iF,MAAA69E,EAAAjlD,KACAwoD,kBAAAljE,EAAA9D,QAAAyoE,KACAjG,SAAA1+D,EAAA9D,QAAAyoE,KACA/F,YAAA5+D,EAAA9D,QAAAyoE,KACAjW,SAAA1uD,EAAA9D,QAAA2J,OACArB,eAAAxE,EAAA9D,QAAA2J,OACAs8D,qBAAAniE,EAAA9D,QAAA2J,OACAu+D,UAAApkE,EAAA9D,QAAAyoE,KACAX,cAAAhkE,EAAA9D,QAAAyoE,KACAL,aAAAtkE,EAAA9D,QAAAyoE,KACAlB,gBAAAzjE,EAAA9D,QAAA62B,KAAAntB,WACAu9D,WAAAnjE,EAAA9D,QAAAyoE,KACAvB,sBAAApjE,EAAA9D,QAAA2J,QAEA24D,EAAA14D,cACA09D,gBAAA,EACA5hE,YAAA,EACAk9D,YAAA,EACA4E,YAAA,EACA/E,cAAA,EACA38D,aAAA,EACA5J,KAAA,aACA8rE,cAAA,WACApiF,MAAA,OACAohF,mBAAA,EACAxE,UAAA,EACAE,aAAA,EACAlQ,SAAA,IACAlqD,eAAA,IACA29D,qBAAA,EACAiC,WAAA,EACAJ,eAAA,EACAM,cAAA,EACA/C,YAAAx6E,EACA26E,aAAA36E,EACAyiB,SAAAziB,EACA08E,gBAAA5D,EACAsD,YAAA,EACAC,sBAAA,IAEAjnF,EAAA+f,QAAAsiE,G1EwziBMqG,KACA,SAAUxpF,EAAQc,EAASZ,G2EjhkBjC,GAAAyiB,GAAAC,EAAAC,GAAA,SAAAtC,EAAAuC,GAEAF,GAAA9hB,EAAAZ,EAAA,GAAAA,EAAA,IAAAyiB,EAAA,MAAA1R,MAAA4R,EAAA,mBAAAF,KAAAvf,MAAAtC,EAAA8hB,GAAAD,KAAA3iB,EAAAc,QAAA+hB,IAUCrhB,EAAA,SAAAV,EAAAyjB,EAAAG,GACD,YAWA,SAAAxB,GAAA1N,GACA,MAAAA,MAAAoL,WAAApL,GACAqL,QAAArL,GAIA,QAAA2N,GAAAC,EAAAC,GACA,KAAAD,YAAAC,IACA,SAAAC,WAAA,qCAsBA,QAAAC,GAAAC,EAAAxX,GACA,IAAAwX,EACA,SAAAC,gBAAA,4DAGA,QAAAzX,GAAA,iBAAAA,IAAA,mBAAAA,GAAAwX,EAAAxX,EAGA,QAAA0X,GAAAC,EAAAC,GACA,sBAAAA,IAAA,OAAAA,EACA,SAAAN,WAAA,iEAAAM,GAGAD,GAAArgB,UAAA9C,OAAAqjB,OAAAD,KAAAtgB,WACAsK,aACAlN,MAAAijB,EACAG,YAAA,EACAC,UAAA,EACAC,cAAA,KAGAJ,IAAApjB,OAAAyjB,eAAAzjB,OAAAyjB,eAAAN,EAAAC,GAAAD,EAAAO,UAAAN,GAIA,QAAA6lE,GAAAC,GACAC,EAAAD,EASA,QAAAE,KACA,GAAA3oF,GAAAoC,UAAAZ,OAAA,OAAAwO,KAAA5N,UAAA,GAAAA,UAAA,IAAuFwmF,SAAA,EAEvF,OAAAF,GAAA1oF,IAAA4oF,QAQA,QAAArD,GAAAntD,GACA,cAAAA,GAAA,CACA,GAAAywD,GAAAzwD,EAAAob,QAAA,EAIA,QAAczwC,EAHd8lF,EAAAC,MAGc9lF,EAFd6lF,EAAAE,OAQA,OAAYhmF,EAHZq1B,EAAA4wD,QAGYhmF,EAFZo1B,EAAA6wD,SA/FA1pF,OAAAC,eAAAK,EAAA,cACAJ,OAAA,IAEAI,EAAA2oF,8BAEA,IAAAjlE,GAAAtB,EAAAqB,GAEAI,EAAAzB,EAAAwB,GAcAP,EAAA,WACA,QAAAC,GAAAhiB,EAAAmE,GACA,OAAAxE,GAAA,EAAqBA,EAAAwE,EAAA9D,OAAkBV,IAAA,CACvC,GAAAge,GAAAxZ,EAAAxE,EACAge,GAAA+D,WAAA/D,EAAA+D,aAAA,EACA/D,EAAAiE,cAAA,EACA,SAAAjE,OAAAgE,UAAA,GACAvjB,OAAAC,eAAA2B,EAAA2d,EAAA9d,IAAA8d,IAIA,gBAAAsD,EAAAgB,EAAAC,GAGA,MAFAD,IAAAD,EAAAf,EAAA/f,UAAA+gB,GACAC,GAAAF,EAAAf,EAAAiB,GACAjB,MA4BAsmE,GAAA,CAKA,KACA3qE,iBAAA,YAAAxe,OAAAC,kBAA2D,WAAc6N,IAAA,WACzEm7E,GAAA,OAEG,MAAAnuE,IA4BH,GAAA6uE,GAAA,SAAA/kE,GAGA,QAAA+kE,KACA,GAAAp+D,EAEA5I,GAAA3hB,KAAA2oF,EAEA,QAAAj+D,GAAA7oB,UAAAZ,OAAA8J,EAAAT,MAAAogB,GAAAC,EAAA,EAAqEA,EAAAD,EAAaC,IAClF5f,EAAA4f,GAAA9oB,UAAA8oB,EAGA,IAAA9G,GAAA9B,EAAA/hB,MAAAuqB,EAAAo+D,EAAAjmE,WAAA1jB,OAAA8kB,eAAA6kE,IAAAn+E,KAAA5I,MAAA2oB,GAAAvqB,MAAAkI,OAAA6C,IASA,OAPA8Y,GAAA+kE,kBAAA/kE,EAAA+kE,kBAAAxhE,KAAAvD,GACAA,EAAAglE,iBAAAhlE,EAAAglE,iBAAAzhE,KAAAvD,GACAA,EAAAilE,gBAAAjlE,EAAAilE,gBAAA1hE,KAAAvD,GAEAA,EAAAklE,aAAAllE,EAAAklE,aAAA3hE,KAAAvD,GACAA,EAAAmlE,aAAAnlE,EAAAmlE,aAAA5hE,KAAAvD,GACAA,EAAAolE,WAAAplE,EAAAolE,WAAA7hE,KAAAvD,GACAA,EA6IA,MAjKA3B,GAAAymE,EAAA/kE,GAuBAjB,EAAAgmE,IACAloF,IAAA,oBACAvB,MAAA,WACAc,KAAAkpF,QACAlpF,KAAAkpF,OAAA1rE,iBAAA,YAAAxd,KAAA6oF,iBAAAT,GACAC,SAAA,EACAh7B,SAAA,QAKA5sD,IAAA,uBACAvB,MAAA,WACAc,KAAAkpF,QACAlpF,KAAAkpF,OAAAzrE,oBAAA,YAAAzd,KAAA6oF,iBAAAT,GACAC,SAAA,EACAh7B,SAAA,QAKA5sD,IAAA,eACAvB,MAAA,SAAA24B,GACA73B,KAAA+E,MAAAyiF,mBAIAxnF,KAAAmpF,WAAA,EAEArzD,SAAAtY,iBAAA,UAAAxd,KAAAipF,YACAnzD,SAAAtY,iBAAA,YAAAxd,KAAAgpF,cAEAhpF,KAAA4oF,kBAAA/wD,OAGAp3B,IAAA,eACAvB,MAAA,SAAA24B,GACA73B,KAAAmpF,WAIAnpF,KAAA6oF,iBAAAhxD,MAGAp3B,IAAA,aACAvB,MAAA,SAAA24B,GACA73B,KAAAmpF,WAAA,EAEArzD,SAAArY,oBAAA,UAAAzd,KAAAipF,YACAnzD,SAAArY,oBAAA,YAAAzd,KAAAgpF,cAEAhpF,KAAA8oF,gBAAAjxD,MAGAp3B,IAAA,oBACAvB,MAAA,SAAA24B,GACA,GAAAuxD,GAAApE,EAAAntD,GACAr1B,EAAA4mF,EAAA5mF,EACAC,EAAA2mF,EAAA3mF,CAEAzC,MAAAqpF,WAA0B7mF,IAAAC,KAC1BzC,KAAA+E,MAAAygB,aAAAqS,MAGAp3B,IAAA,mBACAvB,MAAA,SAAA24B,GACA,GAAA73B,KAAAqpF,UAAA,CAIA,GAAAC,GAAAtE,EAAAntD,GACAr1B,EAAA8mF,EAAA9mF,EACAC,EAAA6mF,EAAA7mF,EAEAmZ,EAAApZ,EAAAxC,KAAAqpF,UAAA7mF,EACAqZ,EAAApZ,EAAAzC,KAAAqpF,UAAA5mF,CACAzC,MAAAupF,QAAA,CAIAvpF,MAAA+E,MAAA4gB,aACAnjB,EAAAoZ,EACAnZ,EAAAoZ,GACSgc,IAGTA,EAAA2xD,iBAGAxpF,KAAAypF,cAA6B7tE,SAAAC,cAG7Bpb,IAAA,kBACAvB,MAAA,SAAA24B,GACA73B,KAAA+E,MAAA2gB,WAAAmS,EAEA,IAAAovD,GAAAjnF,KAAA+E,MAAAkiF,SAGAjnF,MAAAupF,QAAAvpF,KAAAypF,eACAzpF,KAAAypF,aAAA7tE,QAAAqrE,EACAjnF,KAAA+E,MAAA0jB,YAAA,EAAAoP,GACW73B,KAAAypF,aAAA7tE,OAAAqrE,GACXjnF,KAAA+E,MAAA2jB,aAAA,EAAAmP,GAEA73B,KAAAypF,aAAA5tE,QAAAorE,EACAjnF,KAAA+E,MAAAqiF,UAAA,EAAAvvD,GACW73B,KAAAypF,aAAA5tE,OAAAorE,GACXjnF,KAAA+E,MAAAuiF,YAAA,EAAAzvD,IAIA73B,KAAAqpF,UAAA,KACArpF,KAAAupF,QAAA,EACAvpF,KAAAypF,aAAA,QAGAhpF,IAAA,SACAvB,MAAA,WACA,GAAA4nB,GAAA9mB,IAEA,OAAAgjB,GAAA3D,QAAAvgB,cACAkB,KAAA+E,MAAAyjB,SAEAvB,IAAA,SAAAjD,GACA,MAAA8C,GAAAoiE,OAAAllE,GAEA0lE,YAAA1pF,KAAA+oF,aACAY,aAAA3pF,KAAA4oF,kBACAgB,WAAA5pF,KAAA8oF,gBACA5hE,UAAAlnB,KAAA+E,MAAAmiB,UACApB,MAAA9lB,KAAA+E,MAAA+gB,OAEA9lB,KAAA+E,MAAAwf,cAKAokE,GACG5lE,EAAA6F,UAEH+/D,GAAA9/D,YAAA,aACA8/D,EAAAd,WACAr/D,QAAArF,EAAA9D,QAAAvL,OACAoT,UAAA/D,EAAA9D,QAAAvL,OACAgS,MAAA3C,EAAA9D,QAAAo1C,OACAlwC,SAAApB,EAAA9D,QAAA2E,KACAwjE,iBAAArkE,EAAA9D,QAAAyoE,KACAV,UAAAjkE,EAAA9D,QAAA62B,KACAoxC,YAAAnkE,EAAA9D,QAAA62B,KACAztB,YAAAtF,EAAA9D,QAAA62B,KACAxtB,aAAAvF,EAAA9D,QAAA62B,KACA1wB,aAAArC,EAAA9D,QAAA62B,KACAvwB,YAAAxC,EAAA9D,QAAA62B,KACAxwB,WAAAvC,EAAA9D,QAAA62B,KACA+wC,UAAA9jE,EAAA9D,QAAA2J,OAAAD,YAEA4/D,EAAA1/D,cACAT,QAAA,MACAg/D,kBAAA,EACAJ,UAAA,aACAE,YAAA,aACA7+D,YAAA,aACAC,aAAA,aACAlD,aAAA,aACAG,YAAA,aACAD,WAAA,aAEAuhE,UAAA,GAEA3nF,EAAA+f,QAAAspE,K3E2hkBMkB,KACA,SAAUrrF,EAAQc,EAASZ,GAEjC,Y4Ej1kBAM,QAAAC,eAAAK,EAAA,cACAJ,OAAA,GAEAI,GAAAslB,WAAA,SAAAuvB,GACA,GAAAlvC,GAAAkvC,EAAAvY,YACA9V,EAAAwnB,iBAAA6G,EAGA,OADAlvC,IAAAqrB,SAAAxK,EAAAgkE,YAAAx5D,SAAAxK,EAAAikE,e5E01kBMC,KACA,SAAUxrF,EAAQc,EAASZ,GAEjC,Y6Ep2kBAM,QAAAC,eAAAK,EAAA,cACAJ,OAAA,GAEAI,GAAAu+B,KAAA,SAAA94B,EAAAklF,EAAAC,GACA,8BAAAC,KAAAplF,EAAAklF,IACA,UAAAxxD,OAAA,iBAAAwxD,EAAA,kBAAAC,EAAA,kF7E62kBME,KACA,SAAU5rF,EAAQC,EAAqBC,GAE7C,YAQ8f,SAASijB,GAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAuC,QAASC,GAA2BC,EAAKxX,GAAM,IAAIwX,EAAM,KAAM,IAAIC,gBAAe,4DAA8D,QAAOzX,GAAqB,iBAAPA,IAA+B,mBAAPA,GAAwBwX,EAALxX,EAAW,QAAS0X,GAAUC,EAASC,GAAY,GAAuB,mBAAbA,IAAsC,OAAbA,EAAmB,KAAM,IAAIN,WAAU,iEAAkEM,GAAaD,GAASrgB,UAAU9C,OAAOqjB,OAAOD,GAAYA,EAAWtgB,WAAWsK,aAAalN,MAAMijB,EAASG,YAAW,EAAMC,UAAS,EAAKC,cAAa,KAAWJ,IAAWpjB,OAAOyjB,eAAezjB,OAAOyjB,eAAeN,EAASC,GAAYD,EAASO,UAAUN,GAP3wC,GAAIjjB,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GACpEoqB,EAA4C7qB,EAAoB,KAChE2rF,EAAiD3rF,EAAoB,KACrE+qB,EAAqC/qB,EAAoB,IACzD4rF,EAAgE5rF,EAAoB,KACpF6rF,EAAyD7rF,EAAoB,IAClGikB,EAAa,WAAW,QAASC,GAAiBhiB,EAAOmE,GAAO,IAAI,GAAIxE,GAAE,EAAEA,EAAEwE,EAAM9D,OAAOV,IAAI,CAAC,GAAIge,GAAWxZ,EAAMxE,EAAGge,GAAW+D,WAAW/D,EAAW+D,aAAY,EAAM/D,EAAWiE,cAAa,EAAQ,SAAUjE,KAAWA,EAAWgE,UAAS,GAAKvjB,OAAOC,eAAe2B,EAAO2d,EAAW9d,IAAI8d,IAAc,MAAO,UAASsD,EAAYgB,EAAWC,GAAuI,MAAvHD,IAAWD,EAAiBf,EAAY/f,UAAU+gB,GAAeC,GAAYF,EAAiBf,EAAYiB,GAAoBjB,M8Ex3kBpe2oE,EAAW/gE,EAAA,EAAX+gE,OAEFC,E9Es3kBg4C,SAAS7mE,GAAkD,QAAS6mE,KAAkB,GAAIlgE,GAASC,EAAM3G,EAAM4G,CAAK9I,GAAgB3hB,KAAKyqF,EAAiB,KAAI,GAAI//D,GAAK7oB,UAAUZ,OAAO8J,EAAKT,MAAMogB,GAAMC,EAAK,EAAEA,EAAKD,EAAKC,IAAQ5f,EAAK4f,GAAM9oB,UAAU8oB,EAAO,OAAaH,GAAO3G,EAAM9B,EAA2B/hB,MAAMuqB,EAAKkgE,EAAgB/nE,WAAW1jB,OAAO8kB,eAAe2mE,IAAkBjgF,KAAK5I,MAAM2oB,GAAMvqB,MAAMkI,OAAO6C,KAAe8Y,E8El3kBlzD6mE,mBAAqB,WAAM,GACjB19E,GAAS6W,EAAK9e,MAAdiI,KACAiD,EAAYjD,EAAZiD,OA+BR,SA5BEod,MAAO,oBACP5sB,IAAK,iBAEL4sB,MAAO,sBACP5sB,IAAK,WACL6tB,OAHC,SAGMf,EAAMo9D,GACX,MAAO16E,GAAQ26E,OAAOx7E,KAAK,SAAAy7E,GAAA,MAAUA,GAAOzgF,KAAOugF,EAAOG,WAAUt6E,QAGtE6c,MAAO,yBACP5sB,IAAK,gBACL6tB,OAHC,SAGMf,EAAMo9D,GACX,GAAMI,GAAc96E,EAAQ+6E,YAAY57E,KACtC,SAAAC,GAAA,MAAWA,GAAQjF,KAAOugF,EAAOM,eACnC,OAAOF,GAAcA,EAAYv6E,KAAO,MAG1C6c,MAAO,kBACP5sB,IAAK,cACL6tB,OAHC,SAGMf,EAAMo9D,GACX,MACE/rF,GAAAC,EAAAC,cAACurF,EAAA,GAAK/zC,GAAA,sBAA0Bq0C,EAAOvgF,IAAvC,UAOSmB,IAAI,SAAA2/E,GAAA,MACjBtsF,GAAAC,EAAAC,cAAC0rF,GACCn9D,MAAOzuB,EAAAC,EAAAC,cAACyrF,EAAA,GAAiBngF,GAAI8gF,EAAO79D,QACpC5sB,IAAKyqF,EAAOzqF,IACZ23E,UAAW8S,EAAOzqF,IAClB6tB,OAAQ48D,EAAO58D,Y9E40kBonD7D,EAA8xCD,EAAOzI,EAA2B8B,EAAM4G,GAAurB,MAA7uEvI,GAAUuoE,EAAgB7mE,GAAmiDjB,EAAa8nE,IAAkBhqF,IAAI,oBAAoBvB,MAAM,W8Ep3kBjhGc,KAAK+E,MAAMomF,0B9Eo3kBykG1qF,IAAI,SAASvB,MAAM,W8Ex0kBhmG,GAAA0rB,GACmB5qB,KAAK+E,MAAvBiI,EADD4d,EACC5d,KAAM6d,EADPD,EACOC,QACN1b,EAAcnC,EAAdmC,SACR,OACEvQ,GAAAC,EAAAC,cAAC2qB,EAAA,GAAKwB,SAAUJ,GACdjsB,EAAAC,EAAAC,cAAC2qB,EAAA,GACC2hE,OAAQ,SAAAT,GAAA,MAAUA,GAAOvgF,IACzBmsB,WAAYpnB,GAAaA,EAAU0C,OAAO,SAAArP,GAAA,MAAiB,6BAAZA,EAAEuO,SAG/C/Q,KAAK0qF,2B9E8zkB8nHD,G8Et3kBjnHtrF,EAAA,WAgExBksB,EAAkB,SAAAta,GAAA,OACtB/D,KAAM+D,EAAMs6E,kBAAkBr+E,KAC9B6d,QAAS9Z,EAAMs6E,kBAAkBxgE,SAGnCpsB,GAAA,EAAeO,OAAAuqB,EAAA,GACb8B,EACAi/D,GACAG,I9EkzkBIa,KACA,SAAU9sF,EAAQC,EAAqBC,GAE7C,YAQ8f,SAASijB,GAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAuC,QAASC,GAA2BC,EAAKxX,GAAM,IAAIwX,EAAM,KAAM,IAAIC,gBAAe,4DAA8D,QAAOzX,GAAqB,iBAAPA,IAA+B,mBAAPA,GAAwBwX,EAALxX,EAAW,QAAS0X,GAAUC,EAASC,GAAY,GAAuB,mBAAbA,IAAsC,OAAbA,EAAmB,KAAM,IAAIN,WAAU,iEAAkEM,GAAaD,GAASrgB,UAAU9C,OAAOqjB,OAAOD,GAAYA,EAAWtgB,WAAWsK,aAAalN,MAAMijB,EAASG,YAAW,EAAMC,UAAS,EAAKC,cAAa,KAAWJ,IAAWpjB,OAAOyjB,eAAezjB,OAAOyjB,eAAeN,EAASC,GAAYD,EAASO,UAAUN,GAP3wC,GAAIjjB,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GACpEoqB,EAA4C7qB,EAAoB,KAChE2rF,EAAiD3rF,EAAoB,KACrE+qB,EAAqC/qB,EAAoB,IACzD6sF,EAAkE7sF,EAAoB,MACtF6rF,EAAyD7rF,EAAoB,IAClGikB,EAAa,WAAW,QAASC,GAAiBhiB,EAAOmE,GAAO,IAAI,GAAIxE,GAAE,EAAEA,EAAEwE,EAAM9D,OAAOV,IAAI,CAAC,GAAIge,GAAWxZ,EAAMxE,EAAGge,GAAW+D,WAAW/D,EAAW+D,aAAY,EAAM/D,EAAWiE,cAAa,EAAQ,SAAUjE,KAAWA,EAAWgE,UAAS,GAAKvjB,OAAOC,eAAe2B,EAAO2d,EAAW9d,IAAI8d,IAAc,MAAO,UAASsD,EAAYgB,EAAWC,GAAuI,MAAvHD,IAAWD,EAAiBf,EAAY/f,UAAU+gB,GAAeC,GAAYF,EAAiBf,EAAYiB,GAAoBjB,M+Ev4kBpe2oE,EAAW/gE,EAAA,EAAX+gE,OAEFgB,E/Eq4kBk4C,SAAS5nE,GAAoD,QAAS4nE,KAAoB,GAAIjhE,GAASC,EAAM3G,EAAM4G,CAAK9I,GAAgB3hB,KAAKwrF,EAAmB,KAAI,GAAI9gE,GAAK7oB,UAAUZ,OAAO8J,EAAKT,MAAMogB,GAAMC,EAAK,EAAEA,EAAKD,EAAKC,IAAQ5f,EAAK4f,GAAM9oB,UAAU8oB,EAAO,OAAaH,GAAO3G,EAAM9B,EAA2B/hB,MAAMuqB,EAAKihE,EAAkB9oE,WAAW1jB,OAAO8kB,eAAe0nE,IAAoBhhF,KAAK5I,MAAM2oB,GAAMvqB,MAAMkI,OAAO6C,KAAe8Y,E+Ej4kB9zD6mE,mBAAqB,WAAM,GACjB19E,GAAS6W,EAAK9e,MAAdiI,KACAiD,EAAYjD,EAAZiD,OA+BR,SA5BEod,MAAO,oBACP5sB,IAAK,iBAEL4sB,MAAO,sBACP5sB,IAAK,WACL6tB,OAHC,SAGMf,EAAMo9D,GACX,MAAO16E,GAAQ26E,OAAOx7E,KAAK,SAAAy7E,GAAA,MAAUA,GAAOzgF,KAAOugF,EAAOG,WAAUt6E,QAGtE6c,MAAO,yBACP5sB,IAAK,gBACL6tB,OAHC,SAGMf,EAAMo9D,GACX,GAAMI,GAAc96E,EAAQ+6E,YAAY57E,KACtC,SAAAC,GAAA,MAAWA,GAAQjF,KAAOugF,EAAOM,eACnC,OAAOF,GAAcA,EAAYv6E,KAAO,MAG1C6c,MAAO,kBACP5sB,IAAK,gBACL6tB,OAHC,SAGMf,EAAMo9D,GACX,MACE/rF,GAAAC,EAAAC,cAACurF,EAAA,GAAK/zC,GAAA,wBAA4Bq0C,EAAOvgF,IAAzC,UAOSmB,IAAI,SAAA2/E,GAAA,MACjBtsF,GAAAC,EAAAC,cAAC0rF,GACCn9D,MAAOzuB,EAAAC,EAAAC,cAACyrF,EAAA,GAAiBngF,GAAI8gF,EAAO79D,QACpC5sB,IAAKyqF,EAAOzqF,IACZ23E,UAAW8S,EAAOzqF,IAClB6tB,OAAQ48D,EAAO58D,Y/E21kB4nD7D,EAAsyCD,EAAOzI,EAA2B8B,EAAM4G,GAAurB,MAA3vEvI,GAAUspE,EAAkB5nE,GAA+iDjB,EAAa6oE,IAAoB/qF,IAAI,oBAAoBvB,MAAM,W+En4kBniGc,KAAK+E,MAAMqI,4B/Em4kB6lG3M,IAAI,SAASvB,MAAM,W+Ev1kBpnG,GAAA0rB,GACmB5qB,KAAK+E,MAAvBiI,EADD4d,EACC5d,KAAM6d,EADPD,EACOC,QACN1b,EAAcnC,EAAdmC,SACR,OACEvQ,GAAAC,EAAAC,cAAC2qB,EAAA,GAAKwB,SAAUJ,GACdjsB,EAAAC,EAAAC,cAAC2qB,EAAA,GACC2hE,OAAQ,SAAAT,GAAA,MAAUA,GAAOvgF,IACzBmsB,WAAYpnB,GAAaA,EAAU0C,OAAO,SAAArP,GAAA,MAAiB,yBAAZA,EAAEuO,SAG/C/Q,KAAK0qF,2B/E60kB8oHc,G+Er4kB/nHrsF,EAAA,WAgE1BksB,EAAkB,SAAAta,GAAA,OACtB/D,KAAM+D,EAAM7B,oBAAoBlC,KAChC6d,QAAS9Z,EAAM7B,oBAAoB2b,SAGrCpsB,GAAA,EAAeO,OAAAuqB,EAAA,GACb8B,EACAkgE,GACAC,I/Ei0kBIC,KACA,SAAUjtF,EAAQC,EAAqBC,GAE7C,YAQ8f,SAASijB,GAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAuC,QAASC,GAA2BC,EAAKxX,GAAM,IAAIwX,EAAM,KAAM,IAAIC,gBAAe,4DAA8D,QAAOzX,GAAqB,iBAAPA,IAA+B,mBAAPA,GAAwBwX,EAALxX,EAAW,QAAS0X,GAAUC,EAASC,GAAY,GAAuB,mBAAbA,IAAsC,OAAbA,EAAmB,KAAM,IAAIN,WAAU,iEAAkEM,GAAaD,GAASrgB,UAAU9C,OAAOqjB,OAAOD,GAAYA,EAAWtgB,WAAWsK,aAAalN,MAAMijB,EAASG,YAAW,EAAMC,UAAS,EAAKC,cAAa,KAAWJ,IAAWpjB,OAAOyjB,eAAezjB,OAAOyjB,eAAeN,EAASC,GAAYD,EAASO,UAAUN,GAP3wC,GAAIjjB,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GACpEoqB,EAA4C7qB,EAAoB,KAChE2rF,EAAiD3rF,EAAoB,KACrE+qB,EAAqC/qB,EAAoB,IACzDgtF,EAAuDhtF,EAAoB,MAC3E6rF,EAAyD7rF,EAAoB,IAClGikB,EAAa,WAAW,QAASC,GAAiBhiB,EAAOmE,GAAO,IAAI,GAAIxE,GAAE,EAAEA,EAAEwE,EAAM9D,OAAOV,IAAI,CAAC,GAAIge,GAAWxZ,EAAMxE,EAAGge,GAAW+D,WAAW/D,EAAW+D,aAAY,EAAM/D,EAAWiE,cAAa,EAAQ,SAAUjE,KAAWA,EAAWgE,UAAS,GAAKvjB,OAAOC,eAAe2B,EAAO2d,EAAW9d,IAAI8d,IAAc,MAAO,UAASsD,EAAYgB,EAAWC,GAAuI,MAAvHD,IAAWD,EAAiBf,EAAY/f,UAAU+gB,GAAeC,GAAYF,EAAiBf,EAAYiB,GAAoBjB,MgFt5kBpe2oE,EAAW/gE,EAAA,EAAX+gE,OAEFmB,EhFo5kBk4C,SAAS/nE,GAAoD,QAAS+nE,KAAoB,GAAIphE,GAASC,EAAM3G,EAAM4G,CAAK9I,GAAgB3hB,KAAK2rF,EAAmB,KAAI,GAAIjhE,GAAK7oB,UAAUZ,OAAO8J,EAAKT,MAAMogB,GAAMC,EAAK,EAAEA,EAAKD,EAAKC,IAAQ5f,EAAK4f,GAAM9oB,UAAU8oB,EAAO,OAAaH,GAAO3G,EAAM9B,EAA2B/hB,MAAMuqB,EAAKohE,EAAkBjpE,WAAW1jB,OAAO8kB,eAAe6nE,IAAoBnhF,KAAK5I,MAAM2oB,GAAMvqB,MAAMkI,OAAO6C,KAAe8Y,EgFh5kB9zD6mE,mBAAqB,WAAM,GACjB19E,GAAS6W,EAAK9e,MAAdiI,KACA6C,EAA6B7C,EAA7B6C,gBAAiBI,EAAYjD,EAAZiD,OAkCzB,SA/BEod,MAAO,oBACP5sB,IAAK,iBAEL4sB,MAAO,sBACP5sB,IAAK,WACL6tB,OAHC,SAGMf,EAAMo9D,GACX,MAAO16E,GAAQ26E,OAAOx7E,KAAK,SAAAy7E,GAAA,MAAUA,GAAOzgF,KAAOugF,EAAOG,WAAUt6E,QAGtE6c,MAAO,yBACP5sB,IAAK,gBACL6tB,OAHC,SAGMf,EAAMo9D,GACX,GAAMI,GAAc96E,EAAQ+6E,YAAY57E,KACtC,SAAAC,GAAA,MAAWA,GAAQjF,KAAOugF,EAAOM,eACnC,OAAOF,GAAcA,EAAYv6E,KAAO,MAG1C6c,MAAO,kBACP5sB,IAAK,cACL6tB,OAHC,SAGMf,EAAMo9D,GACX,GAAM76E,GAAmBD,EACtBT,KAAK,SAAAhL,GAAA,MAAQA,GAAKgK,aAAeu8E,EAAOvgF,KACxCA,EACH,OACExL,GAAAC,EAAAC,cAACurF,EAAA,GAAK/zC,GAAA,aAAiBq0C,EAAOvgF,GAAxB,IAA8B0F,GAApC,UAOSvE,IAAI,SAAA2/E,GAAA,MACjBtsF,GAAAC,EAAAC,cAAC0rF,GACCn9D,MAAOzuB,EAAAC,EAAAC,cAACyrF,EAAA,GAAiBngF,GAAI8gF,EAAO79D,QACpC5sB,IAAKyqF,EAAOzqF,IACZ23E,UAAW8S,EAAOzqF,IAClB6tB,OAAQ48D,EAAO58D,YhFu2kB4nD7D,EAAq7CD,EAAOzI,EAA2B8B,EAAM4G,GAAi6B,MAApnFvI,GAAUypE,EAAkB/nE,GAA8rDjB,EAAagpE,IAAoBlrF,IAAI,oBAAoBvB,MAAM,WgFl5kBlrGc,KAAK+E,MAAMmN,iBhFk5kBiuGzR,IAAI,SAASvB,MAAM,WgFn2kBxvG,GAAA0rB,GACmB5qB,KAAK+E,MAAvBiI,EADD4d,EACC5d,KAAM6d,EADPD,EACOC,QACN1b,EAAuCnC,EAAvCmC,UAAWU,EAA4B7C,EAA5B6C,gBAAiB+7E,EAAW5+E,EAAX4+E,MACpC,OACEhtF,GAAAC,EAAAC,cAAC2qB,EAAA,GAAKwB,SAAUJ,GACdjsB,EAAAC,EAAAC,cAAC2qB,EAAA,GACC2hE,OAAQ,SAAAT,GAAA,MAAUA,GAAOvgF,IACzBmsB,WAAYpnB,GAAaA,EAAU0C,OAAO,SAACrP,GACzC,GAAMqpF,GAAkBh8E,EACrBT,KAAK,SAAAC,GAAA,MAAWA,GAAQjB,aAAe5L,EAAE4H,KAAI2F,OAEhD,OAAqB,oBADH67E,EAAOx8E,KAAK,SAAA2B,GAAA,MAASA,GAAM3G,KAAOyhF,IAAiB56E,aAKrEjR,KAAK0qF,2BhFo1kBugIiB,GgFp5kBx/HxsF,EAAA,WAwE1BksB,EAAkB,SAAAta,GAAA,OACtB/D,KAAM+D,EAAM+6E,SAAS9+E,KACrB6d,QAAS9Z,EAAM+6E,SAASjhE,SAG1BpsB,GAAA,EAAeO,OAAAuqB,EAAA,GACb8B,EACAqgE,GACAC,IhFw0kBII,KACA,SAAUvtF,EAAQC,EAAqBC,GAE7C,YAO8f,SAASijB,GAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAuC,QAASC,GAA2BC,EAAKxX,GAAM,IAAIwX,EAAM,KAAM,IAAIC,gBAAe,4DAA8D,QAAOzX,GAAqB,iBAAPA,IAA+B,mBAAPA,GAAwBwX,EAALxX,EAAW,QAAS0X,GAAUC,EAASC,GAAY,GAAuB,mBAAbA,IAAsC,OAAbA,EAAmB,KAAM,IAAIN,WAAU,iEAAkEM,GAAaD,GAASrgB,UAAU9C,OAAOqjB,OAAOD,GAAYA,EAAWtgB,WAAWsK,aAAalN,MAAMijB,EAASG,YAAW,EAAMC,UAAS,EAAKC,cAAa,KAAWJ,IAAWpjB,OAAOyjB,eAAezjB,OAAOyjB,eAAeN,EAASC,GAAYD,EAASO,UAAUN,GAN3wC,GAAIjjB,GAAsCT,EAAoB,GAC1DE,EAA8CF,EAAoBU,EAAED,GACpEoqB,EAA4C7qB,EAAoB,KAChE2rF,EAAiD3rF,EAAoB,KACrE+qB,EAAqC/qB,EAAoB,IACzDstF,EAAyDttF,EAAoB,IAClGikB,EAAa,WAAW,QAASC,GAAiBhiB,EAAOmE,GAAO,IAAI,GAAIxE,GAAE,EAAEA,EAAEwE,EAAM9D,OAAOV,IAAI,CAAC,GAAIge,GAAWxZ,EAAMxE,EAAGge,GAAW+D,WAAW/D,EAAW+D,aAAY,EAAM/D,EAAWiE,cAAa,EAAQ,SAAUjE,KAAWA,EAAWgE,UAAS,GAAKvjB,OAAOC,eAAe2B,EAAO2d,EAAW9d,IAAI8d,IAAc,MAAO,UAASsD,EAAYgB,EAAWC,GAAuI,MAAvHD,IAAWD,EAAiBf,EAAY/f,UAAU+gB,GAAeC,GAAYF,EAAiBf,EAAYiB,GAAoBjB,MiFr6kBpe2oE,EAAW/gE,EAAA,EAAX+gE,OAEFyB,EjFm6kBi4C,SAASroE,GAAmD,QAASqoE,KAAmB,GAAI1hE,GAASC,EAAM3G,EAAM4G,CAAK9I,GAAgB3hB,KAAKisF,EAAkB,KAAI,GAAIvhE,GAAK7oB,UAAUZ,OAAO8J,EAAKT,MAAMogB,GAAMC,EAAK,EAAEA,EAAKD,EAAKC,IAAQ5f,EAAK4f,GAAM9oB,UAAU8oB,EAAO,OAAaH,GAAO3G,EAAM9B,EAA2B/hB,MAAMuqB,EAAK0hE,EAAiBvpE,WAAW1jB,OAAO8kB,eAAemoE,IAAmBzhF,KAAK5I,MAAM2oB,GAAMvqB,MAAMkI,OAAO6C,KAAe8Y,EiFl6kBxzD6mE,mBAAqB,WAsBnB,QApBEr9D,MAAO,oBACP5sB,IAAK,SAEL4sB,MAAO,sBACP5sB,IAAK,WAEL4sB,MAAO,yBACP5sB,IAAK,iBAEL4sB,MAAO,kBACP5sB,IAAK,cACL6tB,OAHC,WAIC,MACE1vB,GAAAC,EAAAC,cAACurF,EAAA,GAAK/zC,GAAI,aAAV,UAOS/qC,IAAI,SAAA2/E,GAAA,MACjBtsF,GAAAC,EAAAC,cAAC0rF,GACCn9D,MAAOzuB,EAAAC,EAAAC,cAACktF,EAAA,GAAiB5hF,GAAI8gF,EAAO79D,QACpC5sB,IAAKyqF,EAAOzqF,IACZ23E,UAAW8S,EAAOzqF,IAClB6tB,OAAQ48D,EAAO58D,YjFu4kBwnD7D,EAAk5BD,EAAOzI,EAA2B8B,EAAM4G,GAAygB,MAAtrDvI,GAAU+pE,EAAiBroE,GAAypCjB,EAAaspE,IAAmBxrF,IAAI,SAASvB,MAAM,WiFn4kBxnF,GAAA0rB,GACmB5qB,KAAK+E,MAAvBiI,EADD4d,EACC5d,KAAM6d,EADPD,EACOC,QACNqhE,EAAal/E,EAAbk/E,QACR,OACEttF,GAAAC,EAAAC,cAAC2qB,EAAA,GAAKwB,SAAUJ,GACdjsB,EAAAC,EAAAC,cAAC2qB,EAAA,GACC2hE,OAAQ,SAAAT,GAAA,MAAUA,GAAOvgF,IACzBmsB,YAAa21D,IAGXlsF,KAAK0qF,2BjFy3kBwkGuB,GiFn6kB1jG9sF,EAAA,WAkDzBksB,EAAkB,SAAAta,GAAA,OACtB/D,KAAM+D,EAAMoZ,KAAKnd,KACjB6d,QAAS9Z,EAAMoZ,KAAKU,SAGtBpsB,GAAA,EAAeO,OAAAuqB,EAAA,GACb8B,GACA4gE","file":"static/js/6.6a376720.chunk.js","sourcesContent":["webpackJsonp([6],{\n\n/***/ 1180:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Home_HomeContainer__ = __webpack_require__(1278);\nfunction Home(){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_Home_HomeContainer__[\"a\" /* default */],null);}/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\n\n/***/ }),\n\n/***/ 1213:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(1251);\nmodule.exports.easing = __webpack_require__(1285);\nmodule.exports.canvas = __webpack_require__(1286);\nmodule.exports.options = __webpack_require__(1287);\n\n\n/***/ }),\n\n/***/ 1217:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1213);\n\nmodule.exports = {\n\t/**\n\t * @private\n\t */\n\t_set: function(scope, values) {\n\t\treturn helpers.merge(this[scope] || (this[scope] = {}), values);\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1224:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar color = __webpack_require__(1266);\nvar helpers = __webpack_require__(1213);\n\nfunction interpolate(start, view, model, ease) {\n\tvar keys = Object.keys(model);\n\tvar i, ilen, key, actual, origin, target, type, c0, c1;\n\n\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\tkey = keys[i];\n\n\t\ttarget = model[key];\n\n\t\t// if a value is added to the model after pivot() has been called, the view\n\t\t// doesn't contain it, so let's initialize the view to the target value.\n\t\tif (!view.hasOwnProperty(key)) {\n\t\t\tview[key] = target;\n\t\t}\n\n\t\tactual = view[key];\n\n\t\tif (actual === target || key[0] === '_') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!start.hasOwnProperty(key)) {\n\t\t\tstart[key] = actual;\n\t\t}\n\n\t\torigin = start[key];\n\n\t\ttype = typeof target;\n\n\t\tif (type === typeof origin) {\n\t\t\tif (type === 'string') {\n\t\t\t\tc0 = color(origin);\n\t\t\t\tif (c0.valid) {\n\t\t\t\t\tc1 = color(target);\n\t\t\t\t\tif (c1.valid) {\n\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'number' && isFinite(origin) && isFinite(target)) {\n\t\t\t\tview[key] = origin + (target - origin) * ease;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tview[key] = target;\n\t}\n}\n\nvar Element = function(configuration) {\n\thelpers.extend(this, configuration);\n\tthis.initialize.apply(this, arguments);\n};\n\nhelpers.extend(Element.prototype, {\n\n\tinitialize: function() {\n\t\tthis.hidden = false;\n\t},\n\n\tpivot: function() {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\tme._view = helpers.clone(me._model);\n\t\t}\n\t\tme._start = {};\n\t\treturn me;\n\t},\n\n\ttransition: function(ease) {\n\t\tvar me = this;\n\t\tvar model = me._model;\n\t\tvar start = me._start;\n\t\tvar view = me._view;\n\n\t\t// No animation -> No Transition\n\t\tif (!model || ease === 1) {\n\t\t\tme._view = model;\n\t\t\tme._start = null;\n\t\t\treturn me;\n\t\t}\n\n\t\tif (!view) {\n\t\t\tview = me._view = {};\n\t\t}\n\n\t\tif (!start) {\n\t\t\tstart = me._start = {};\n\t\t}\n\n\t\tinterpolate(start, view, model, ease);\n\n\t\treturn me;\n\t},\n\n\ttooltipPosition: function() {\n\t\treturn {\n\t\t\tx: this._model.x,\n\t\t\ty: this._model.y\n\t\t};\n\t},\n\n\thasValue: function() {\n\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t}\n});\n\nElement.extend = helpers.inherits;\n\nmodule.exports = Element;\n\n\n/***/ }),\n\n/***/ 1225:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {};\nmodule.exports.Arc = __webpack_require__(1293);\nmodule.exports.Line = __webpack_require__(1294);\nmodule.exports.Point = __webpack_require__(1295);\nmodule.exports.Rectangle = __webpack_require__(1296);\n\n\n/***/ }),\n\n/***/ 1233:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1213);\n\nfunction filterByPosition(array, position) {\n\treturn helpers.where(array, function(v) {\n\t\treturn v.position === position;\n\t});\n}\n\nfunction sortByWeight(array, reverse) {\n\tarray.forEach(function(v, i) {\n\t\tv._tmpIndex_ = i;\n\t\treturn v;\n\t});\n\tarray.sort(function(a, b) {\n\t\tvar v0 = reverse ? b : a;\n\t\tvar v1 = reverse ? a : b;\n\t\treturn v0.weight === v1.weight ?\n\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\tv0.weight - v1.weight;\n\t});\n\tarray.forEach(function(v) {\n\t\tdelete v._tmpIndex_;\n\t});\n}\n\n/**\n * @interface ILayoutItem\n * @prop {String} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n * @prop {Function} getPadding -  Returns an object with padding on the edges\n * @prop {Number} width - Width of item. Must be valid after update()\n * @prop {Number} height - Height of item. Must be valid after update()\n * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nmodule.exports = {\n\tdefaults: {},\n\n\t/**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {ILayoutItem} item - the item to add to be layed out\n\t */\n\taddBox: function(chart, item) {\n\t\tif (!chart.boxes) {\n\t\t\tchart.boxes = [];\n\t\t}\n\n\t\t// initialize item with default values\n\t\titem.fullWidth = item.fullWidth || false;\n\t\titem.position = item.position || 'top';\n\t\titem.weight = item.weight || 0;\n\n\t\tchart.boxes.push(item);\n\t},\n\n\t/**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {Object} layoutItem - the item to remove from the layout\n\t */\n\tremoveBox: function(chart, layoutItem) {\n\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\tif (index !== -1) {\n\t\t\tchart.boxes.splice(index, 1);\n\t\t}\n\t},\n\n\t/**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {Object} item - the item to configure with the given options\n\t * @param {Object} options - the new item options.\n\t */\n\tconfigure: function(chart, item, options) {\n\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\tvar ilen = props.length;\n\t\tvar i = 0;\n\t\tvar prop;\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\tprop = props[i];\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\titem[prop] = options[prop];\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {Number} width - the width to fit into\n\t * @param {Number} height - the height to fit into\n\t */\n\tupdate: function(chart, width, height) {\n\t\tif (!chart) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar layoutOptions = chart.options.layout || {};\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\n\t\tvar leftPadding = padding.left;\n\t\tvar rightPadding = padding.right;\n\t\tvar topPadding = padding.top;\n\t\tvar bottomPadding = padding.bottom;\n\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\tsortByWeight(leftBoxes, true);\n\t\tsortByWeight(rightBoxes, false);\n\t\tsortByWeight(topBoxes, true);\n\t\tsortByWeight(bottomBoxes, false);\n\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t// Our canvas looks like the following.\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t// B1 is the bottom axis\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t// an error will be thrown.\n\t\t//\n\t\t// |----------------------------------------------------|\n\t\t// |                  T1 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t// |    |    |                 T2                  |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    | C1 |                           | C2 |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    |                                     |    |\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t// |    |    |                                     |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    | C3 |                           | C4 |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    |                 B1                  |    |\n\t\t// |----------------------------------------------------|\n\t\t// |                  B2 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t//\n\t\t// What we do to find the best sizing, we do the following\n\t\t// 1. Determine the minimum size of the chart area.\n\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t// 6. Refit each axis\n\t\t// 7. Position each axis in the final location\n\t\t// 8. Tell the chart the final location of the chart area\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t// Step 1\n\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t// Step 2\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t// Step 3\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t// Step 4\n\t\tvar maxChartAreaWidth = chartWidth;\n\t\tvar maxChartAreaHeight = chartHeight;\n\t\tvar minBoxSizes = [];\n\n\t\tfunction getMinimumBoxSize(box) {\n\t\t\tvar minSize;\n\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t} else {\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t}\n\n\t\t\tminBoxSizes.push({\n\t\t\t\thorizontal: isHorizontal,\n\t\t\t\tminSize: minSize,\n\t\t\t\tbox: box,\n\t\t\t});\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\tvar maxHorizontalLeftPadding = 0;\n\t\tvar maxHorizontalRightPadding = 0;\n\t\tvar maxVerticalTopPadding = 0;\n\t\tvar maxVerticalBottomPadding = 0;\n\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\tif (verticalBox.getPadding) {\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t}\n\t\t});\n\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t// be if the axes are drawn at their minimum sizes.\n\t\t// Steps 5 & 6\n\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\tvar totalRightBoxesWidth = rightPadding;\n\t\tvar totalTopBoxesHeight = topPadding;\n\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t// Function to fit a box\n\t\tfunction fitBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\treturn minBox.box === box;\n\t\t\t});\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t} else {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\t// Set the Left and Right margins for the horizontal boxes\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\tfunction finalFitVerticalBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\treturn minSize.box === box;\n\t\t\t});\n\n\t\t\tvar scaleMargin = {\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t};\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t}\n\t\t}\n\n\t\t// Let the left layout know the final margin\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\ttotalLeftBoxesWidth = leftPadding;\n\t\ttotalRightBoxesWidth = rightPadding;\n\t\ttotalTopBoxesHeight = topPadding;\n\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\t// We may be adding some padding to account for rotated x axis labels\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t// without calling `fit` again\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t}\n\n\t\t// Step 7 - Position the boxes\n\t\tvar left = leftPadding + leftPaddingAddition;\n\t\tvar top = topPadding + topPaddingAddition;\n\n\t\tfunction placeBox(box) {\n\t\t\tif (box.isHorizontal()) {\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\tbox.top = top;\n\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t// Move to next point\n\t\t\t\ttop = box.bottom;\n\n\t\t\t} else {\n\n\t\t\t\tbox.left = left;\n\t\t\t\tbox.right = left + box.width;\n\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t// Move to next point\n\t\t\t\tleft = box.right;\n\t\t\t}\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t// Account for chart width and height\n\t\tleft += maxChartAreaWidth;\n\t\ttop += maxChartAreaHeight;\n\n\t\thelpers.each(rightBoxes, placeBox);\n\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t// Step 8\n\t\tchart.chartArea = {\n\t\t\tleft: totalLeftBoxesWidth,\n\t\t\ttop: totalTopBoxesHeight,\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t};\n\n\t\t// Step 9\n\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\tbox.left = chart.chartArea.left;\n\t\t\tbox.top = chart.chartArea.top;\n\t\t\tbox.right = chart.chartArea.right;\n\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t});\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1234:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1213);\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nmodule.exports = {\n\t/**\n\t * Namespace to hold formatters for different types of ticks\n\t * @namespace Chart.Ticks.formatters\n\t */\n\tformatters: {\n\t\t/**\n\t\t * Formatter for value labels\n\t\t * @method Chart.Ticks.formatters.values\n\t\t * @param value the value to display\n\t\t * @return {String|Array} the label to display\n\t\t */\n\t\tvalues: function(value) {\n\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t},\n\n\t\t/**\n\t\t * Formatter for linear numeric ticks\n\t\t * @method Chart.Ticks.formatters.linear\n\t\t * @param tickValue {Number} the value to be formatted\n\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t * @return {String} string representation of the tickValue parameter\n\t\t */\n\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t// not an integer\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\tvar tickString = '';\n\n\t\t\tif (tickValue !== 0) {\n\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t} else {\n\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t}\n\n\t\t\treturn tickString;\n\t\t},\n\n\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\tif (tickValue === 0) {\n\t\t\t\treturn '0';\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\treturn tickValue.toExponential();\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1251:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * @namespace Chart.helpers\n */\nvar helpers = {\n\t/**\n\t * An empty function that can be used, for example, for optional callback.\n\t */\n\tnoop: function() {},\n\n\t/**\n\t * Returns a unique id, sequentially generated from a global variable.\n\t * @returns {Number}\n\t * @function\n\t */\n\tuid: (function() {\n\t\tvar id = 0;\n\t\treturn function() {\n\t\t\treturn id++;\n\t\t};\n\t}()),\n\n\t/**\n\t * Returns true if `value` is neither null nor undefined, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @since 2.7.0\n\t */\n\tisNullOrUndef: function(value) {\n\t\treturn value === null || typeof value === 'undefined';\n\t},\n\n\t/**\n\t * Returns true if `value` is an array, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @function\n\t */\n\tisArray: Array.isArray ? Array.isArray : function(value) {\n\t\treturn Object.prototype.toString.call(value) === '[object Array]';\n\t},\n\n\t/**\n\t * Returns true if `value` is an object (excluding null), else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @since 2.7.0\n\t */\n\tisObject: function(value) {\n\t\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\n\t},\n\n\t/**\n\t * Returns `value` if defined, else returns `defaultValue`.\n\t * @param {*} value - The value to return if defined.\n\t * @param {*} defaultValue - The value to return if `value` is undefined.\n\t * @returns {*}\n\t */\n\tvalueOrDefault: function(value, defaultValue) {\n\t\treturn typeof value === 'undefined' ? defaultValue : value;\n\t},\n\n\t/**\n\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\n\t * @param {Array} value - The array to lookup for value at `index`.\n\t * @param {Number} index - The index in `value` to lookup for value.\n\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\n\t * @returns {*}\n\t */\n\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\n\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n\t},\n\n\t/**\n\t * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n\t * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n\t * @param {Function} fn - The function to call.\n\t * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @returns {*}\n\t */\n\tcallback: function(fn, args, thisArg) {\n\t\tif (fn && typeof fn.call === 'function') {\n\t\t\treturn fn.apply(thisArg, args);\n\t\t}\n\t},\n\n\t/**\n\t * Note(SB) for performance sake, this method should only be used when loopable type\n\t * is unknown or in none intensive code (not called often and small loopable). Else\n\t * it's preferable to use a regular for() loop and save extra function calls.\n\t * @param {Object|Array} loopable - The object or array to be iterated.\n\t * @param {Function} fn - The function to call for each item.\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @param {Boolean} [reverse] - If true, iterates backward on the loopable.\n\t */\n\teach: function(loopable, fn, thisArg, reverse) {\n\t\tvar i, len, keys;\n\t\tif (helpers.isArray(loopable)) {\n\t\t\tlen = loopable.length;\n\t\t\tif (reverse) {\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (helpers.isObject(loopable)) {\n\t\t\tkeys = Object.keys(loopable);\n\t\t\tlen = keys.length;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n\t * @see http://stackoverflow.com/a/14853974\n\t * @param {Array} a0 - The array to compare\n\t * @param {Array} a1 - The array to compare\n\t * @returns {Boolean}\n\t */\n\tarrayEquals: function(a0, a1) {\n\t\tvar i, ilen, v0, v1;\n\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\t\tv0 = a0[i];\n\t\t\tv1 = a1[i];\n\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (v0 !== v1) {\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\n\t * @param {*} source - The value to clone.\n\t * @returns {*}\n\t */\n\tclone: function(source) {\n\t\tif (helpers.isArray(source)) {\n\t\t\treturn source.map(helpers.clone);\n\t\t}\n\n\t\tif (helpers.isObject(source)) {\n\t\t\tvar target = {};\n\t\t\tvar keys = Object.keys(source);\n\t\t\tvar klen = keys.length;\n\t\t\tvar k = 0;\n\n\t\t\tfor (; k < klen; ++k) {\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\treturn source;\n\t},\n\n\t/**\n\t * The default merger when Chart.helpers.merge is called without merger option.\n\t * Note(SB): this method is also used by configMerge and scaleMerge as fallback.\n\t * @private\n\t */\n\t_merger: function(key, target, source, options) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.merge(tval, sval, options);\n\t\t} else {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Merges source[key] in target[key] only if target[key] is undefined.\n\t * @private\n\t */\n\t_mergerIf: function(key, target, source) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.mergeIf(tval, sval);\n\t\t} else if (!target.hasOwnProperty(key)) {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {Object} target - The target object in which all sources are merged into.\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\n\t * @param {Object} [options] - Merging options:\n\t * @param {Function} [options.merger] - The merge method (key, target, source, options)\n\t * @returns {Object} The `target` object.\n\t */\n\tmerge: function(target, source, options) {\n\t\tvar sources = helpers.isArray(source) ? source : [source];\n\t\tvar ilen = sources.length;\n\t\tvar merge, i, keys, klen, k;\n\n\t\tif (!helpers.isObject(target)) {\n\t\t\treturn target;\n\t\t}\n\n\t\toptions = options || {};\n\t\tmerge = options.merger || helpers._merger;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!helpers.isObject(source)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkeys = Object.keys(source);\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\t\tmerge(keys[k], target, source, options);\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {Object} target - The target object in which all sources are merged into.\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\n\t * @returns {Object} The `target` object.\n\t */\n\tmergeIf: function(target, source) {\n\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\n\t},\n\n\t/**\n\t * Applies the contents of two or more objects together into the first object.\n\t * @param {Object} target - The target object in which all objects are merged into.\n\t * @param {Object} arg1 - Object containing additional properties to merge in target.\n\t * @param {Object} argN - Additional objects containing properties to merge in target.\n\t * @returns {Object} The `target` object.\n\t */\n\textend: function(target) {\n\t\tvar setFn = function(value, key) {\n\t\t\ttarget[key] = value;\n\t\t};\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; ++i) {\n\t\t\thelpers.each(arguments[i], setFn);\n\t\t}\n\t\treturn target;\n\t},\n\n\t/**\n\t * Basic javascript inheritance based on the model created in Backbone.js\n\t */\n\tinherits: function(extensions) {\n\t\tvar me = this;\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\treturn me.apply(this, arguments);\n\t\t};\n\n\t\tvar Surrogate = function() {\n\t\t\tthis.constructor = ChartElement;\n\t\t};\n\n\t\tSurrogate.prototype = me.prototype;\n\t\tChartElement.prototype = new Surrogate();\n\t\tChartElement.extend = helpers.inherits;\n\n\t\tif (extensions) {\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t}\n\n\t\tChartElement.__super__ = me.prototype;\n\t\treturn ChartElement;\n\t}\n};\n\nmodule.exports = helpers;\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.callback instead.\n * @function Chart.helpers.callCallback\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nhelpers.callCallback = helpers.callback;\n\n/**\n * Provided for backward compatibility, use Array.prototype.indexOf instead.\n * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\n * @function Chart.helpers.indexOf\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.indexOf = function(array, item, fromIndex) {\n\treturn Array.prototype.indexOf.call(array, item, fromIndex);\n};\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\n * @function Chart.helpers.getValueOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueOrDefault = helpers.valueOrDefault;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\n * @function Chart.helpers.getValueAtIndexOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n\n/***/ }),\n\n/***/ 1252:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getGeneralAdministratorApi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return saveGeneralAdministratorApi; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__instance__ = __webpack_require__(82);\nfunction getGeneralAdministratorApi(){return __WEBPACK_IMPORTED_MODULE_0__instance__[\"a\" /* default */].get('System?action=getConfiguration');}function saveGeneralAdministratorApi(data){return __WEBPACK_IMPORTED_MODULE_0__instance__[\"a\" /* default */].post('System?action=save',data);}\n\n/***/ }),\n\n/***/ 1253:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTechnicalTeamSurvey\", function() { return getTechnicalTeamSurvey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFailedRequest\", function() { return getFailedRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterTechnicalTeamSurvey\", function() { return filterTechnicalTeamSurvey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setScore\", function() { return setScore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setComment\", function() { return setComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"finishTechnicalTeamSurvey\", function() { return finishTechnicalTeamSurvey; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__const__ = __webpack_require__(404);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__api_call__ = __webpack_require__(394);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__api_technicalTeamAnswer__ = __webpack_require__(1254);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__api_supplier__ = __webpack_require__(395);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_action__ = __webpack_require__(208);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Generic_action__ = __webpack_require__(211);\nvar getDataTechnicalTeamSurveyProgress=function getDataTechnicalTeamSurveyProgress(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"e\" /* GET_TECHNICAL_TEAM_SURVEY_PROGRESS */]};};var getDataTechnicalTeamSurveySuccess=function getDataTechnicalTeamSurveySuccess(data){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"f\" /* GET_TECHNICAL_TEAM_SURVEY_SUCCESS */],data:data};};var getFailedRequest=function getFailedRequest(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"g\" /* REQUEST_FAILED */]};};var filterTechnicalTeamSurvey=function filterTechnicalTeamSurvey(data){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"d\" /* FILTER_TECHNICAL_TEAM_SURVEY */],data:data};};var calculateTotal=function calculateTotal(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"a\" /* CALCULATE_TOTAL */]};};var changeScore=function changeScore(idSupplier,id,answer,value){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"c\" /* CHANGE_SCORE_TECHNICAL */],idSupplier:idSupplier,answer:answer,value:value,new:!id};};var changeComment=function changeComment(idSupplier,id,comment,value){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"b\" /* CHANGE_COMMENT_TECHNICAL */],idSupplier:idSupplier,comment:comment,value:value,new:!id};};var updateErrors=function updateErrors(data){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"h\" /* UPDATE_ERRORS_TECHNICAL */],data:data};};var updateSuppliers=function updateSuppliers(idSuppliers,idSuppliersByCall){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"i\" /* UPDATE_SUPPLIERS_TECHNICAL */],idSuppliers:idSuppliers,idSuppliersByCall:idSuppliersByCall};};var setScore=function setScore(idSupplier,value,answer){return function(dispatch){Object(__WEBPACK_IMPORTED_MODULE_4__utils_action__[\"a\" /* requestApi */])(dispatch,getDataTechnicalTeamSurveyProgress,__WEBPACK_IMPORTED_MODULE_2__api_technicalTeamAnswer__[\"a\" /* saveTechnicalTeamAnswerApi */],answer).then(function(response){dispatch(changeScore(idSupplier,answer.id,response.data.data,value));dispatch(calculateTotal());}).catch(function(){dispatch(changeScore(idSupplier,answer.id,answer,null));dispatch(getFailedRequest());});};};var setComment=function setComment(idSupplier,value,comment){return function(dispatch,getState){var storedValue=getState().technicalTeamSurvey.data.suppliers.find(function(element){return element.id===idSupplier;}).comments.find(function(element){return element.idService===comment.idService;}).value;if(storedValue!==value){Object(__WEBPACK_IMPORTED_MODULE_4__utils_action__[\"a\" /* requestApi */])(dispatch,getDataTechnicalTeamSurveyProgress,__WEBPACK_IMPORTED_MODULE_2__api_technicalTeamAnswer__[\"b\" /* saveTechnicalTeamCommentApi */],comment).then(function(response){dispatch(changeComment(idSupplier,comment.id,response.data.data,value));}).catch(function(){dispatch(changeComment(idSupplier,comment.id,comment,null));dispatch(getFailedRequest());});}};};var getTechnicalTeamSurvey=function getTechnicalTeamSurvey(){var year=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';var supplierId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';return function(dispatch){Object(__WEBPACK_IMPORTED_MODULE_4__utils_action__[\"a\" /* requestApi */])(dispatch,getDataTechnicalTeamSurveyProgress,__WEBPACK_IMPORTED_MODULE_1__api_call__[\"k\" /* getTechnicalTeamSurveyApi */],year).then(function(response){var data=response.data.data;data.suppliers=data.suppliers.map(function(supplier){var supplierByCall=data.suppliersByCall.find(function(element){return element.idSupplier===supplier.id;});var idSupplierByCall=supplierByCall.id;var idState=supplierByCall.idState;var items=data.masters.Item.map(function(item){var answer=data.masters.TechnicalTeamAnswer.find(function(element){return element.idItem===item.id&&element.idSupplierByCall===idSupplierByCall;});var option=answer?data.masters.EvaluationScale.find(function(element){return element.id===answer.idEvaluationScale;}):null;return{id:item.id,idService:item.idService,defaultValue:{key:option?option.id:null,name:option?option.name:null},value:option?option.score:null,error:false};});var comments=[];var totals=[];data.masters.Service.forEach(function(service){var comment=data.masters.TechnicalTeamComment.find(function(element){return element.idSupplierByCall===idSupplierByCall&&element.idService===service.id;});comments.push({idService:service.id,value:comment?comment.comment:''});totals.push({idService:service.id,value:null});});var state=data.masters.State.find(function(element){return element.id===idState;}).shortName;var readOnly=state!=='NOT_STARTED_TECHNICAL_TEAM'&&state!=='TECHNICAL_TEAM'||supplierByCall.whoEvaluateOfTechnicalTeam!==''&&supplierByCall.whoEvaluateOfTechnicalTeam!==data.masters.User[0].name;var required=!readOnly&&supplierByCall.whoEvaluateOfTechnicalTeam===data.masters.User[0].name;supplier.visible=true;supplier.readOnly=readOnly;supplier.required=required;supplier.items=items;supplier.comments=comments;supplier.totals=totals;supplier.total=null;return supplier;});data.masters.Service.push({id:'total',name:'Resumen total'});data.masters.Service.forEach(function(service,index){if(service.id!=='total'){data.masters.Item=data.masters.Item.concat([{idService:service.id,id:'comment'+index.toString(),type:'comment',name:'Comentarios'},{idService:service.id,id:'subtotal'+index.toString(),idServiceForTotal:service.id,type:'subtotal',name:'Total'}]);}data.masters.Item.push({idService:'total',id:'total'+index.toString(),idServiceForTotal:service.id,type:index<data.masters.Service.length-1?'subtotal':'total',name:index<data.masters.Service.length-1?service.name:'Total general'});});data.masters.EvaluationScale=Object(__WEBPACK_IMPORTED_MODULE_4__utils_action__[\"c\" /* sortByField */])(data.masters.EvaluationScale,'score');data.supplierId=supplierId;dispatch(getDataTechnicalTeamSurveySuccess(data));dispatch(calculateTotal());}).catch(function(){dispatch(getFailedRequest());});};};var finishTechnicalTeamSurvey=function finishTechnicalTeamSurvey(){return function(dispatch,getState){var _getState$technicalTe=getState().technicalTeamSurvey.data,suppliers=_getState$technicalTe.suppliers,suppliersByCall=_getState$technicalTe.suppliersByCall;var idSuppliersByCall=[];var idSuppliers=[];var updatedErrors=suppliers.map(function(supplier){var updatedError=Object.assign({},supplier,{items:supplier.items.map(function(item){return Object.assign({},item,{error:supplier.visible&&supplier.required&&!item.value});})});if(supplier.visible&&!supplier.readOnly){if(supplier.items.filter(function(item){return item.value;}).length===supplier.items.length){idSuppliersByCall.push(suppliersByCall.find(function(element){return element.idSupplier===supplier.id;}).id);idSuppliers.push(supplier.id);}}return updatedError;});if(suppliers.filter(function(element){return element.required;}).length===idSuppliersByCall.length){Object(__WEBPACK_IMPORTED_MODULE_4__utils_action__[\"a\" /* requestApi */])(dispatch,getDataTechnicalTeamSurveyProgress,__WEBPACK_IMPORTED_MODULE_3__api_supplier__[\"e\" /* finishTechnicalTeamSurveyApi */],{idSuppliersByCall:idSuppliersByCall}).then(function(){dispatch(updateErrors(updatedErrors));dispatch(updateSuppliers(idSuppliers,idSuppliersByCall));}).catch(function(){dispatch(getFailedRequest());});}else{dispatch(updateErrors(updatedErrors));Object(__WEBPACK_IMPORTED_MODULE_5__Generic_action__[\"a\" /* default */])('Algunos proveedores no han sido calificados completamente','error');}};};\n\n/***/ }),\n\n/***/ 1254:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return saveTechnicalTeamAnswerApi; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return saveTechnicalTeamCommentApi; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__instance__ = __webpack_require__(82);\nvar saveTechnicalTeamAnswerApi=function saveTechnicalTeamAnswerApi(data){return __WEBPACK_IMPORTED_MODULE_0__instance__[\"a\" /* default */].post('TechnicalTeamAnswer?action=save',data);};var saveTechnicalTeamCommentApi=function saveTechnicalTeamCommentApi(data){return __WEBPACK_IMPORTED_MODULE_0__instance__[\"a\" /* default */].post('TechnicalTeamComment?action=save',data);};\n\n/***/ }),\n\n/***/ 1255:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPendings\", function() { return getPendings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFailedRequest\", function() { return getFailedRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filterPendings\", function() { return filterPendings; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__const__ = __webpack_require__(403);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__api_supplier__ = __webpack_require__(395);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_action__ = __webpack_require__(208);\nvar getDataPendingsProgress=function getDataPendingsProgress(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"b\" /* GET_DATA_PENDINGS_PROGRESS */]};};var getDataPendingsSuccess=function getDataPendingsSuccess(data){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"c\" /* GET_DATA_PENDINGS_SUCCESS */],data:data};};var getFailedRequest=function getFailedRequest(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"d\" /* REQUEST_FAILED */]};};var filterPendings=function filterPendings(data){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"a\" /* FILTER_PENDINGS */],data:data};};var getPendings=function getPendings(year){return function(dispatch){Object(__WEBPACK_IMPORTED_MODULE_2__utils_action__[\"a\" /* requestApi */])(dispatch,getDataPendingsProgress,__WEBPACK_IMPORTED_MODULE_1__api_supplier__[\"j\" /* getPendingsApi */],year).then(function(response){var data=response.data.data;data.suppliers=Object(__WEBPACK_IMPORTED_MODULE_2__utils_action__[\"c\" /* sortByField */])(data.suppliers,'name').map(function(item){item.visible=true;return item;});dispatch(getDataPendingsSuccess(data));}).catch(function(){dispatch(getFailedRequest());});};};\n\n/***/ }),\n\n/***/ 1265:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAllGeneralData\", function() { return getAllGeneralData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFailedRequest\", function() { return getFailedRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStatisticalData\", function() { return getStatisticalData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCurrentData\", function() { return getCurrentData; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__const__ = __webpack_require__(425);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__api_generalAdministrator__ = __webpack_require__(1252);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__api_call__ = __webpack_require__(394);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_action__ = __webpack_require__(208);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Main_action__ = __webpack_require__(393);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"getUserContext\", function() { return __WEBPACK_IMPORTED_MODULE_4__Main_action__[\"getUserContext\"]; });\nvar getDataGeneralAdministratorProgress=function getDataGeneralAdministratorProgress(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"c\" /* GET_DATA_GENERAL_PROGRESS */]};};var getDataStatisticalProgress=function getDataStatisticalProgress(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"e\" /* GET_DATA_STATISTICAL_PROGRESS */]};};var getDataCurrentProgress=function getDataCurrentProgress(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"a\" /* GET_DATA_CURRENT_PROGRESS */]};};var getDataGeneralAdministratorSuccess=function getDataGeneralAdministratorSuccess(data){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"d\" /* GET_DATA_GENERAL_SUCCESS */],data:data};};var getDataCurrentSuccess=function getDataCurrentSuccess(dataCurrent){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"b\" /* GET_DATA_CURRENT_SUCCESS */],dataCurrent:dataCurrent};};var getDataStatisticalSuccess=function getDataStatisticalSuccess(statisticalData){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"f\" /* GET_DATA_STATISTICAL_SUCCESS */],statisticalData:statisticalData};};var getFailedRequest=function getFailedRequest(){return{type:__WEBPACK_IMPORTED_MODULE_0__const__[\"g\" /* REQUEST_FAILED */]};};var getAllGeneralData=function getAllGeneralData(){return function(dispatch){Object(__WEBPACK_IMPORTED_MODULE_3__utils_action__[\"a\" /* requestApi */])(dispatch,getDataGeneralAdministratorProgress,__WEBPACK_IMPORTED_MODULE_1__api_generalAdministrator__[\"a\" /* getGeneralAdministratorApi */]).then(function(response){var data=response.data.data;dispatch(getDataGeneralAdministratorSuccess(data));}).catch(function(){dispatch(getFailedRequest());});};};var getStatisticalData=function getStatisticalData(){var filter=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;return function(dispatch){Object(__WEBPACK_IMPORTED_MODULE_3__utils_action__[\"a\" /* requestApi */])(dispatch,getDataStatisticalProgress,__WEBPACK_IMPORTED_MODULE_2__api_call__[\"i\" /* getStatisticalProgressApi */],filter).then(function(response){var data=response.data.data;var objectStatisticData=data?data.axesStatisticData:{};Object.entries(objectStatisticData).forEach(function(item){data.axesStatisticData[item[0]]=parseFloat(item[1]).toFixed(2);});dispatch(getDataStatisticalSuccess(data));}).catch(function(){dispatch(getFailedRequest());});};};var getCurrentData=function getCurrentData(){return function(dispatch){Object(__WEBPACK_IMPORTED_MODULE_3__utils_action__[\"a\" /* requestApi */])(dispatch,getDataCurrentProgress,__WEBPACK_IMPORTED_MODULE_2__api_call__[\"l\" /* identifyCurrentStageApi */]).then(function(response){var data=response.data.data;dispatch(getDataCurrentSuccess(data));}).catch(function(){dispatch(getFailedRequest());});};};\n\n/***/ }),\n\n/***/ 1266:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* MIT license */\nvar convert = __webpack_require__(1289);\nvar string = __webpack_require__(1291);\n\nvar Color = function (obj) {\n\tif (obj instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0, 0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk: [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif (typeof obj === 'string') {\n\t\tvals = string.getRgba(obj);\n\t\tif (vals) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = string.getHsla(obj)) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = string.getHwb(obj)) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv', vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk', vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl: function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk', arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray: function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha: function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha', val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb', 0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1, val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue: function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360 + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation: function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness: function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv: function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness: function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness: function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val) {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val) {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val) {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val) {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function () {\n\t\treturn string.hexString(this.values.rgb);\n\t},\n\trgbString: function () {\n\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString: function () {\n\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString: function () {\n\t\treturn string.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString: function () {\n\t\treturn string.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString: function () {\n\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString: function () {\n\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword: function () {\n\t\treturn string.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb', rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1] += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb', [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2 = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except 'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source) {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv: ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb: [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360, 100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0; i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255, b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space, vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10, 10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red: 10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !== space) {\n\t\t\tvalues[sname] = convert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals = args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t// color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space, vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index, val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t// color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index]) {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index] = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nmodule.exports = Color;\n\n\n/***/ }),\n\n/***/ 1267:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1213);\n\n/**\n * Helper function to get relative position for an event\n * @param {Event|IEvent} event - The event to get the position for\n * @param {Chart} chart - The chart\n * @returns {Point} the event position\n */\nfunction getRelativePosition(e, chart) {\n\tif (e.native) {\n\t\treturn {\n\t\t\tx: e.x,\n\t\t\ty: e.y\n\t\t};\n\t}\n\n\treturn helpers.getRelativePosition(e, chart);\n}\n\n/**\n * Helper function to traverse all of the visible elements in the chart\n * @param chart {chart} the chart\n * @param handler {Function} the callback to execute for each visible item\n */\nfunction parseVisibleItems(chart, handler) {\n\tvar datasets = chart.data.datasets;\n\tvar meta, i, j, ilen, jlen;\n\n\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmeta = chart.getDatasetMeta(i);\n\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\tvar element = meta.data[j];\n\t\t\tif (!element._view.skip) {\n\t\t\t\thandler(element);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param items {ChartElement[]} elements to filter\n * @param position {Point} the point to be nearest to\n * @return {ChartElement[]} the nearest items\n */\nfunction getIntersectItems(chart, position) {\n\tvar elements = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (element.inRange(position.x, position.y)) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\n * @param chart {Chart} the chart to look at elements from\n * @param position {Point} the point to be nearest to\n * @param intersect {Boolean} if true, only consider items that intersect the position\n * @param distanceMetric {Function} function to provide the distance between points\n * @return {ChartElement[]} the nearest items\n */\nfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\tvar minDistance = Number.POSITIVE_INFINITY;\n\tvar nearestItems = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar center = element.getCenterPoint();\n\t\tvar distance = distanceMetric(position, center);\n\n\t\tif (distance < minDistance) {\n\t\t\tnearestItems = [element];\n\t\t\tminDistance = distance;\n\t\t} else if (distance === minDistance) {\n\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\tnearestItems.push(element);\n\t\t}\n\t});\n\n\treturn nearestItems;\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {String} axis the axis mode. x|y|xy\n */\nfunction getDistanceMetricForAxis(axis) {\n\tvar useX = axis.indexOf('x') !== -1;\n\tvar useY = axis.indexOf('y') !== -1;\n\n\treturn function(pt1, pt2) {\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\tvar deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t};\n}\n\nfunction indexMode(chart, e, options) {\n\tvar position = getRelativePosition(e, chart);\n\t// Default axis for index mode is 'x' to match old behaviour\n\toptions.axis = options.axis || 'x';\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\tvar elements = [];\n\n\tif (!items.length) {\n\t\treturn [];\n\t}\n\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\tvar element = meta.data[items[0]._index];\n\n\t\t\t// don't count items that are skipped (null data)\n\t\t\tif (element && !element._view.skip) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * @interface IInteractionOptions\n */\n/**\n * If true, only consider items that intersect the point\n * @name IInterfaceOptions#boolean\n * @type Boolean\n */\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nmodule.exports = {\n\t// Helper function for different modes\n\tmodes: {\n\t\tsingle: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar elements = [];\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn elements.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.label\n\t\t * @deprecated since version 2.4.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\tlabel: indexMode,\n\n\t\t/**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tindex: indexMode,\n\n\t\t/**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tdataset: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n\t\t\tif (items.length > 0) {\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t}\n\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.x-axis\n\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\t'x-axis': function(chart, e) {\n\t\t\treturn indexMode(chart, e, {intersect: false});\n\t\t},\n\n\t\t/**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tpoint: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\treturn getIntersectItems(chart, position);\n\t\t},\n\n\t\t/**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tnearest: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);\n\n\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\tif (nearestItems.length > 1) {\n\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Return only 1 item\n\t\t\treturn nearestItems.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tx: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\ty: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1268:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1213);\nvar basic = __webpack_require__(1297);\nvar dom = __webpack_require__(1298);\n\n// @TODO Make possible to select another platform at build time.\nvar implementation = dom._enabled ? dom : basic;\n\n/**\n * @namespace Chart.platform\n * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n * @since 2.4.0\n */\nmodule.exports = helpers.extend({\n\t/**\n\t * @since 2.7.0\n\t */\n\tinitialize: function() {},\n\n\t/**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t * @param {Object} options - The chart options\n\t * @returns {CanvasRenderingContext2D} context2d instance\n\t */\n\tacquireContext: function() {},\n\n\t/**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {Boolean} true if the method succeeded, else false\n\t */\n\treleaseContext: function() {},\n\n\t/**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {String} type - The ({@link IEvent}) type to listen for\n\t * @param {Function} listener - Receives a notification (an object that implements\n\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t */\n\taddEventListener: function() {},\n\n\t/**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart -Chart from which to remove the listener\n\t * @param {String} type - The ({@link IEvent}) type to remove\n\t * @param {Function} listener - The listener function to remove from the event target.\n\t */\n\tremoveEventListener: function() {}\n\n}, implementation);\n\n/**\n * @interface IPlatform\n * Allows abstracting platform dependencies away from the chart\n * @borrows Chart.platform.acquireContext as acquireContext\n * @borrows Chart.platform.releaseContext as releaseContext\n * @borrows Chart.platform.addEventListener as addEventListener\n * @borrows Chart.platform.removeEventListener as removeEventListener\n */\n\n/**\n * @interface IEvent\n * @prop {String} type - The event type name, possible values are:\n * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n */\n\n\n/***/ }),\n\n/***/ 1269:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('global', {\n\tplugins: {}\n});\n\n/**\n * The plugin service singleton\n * @namespace Chart.plugins\n * @since 2.1.0\n */\nmodule.exports = {\n\t/**\n\t * Globally registered plugins.\n\t * @private\n\t */\n\t_plugins: [],\n\n\t/**\n\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t * incremented and descriptors are regenerated during following API calls.\n\t * @private\n\t */\n\t_cacheId: 0,\n\n\t/**\n\t * Registers the given plugin(s) if not already registered.\n\t * @param {Array|Object} plugins plugin instance(s).\n\t */\n\tregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\tp.push(plugin);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Unregisters the given plugin(s) only if registered.\n\t * @param {Array|Object} plugins plugin instance(s).\n\t */\n\tunregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tvar idx = p.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\tp.splice(idx, 1);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Remove all registered plugins.\n\t * @since 2.1.5\n\t */\n\tclear: function() {\n\t\tthis._plugins = [];\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Returns the number of registered plugins?\n\t * @returns {Number}\n\t * @since 2.1.5\n\t */\n\tcount: function() {\n\t\treturn this._plugins.length;\n\t},\n\n\t/**\n\t * Returns all registered plugin instances.\n\t * @returns {Array} array of plugin objects.\n\t * @since 2.1.5\n\t */\n\tgetAll: function() {\n\t\treturn this._plugins;\n\t},\n\n\t/**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Object} chart - The chart instance for which plugins should be called.\n\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t * @returns {Boolean} false if any of the plugins return false, else returns true.\n\t */\n\tnotify: function(chart, hook, args) {\n\t\tvar descriptors = this.descriptors(chart);\n\t\tvar ilen = descriptors.length;\n\t\tvar i, descriptor, plugin, params, method;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tdescriptor = descriptors[i];\n\t\t\tplugin = descriptor.plugin;\n\t\t\tmethod = plugin[hook];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\tparams.push(descriptor.options);\n\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns descriptors of enabled plugins for the given chart.\n\t * @returns {Array} [{ plugin, options }]\n\t * @private\n\t */\n\tdescriptors: function(chart) {\n\t\tvar cache = chart.$plugins || (chart.$plugins = {});\n\t\tif (cache.id === this._cacheId) {\n\t\t\treturn cache.descriptors;\n\t\t}\n\n\t\tvar plugins = [];\n\t\tvar descriptors = [];\n\t\tvar config = (chart && chart.config) || {};\n\t\tvar options = (config.options && config.options.plugins) || {};\n\n\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar id = plugin.id;\n\t\t\tvar opts = options[id];\n\t\t\tif (opts === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (opts === true) {\n\t\t\t\topts = helpers.clone(defaults.global.plugins[id]);\n\t\t\t}\n\n\t\t\tplugins.push(plugin);\n\t\t\tdescriptors.push({\n\t\t\t\tplugin: plugin,\n\t\t\t\toptions: opts || {}\n\t\t\t});\n\t\t});\n\n\t\tcache.descriptors = descriptors;\n\t\tcache.id = this._cacheId;\n\t\treturn descriptors;\n\t},\n\n\t/**\n\t * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\n\t * but in some cases, this reference can be changed by the user when updating options.\n\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t * @private\n\t */\n\t_invalidate: function(chart) {\n\t\tdelete chart.$plugins;\n\t}\n};\n\n/**\n * Plugin extension hooks.\n * @interface IPlugin\n * @since 2.1.0\n */\n/**\n * @method IPlugin#beforeInit\n * @desc Called before initializing `chart`.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#afterInit\n * @desc Called after `chart` has been initialized and before the first update.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeUpdate\n * @desc Called before updating `chart`. If any plugin returns `false`, the update\n * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart update.\n */\n/**\n * @method IPlugin#afterUpdate\n * @desc Called after `chart` has been updated and before rendering. Note that this\n * hook will not be called if the chart update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetsUpdate\n * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n * the datasets update is cancelled until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} false to cancel the datasets update.\n * @since version 2.1.5\n*/\n/**\n * @method IPlugin#afterDatasetsUpdate\n * @desc Called after the `chart` datasets have been updated. Note that this hook\n * will not be called if the datasets update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @since version 2.1.5\n */\n/**\n * @method IPlugin#beforeDatasetUpdate\n * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin\n * returns `false`, the datasets update is cancelled until another `update` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetUpdate\n * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note\n * that this hook will not be called if the datasets update has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeLayout\n * @desc Called before laying out `chart`. If any plugin returns `false`,\n * the layout update is cancelled until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart layout.\n */\n/**\n * @method IPlugin#afterLayout\n * @desc Called after the `chart` has been layed out. Note that this hook will not\n * be called if the layout update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeRender\n * @desc Called before rendering `chart`. If any plugin returns `false`,\n * the rendering is cancelled until another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart rendering.\n */\n/**\n * @method IPlugin#afterRender\n * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n * that this hook will not be called if the rendering has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDraw\n * @desc Called before drawing `chart` at every animation frame specified by the given\n * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n * another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart drawing.\n */\n/**\n * @method IPlugin#afterDraw\n * @desc Called after the `chart` has been drawn for the specific easing value. Note\n * that this hook will not be called if the drawing has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetsDraw\n * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n * the datasets drawing is cancelled until another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetsDraw\n * @desc Called after the `chart` datasets have been drawn. Note that this hook\n * will not be called if the datasets drawing has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetDraw\n * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets\n * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing\n * is cancelled until another `render` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetDraw\n * @desc Called after the `chart` datasets at the given `args.index` have been drawn\n * (datasets are drawn in the reverse order). Note that this hook will not be called\n * if the datasets drawing has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeTooltipDraw\n * @desc Called before drawing the `tooltip`. If any plugin returns `false`,\n * the tooltip drawing is cancelled until another `render` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Object} args.tooltip - The tooltip.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart tooltip drawing.\n */\n/**\n * @method IPlugin#afterTooltipDraw\n * @desc Called after drawing the `tooltip`. Note that this hook will not\n * be called if the tooltip drawing has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Object} args.tooltip - The tooltip.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeEvent\n * @desc Called before processing the specified `event`. If any plugin returns `false`,\n * the event will be discarded.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {IEvent} event - The event object.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#afterEvent\n * @desc Called after the `event` has been consumed. Note that this hook\n * will not be called if the `event` has been previously discarded.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {IEvent} event - The event object.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#resize\n * @desc Called after the chart as been resized.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#destroy\n * @desc Called after the chart as been destroyed.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n\n\n/***/ }),\n\n/***/ 1270:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _classnames = __webpack_require__(6);\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    CAROUSEL: function CAROUSEL(isSlider) {\n        return (0, _classnames2.default)({\n            \"carousel\": true,\n            \"carousel-slider\": isSlider\n        });\n    },\n\n    WRAPPER: function WRAPPER(isSlider, axis) {\n        return (0, _classnames2.default)({\n            \"thumbs-wrapper\": !isSlider,\n            \"slider-wrapper\": isSlider,\n            \"axis-horizontal\": axis === \"horizontal\",\n            \"axis-vertical\": axis !== \"horizontal\"\n        });\n    },\n\n    SLIDER: function SLIDER(isSlider, isSwiping) {\n        return (0, _classnames2.default)({\n            \"thumbs\": !isSlider,\n            \"slider\": isSlider,\n            \"animated\": !isSwiping\n        });\n    },\n\n    ITEM: function ITEM(isSlider, selected) {\n        return (0, _classnames2.default)({\n            \"thumb\": !isSlider,\n            \"slide\": isSlider,\n            \"selected\": selected\n        });\n    },\n\n    ARROW_PREV: function ARROW_PREV(disabled) {\n        return (0, _classnames2.default)({\n            \"control-arrow control-prev\": true,\n            \"control-disabled\": disabled\n        });\n    },\n\n    ARROW_NEXT: function ARROW_NEXT(disabled) {\n        return (0, _classnames2.default)({\n            \"control-arrow control-next\": true,\n            \"control-disabled\": disabled\n        });\n    },\n\n    DOT: function DOT(selected) {\n        return (0, _classnames2.default)({\n            \"dot\": true,\n            'selected': selected\n        });\n    }\n};\n\n/***/ }),\n\n/***/ 1271:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (position, axis) {\n    var positionCss = axis === 'horizontal' ? [position, 0, 0] : [0, position, 0];\n    var transitionProp = 'translate3d';\n\n    var translatedPosition = '(' + positionCss.join(',') + ')';\n\n    return transitionProp + translatedPosition;\n};\n\n/***/ }),\n\n/***/ 1272:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(1332)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('./react-swipe'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.reactSwipe);\n    global.index = mod.exports;\n  }\n})(this, function (exports, _reactSwipe) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _reactSwipe2 = _interopRequireDefault(_reactSwipe);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  exports.default = _reactSwipe2.default;\n});\n\n/***/ }),\n\n/***/ 1273:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(9);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = __webpack_require__(5);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _cssClasses = __webpack_require__(1270);\n\nvar _cssClasses2 = _interopRequireDefault(_cssClasses);\n\nvar _dimensions = __webpack_require__(1333);\n\nvar _CSSTranslate = __webpack_require__(1271);\n\nvar _CSSTranslate2 = _interopRequireDefault(_CSSTranslate);\n\nvar _reactEasySwipe = __webpack_require__(1272);\n\nvar _reactEasySwipe2 = _interopRequireDefault(_reactEasySwipe);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Thumbs = function (_Component) {\n    _inherits(Thumbs, _Component);\n\n    function Thumbs(props) {\n        _classCallCheck(this, Thumbs);\n\n        var _this = _possibleConstructorReturn(this, (Thumbs.__proto__ || Object.getPrototypeOf(Thumbs)).call(this, props));\n\n        _this.setItemsWrapperRef = function (node) {\n            _this.itemsWrapperRef = node;\n        };\n\n        _this.setItemsListRef = function (node) {\n            _this.itemsListRef = node;\n        };\n\n        _this.setThumbsRef = function (node, index) {\n            if (!_this.thumbsRef) {\n                _this.thumbsRef = [];\n            }\n            _this.thumbsRef[index] = node;\n        };\n\n        _this.updateSizes = function () {\n            if (!_this.props.children || !_this.itemsWrapperRef) {\n                return;\n            }\n\n            var total = _this.props.children.length;\n            var wrapperSize = _this.itemsWrapperRef.clientWidth;\n            var itemSize = _this.props.thumbWidth ? _this.props.thumbWidth : (0, _dimensions.outerWidth)(_this.thumbsRef[0]);\n            var visibleItems = Math.floor(wrapperSize / itemSize);\n            var lastPosition = total - visibleItems;\n            var showArrows = visibleItems < total;\n            _this.setState({\n                itemSize: itemSize,\n                visibleItems: visibleItems,\n                firstItem: showArrows ? _this.getFirstItem(_this.props.selectedItem) : 0,\n                lastPosition: lastPosition,\n                showArrows: showArrows\n            });\n        };\n\n        _this.setMountState = function () {\n            _this.setState({ hasMount: true });\n            _this.updateSizes();\n        };\n\n        _this.handleClickItem = function (index, item) {\n            var handler = _this.props.onSelectItem;\n\n            if (typeof handler === 'function') {\n                handler(index, item);\n            }\n        };\n\n        _this.onSwipeStart = function () {\n            _this.setState({\n                swiping: true\n            });\n        };\n\n        _this.onSwipeEnd = function () {\n            _this.setState({\n                swiping: false\n            });\n        };\n\n        _this.onSwipeMove = function (deltaX) {\n            var leftBoundary = 0;\n\n            var currentPosition = -_this.state.firstItem * _this.state.itemSize;\n            var lastLeftBoundary = -_this.state.visibleItems * _this.state.itemSize;\n\n            // prevent user from swiping left out of boundaries\n            if (currentPosition === leftBoundary && deltaX > 0) {\n                deltaX = 0;\n            }\n\n            // prevent user from swiping right out of boundaries\n            if (currentPosition === lastLeftBoundary && deltaX < 0) {\n                deltaX = 0;\n            }\n\n            var wrapperSize = _this.itemsWrapperRef.clientWidth;\n            var position = currentPosition + 100 / (wrapperSize / deltaX) + '%';\n\n            // if 3d isn't available we will use left to move\n            ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {\n                _this.itemsListRef.style[prop] = (0, _CSSTranslate2.default)(position, _this.props.axis);\n            });\n        };\n\n        _this.slideRight = function (positions) {\n            _this.moveTo(_this.state.firstItem - (typeof positions === 'number' ? positions : 1));\n        };\n\n        _this.slideLeft = function (positions) {\n            _this.moveTo(_this.state.firstItem + (typeof positions === 'number' ? positions : 1));\n        };\n\n        _this.moveTo = function (position) {\n            // position can't be lower than 0\n            position = position < 0 ? 0 : position;\n            // position can't be higher than last postion\n            position = position >= _this.lastPosition ? _this.lastPosition : position;\n\n            _this.setState({\n                firstItem: position,\n                // if it's not a slider, we don't need to set position here\n                selectedItem: _this.state.selectedItem\n            });\n        };\n\n        _this.state = {\n            selectedItem: props.selectedItem,\n            hasMount: false,\n            firstItem: 0,\n            itemSize: null,\n            visibleItems: 0,\n            lastPosition: 0,\n            showArrows: false,\n            images: _this.getImages()\n        };\n        return _this;\n    }\n\n    _createClass(Thumbs, [{\n        key: 'componentDidMount',\n        value: function componentDidMount(nextProps) {\n            this.setupThumbs();\n        }\n    }, {\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(props, state) {\n            if (props.selectedItem !== this.state.selectedItem) {\n                this.setState({\n                    selectedItem: props.selectedItem,\n                    firstItem: this.getFirstItem(props.selectedItem)\n                });\n            }\n            if (props.children !== this.props.children) {\n                this.setState({\n                    images: this.getImages()\n                });\n            }\n        }\n    }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate(prevProps) {\n            if (this.props.children === prevProps.children) {\n                return;\n            }\n\n            // This will capture any size changes for arrow adjustments etc.\n            // usually in the same render cycle so we don't see any flickers\n            this.updateSizes();\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            this.destroyThumbs();\n        }\n    }, {\n        key: 'setupThumbs',\n        value: function setupThumbs() {\n            // as the widths are calculated, we need to resize\n            // the carousel when the window is resized\n            window.addEventListener(\"resize\", this.updateSizes);\n            // issue #2 - image loading smaller\n            window.addEventListener(\"DOMContentLoaded\", this.updateSizes);\n\n            // when the component is rendered we need to calculate\n            // the container size to adjust the responsive behaviour\n            this.updateSizes();\n        }\n    }, {\n        key: 'destroyThumbs',\n        value: function destroyThumbs() {\n            // removing listeners\n            window.removeEventListener(\"resize\", this.updateSizes);\n            window.removeEventListener(\"DOMContentLoaded\", this.updateSizes);\n        }\n    }, {\n        key: 'getImages',\n        value: function getImages() {\n            var images = _react.Children.map(this.props.children, function (item, index) {\n                var img = item;\n\n                // if the item is not an image, try to find the first image in the item's children.\n                if (item.type !== \"img\") {\n                    img = _react.Children.toArray(item.props.children).filter(function (children) {\n                        return children.type === \"img\";\n                    })[0];\n                }\n\n                if (!img || img.length === 0) {\n                    return null;\n                }\n\n                return img;\n            });\n\n            if (images.filter(function (image) {\n                return image !== null;\n            }).length === 0) {\n                console.warn('No images found! Can\\'t build the thumb list without images. If you don\\'t need thumbs, set showThumbs={false} in the Carousel. Note that it\\'s not possible to get images rendered inside custom components. More info at https://github.com/leandrowd/react-responsive-carousel/blob/master/TROUBLESHOOTING.md');\n\n                return null;\n            }\n\n            return images;\n        }\n    }, {\n        key: 'getFirstItem',\n        value: function getFirstItem(selectedItem) {\n            var firstItem = selectedItem;\n\n            if (selectedItem >= this.state.lastPosition) {\n                firstItem = this.state.lastPosition;\n            }\n\n            if (selectedItem < this.state.firstItem + this.state.visibleItems) {\n                firstItem = this.state.firstItem;\n            }\n\n            if (selectedItem < this.state.firstItem) {\n                firstItem = selectedItem;\n            }\n\n            return firstItem;\n        }\n    }, {\n        key: 'renderItems',\n        value: function renderItems() {\n            var _this2 = this;\n\n            return this.state.images.map(function (img, index) {\n                var itemClass = _cssClasses2.default.ITEM(false, index === _this2.state.selectedItem && _this2.state.hasMount);\n\n                var thumbProps = {\n                    key: index,\n                    ref: function ref(e) {\n                        return _this2.setThumbsRef(e, index);\n                    },\n                    className: itemClass,\n                    onClick: _this2.handleClickItem.bind(_this2, index, _this2.props.children[index])\n                };\n\n                if (index === 0) {\n                    img = _react2.default.cloneElement(img, {\n                        onLoad: _this2.setMountState\n                    });\n                }\n\n                return _react2.default.createElement(\n                    'li',\n                    thumbProps,\n                    img\n                );\n            });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            if (!this.props.children) {\n                return null;\n            }\n\n            // show left arrow?\n            var hasPrev = this.state.showArrows && this.state.firstItem > 0;\n            // show right arrow\n            var hasNext = this.state.showArrows && this.state.firstItem < this.state.lastPosition;\n            // obj to hold the transformations and styles\n            var itemListStyles = {};\n\n            var currentPosition = -this.state.firstItem * this.state.itemSize + 'px';\n\n            var transformProp = (0, _CSSTranslate2.default)(currentPosition, this.props.axis);\n\n            var transitionTime = this.props.transitionTime + 'ms';\n\n            itemListStyles = {\n                'WebkitTransform': transformProp,\n                'MozTransform': transformProp,\n                'MsTransform': transformProp,\n                'OTransform': transformProp,\n                'transform': transformProp,\n                'msTransform': transformProp,\n                'WebkitTransitionDuration': transitionTime,\n                'MozTransitionDuration': transitionTime,\n                'MsTransitionDuration': transitionTime,\n                'OTransitionDuration': transitionTime,\n                'transitionDuration': transitionTime,\n                'msTransitionDuration': transitionTime\n            };\n\n            return _react2.default.createElement(\n                'div',\n                { className: _cssClasses2.default.CAROUSEL(false) },\n                _react2.default.createElement(\n                    'div',\n                    { className: _cssClasses2.default.WRAPPER(false), ref: this.setItemsWrapperRef },\n                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_PREV(!hasPrev), onClick: this.slideRight }),\n                    _react2.default.createElement(\n                        _reactEasySwipe2.default,\n                        { tagName: 'ul',\n                            selectedItem: this.state.selectedItem,\n                            className: _cssClasses2.default.SLIDER(false, this.state.swiping),\n                            onSwipeLeft: this.slideLeft,\n                            onSwipeRight: this.slideRight,\n                            onSwipeMove: this.onSwipeMove,\n                            onSwipeStart: this.onSwipeStart,\n                            onSwipeEnd: this.onSwipeEnd,\n                            style: itemListStyles,\n                            ref: this.setItemsListRef },\n                        this.renderItems()\n                    ),\n                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_NEXT(!hasNext), onClick: this.slideLeft })\n                )\n            );\n        }\n    }]);\n\n    return Thumbs;\n}(_react.Component);\n\nThumbs.displayName = 'Thumbs';\nThumbs.propsTypes = {\n    children: _propTypes2.default.element.isRequired,\n    transitionTime: _propTypes2.default.number,\n    selectedItem: _propTypes2.default.number,\n    thumbWidth: _propTypes2.default.number\n};\nThumbs.defaultProps = {\n    selectedItem: 0,\n    transitionTime: 350,\n    axis: 'horizontal'\n};\nexports.default = Thumbs;\n\n/***/ }),\n\n/***/ 1278:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux__ = __webpack_require__(129);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_styled_components__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_antd__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__state_Home_action__ = __webpack_require__(1265);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5____ = __webpack_require__(1279);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__shared_FormattedMessage__ = __webpack_require__(55);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _templateObject=_taggedTemplateLiteral(['\\n  color: ',';\\n  margin-bottom: ',';\\n  font-weight: bold;\\n'],['\\n  color: ',';\\n  margin-bottom: ',';\\n  font-weight: bold;\\n']),_templateObject2=_taggedTemplateLiteral(['\\n  border: 1px solid #37907c7a;\\n  margin: 20px 0;\\n'],['\\n  border: 1px solid #37907c7a;\\n  margin: 20px 0;\\n']);function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}function _taggedTemplateLiteral(strings,raw){return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}var H3=__WEBPACK_IMPORTED_MODULE_2_styled_components__[\"c\" /* default */].h3(_templateObject,function(props){return props.theme.color.primary;},function(props){return props.theme.spaces.main;});var Linea=__WEBPACK_IMPORTED_MODULE_2_styled_components__[\"c\" /* default */].div(_templateObject2);var HomeContainer=function(_Component){_inherits(HomeContainer,_Component);function HomeContainer(){var _ref;var _temp,_this,_ret;_classCallCheck(this,HomeContainer);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=HomeContainer.__proto__||Object.getPrototypeOf(HomeContainer)).call.apply(_ref,[this].concat(args))),_this),_this.state={value:1},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(HomeContainer,[{key:'componentDidMount',value:function componentDidMount(){this.props.getAllGeneralData();this.props.getCurrentData();}},{key:'render',value:function render(){var _props=this.props,loading=_props.loading,dataCurrent=_props.dataCurrent,dataUser=_props.dataUser;var rol=dataUser.rols&&dataUser.rols.find(function(x){return x;}).shortName;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"u\" /* Spin */],{spinning:loading},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"s\" /* Row */],{type:'flex',justify:'center'},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"e\" /* Col */],{span:10,offset:2},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(H3,null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_6__shared_FormattedMessage__[\"a\" /* default */],{id:'Title.imageGallery'})),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5____[\"a\" /* Carousel */],this.props)),rol&&rol!=='SUPPLIER'&&__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"e\" /* Col */],{span:10,offset:2},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(H3,null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_6__shared_FormattedMessage__[\"a\" /* default */],{id:'Title.percentageAdvance'})),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5____[\"b\" /* Doughnut */],this.props))),rol===dataCurrent&&__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Linea,null),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"s\" /* Row */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"e\" /* Col */],{span:24},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(H3,null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_6__shared_FormattedMessage__[\"a\" /* default */],{id:'Title.pendings'})),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('p',null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_6__shared_FormattedMessage__[\"a\" /* default */],{id:'Title.informationMessage'})),dataCurrent==='MANAGER_TEAM'&&__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5____[\"d\" /* PendingsManager */],null),dataCurrent==='TECHNICAL_TEAM'&&__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5____[\"f\" /* PendingsTechnical */],null),dataCurrent==='EVALUATOR'&&__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5____[\"c\" /* PendingsEvaluator */],null),dataCurrent==='SUPPLIER'&&__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5____[\"e\" /* PendingsSupplier */],null)))));}}]);return HomeContainer;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);var mapStateToProps=function mapStateToProps(state){return{data:state.home.data,loading:state.home.loading,dataUser:state.main.data,dataCurrent:state.home.dataCurrent};};/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1_react_redux__[\"b\" /* connect */])(mapStateToProps,__WEBPACK_IMPORTED_MODULE_4__state_Home_action__)(HomeContainer));\n\n/***/ }),\n\n/***/ 1279:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Doughnut__ = __webpack_require__(1280);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_0__Doughnut__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Carousel__ = __webpack_require__(1329);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_1__Carousel__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PendingsManager__ = __webpack_require__(1335);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return __WEBPACK_IMPORTED_MODULE_2__PendingsManager__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PendingsTechnical__ = __webpack_require__(1336);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return __WEBPACK_IMPORTED_MODULE_3__PendingsTechnical__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__PendingsEvaluator__ = __webpack_require__(1337);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return __WEBPACK_IMPORTED_MODULE_4__PendingsEvaluator__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__PendingsSupplier__ = __webpack_require__(1338);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return __WEBPACK_IMPORTED_MODULE_5__PendingsSupplier__[\"a\"]; });\n\n\n/***/ }),\n\n/***/ 1280:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux__ = __webpack_require__(129);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_styled_components__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_react_chartkick__ = __webpack_require__(1281);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_chart_js__ = __webpack_require__(1283);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_chart_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_chart_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_antd__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_const__ = __webpack_require__(212);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__state_Home_action__ = __webpack_require__(1265);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__shared_FormattedMessage__ = __webpack_require__(55);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _templateObject=_taggedTemplateLiteral(['\\n  margin-bottom: 20px;\\n  display: flex;\\n  justify-content: center;\\n'],['\\n  margin-bottom: 20px;\\n  display: flex;\\n  justify-content: center;\\n']);function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}function _taggedTemplateLiteral(strings,raw){return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}var RadioGroup=__WEBPACK_IMPORTED_MODULE_5_antd__[\"r\" /* Radio */].Group;__WEBPACK_IMPORTED_MODULE_3_react_chartkick__[\"b\" /* default */].addAdapter(__WEBPACK_IMPORTED_MODULE_4_chart_js___default.a);var RadioGroupStyle=Object(__WEBPACK_IMPORTED_MODULE_2_styled_components__[\"c\" /* default */])(RadioGroup)(_templateObject);var Doughnut=function(_Component){_inherits(Doughnut,_Component);function Doughnut(){var _ref;var _temp,_this,_ret;_classCallCheck(this,Doughnut);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=Doughnut.__proto__||Object.getPrototypeOf(Doughnut)).call.apply(_ref,[this].concat(args))),_this),_this.state={value:'SUPPLY_FILTER'},_this.onChange=function(e){var value=e.target.value;_this.setState({value:value});_this.props.getStatisticalData(value);},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(Doughnut,[{key:'componentDidMount',value:function componentDidMount(){this.props.getUserContext();}},{key:'componentWillReceiveProps',value:function componentWillReceiveProps(nextProps){if(this.props.dataUser!==nextProps.dataUser){var dataUser=this.props.dataUser;if(dataUser.rols&&dataUser.rols.find(function(x){return x;}).shortName!=='SUPPLIER'){this.props.getStatisticalData();}}}},{key:'render',value:function render(){var _props=this.props,dataUser=_props.dataUser,statisticalData=_props.statisticalData;var axesStatisticData=statisticalData.axesStatisticData,totalSupplier=statisticalData.totalSupplier;var data=axesStatisticData;var options={donut:true,data:data,legend:'bottom',suffix:'%',colors:['#8ebfb4','#fdbb6a','#99bd73','#eae57b','#f00','#0f0','00f'],messages:{empty:'No hay datos'},library:{title:{display:true,text:[new Date().getFullYear(),totalSupplier+' proveedores'],fontColor:'#37907c'}}};if(dataUser.rols&&dataUser.rols.find(function(x){return x;}).shortName==='SUPPLIER'){return null;}return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('span',null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(RadioGroupStyle,{onChange:this.onChange,value:this.state.value},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5_antd__[\"r\" /* Radio */],{value:'SUPPLY_FILTER'},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__shared_FormattedMessage__[\"a\" /* default */],{id:'Title.supplyType'})),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5_antd__[\"r\" /* Radio */],{value:'COMPANY_SIZE_FILTER'},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__shared_FormattedMessage__[\"a\" /* default */],{id:'Title.companySize'})),dataUser.rols&&dataUser.rols.find(function(x){return x;}).shortName===(__WEBPACK_IMPORTED_MODULE_6__utils_const__[\"a\" /* ADMINISTRATOR */]||__WEBPACK_IMPORTED_MODULE_6__utils_const__[\"d\" /* LIBERATOR */]||__WEBPACK_IMPORTED_MODULE_6__utils_const__[\"h\" /* READER */])&&__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5_antd__[\"r\" /* Radio */],{value:'COUNTRY_FILTER'},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__shared_FormattedMessage__[\"a\" /* default */],{id:'Title.country'}))),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_react_chartkick__[\"a\" /* PieChart */],options));}}]);return Doughnut;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);var mapDispatchToProps=Object.assign({},__WEBPACK_IMPORTED_MODULE_7__state_Home_action__);var mapStateToProps=function mapStateToProps(state){return{statisticalData:state.home.statisticalData,dataUser:state.main.data};};/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1_react_redux__[\"b\" /* connect */])(mapStateToProps,mapDispatchToProps)(Doughnut));\n\n/***/ }),\n\n/***/ 1281:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export LineChart */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PieChart; });\n/* unused harmony export ColumnChart */\n/* unused harmony export BarChart */\n/* unused harmony export AreaChart */\n/* unused harmony export ScatterChart */\n/* unused harmony export GeoChart */\n/* unused harmony export Timeline */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_chartkick__ = __webpack_require__(1282);\n/*\n * React Chartkick\n * Create beautiful JavaScript charts with one line of React\n * https://github.com/ankane/react-chartkick\n * v0.2.0\n * MIT License\n */\n\n\n\n\nvar chartId = 1;\n\nvar ChartComponent = (function (superclass) {\n  function ChartComponent () {\n    superclass.apply(this, arguments);\n  }\n\n  if ( superclass ) ChartComponent.__proto__ = superclass;\n  ChartComponent.prototype = Object.create( superclass && superclass.prototype );\n  ChartComponent.prototype.constructor = ChartComponent;\n\n  ChartComponent.prototype.newChartType = function newChartType (props) {\n    var data = props.data;\n    var options = {};\n    for (var prop in props) {\n      if (props.hasOwnProperty(prop) && prop !== \"data\" && prop !== \"id\" && prop !== \"height\" && prop !== \"width\") {\n        options[prop] = props[prop];\n      }\n    }\n    if (this.element) {\n      new props.chartType(this.element, data, options);\n    }\n  };\n\n  ChartComponent.prototype.componentDidMount = function componentDidMount () {\n    this.newChartType(this.props);\n  };\n\n  ChartComponent.prototype.componentDidUpdate = function componentDidUpdate () {\n    this.newChartType(this.props);\n  };\n\n  ChartComponent.prototype.render = function render () {\n    var this$1 = this;\n\n    var props = this.props;\n    var style = {\n      height: props.height || \"300px\",\n      lineHeight: props.height || \"300px\",\n      width: props.width || \"100%\",\n      textAlign: \"center\",\n      color: \"#999\",\n      fontSize: \"14px\",\n      fontFamily: \"'Lucida Grande', 'Lucida Sans Unicode', Verdana, Arial, Helvetica, sans-serif\"\n    };\n    this.chartId = props.id || this.chartId || (\"chart-\" + chartId++);\n    return (\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\", {id: this.chartId, style: style, ref: function (element) { return this$1.element = element; }},\n        \"Loading...\"\n      )\n    )\n  };\n\n  return ChartComponent;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component));\n\nvar createComponent = function (chartType) {\n  return function (props) {\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(ChartComponent, Object.assign({}, props, {chartType: chartType}))\n  }\n};\n\nvar LineChart = createComponent(__WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].LineChart);\nvar PieChart = createComponent(__WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].PieChart);\nvar ColumnChart = createComponent(__WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].ColumnChart);\nvar BarChart = createComponent(__WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].BarChart);\nvar AreaChart = createComponent(__WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].AreaChart);\nvar ScatterChart = createComponent(__WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].ScatterChart);\nvar GeoChart = createComponent(__WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].GeoChart);\nvar Timeline = createComponent(__WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].Timeline);\n\nvar index = {\n  addAdapter: function(library) {\n    __WEBPACK_IMPORTED_MODULE_1_chartkick__[\"a\" /* default */].addAdapter(library);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"b\"] = (index);\n\n\n\n/***/ }),\n\n/***/ 1282:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/*\n * Chartkick.js\n * Create beautiful charts with one line of JavaScript\n * https://github.com/ankane/chartkick.js\n * v2.3.6\n * MIT License\n */\n\nfunction isArray(variable) {\n  return Object.prototype.toString.call(variable) === \"[object Array]\";\n}\n\nfunction isFunction(variable) {\n  return variable instanceof Function;\n}\n\nfunction isPlainObject(variable) {\n  return !isFunction(variable) && variable instanceof Object;\n}\n\n// https://github.com/madrobby/zepto/blob/master/src/zepto.js\nfunction extend(target, source) {\n  var key;\n  for (key in source) {\n    if (isPlainObject(source[key]) || isArray(source[key])) {\n      if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n        target[key] = {};\n      }\n      if (isArray(source[key]) && !isArray(target[key])) {\n        target[key] = [];\n      }\n      extend(target[key], source[key]);\n    } else if (source[key] !== undefined) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction merge(obj1, obj2) {\n  var target = {};\n  extend(target, obj1);\n  extend(target, obj2);\n  return target;\n}\n\nvar DATE_PATTERN = /^(\\d\\d\\d\\d)(-)?(\\d\\d)(-)?(\\d\\d)$/i;\n\n// https://github.com/Do/iso8601.js\nvar ISO8601_PATTERN = /(\\d\\d\\d\\d)(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)?(:)?(\\d\\d)?([.,]\\d+)?($|Z|([+-])(\\d\\d)(:)?(\\d\\d)?)/i;\nvar DECIMAL_SEPARATOR = String(1.5).charAt(1);\n\nfunction parseISO8601(input) {\n  var day, hour, matches, milliseconds, minutes, month, offset, result, seconds, type, year;\n  type = Object.prototype.toString.call(input);\n  if (type === \"[object Date]\") {\n    return input;\n  }\n  if (type !== \"[object String]\") {\n    return;\n  }\n  matches = input.match(ISO8601_PATTERN);\n  if (matches) {\n    year = parseInt(matches[1], 10);\n    month = parseInt(matches[3], 10) - 1;\n    day = parseInt(matches[5], 10);\n    hour = parseInt(matches[7], 10);\n    minutes = matches[9] ? parseInt(matches[9], 10) : 0;\n    seconds = matches[11] ? parseInt(matches[11], 10) : 0;\n    milliseconds = matches[12] ? parseFloat(DECIMAL_SEPARATOR + matches[12].slice(1)) * 1000 : 0;\n    result = Date.UTC(year, month, day, hour, minutes, seconds, milliseconds);\n    if (matches[13] && matches[14]) {\n      offset = matches[15] * 60;\n      if (matches[17]) {\n        offset += parseInt(matches[17], 10);\n      }\n      offset *= matches[14] === \"-\" ? -1 : 1;\n      result -= offset * 60 * 1000;\n    }\n    return new Date(result);\n  }\n}\n// end iso8601.js\n\nfunction negativeValues(series) {\n  var i, j, data;\n  for (i = 0; i < series.length; i++) {\n    data = series[i].data;\n    for (j = 0; j < data.length; j++) {\n      if (data[j][1] < 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction toStr(n) {\n  return \"\" + n;\n}\n\nfunction toFloat(n) {\n  return parseFloat(n);\n}\n\nfunction toDate(n) {\n  var matches, year, month, day;\n  if (typeof n !== \"object\") {\n    if (typeof n === \"number\") {\n      n = new Date(n * 1000); // ms\n    } else {\n      n = toStr(n);\n      if ((matches = n.match(DATE_PATTERN))) {\n      year = parseInt(matches[1], 10);\n      month = parseInt(matches[3], 10) - 1;\n      day = parseInt(matches[5], 10);\n      return new Date(year, month, day);\n      } else { // str\n        // try our best to get the str into iso8601\n        // TODO be smarter about this\n        var str = n.replace(/ /, \"T\").replace(\" \", \"\").replace(\"UTC\", \"Z\");\n        n = parseISO8601(str) || new Date(n);\n      }\n    }\n  }\n  return n;\n}\n\nfunction toArr(n) {\n  if (!isArray(n)) {\n    var arr = [], i;\n    for (i in n) {\n      if (n.hasOwnProperty(i)) {\n        arr.push([i, n[i]]);\n      }\n    }\n    n = arr;\n  }\n  return n;\n}\n\nfunction jsOptionsFunc(defaultOptions, hideLegend, setTitle, setMin, setMax, setStacked, setXtitle, setYtitle) {\n  return function (chart, opts, chartOptions) {\n    var series = chart.data;\n    var options = merge({}, defaultOptions);\n    options = merge(options, chartOptions || {});\n\n    if (chart.hideLegend || \"legend\" in opts) {\n      hideLegend(options, opts.legend, chart.hideLegend);\n    }\n\n    if (opts.title) {\n      setTitle(options, opts.title);\n    }\n\n    // min\n    if (\"min\" in opts) {\n      setMin(options, opts.min);\n    } else if (!negativeValues(series)) {\n      setMin(options, 0);\n    }\n\n    // max\n    if (opts.max) {\n      setMax(options, opts.max);\n    }\n\n    if (\"stacked\" in opts) {\n      setStacked(options, opts.stacked);\n    }\n\n    if (opts.colors) {\n      options.colors = opts.colors;\n    }\n\n    if (opts.xtitle) {\n      setXtitle(options, opts.xtitle);\n    }\n\n    if (opts.ytitle) {\n      setYtitle(options, opts.ytitle);\n    }\n\n    // merge library last\n    options = merge(options, opts.library || {});\n\n    return options;\n  };\n}\n\nfunction sortByTime(a, b) {\n  return a[0].getTime() - b[0].getTime();\n}\n\nfunction sortByNumberSeries(a, b) {\n  return a[0] - b[0];\n}\n\nfunction sortByNumber(a, b) {\n  return a - b;\n}\n\nfunction isMinute(d) {\n  return d.getMilliseconds() === 0 && d.getSeconds() === 0;\n}\n\nfunction isHour(d) {\n  return isMinute(d) && d.getMinutes() === 0;\n}\n\nfunction isDay(d) {\n  return isHour(d) && d.getHours() === 0;\n}\n\nfunction isWeek(d, dayOfWeek) {\n  return isDay(d) && d.getDay() === dayOfWeek;\n}\n\nfunction isMonth(d) {\n  return isDay(d) && d.getDate() === 1;\n}\n\nfunction isYear(d) {\n  return isMonth(d) && d.getMonth() === 0;\n}\n\nfunction isDate(obj) {\n  return !isNaN(toDate(obj)) && toStr(obj).length >= 6;\n}\n\nfunction formatValue(pre, value, options) {\n  pre = pre || \"\";\n  if (options.prefix) {\n    if (value < 0) {\n      value = value * -1;\n      pre += \"-\";\n    }\n    pre += options.prefix;\n  }\n\n  if (options.thousands || options.decimal) {\n    value = toStr(value);\n    var parts = value.split(\".\");\n    value = parts[0];\n    if (options.thousands) {\n      value = value.replace(/\\B(?=(\\d{3})+(?!\\d))/g, options.thousands);\n    }\n    if (parts.length > 1) {\n      value += (options.decimal || \".\") + parts[1];\n    }\n  }\n\n  return pre + value + (options.suffix || \"\");\n}\n\nfunction allZeros(data) {\n  var i, j, d;\n  for (i = 0; i < data.length; i++) {\n    d = data[i].data;\n    for (j = 0; j < d.length; j++) {\n      if (d[j][1] != 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar baseOptions = {\n  maintainAspectRatio: false,\n  animation: false,\n  tooltips: {\n    displayColors: false,\n    callbacks: {}\n  },\n  legend: {},\n  title: {fontSize: 20, fontColor: \"#333\"}\n};\n\nvar defaultOptions = {\n  scales: {\n    yAxes: [\n      {\n        ticks: {\n          maxTicksLimit: 4\n        },\n        scaleLabel: {\n          fontSize: 16,\n          // fontStyle: \"bold\",\n          fontColor: \"#333\"\n        }\n      }\n    ],\n    xAxes: [\n      {\n        gridLines: {\n          drawOnChartArea: false\n        },\n        scaleLabel: {\n          fontSize: 16,\n          // fontStyle: \"bold\",\n          fontColor: \"#333\"\n        },\n        time: {},\n        ticks: {}\n      }\n    ]\n  }\n};\n\n// http://there4.io/2012/05/02/google-chart-color-list/\nvar defaultColors = [\n  \"#3366CC\", \"#DC3912\", \"#FF9900\", \"#109618\", \"#990099\", \"#3B3EAC\", \"#0099C6\",\n  \"#DD4477\", \"#66AA00\", \"#B82E2E\", \"#316395\", \"#994499\", \"#22AA99\", \"#AAAA11\",\n  \"#6633CC\", \"#E67300\", \"#8B0707\", \"#329262\", \"#5574A6\", \"#651067\"\n];\n\nvar hideLegend = function (options, legend, hideLegend) {\n  if (legend !== undefined) {\n    options.legend.display = !!legend;\n    if (legend && legend !== true) {\n      options.legend.position = legend;\n    }\n  } else if (hideLegend) {\n    options.legend.display = false;\n  }\n};\n\nvar setTitle = function (options, title) {\n  options.title.display = true;\n  options.title.text = title;\n};\n\nvar setMin = function (options, min) {\n  if (min !== null) {\n    options.scales.yAxes[0].ticks.min = toFloat(min);\n  }\n};\n\nvar setMax = function (options, max) {\n  options.scales.yAxes[0].ticks.max = toFloat(max);\n};\n\nvar setBarMin = function (options, min) {\n  if (min !== null) {\n    options.scales.xAxes[0].ticks.min = toFloat(min);\n  }\n};\n\nvar setBarMax = function (options, max) {\n  options.scales.xAxes[0].ticks.max = toFloat(max);\n};\n\nvar setStacked = function (options, stacked) {\n  options.scales.xAxes[0].stacked = !!stacked;\n  options.scales.yAxes[0].stacked = !!stacked;\n};\n\nvar setXtitle = function (options, title) {\n  options.scales.xAxes[0].scaleLabel.display = true;\n  options.scales.xAxes[0].scaleLabel.labelString = title;\n};\n\nvar setYtitle = function (options, title) {\n  options.scales.yAxes[0].scaleLabel.display = true;\n  options.scales.yAxes[0].scaleLabel.labelString = title;\n};\n\n// http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\nvar addOpacity = function(hex, opacity) {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? \"rgba(\" + parseInt(result[1], 16) + \", \" + parseInt(result[2], 16) + \", \" + parseInt(result[3], 16) + \", \" + opacity + \")\" : hex;\n};\n\nvar setLabelSize = function (chart, data, options) {\n  var maxLabelSize = Math.ceil(chart.element.offsetWidth / 4.0 / data.labels.length);\n  if (maxLabelSize > 25) {\n    maxLabelSize = 25;\n  }\n  options.scales.xAxes[0].ticks.callback = function (value) {\n    value = toStr(value);\n    if (value.length > maxLabelSize) {\n      return value.substring(0, maxLabelSize - 2) + \"...\";\n    } else {\n      return value;\n    }\n  };\n};\n\nvar setFormatOptions = function(chart, options, chartType) {\n  var formatOptions = {\n    prefix: chart.options.prefix,\n    suffix: chart.options.suffix,\n    thousands: chart.options.thousands,\n    decimal: chart.options.decimal\n  };\n\n  if (formatOptions.prefix || formatOptions.suffix || formatOptions.thousands || formatOptions.decimal) {\n    if (chartType !== \"pie\") {\n      var myAxes = options.scales.yAxes;\n      if (chartType === \"bar\") {\n        myAxes = options.scales.xAxes;\n      }\n\n      if (!myAxes[0].ticks.callback) {\n        myAxes[0].ticks.callback = function (value) {\n          return formatValue(\"\", value, formatOptions);\n        };\n      }\n    }\n\n    if (!options.tooltips.callbacks.label) {\n      if (chartType !== \"pie\") {\n        var valueLabel = chartType === \"bar\" ? \"xLabel\" : \"yLabel\";\n        options.tooltips.callbacks.label = function (tooltipItem, data) {\n          var label = data.datasets[tooltipItem.datasetIndex].label || '';\n          if (label) {\n            label += ': ';\n          }\n          return formatValue(label, tooltipItem[valueLabel], formatOptions);\n        };\n      } else {\n        // need to use separate label for pie charts\n        options.tooltips.callbacks.label = function (tooltipItem, data) {\n          var dataLabel = data.labels[tooltipItem.index];\n          var value = ': ';\n\n          if (isArray(dataLabel)) {\n            // show value on first line of multiline label\n            // need to clone because we are changing the value\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n\n          return formatValue(dataLabel, data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index], formatOptions);\n        };\n      }\n    }\n  }\n};\n\nvar jsOptions = jsOptionsFunc(merge(baseOptions, defaultOptions), hideLegend, setTitle, setMin, setMax, setStacked, setXtitle, setYtitle);\n\nvar createDataTable = function (chart, options, chartType) {\n  var datasets = [];\n  var labels = [];\n\n  var colors = chart.options.colors || defaultColors;\n\n  var day = true;\n  var week = true;\n  var dayOfWeek;\n  var month = true;\n  var year = true;\n  var hour = true;\n  var minute = true;\n  var detectType = (chartType === \"line\" || chartType === \"area\") && !chart.discrete;\n\n  var series = chart.data;\n\n  var sortedLabels = [];\n\n  var i, j, s, d, key, rows = [];\n  for (i = 0; i < series.length; i++) {\n    s = series[i];\n\n    for (j = 0; j < s.data.length; j++) {\n      d = s.data[j];\n      key = detectType ? d[0].getTime() : d[0];\n      if (!rows[key]) {\n        rows[key] = new Array(series.length);\n      }\n      rows[key][i] = toFloat(d[1]);\n      if (sortedLabels.indexOf(key) === -1) {\n        sortedLabels.push(key);\n      }\n    }\n  }\n\n  if (detectType || chart.options.xtype === \"number\") {\n    sortedLabels.sort(sortByNumber);\n  }\n\n  var rows2 = [];\n  for (j = 0; j < series.length; j++) {\n    rows2.push([]);\n  }\n\n  var value;\n  var k;\n  for (k = 0; k < sortedLabels.length; k++) {\n    i = sortedLabels[k];\n    if (detectType) {\n      value = new Date(toFloat(i));\n      // TODO make this efficient\n      day = day && isDay(value);\n      if (!dayOfWeek) {\n        dayOfWeek = value.getDay();\n      }\n      week = week && isWeek(value, dayOfWeek);\n      month = month && isMonth(value);\n      year = year && isYear(value);\n      hour = hour && isHour(value);\n      minute = minute && isMinute(value);\n    } else {\n      value = i;\n    }\n    labels.push(value);\n    for (j = 0; j < series.length; j++) {\n      // Chart.js doesn't like undefined\n      rows2[j].push(rows[i][j] === undefined ? null : rows[i][j]);\n    }\n  }\n\n  for (i = 0; i < series.length; i++) {\n    s = series[i];\n\n    var color = s.color || colors[i];\n    var backgroundColor = chartType !== \"line\" ? addOpacity(color, 0.5) : color;\n\n    var dataset = {\n      label: s.name,\n      data: rows2[i],\n      fill: chartType === \"area\",\n      borderColor: color,\n      backgroundColor: backgroundColor,\n      pointBackgroundColor: color,\n      pointHoverBackgroundColor: color,\n      borderWidth: 2\n    };\n\n    if (s.stack) {\n      dataset.stack = s.stack;\n    }\n\n    if (chart.options.curve === false) {\n      dataset.lineTension = 0;\n    }\n\n    if (chart.options.points === false) {\n      dataset.pointRadius = 0;\n      dataset.pointHitRadius = 5;\n    }\n\n    dataset = merge(dataset, chart.options.dataset || {});\n    dataset = merge(dataset, s.library || {});\n    dataset = merge(dataset, s.dataset || {});\n\n    datasets.push(dataset);\n  }\n\n  if (detectType && labels.length > 0) {\n    var minTime = labels[0].getTime();\n    var maxTime = labels[0].getTime();\n    for (i = 1; i < labels.length; i++) {\n      value = labels[i].getTime();\n      if (value < minTime) {\n        minTime = value;\n      }\n      if (value > maxTime) {\n        maxTime = value;\n      }\n    }\n\n    var timeDiff = (maxTime - minTime) / (86400 * 1000.0);\n\n    if (!options.scales.xAxes[0].time.unit) {\n      var step;\n      if (year || timeDiff > 365 * 10) {\n        options.scales.xAxes[0].time.unit = \"year\";\n        step = 365;\n      } else if (month || timeDiff > 30 * 10) {\n        options.scales.xAxes[0].time.unit = \"month\";\n        step = 30;\n      } else if (day || timeDiff > 10) {\n        options.scales.xAxes[0].time.unit = \"day\";\n        step = 1;\n      } else if (hour || timeDiff > 0.5) {\n        options.scales.xAxes[0].time.displayFormats = {hour: \"MMM D, h a\"};\n        options.scales.xAxes[0].time.unit = \"hour\";\n        step = 1 / 24.0;\n      } else if (minute) {\n        options.scales.xAxes[0].time.displayFormats = {minute: \"h:mm a\"};\n        options.scales.xAxes[0].time.unit = \"minute\";\n        step = 1 / 24.0 / 60.0;\n      }\n\n      if (step && timeDiff > 0) {\n        var unitStepSize = Math.ceil(timeDiff / step / (chart.element.offsetWidth / 100.0));\n        if (week && step === 1) {\n          unitStepSize = Math.ceil(unitStepSize / 7.0) * 7;\n        }\n        options.scales.xAxes[0].time.unitStepSize = unitStepSize;\n      }\n    }\n\n    if (!options.scales.xAxes[0].time.tooltipFormat) {\n      if (day) {\n        options.scales.xAxes[0].time.tooltipFormat = \"ll\";\n      } else if (hour) {\n        options.scales.xAxes[0].time.tooltipFormat = \"MMM D, h a\";\n      } else if (minute) {\n        options.scales.xAxes[0].time.tooltipFormat = \"h:mm a\";\n      }\n    }\n  }\n\n  var data = {\n    labels: labels,\n    datasets: datasets\n  };\n\n  return data;\n};\n\nvar defaultExport = function defaultExport(library) {\n  this.name = \"chartjs\";\n  this.library = library;\n};\n\ndefaultExport.prototype.renderLineChart = function renderLineChart (chart, chartType) {\n  if (chart.options.xtype === \"number\") {\n    return this.renderScatterChart(chart, chartType, true);\n  }\n\n  var chartOptions = {};\n  // fix for https://github.com/chartjs/Chart.js/issues/2441\n  if (!chart.options.max && allZeros(chart.data)) {\n    chartOptions.max = 1;\n  }\n\n  var options = jsOptions(chart, merge(chartOptions, chart.options));\n  setFormatOptions(chart, options, chartType);\n\n  var data = createDataTable(chart, options, chartType || \"line\");\n\n  options.scales.xAxes[0].type = chart.discrete ? \"category\" : \"time\";\n\n  this.drawChart(chart, \"line\", data, options);\n};\n\ndefaultExport.prototype.renderPieChart = function renderPieChart (chart) {\n  var options = merge({}, baseOptions);\n  if (chart.options.donut) {\n    options.cutoutPercentage = 50;\n  }\n\n  if (\"legend\" in chart.options) {\n    hideLegend(options, chart.options.legend);\n  }\n\n  if (chart.options.title) {\n    setTitle(options, chart.options.title);\n  }\n\n  options = merge(options, chart.options.library || {});\n  setFormatOptions(chart, options, \"pie\");\n\n  var labels = [];\n  var values = [];\n  for (var i = 0; i < chart.data.length; i++) {\n    var point = chart.data[i];\n    labels.push(point[0]);\n    values.push(point[1]);\n  }\n\n  var dataset = {\n    data: values,\n    backgroundColor: chart.options.colors || defaultColors\n  };\n  dataset = merge(dataset, chart.options.dataset || {});\n\n  var data = {\n    labels: labels,\n    datasets: [dataset]\n  };\n\n  this.drawChart(chart, \"pie\", data, options);\n};\n\ndefaultExport.prototype.renderColumnChart = function renderColumnChart (chart, chartType) {\n  var options;\n  if (chartType === \"bar\") {\n    options = jsOptionsFunc(merge(baseOptions, defaultOptions), hideLegend, setTitle, setBarMin, setBarMax, setStacked, setXtitle, setYtitle)(chart, chart.options);\n  } else {\n    options = jsOptions(chart, chart.options);\n  }\n  setFormatOptions(chart, options, chartType);\n  var data = createDataTable(chart, options, \"column\");\n  if (chartType !== \"bar\") {\n    setLabelSize(chart, data, options);\n  }\n  this.drawChart(chart, (chartType === \"bar\" ? \"horizontalBar\" : \"bar\"), data, options);\n};\n\ndefaultExport.prototype.renderAreaChart = function renderAreaChart (chart) {\n  this.renderLineChart(chart, \"area\");\n};\n\ndefaultExport.prototype.renderBarChart = function renderBarChart (chart) {\n  this.renderColumnChart(chart, \"bar\");\n};\n\ndefaultExport.prototype.renderScatterChart = function renderScatterChart (chart, chartType, lineChart) {\n  chartType = chartType || \"line\";\n\n  var options = jsOptions(chart, chart.options);\n  if (!lineChart) {\n    setFormatOptions(chart, options, chartType);\n  }\n\n  var colors = chart.options.colors || defaultColors;\n\n  var datasets = [];\n  var series = chart.data;\n  for (var i = 0; i < series.length; i++) {\n    var s = series[i];\n    var d = [];\n    for (var j = 0; j < s.data.length; j++) {\n      var point = {\n        x: toFloat(s.data[j][0]),\n        y: toFloat(s.data[j][1])\n      };\n      if (chartType === \"bubble\") {\n        point.r = toFloat(s.data[j][2]);\n      }\n      d.push(point);\n    }\n\n    var color = s.color || colors[i];\n    var backgroundColor = chartType === \"area\" ? addOpacity(color, 0.5) : color;\n\n    datasets.push({\n      label: s.name,\n      showLine: lineChart || false,\n      data: d,\n      borderColor: color,\n      backgroundColor: backgroundColor,\n      pointBackgroundColor: color,\n      fill: chartType === \"area\"\n    });\n  }\n\n  if (chartType === \"area\") {\n    chartType = \"line\";\n  }\n\n  var data = {datasets: datasets};\n\n  options.scales.xAxes[0].type = \"linear\";\n  options.scales.xAxes[0].position = \"bottom\";\n\n  this.drawChart(chart, chartType, data, options);\n};\n\ndefaultExport.prototype.renderBubbleChart = function renderBubbleChart (chart) {\n  this.renderScatterChart(chart, \"bubble\");\n};\n\ndefaultExport.prototype.destroy = function destroy (chart) {\n  if (chart.chart) {\n    chart.chart.destroy();\n  }\n};\n\ndefaultExport.prototype.drawChart = function drawChart (chart, type, data, options) {\n  this.destroy(chart);\n\n  chart.element.innerHTML = \"<canvas></canvas>\";\n  var ctx = chart.element.getElementsByTagName(\"CANVAS\")[0];\n  chart.chart = new this.library(ctx, {\n    type: type,\n    data: data,\n    options: options\n  });\n};\n\nvar defaultOptions$1 = {\n  chart: {},\n  xAxis: {\n    title: {\n      text: null\n    },\n    labels: {\n      style: {\n        fontSize: \"12px\"\n      }\n    }\n  },\n  yAxis: {\n    title: {\n      text: null\n    },\n    labels: {\n      style: {\n        fontSize: \"12px\"\n      }\n    }\n  },\n  title: {\n    text: null\n  },\n  credits: {\n    enabled: false\n  },\n  legend: {\n    borderWidth: 0\n  },\n  tooltip: {\n    style: {\n      fontSize: \"12px\"\n    }\n  },\n  plotOptions: {\n    areaspline: {},\n    series: {\n      marker: {}\n    }\n  }\n};\n\nvar hideLegend$1 = function (options, legend, hideLegend) {\n  if (legend !== undefined) {\n    options.legend.enabled = !!legend;\n    if (legend && legend !== true) {\n      if (legend === \"top\" || legend === \"bottom\") {\n        options.legend.verticalAlign = legend;\n      } else {\n        options.legend.layout = \"vertical\";\n        options.legend.verticalAlign = \"middle\";\n        options.legend.align = legend;\n      }\n    }\n  } else if (hideLegend) {\n    options.legend.enabled = false;\n  }\n};\n\nvar setTitle$1 = function (options, title) {\n  options.title.text = title;\n};\n\nvar setMin$1 = function (options, min) {\n  options.yAxis.min = min;\n};\n\nvar setMax$1 = function (options, max) {\n  options.yAxis.max = max;\n};\n\nvar setStacked$1 = function (options, stacked) {\n  options.plotOptions.series.stacking = stacked ? (stacked === true ? \"normal\" : stacked) : null;\n};\n\nvar setXtitle$1 = function (options, title) {\n  options.xAxis.title.text = title;\n};\n\nvar setYtitle$1 = function (options, title) {\n  options.yAxis.title.text = title;\n};\n\nvar jsOptions$1 = jsOptionsFunc(defaultOptions$1, hideLegend$1, setTitle$1, setMin$1, setMax$1, setStacked$1, setXtitle$1, setYtitle$1);\n\nvar setFormatOptions$1 = function(chart, options, chartType) {\n  var formatOptions = {\n    prefix: chart.options.prefix,\n    suffix: chart.options.suffix,\n    thousands: chart.options.thousands,\n    decimal: chart.options.decimal\n  };\n\n  if (formatOptions.prefix || formatOptions.suffix || formatOptions.thousands || formatOptions.decimal) {\n    if (chartType !== \"pie\" && !options.yAxis.labels.formatter) {\n      options.yAxis.labels.formatter = function () {\n        return formatValue(\"\", this.value, formatOptions);\n      };\n    }\n\n    if (!options.tooltip.pointFormatter) {\n      options.tooltip.pointFormatter = function () {\n        return '<span style=\"color:' + this.color + '>\\u25CF</span> ' + formatValue(this.series.name + ': <b>', this.y, formatOptions) + '</b><br/>';\n      };\n    }\n  }\n};\n\nvar defaultExport$1 = function defaultExport(library) {\n  this.name = \"highcharts\";\n  this.library = library;\n};\n\ndefaultExport$1.prototype.renderLineChart = function renderLineChart (chart, chartType) {\n  chartType = chartType || \"spline\";\n  var chartOptions = {};\n  if (chartType === \"areaspline\") {\n    chartOptions = {\n      plotOptions: {\n        areaspline: {\n          stacking: \"normal\"\n        },\n        area: {\n          stacking: \"normal\"\n        },\n        series: {\n          marker: {\n            enabled: false\n          }\n        }\n      }\n    };\n  }\n\n  if (chart.options.curve === false) {\n    if (chartType === \"areaspline\") {\n      chartType = \"area\";\n    } else if (chartType === \"spline\") {\n      chartType = \"line\";\n    }\n  }\n\n  var options = jsOptions$1(chart, chart.options, chartOptions), data, i, j;\n  options.xAxis.type = chart.discrete ? \"category\" : \"datetime\";\n  if (!options.chart.type) {\n    options.chart.type = chartType;\n  }\n  setFormatOptions$1(chart, options, chartType);\n\n  var series = chart.data;\n  for (i = 0; i < series.length; i++) {\n    data = series[i].data;\n    if (!chart.discrete) {\n      for (j = 0; j < data.length; j++) {\n        data[j][0] = data[j][0].getTime();\n      }\n    }\n    series[i].marker = {symbol: \"circle\"};\n    if (chart.options.points === false) {\n      series[i].marker.enabled = false;\n    }\n  }\n\n  this.drawChart(chart, series, options);\n};\n\ndefaultExport$1.prototype.renderScatterChart = function renderScatterChart (chart) {\n  var options = jsOptions$1(chart, chart.options, {});\n  options.chart.type = \"scatter\";\n  this.drawChart(chart, chart.data, options);\n};\n\ndefaultExport$1.prototype.renderPieChart = function renderPieChart (chart) {\n  var chartOptions = merge(defaultOptions$1, {});\n\n  if (chart.options.colors) {\n    chartOptions.colors = chart.options.colors;\n  }\n  if (chart.options.donut) {\n    chartOptions.plotOptions = {pie: {innerSize: \"50%\"}};\n  }\n\n  if (\"legend\" in chart.options) {\n    hideLegend$1(chartOptions, chart.options.legend);\n  }\n\n  if (chart.options.title) {\n    setTitle$1(chartOptions, chart.options.title);\n  }\n\n  var options = merge(chartOptions, chart.options.library || {});\n  setFormatOptions$1(chart, options, \"pie\");\n  var series = [{\n    type: \"pie\",\n    name: chart.options.label || \"Value\",\n    data: chart.data\n  }];\n\n  this.drawChart(chart, series, options);\n};\n\ndefaultExport$1.prototype.renderColumnChart = function renderColumnChart (chart, chartType) {\n  chartType = chartType || \"column\";\n  var series = chart.data;\n  var options = jsOptions$1(chart, chart.options), i, j, s, d, rows = [], categories = [];\n  options.chart.type = chartType;\n  setFormatOptions$1(chart, options, chartType);\n\n  for (i = 0; i < series.length; i++) {\n    s = series[i];\n\n    for (j = 0; j < s.data.length; j++) {\n      d = s.data[j];\n      if (!rows[d[0]]) {\n        rows[d[0]] = new Array(series.length);\n        categories.push(d[0]);\n      }\n      rows[d[0]][i] = d[1];\n    }\n  }\n\n  if (chart.options.xtype === \"number\") {\n    categories.sort(sortByNumber);\n  }\n\n  options.xAxis.categories = categories;\n\n  var newSeries = [], d2;\n  for (i = 0; i < series.length; i++) {\n    d = [];\n    for (j = 0; j < categories.length; j++) {\n      d.push(rows[categories[j]][i] || 0);\n    }\n\n    d2 = {\n      name: series[i].name,\n      data: d\n    };\n    if (series[i].stack) {\n      d2.stack = series[i].stack;\n    }\n\n    newSeries.push(d2);\n  }\n\n  this.drawChart(chart, newSeries, options);\n};\n\ndefaultExport$1.prototype.renderBarChart = function renderBarChart (chart) {\n  this.renderColumnChart(chart, \"bar\");\n};\n\ndefaultExport$1.prototype.renderAreaChart = function renderAreaChart (chart) {\n  this.renderLineChart(chart, \"areaspline\");\n};\n\ndefaultExport$1.prototype.destroy = function destroy (chart) {\n  if (chart.chart) {\n    chart.chart.destroy();\n  }\n};\n\ndefaultExport$1.prototype.drawChart = function drawChart (chart, data, options) {\n  this.destroy(chart);\n\n  options.chart.renderTo = chart.element.id;\n  options.series = data;\n  chart.chart = new this.library.Chart(options);\n};\n\nvar loaded = {};\nvar callbacks = [];\n\n// Set chart options\nvar defaultOptions$2 = {\n  chartArea: {},\n  fontName: \"'Lucida Grande', 'Lucida Sans Unicode', Verdana, Arial, Helvetica, sans-serif\",\n  pointSize: 6,\n  legend: {\n    textStyle: {\n      fontSize: 12,\n      color: \"#444\"\n    },\n    alignment: \"center\",\n    position: \"right\"\n  },\n  curveType: \"function\",\n  hAxis: {\n    textStyle: {\n      color: \"#666\",\n      fontSize: 12\n    },\n    titleTextStyle: {},\n    gridlines: {\n      color: \"transparent\"\n    },\n    baselineColor: \"#ccc\",\n    viewWindow: {}\n  },\n  vAxis: {\n    textStyle: {\n      color: \"#666\",\n      fontSize: 12\n    },\n    titleTextStyle: {},\n    baselineColor: \"#ccc\",\n    viewWindow: {}\n  },\n  tooltip: {\n    textStyle: {\n      color: \"#666\",\n      fontSize: 12\n    }\n  }\n};\n\nvar hideLegend$2 = function (options, legend, hideLegend) {\n  if (legend !== undefined) {\n    var position;\n    if (!legend) {\n      position = \"none\";\n    } else if (legend === true) {\n      position = \"right\";\n    } else {\n      position = legend;\n    }\n    options.legend.position = position;\n  } else if (hideLegend) {\n    options.legend.position = \"none\";\n  }\n};\n\nvar setTitle$2 = function (options, title) {\n  options.title = title;\n  options.titleTextStyle = {color: \"#333\", fontSize: \"20px\"};\n};\n\nvar setMin$2 = function (options, min) {\n  options.vAxis.viewWindow.min = min;\n};\n\nvar setMax$2 = function (options, max) {\n  options.vAxis.viewWindow.max = max;\n};\n\nvar setBarMin$1 = function (options, min) {\n  options.hAxis.viewWindow.min = min;\n};\n\nvar setBarMax$1 = function (options, max) {\n  options.hAxis.viewWindow.max = max;\n};\n\nvar setStacked$2 = function (options, stacked) {\n  options.isStacked = stacked ? stacked : false;\n};\n\nvar setXtitle$2 = function (options, title) {\n  options.hAxis.title = title;\n  options.hAxis.titleTextStyle.italic = false;\n};\n\nvar setYtitle$2 = function (options, title) {\n  options.vAxis.title = title;\n  options.vAxis.titleTextStyle.italic = false;\n};\n\nvar jsOptions$2 = jsOptionsFunc(defaultOptions$2, hideLegend$2, setTitle$2, setMin$2, setMax$2, setStacked$2, setXtitle$2, setYtitle$2);\n\nvar resize = function (callback) {\n  if (window.attachEvent) {\n    window.attachEvent(\"onresize\", callback);\n  } else if (window.addEventListener) {\n    window.addEventListener(\"resize\", callback, true);\n  }\n  callback();\n};\n\nvar defaultExport$2 = function defaultExport(library) {\n  this.name = \"google\";\n  this.library = library;\n};\n\ndefaultExport$2.prototype.renderLineChart = function renderLineChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {};\n\n    if (chart.options.curve === false) {\n      chartOptions.curveType = \"none\";\n    }\n\n    if (chart.options.points === false) {\n      chartOptions.pointSize = 0;\n    }\n\n    var options = jsOptions$2(chart, chart.options, chartOptions);\n    var columnType = chart.discrete ? \"string\" : \"datetime\";\n    if (chart.options.xtype === \"number\") {\n      columnType = \"number\";\n    }\n    var data = this$1.createDataTable(chart.data, columnType);\n\n    this$1.drawChart(chart, this$1.library.visualization.LineChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderPieChart = function renderPieChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {\n      chartArea: {\n        top: \"10%\",\n        height: \"80%\"\n      },\n      legend: {}\n    };\n    if (chart.options.colors) {\n      chartOptions.colors = chart.options.colors;\n    }\n    if (chart.options.donut) {\n      chartOptions.pieHole = 0.5;\n    }\n    if (\"legend\" in chart.options) {\n      hideLegend$2(chartOptions, chart.options.legend);\n    }\n    if (chart.options.title) {\n      setTitle$2(chartOptions, chart.options.title);\n    }\n    var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n\n    var data = new this$1.library.visualization.DataTable();\n    data.addColumn(\"string\", \"\");\n    data.addColumn(\"number\", \"Value\");\n    data.addRows(chart.data);\n\n    this$1.drawChart(chart, this$1.library.visualization.PieChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderColumnChart = function renderColumnChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var options = jsOptions$2(chart, chart.options);\n    var data = this$1.createDataTable(chart.data, \"string\", chart.options.xtype);\n\n    this$1.drawChart(chart, this$1.library.visualization.ColumnChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderBarChart = function renderBarChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {\n      hAxis: {\n        gridlines: {\n          color: \"#ccc\"\n        }\n      }\n    };\n    var options = jsOptionsFunc(defaultOptions$2, hideLegend$2, setTitle$2, setBarMin$1, setBarMax$1, setStacked$2, setXtitle$2, setYtitle$2)(chart, chart.options, chartOptions);\n    var data = this$1.createDataTable(chart.data, \"string\", chart.options.xtype);\n\n    this$1.drawChart(chart, this$1.library.visualization.BarChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderAreaChart = function renderAreaChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {\n      isStacked: true,\n      pointSize: 0,\n      areaOpacity: 0.5\n    };\n\n    var options = jsOptions$2(chart, chart.options, chartOptions);\n    var columnType = chart.discrete ? \"string\" : \"datetime\";\n    if (chart.options.xtype === \"number\") {\n      columnType = \"number\";\n    }\n    var data = this$1.createDataTable(chart.data, columnType);\n\n    this$1.drawChart(chart, this$1.library.visualization.AreaChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderGeoChart = function renderGeoChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {\n      legend: \"none\",\n      colorAxis: {\n        colors: chart.options.colors || [\"#f6c7b6\", \"#ce502d\"]\n      }\n    };\n    var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n\n    var data = new this$1.library.visualization.DataTable();\n    data.addColumn(\"string\", \"\");\n    data.addColumn(\"number\", chart.options.label || \"Value\");\n    data.addRows(chart.data);\n\n    this$1.drawChart(chart, this$1.library.visualization.GeoChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderScatterChart = function renderScatterChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {};\n    var options = jsOptions$2(chart, chart.options, chartOptions);\n\n    var series = chart.data, rows2 = [], i, j, data, d;\n    for (i = 0; i < series.length; i++) {\n      d = series[i].data;\n      for (j = 0; j < d.length; j++) {\n        var row = new Array(series.length + 1);\n        row[0] = d[j][0];\n        row[i + 1] = d[j][1];\n        rows2.push(row);\n      }\n    }\n\n    data = new this$1.library.visualization.DataTable();\n    data.addColumn(\"number\", \"\");\n    for (i = 0; i < series.length; i++) {\n      data.addColumn(\"number\", series[i].name);\n    }\n    data.addRows(rows2);\n\n    this$1.drawChart(chart, this$1.library.visualization.ScatterChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderTimeline = function renderTimeline (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, \"timeline\", function () {\n    var chartOptions = {\n      legend: \"none\"\n    };\n\n    if (chart.options.colors) {\n      chartOptions.colors = chart.options.colors;\n    }\n    var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n\n    var data = new this$1.library.visualization.DataTable();\n    data.addColumn({type: \"string\", id: \"Name\"});\n    data.addColumn({type: \"date\", id: \"Start\"});\n    data.addColumn({type: \"date\", id: \"End\"});\n    data.addRows(chart.data);\n\n    chart.element.style.lineHeight = \"normal\";\n\n    this$1.drawChart(chart, this$1.library.visualization.Timeline, data, options);\n  });\n};\n\ndefaultExport$2.prototype.destroy = function destroy (chart) {\n  if (chart.chart) {\n    chart.chart.clearChart();\n  }\n};\n\ndefaultExport$2.prototype.drawChart = function drawChart (chart, type, data, options) {\n  this.destroy(chart);\n\n  chart.chart = new type(chart.element);\n  resize(function () {\n    chart.chart.draw(data, options);\n  });\n};\n\ndefaultExport$2.prototype.waitForLoaded = function waitForLoaded (chart, pack, callback) {\n    var this$1 = this;\n\n  if (!callback) {\n    callback = pack;\n    pack = \"corechart\";\n  }\n\n  callbacks.push({pack: pack, callback: callback});\n\n  if (loaded[pack]) {\n    this.runCallbacks();\n  } else {\n    loaded[pack] = true;\n\n    // https://groups.google.com/forum/#!topic/google-visualization-api/fMKJcyA2yyI\n    var loadOptions = {\n      packages: [pack],\n      callback: function () { this$1.runCallbacks(); }\n    };\n    var config = chart.__config();\n    if (config.language) {\n      loadOptions.language = config.language;\n    }\n    if (pack === \"corechart\" && config.mapsApiKey) {\n      loadOptions.mapsApiKey = config.mapsApiKey;\n    }\n\n    if (this.library.setOnLoadCallback) {\n      this.library.load(\"visualization\", \"1\", loadOptions);\n    } else {\n      this.library.charts.load(\"current\", loadOptions);\n    }\n  }\n};\n\ndefaultExport$2.prototype.runCallbacks = function runCallbacks () {\n    var this$1 = this;\n\n  var cb, call;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    call = this$1.library.visualization && ((cb.pack === \"corechart\" && this$1.library.visualization.LineChart) || (cb.pack === \"timeline\" && this$1.library.visualization.Timeline));\n    if (call) {\n      cb.callback();\n      callbacks.splice(i, 1);\n      i--;\n    }\n  }\n};\n\n// cant use object as key\ndefaultExport$2.prototype.createDataTable = function createDataTable (series, columnType, xtype) {\n  var i, j, s, d, key, rows = [], sortedLabels = [];\n  for (i = 0; i < series.length; i++) {\n    s = series[i];\n\n    for (j = 0; j < s.data.length; j++) {\n      d = s.data[j];\n      key = (columnType === \"datetime\") ? d[0].getTime() : d[0];\n      if (!rows[key]) {\n        rows[key] = new Array(series.length);\n        sortedLabels.push(key);\n      }\n      rows[key][i] = toFloat(d[1]);\n    }\n  }\n\n  var rows2 = [];\n  var day = true;\n  var value;\n  for (j = 0; j < sortedLabels.length; j++) {\n    i = sortedLabels[j];\n    if (columnType === \"datetime\") {\n      value = new Date(toFloat(i));\n      day = day && isDay(value);\n    } else if (columnType === \"number\") {\n      value = toFloat(i);\n    } else {\n      value = i;\n    }\n    rows2.push([value].concat(rows[i]));\n  }\n  if (columnType === \"datetime\") {\n    rows2.sort(sortByTime);\n  } else if (columnType === \"number\") {\n    rows2.sort(sortByNumberSeries);\n  }\n\n  if (xtype === \"number\") {\n    rows2.sort(sortByNumberSeries);\n\n    for (i = 0; i < rows2.length; i++) {\n      rows2[i][0] = toStr(rows2[i][0]);\n    }\n  }\n\n  // create datatable\n  var data = new this.library.visualization.DataTable();\n  columnType = columnType === \"datetime\" && day ? \"date\" : columnType;\n  data.addColumn(columnType, \"\");\n  for (i = 0; i < series.length; i++) {\n    data.addColumn(\"number\", series[i].name);\n  }\n  data.addRows(rows2);\n\n  return data;\n};\n\nvar pendingRequests = [], runningRequests = 0, maxRequests = 4;\n\nfunction pushRequest(url, success, error) {\n  pendingRequests.push([url, success, error]);\n  runNext();\n}\n\nfunction runNext() {\n  if (runningRequests < maxRequests) {\n    var request = pendingRequests.shift();\n    if (request) {\n      runningRequests++;\n      getJSON(request[0], request[1], request[2]);\n      runNext();\n    }\n  }\n}\n\nfunction requestComplete() {\n  runningRequests--;\n  runNext();\n}\n\nfunction getJSON(url, success, error) {\n  ajaxCall(url, success, function (jqXHR, textStatus, errorThrown) {\n    var message = (typeof errorThrown === \"string\") ? errorThrown : errorThrown.message;\n    error(message);\n  });\n}\n\nfunction ajaxCall(url, success, error) {\n  var $ = window.jQuery || window.Zepto || window.$;\n\n  if ($) {\n    $.ajax({\n      dataType: \"json\",\n      url: url,\n      success: success,\n      error: error,\n      complete: requestComplete\n    });\n  } else {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, true);\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n    xhr.onload = function () {\n      requestComplete();\n      if (xhr.status === 200) {\n        success(JSON.parse(xhr.responseText), xhr.statusText, xhr);\n      } else {\n        error(xhr, \"error\", xhr.statusText);\n      }\n    };\n    xhr.send();\n  }\n}\n\nvar config = (typeof window !== \"undefined\" && window.Chartkick) || {};\nvar adapters = [];\n\n// helpers\n\nfunction setText(element, text) {\n  if (document.body.innerText) {\n    element.innerText = text;\n  } else {\n    element.textContent = text;\n  }\n}\n\nfunction chartError(element, message) {\n  setText(element, \"Error Loading Chart: \" + message);\n  element.style.color = \"#ff0000\";\n}\n\nfunction errorCatcher(chart) {\n  try {\n    chart.__render();\n  } catch (err) {\n    chartError(chart.element, err.message);\n    throw err;\n  }\n}\n\nfunction fetchDataSource(chart, dataSource) {\n  if (typeof dataSource === \"string\") {\n    pushRequest(dataSource, function (data) {\n      chart.rawData = data;\n      errorCatcher(chart);\n    }, function (message) {\n      chartError(chart.element, message);\n    });\n  } else {\n    chart.rawData = dataSource;\n    errorCatcher(chart);\n  }\n}\n\nfunction addDownloadButton(chart) {\n  var element = chart.element;\n  var link = document.createElement(\"a\");\n  link.download = chart.options.download === true ? \"chart.png\" : chart.options.download; // http://caniuse.com/download\n  link.style.position = \"absolute\";\n  link.style.top = \"20px\";\n  link.style.right = \"20px\";\n  link.style.zIndex = 1000;\n  link.style.lineHeight = \"20px\";\n  link.target = \"_blank\"; // for safari\n  var image = document.createElement(\"img\");\n  image.alt = \"Download\";\n  image.style.border = \"none\";\n  // icon from font-awesome\n  // http://fa2png.io/\n  image.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAABCFBMVEUAAADMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMywEsqxAAAAV3RSTlMAAQIDBggJCgsMDQ4PERQaHB0eISIjJCouLzE0OTo/QUJHSUpLTU5PUllhYmltcHh5foWLjI+SlaCio6atr7S1t7m6vsHHyM7R2tze5Obo7fHz9ff5+/1hlxK2AAAA30lEQVQYGUXBhVYCQQBA0TdYWAt2d3d3YWAHyur7/z9xgD16Lw0DW+XKx+1GgX+FRzM3HWQWrHl5N/oapW5RPe0PkBu+UYeICvozTWZVK23Ao04B79oJrOsJDOoxkZoQPWgX29pHpCZEk7rEvQYiNSFq1UMqvlCjJkRBS1R8hb00Vb/TajtBL7nTHE1X1vyMQF732dQhyF2o6SAwrzP06iUQzvwsArlnzcOdrgBhJyHa1QOgO9U1GsKuvjUTjavliZYQ8nNPapG6sap/3nrIdJ6bOWzmX/fy0XVpfzZP3S8OJT3g9EEiJwAAAABJRU5ErkJggg==\";\n  link.appendChild(image);\n  element.style.position = \"relative\";\n\n  chart.__downloadAttached = true;\n\n  // mouseenter\n  chart.__enterEvent = addEvent(element, \"mouseover\", function(e) {\n    var related = e.relatedTarget;\n    // check download option again to ensure it wasn't changed\n    if ((!related || (related !== this && !childOf(this, related))) && chart.options.download) {\n      link.href = chart.toImage();\n      element.appendChild(link);\n    }\n  });\n\n  // mouseleave\n  chart.__leaveEvent = addEvent(element, \"mouseout\", function(e) {\n    var related = e.relatedTarget;\n    if (!related || (related !== this && !childOf(this, related))) {\n      if (link.parentNode) {\n        link.parentNode.removeChild(link);\n      }\n    }\n  });\n}\n\n// http://stackoverflow.com/questions/10149963/adding-event-listener-cross-browser\nfunction addEvent(elem, event, fn) {\n  if (elem.addEventListener) {\n    elem.addEventListener(event, fn, false);\n    return fn;\n  } else {\n    var fn2 = function() {\n      // set the this pointer same as addEventListener when fn is called\n      return(fn.call(elem, window.event));\n    };\n    elem.attachEvent(\"on\" + event, fn2);\n    return fn2;\n  }\n}\n\nfunction removeEvent(elem, event, fn) {\n  if (elem.removeEventListener) {\n    elem.removeEventListener(event, fn, false);\n  } else {\n    elem.detachEvent(\"on\" + event, fn);\n  }\n}\n\n// https://gist.github.com/shawnbot/4166283\nfunction childOf(p, c) {\n  if (p === c) { return false; }\n  while (c && c !== p) { c = c.parentNode; }\n  return c === p;\n}\n\nfunction getAdapterType(library) {\n  if (library) {\n    if (library.product === \"Highcharts\") {\n      return defaultExport$1;\n    } else if (library.setOnLoadCallback || library.charts) {\n      return defaultExport$2;\n    } else if (isFunction(library)) {\n      return defaultExport;\n    }\n  }\n  throw new Error(\"Unknown adapter\");\n}\n\nfunction addAdapter(library) {\n  var adapterType = getAdapterType(library);\n  var adapter = new adapterType(library);\n\n  if (adapters.indexOf(adapter) === -1) {\n    adapters.push(adapter);\n  }\n}\n\nfunction loadAdapters() {\n  if (\"Chart\" in window) {\n    addAdapter(window.Chart);\n  }\n\n  if (\"Highcharts\" in window) {\n    addAdapter(window.Highcharts);\n  }\n\n  if (window.google && (window.google.setOnLoadCallback || window.google.charts)) {\n    addAdapter(window.google);\n  }\n}\n\nfunction dataEmpty(data, chartType) {\n  if (chartType === \"PieChart\" || chartType === \"GeoChart\" || chartType === \"Timeline\") {\n    return data.length === 0;\n  } else {\n    for (var i = 0; i < data.length; i++) {\n      if (data[i].data.length > 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nfunction renderChart(chartType, chart) {\n  if (chart.options.messages && chart.options.messages.empty && dataEmpty(chart.data, chartType)) {\n    setText(chart.element, chart.options.messages.empty);\n  } else {\n    callAdapter(chartType, chart);\n    if (chart.options.download && !chart.__downloadAttached && chart.adapter === \"chartjs\") {\n      addDownloadButton(chart);\n    }\n  }\n}\n\n// TODO remove chartType if cross-browser way\n// to get the name of the chart class\nfunction callAdapter(chartType, chart) {\n  var i, adapter, fnName, adapterName;\n  fnName = \"render\" + chartType;\n  adapterName = chart.options.adapter;\n\n  loadAdapters();\n\n  for (i = 0; i < adapters.length; i++) {\n    adapter = adapters[i];\n    if ((!adapterName || adapterName === adapter.name) && isFunction(adapter[fnName])) {\n      chart.adapter = adapter.name;\n      chart.__adapterObject = adapter;\n      return adapter[fnName](chart);\n    }\n  }\n\n  if (adapters.length > 0) {\n    throw new Error(\"No charting library found for \" + chartType);\n  } else {\n    throw new Error(\"No charting libraries found - be sure to include one before your charts\");\n  }\n}\n\n// process data\n\nvar toFormattedKey = function (key, keyType) {\n  if (keyType === \"number\") {\n    key = toFloat(key);\n  } else if (keyType === \"datetime\") {\n    key = toDate(key);\n  } else {\n    key = toStr(key);\n  }\n  return key;\n};\n\nvar formatSeriesData = function (data, keyType) {\n  var r = [], key, j;\n  for (j = 0; j < data.length; j++) {\n    if (keyType === \"bubble\") {\n      r.push([toFloat(data[j][0]), toFloat(data[j][1]), toFloat(data[j][2])]);\n    } else {\n      key = toFormattedKey(data[j][0], keyType);\n      r.push([key, toFloat(data[j][1])]);\n    }\n  }\n  if (keyType === \"datetime\") {\n    r.sort(sortByTime);\n  } else if (keyType === \"number\") {\n    r.sort(sortByNumberSeries);\n  }\n  return r;\n};\n\nfunction detectDiscrete(series) {\n  var i, j, data;\n  for (i = 0; i < series.length; i++) {\n    data = toArr(series[i].data);\n    for (j = 0; j < data.length; j++) {\n      if (!isDate(data[j][0])) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// creates a shallow copy of each element of the array\n// elements are expected to be objects\nfunction copySeries(series) {\n  var newSeries = [], i, j;\n  for (i = 0; i < series.length; i++) {\n    var copy = {};\n    for (j in series[i]) {\n      if (series[i].hasOwnProperty(j)) {\n        copy[j] = series[i][j];\n      }\n    }\n    newSeries.push(copy);\n  }\n  return newSeries;\n}\n\nfunction processSeries(chart, keyType) {\n  var i;\n\n  var opts = chart.options;\n  var series = chart.rawData;\n\n  // see if one series or multiple\n  if (!isArray(series) || typeof series[0] !== \"object\" || isArray(series[0])) {\n    series = [{name: opts.label || \"Value\", data: series}];\n    chart.hideLegend = true;\n  } else {\n    chart.hideLegend = false;\n  }\n  if ((opts.discrete === null || opts.discrete === undefined) && keyType !== \"bubble\" && keyType !== \"number\") {\n    chart.discrete = detectDiscrete(series);\n  } else {\n    chart.discrete = opts.discrete;\n  }\n  if (chart.discrete) {\n    keyType = \"string\";\n  }\n  if (chart.options.xtype) {\n    keyType = chart.options.xtype;\n  }\n\n  // right format\n  series = copySeries(series);\n  for (i = 0; i < series.length; i++) {\n    series[i].data = formatSeriesData(toArr(series[i].data), keyType);\n  }\n\n  return series;\n}\n\nfunction processSimple(chart) {\n  var perfectData = toArr(chart.rawData), i;\n  for (i = 0; i < perfectData.length; i++) {\n    perfectData[i] = [toStr(perfectData[i][0]), toFloat(perfectData[i][1])];\n  }\n  return perfectData;\n}\n\n// define classes\n\nvar Chart = function Chart(element, dataSource, options) {\n  var elementId;\n  if (typeof element === \"string\") {\n    elementId = element;\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error(\"No element with id \" + elementId);\n    }\n  }\n  this.element = element;\n  this.options = merge(Chartkick.options, options || {});\n  this.dataSource = dataSource;\n\n  Chartkick.charts[element.id] = this;\n\n  fetchDataSource(this, dataSource);\n\n  if (this.options.refresh) {\n    this.startRefresh();\n  }\n};\n\nChart.prototype.getElement = function getElement () {\n  return this.element;\n};\n\nChart.prototype.getDataSource = function getDataSource () {\n  return this.dataSource;\n};\n\nChart.prototype.getData = function getData () {\n  return this.data;\n};\n\nChart.prototype.getOptions = function getOptions () {\n  return this.options;\n};\n\nChart.prototype.getChartObject = function getChartObject () {\n  return this.chart;\n};\n\nChart.prototype.getAdapter = function getAdapter () {\n  return this.adapter;\n};\n\nChart.prototype.updateData = function updateData (dataSource, options) {\n  this.dataSource = dataSource;\n  if (options) {\n    this.__updateOptions(options);\n  }\n  fetchDataSource(this, dataSource);\n};\n\nChart.prototype.setOptions = function setOptions (options) {\n  this.__updateOptions(options);\n  this.redraw();\n};\n\nChart.prototype.redraw = function redraw () {\n  fetchDataSource(this, this.rawData);\n};\n\nChart.prototype.refreshData = function refreshData () {\n  if (typeof this.dataSource === \"string\") {\n    // prevent browser from caching\n    var sep = this.dataSource.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n    var url = this.dataSource + sep + \"_=\" + (new Date()).getTime();\n    fetchDataSource(this, url);\n  }\n};\n\nChart.prototype.startRefresh = function startRefresh () {\n    var this$1 = this;\n\n  var refresh = this.options.refresh;\n\n  if (!this.intervalId) {\n    if (refresh) {\n      this.intervalId = setInterval( function () {\n        this$1.refreshData();\n      }, refresh * 1000);\n    } else {\n      throw new Error(\"No refresh interval\");\n    }\n  }\n};\n\nChart.prototype.stopRefresh = function stopRefresh () {\n  if (this.intervalId) {\n    clearInterval(this.intervalId);\n    this.intervalId = null;\n  }\n};\n\nChart.prototype.toImage = function toImage () {\n  if (this.adapter === \"chartjs\") {\n    return this.chart.toBase64Image();\n  } else {\n    return null;\n  }\n};\n\nChart.prototype.destroy = function destroy () {\n  if (this.__adapterObject) {\n    this.__adapterObject.destroy(this);\n  }\n\n  if (this.__enterEvent) {\n    removeEvent(this.element, \"mouseover\", this.__enterEvent);\n  }\n\n  if (this.__leaveEvent) {\n    removeEvent(this.element, \"mouseout\", this.__leaveEvent);\n  }\n};\n\nChart.prototype.__updateOptions = function __updateOptions (options) {\n  var updateRefresh = options.refresh && options.refresh !== this.options.refresh;\n  this.options = merge(Chartkick.options, options);\n  if (updateRefresh) {\n    this.stopRefresh();\n    this.startRefresh();\n  }\n};\n\nChart.prototype.__render = function __render () {\n  this.data = this.__processData();\n  renderChart(this.__chartName(), this);\n};\n\nChart.prototype.__config = function __config () {\n  return config;\n};\n\nvar LineChart = (function (Chart) {\n  function LineChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) LineChart.__proto__ = Chart;\n  LineChart.prototype = Object.create( Chart && Chart.prototype );\n  LineChart.prototype.constructor = LineChart;\n\n  LineChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"datetime\");\n  };\n\n  LineChart.prototype.__chartName = function __chartName () {\n    return \"LineChart\";\n  };\n\n  return LineChart;\n}(Chart));\n\nvar PieChart = (function (Chart) {\n  function PieChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) PieChart.__proto__ = Chart;\n  PieChart.prototype = Object.create( Chart && Chart.prototype );\n  PieChart.prototype.constructor = PieChart;\n\n  PieChart.prototype.__processData = function __processData () {\n    return processSimple(this);\n  };\n\n  PieChart.prototype.__chartName = function __chartName () {\n    return \"PieChart\";\n  };\n\n  return PieChart;\n}(Chart));\n\nvar ColumnChart = (function (Chart) {\n  function ColumnChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) ColumnChart.__proto__ = Chart;\n  ColumnChart.prototype = Object.create( Chart && Chart.prototype );\n  ColumnChart.prototype.constructor = ColumnChart;\n\n  ColumnChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"string\");\n  };\n\n  ColumnChart.prototype.__chartName = function __chartName () {\n    return \"ColumnChart\";\n  };\n\n  return ColumnChart;\n}(Chart));\n\nvar BarChart = (function (Chart) {\n  function BarChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) BarChart.__proto__ = Chart;\n  BarChart.prototype = Object.create( Chart && Chart.prototype );\n  BarChart.prototype.constructor = BarChart;\n\n  BarChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"string\");\n  };\n\n  BarChart.prototype.__chartName = function __chartName () {\n    return \"BarChart\";\n  };\n\n  return BarChart;\n}(Chart));\n\nvar AreaChart = (function (Chart) {\n  function AreaChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) AreaChart.__proto__ = Chart;\n  AreaChart.prototype = Object.create( Chart && Chart.prototype );\n  AreaChart.prototype.constructor = AreaChart;\n\n  AreaChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"datetime\");\n  };\n\n  AreaChart.prototype.__chartName = function __chartName () {\n    return \"AreaChart\";\n  };\n\n  return AreaChart;\n}(Chart));\n\nvar GeoChart = (function (Chart) {\n  function GeoChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) GeoChart.__proto__ = Chart;\n  GeoChart.prototype = Object.create( Chart && Chart.prototype );\n  GeoChart.prototype.constructor = GeoChart;\n\n  GeoChart.prototype.__processData = function __processData () {\n    return processSimple(this);\n  };\n\n  GeoChart.prototype.__chartName = function __chartName () {\n    return \"GeoChart\";\n  };\n\n  return GeoChart;\n}(Chart));\n\nvar ScatterChart = (function (Chart) {\n  function ScatterChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) ScatterChart.__proto__ = Chart;\n  ScatterChart.prototype = Object.create( Chart && Chart.prototype );\n  ScatterChart.prototype.constructor = ScatterChart;\n\n  ScatterChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"number\");\n  };\n\n  ScatterChart.prototype.__chartName = function __chartName () {\n    return \"ScatterChart\";\n  };\n\n  return ScatterChart;\n}(Chart));\n\nvar BubbleChart = (function (Chart) {\n  function BubbleChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) BubbleChart.__proto__ = Chart;\n  BubbleChart.prototype = Object.create( Chart && Chart.prototype );\n  BubbleChart.prototype.constructor = BubbleChart;\n\n  BubbleChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"bubble\");\n  };\n\n  BubbleChart.prototype.__chartName = function __chartName () {\n    return \"BubbleChart\";\n  };\n\n  return BubbleChart;\n}(Chart));\n\nvar Timeline = (function (Chart) {\n  function Timeline () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) Timeline.__proto__ = Chart;\n  Timeline.prototype = Object.create( Chart && Chart.prototype );\n  Timeline.prototype.constructor = Timeline;\n\n  Timeline.prototype.__processData = function __processData () {\n    var i, data = this.rawData;\n    for (i = 0; i < data.length; i++) {\n      data[i][1] = toDate(data[i][1]);\n      data[i][2] = toDate(data[i][2]);\n    }\n    return data;\n  };\n\n  Timeline.prototype.__chartName = function __chartName () {\n    return \"Timeline\";\n  };\n\n  return Timeline;\n}(Chart));\n\nvar Chartkick = {\n  LineChart: LineChart,\n  PieChart: PieChart,\n  ColumnChart: ColumnChart,\n  BarChart: BarChart,\n  AreaChart: AreaChart,\n  GeoChart: GeoChart,\n  ScatterChart: ScatterChart,\n  BubbleChart: BubbleChart,\n  Timeline: Timeline,\n  charts: {},\n  configure: function (options) {\n    for (var key in options) {\n      if (options.hasOwnProperty(key)) {\n        config[key] = options[key];\n      }\n    }\n  },\n  eachChart: function (callback) {\n    for (var chartId in Chartkick.charts) {\n      if (Chartkick.charts.hasOwnProperty(chartId)) {\n        callback(Chartkick.charts[chartId]);\n      }\n    }\n  },\n  config: config,\n  options: {},\n  adapters: adapters,\n  addAdapter: addAdapter\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Chartkick);\n\n\n/***/ }),\n\n/***/ 1283:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @namespace Chart\n */\nvar Chart = __webpack_require__(1284)();\n\nChart.helpers = __webpack_require__(1213);\n\n// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\n__webpack_require__(1288)(Chart);\n\nChart.defaults = __webpack_require__(1217);\nChart.Element = __webpack_require__(1224);\nChart.elements = __webpack_require__(1225);\nChart.Interaction = __webpack_require__(1267);\nChart.layouts = __webpack_require__(1233);\nChart.platform = __webpack_require__(1268);\nChart.plugins = __webpack_require__(1269);\nChart.Ticks = __webpack_require__(1234);\n\n__webpack_require__(1299)(Chart);\n__webpack_require__(1300)(Chart);\n__webpack_require__(1301)(Chart);\n__webpack_require__(1302)(Chart);\n__webpack_require__(1303)(Chart);\n__webpack_require__(1304)(Chart);\n\n__webpack_require__(1305)(Chart);\n__webpack_require__(1306)(Chart);\n__webpack_require__(1307)(Chart);\n__webpack_require__(1308)(Chart);\n__webpack_require__(1309)(Chart);\n__webpack_require__(1310)(Chart);\n\n// Controllers must be loaded after elements\n// See Chart.core.datasetController.dataElementType\n__webpack_require__(1311)(Chart);\n__webpack_require__(1312)(Chart);\n__webpack_require__(1313)(Chart);\n__webpack_require__(1314)(Chart);\n__webpack_require__(1315)(Chart);\n__webpack_require__(1316)(Chart);\n__webpack_require__(1317)(Chart);\n\n__webpack_require__(1318)(Chart);\n__webpack_require__(1319)(Chart);\n__webpack_require__(1320)(Chart);\n__webpack_require__(1321)(Chart);\n__webpack_require__(1322)(Chart);\n__webpack_require__(1323)(Chart);\n__webpack_require__(1324)(Chart);\n\n// Loading built-it plugins\nvar plugins = __webpack_require__(1325);\nfor (var k in plugins) {\n\tif (plugins.hasOwnProperty(k)) {\n\t\tChart.plugins.register(plugins[k]);\n\t}\n}\n\nChart.platform.initialize();\n\nmodule.exports = Chart;\nif (typeof window !== 'undefined') {\n\twindow.Chart = Chart;\n}\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Legend\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.Legend = plugins.legend._element;\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Title\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.Title = plugins.title._element;\n\n/**\n * Provided for backward compatibility, use Chart.plugins instead\n * @namespace Chart.pluginService\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.pluginService = Chart.plugins;\n\n/**\n * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n * effect, instead simply create/register plugins via plain JavaScript objects.\n * @interface Chart.PluginBase\n * @deprecated since version 2.5.0\n * @todo remove at version 3\n * @private\n */\nChart.PluginBase = Chart.Element.extend({});\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas instead.\n * @namespace Chart.canvasHelpers\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nChart.canvasHelpers = Chart.helpers.canvas;\n\n/**\n * Provided for backward compatibility, use Chart.layouts instead.\n * @namespace Chart.layoutService\n * @deprecated since version 2.8.0\n * @todo remove at version 3\n * @private\n */\nChart.layoutService = Chart.layouts;\n\n\n/***/ }),\n\n/***/ 1284:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\n\ndefaults._set('global', {\n\tresponsive: true,\n\tresponsiveAnimationDuration: 0,\n\tmaintainAspectRatio: true,\n\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\thover: {\n\t\tonHover: null,\n\t\tmode: 'nearest',\n\t\tintersect: true,\n\t\tanimationDuration: 400\n\t},\n\tonClick: null,\n\tdefaultColor: 'rgba(0,0,0,0.1)',\n\tdefaultFontColor: '#666',\n\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\tdefaultFontSize: 12,\n\tdefaultFontStyle: 'normal',\n\tshowLines: true,\n\n\t// Element defaults defined in element extensions\n\telements: {},\n\n\t// Layout options such as padding\n\tlayout: {\n\t\tpadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t}\n\t}\n});\n\nmodule.exports = function() {\n\n\t// Occupy the global variable of Chart, and create a simple base class\n\tvar Chart = function(item, config) {\n\t\tthis.construct(item, config);\n\t\treturn this;\n\t};\n\n\tChart.Chart = Chart;\n\n\treturn Chart;\n};\n\n\n/***/ }),\n\n/***/ 1285:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1251);\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easingEffects\n * @see http://www.robertpenner.com/easing/\n */\nvar effects = {\n\tlinear: function(t) {\n\t\treturn t;\n\t},\n\n\teaseInQuad: function(t) {\n\t\treturn t * t;\n\t},\n\n\teaseOutQuad: function(t) {\n\t\treturn -t * (t - 2);\n\t},\n\n\teaseInOutQuad: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t;\n\t\t}\n\t\treturn -0.5 * ((--t) * (t - 2) - 1);\n\t},\n\n\teaseInCubic: function(t) {\n\t\treturn t * t * t;\n\t},\n\n\teaseOutCubic: function(t) {\n\t\treturn (t = t - 1) * t * t + 1;\n\t},\n\n\teaseInOutCubic: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t + 2);\n\t},\n\n\teaseInQuart: function(t) {\n\t\treturn t * t * t * t;\n\t},\n\n\teaseOutQuart: function(t) {\n\t\treturn -((t = t - 1) * t * t * t - 1);\n\t},\n\n\teaseInOutQuart: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t;\n\t\t}\n\t\treturn -0.5 * ((t -= 2) * t * t * t - 2);\n\t},\n\n\teaseInQuint: function(t) {\n\t\treturn t * t * t * t * t;\n\t},\n\n\teaseOutQuint: function(t) {\n\t\treturn (t = t - 1) * t * t * t * t + 1;\n\t},\n\n\teaseInOutQuint: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t * t * t + 2);\n\t},\n\n\teaseInSine: function(t) {\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\n\t},\n\n\teaseOutSine: function(t) {\n\t\treturn Math.sin(t * (Math.PI / 2));\n\t},\n\n\teaseInOutSine: function(t) {\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\n\t},\n\n\teaseInExpo: function(t) {\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\n\t},\n\n\teaseOutExpo: function(t) {\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\n\t},\n\n\teaseInOutExpo: function(t) {\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * Math.pow(2, 10 * (t - 1));\n\t\t}\n\t\treturn 0.5 * (-Math.pow(2, -10 * --t) + 2);\n\t},\n\n\teaseInCirc: function(t) {\n\t\tif (t >= 1) {\n\t\t\treturn t;\n\t\t}\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\n\t},\n\n\teaseOutCirc: function(t) {\n\t\treturn Math.sqrt(1 - (t = t - 1) * t);\n\t},\n\n\teaseInOutCirc: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn -0.5 * (Math.sqrt(1 - t * t) - 1);\n\t\t}\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t},\n\n\teaseInElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t},\n\n\teaseOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n\t},\n\n\teaseInOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((t /= 0.5) === 2) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.45;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\tif (t < 1) {\n\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t\t}\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t},\n\teaseInBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn t * t * ((s + 1) * t - s);\n\t},\n\n\teaseOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\n\t},\n\n\teaseInOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t},\n\n\teaseInBounce: function(t) {\n\t\treturn 1 - effects.easeOutBounce(1 - t);\n\t},\n\n\teaseOutBounce: function(t) {\n\t\tif (t < (1 / 2.75)) {\n\t\t\treturn 7.5625 * t * t;\n\t\t}\n\t\tif (t < (2 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\n\t\t}\n\t\tif (t < (2.5 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\n\t\t}\n\t\treturn 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\n\t},\n\n\teaseInOutBounce: function(t) {\n\t\tif (t < 0.5) {\n\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\n\t\t}\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n\t}\n};\n\nmodule.exports = {\n\teffects: effects\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\n * @function Chart.helpers.easingEffects\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.easingEffects = effects;\n\n\n/***/ }),\n\n/***/ 1286:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1251);\n\n/**\n * @namespace Chart.helpers.canvas\n */\nvar exports = module.exports = {\n\t/**\n\t * Clears the entire canvas associated to the given `chart`.\n\t * @param {Chart} chart - The chart for which to clear the canvas.\n\t */\n\tclear: function(chart) {\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t},\n\n\t/**\n\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n\t * given size (width, height) and the same `radius` for all corners.\n\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n\t * @param {Number} x - The x axis of the coordinate for the rectangle starting point.\n\t * @param {Number} y - The y axis of the coordinate for the rectangle starting point.\n\t * @param {Number} width - The rectangle's width.\n\t * @param {Number} height - The rectangle's height.\n\t * @param {Number} radius - The rounded amount (in pixels) for the four corners.\n\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n\t */\n\troundedRect: function(ctx, x, y, width, height, radius) {\n\t\tif (radius) {\n\t\t\tvar rx = Math.min(radius, width / 2);\n\t\t\tvar ry = Math.min(radius, height / 2);\n\n\t\t\tctx.moveTo(x + rx, y);\n\t\t\tctx.lineTo(x + width - rx, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + ry);\n\t\t\tctx.lineTo(x + width, y + height - ry);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);\n\t\t\tctx.lineTo(x + rx, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - ry);\n\t\t\tctx.lineTo(x, y + ry);\n\t\t\tctx.quadraticCurveTo(x, y, x + rx, y);\n\t\t} else {\n\t\t\tctx.rect(x, y, width, height);\n\t\t}\n\t},\n\n\tdrawPoint: function(ctx, style, radius, x, y) {\n\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\n\t\tif (style && typeof style === 'object') {\n\t\t\ttype = style.toString();\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\tctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (style) {\n\t\t// Default includes circle\n\t\tdefault:\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'triangle':\n\t\t\tctx.beginPath();\n\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rect':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\tcase 'rectRounded':\n\t\t\tvar offset = radius / Math.SQRT2;\n\t\t\tvar leftX = x - offset;\n\t\t\tvar topY = y - offset;\n\t\t\tvar sideSize = Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tthis.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rectRot':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - size, y);\n\t\t\tctx.lineTo(x, y + size);\n\t\t\tctx.lineTo(x + size, y);\n\t\t\tctx.lineTo(x, y - size);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'cross':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'crossRot':\n\t\t\tctx.beginPath();\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'star':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'line':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'dash':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\t}\n\n\t\tctx.stroke();\n\t},\n\n\tclipArea: function(ctx, area) {\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\t\tctx.clip();\n\t},\n\n\tunclipArea: function(ctx) {\n\t\tctx.restore();\n\t},\n\n\tlineTo: function(ctx, previous, target, flip) {\n\t\tif (target.steppedLine) {\n\t\t\tif ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {\n\t\t\t\tctx.lineTo(previous.x, target.y);\n\t\t\t} else {\n\t\t\t\tctx.lineTo(target.x, previous.y);\n\t\t\t}\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target.tension) {\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tctx.bezierCurveTo(\n\t\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\n\t\t\ttarget.x,\n\t\t\ttarget.y);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\n * @namespace Chart.helpers.clear\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.clear = exports.clear;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\n * @namespace Chart.helpers.drawRoundedRectangle\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.drawRoundedRectangle = function(ctx) {\n\tctx.beginPath();\n\texports.roundedRect.apply(exports, arguments);\n\tctx.closePath();\n};\n\n\n/***/ }),\n\n/***/ 1287:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1251);\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\nmodule.exports = {\n\t/**\n\t * Converts the given line height `value` in pixels for a specific font `size`.\n\t * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n\t * @param {Number} size - The font size (in pixels) used to resolve relative `value`.\n\t * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n\t * @since 2.7.0\n\t */\n\ttoLineHeight: function(value, size) {\n\t\tvar matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\t\tif (!matches || matches[1] === 'normal') {\n\t\t\treturn size * 1.2;\n\t\t}\n\n\t\tvalue = +matches[2];\n\n\t\tswitch (matches[3]) {\n\t\tcase 'px':\n\t\t\treturn value;\n\t\tcase '%':\n\t\t\tvalue /= 100;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn size * value;\n\t},\n\n\t/**\n\t * Converts the given value into a padding object with pre-computed width/height.\n\t * @param {Number|Object} value - If a number, set the value to all TRBL component,\n\t *  else, if and object, use defined properties and sets undefined ones to 0.\n\t * @returns {Object} The padding values (top, right, bottom, left, width, height)\n\t * @since 2.7.0\n\t */\n\ttoPadding: function(value) {\n\t\tvar t, r, b, l;\n\n\t\tif (helpers.isObject(value)) {\n\t\t\tt = +value.top || 0;\n\t\t\tr = +value.right || 0;\n\t\t\tb = +value.bottom || 0;\n\t\t\tl = +value.left || 0;\n\t\t} else {\n\t\t\tt = r = b = l = +value || 0;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: t,\n\t\t\tright: r,\n\t\t\tbottom: b,\n\t\t\tleft: l,\n\t\t\theight: t + b,\n\t\t\twidth: l + r\n\t\t};\n\t},\n\n\t/**\n\t * Evaluates the given `inputs` sequentially and returns the first defined value.\n\t * @param {Array[]} inputs - An array of values, falling back to the last value.\n\t * @param {Object} [context] - If defined and the current value is a function, the value\n\t * is called with `context` as first argument and the result becomes the new input.\n\t * @param {Number} [index] - If defined and the current value is an array, the value\n\t * at `index` become the new input.\n\t * @since 2.7.0\n\t */\n\tresolve: function(inputs, context, index) {\n\t\tvar i, ilen, value;\n\n\t\tfor (i = 0, ilen = inputs.length; i < ilen; ++i) {\n\t\t\tvalue = inputs[i];\n\t\t\tif (value === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (context !== undefined && typeof value === 'function') {\n\t\t\t\tvalue = value(context);\n\t\t\t}\n\t\t\tif (index !== undefined && helpers.isArray(value)) {\n\t\t\t\tvalue = value[index];\n\t\t\t}\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1288:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* global window: false */\n/* global document: false */\n\n\nvar color = __webpack_require__(1266);\nvar defaults = __webpack_require__(1217);\nvar helpers = __webpack_require__(1213);\n\nmodule.exports = function(Chart) {\n\n\t// -- Basic js utility methods\n\n\thelpers.configMerge = function(/* objects ... */) {\n\t\treturn helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tvar tval = target[key] || {};\n\t\t\t\tvar sval = source[key];\n\n\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t// scale config merging is complex. Add our own function here for that\n\t\t\t\t\ttarget[key] = helpers.scaleMerge(tval, sval);\n\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t// used in polar area & radar charts since there is only one scale\n\t\t\t\t\ttarget[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);\n\t\t\t\t} else {\n\t\t\t\t\thelpers._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\thelpers.scaleMerge = function(/* objects ... */) {\n\t\treturn helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t\tvar slen = source[key].length;\n\t\t\t\t\tvar i, type, scale;\n\n\t\t\t\t\tif (!target[key]) {\n\t\t\t\t\t\ttarget[key] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < slen; ++i) {\n\t\t\t\t\t\tscale = source[key][i];\n\t\t\t\t\t\ttype = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');\n\n\t\t\t\t\t\tif (i >= target[key].length) {\n\t\t\t\t\t\t\ttarget[key].push({});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\n\t\t\t\t\t\t\t// new/untyped scale or type changed: let's apply the new defaults\n\t\t\t\t\t\t\t// then merge source scale to correctly overwrite the defaults.\n\t\t\t\t\t\t\thelpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// scales type are the same\n\t\t\t\t\t\t\thelpers.merge(target[key][i], scale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thelpers._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\thelpers.where = function(collection, filterCallback) {\n\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\treturn collection.filter(filterCallback);\n\t\t}\n\t\tvar filtered = [];\n\n\t\thelpers.each(collection, function(item) {\n\t\t\tif (filterCallback(item)) {\n\t\t\t\tfiltered.push(item);\n\t\t\t}\n\t\t});\n\n\t\treturn filtered;\n\t};\n\thelpers.findIndex = Array.prototype.findIndex ?\n\t\tfunction(array, callback, scope) {\n\t\t\treturn array.findIndex(callback, scope);\n\t\t} :\n\t\tfunction(array, callback, scope) {\n\t\t\tscope = scope === undefined ? array : scope;\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to start of the array\n\t\tif (helpers.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = -1;\n\t\t}\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to end of the array\n\t\tif (helpers.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = arrayToSearch.length;\n\t\t}\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\n\t// -- Math methods\n\thelpers.isNumber = function(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\thelpers.almostEquals = function(x, y, epsilon) {\n\t\treturn Math.abs(x - y) < epsilon;\n\t};\n\thelpers.almostWhole = function(x, epsilon) {\n\t\tvar rounded = Math.round(x);\n\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t};\n\thelpers.max = function(array) {\n\t\treturn array.reduce(function(max, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.max(max, value);\n\t\t\t}\n\t\t\treturn max;\n\t\t}, Number.NEGATIVE_INFINITY);\n\t};\n\thelpers.min = function(array) {\n\t\treturn array.reduce(function(min, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.min(min, value);\n\t\t\t}\n\t\t\treturn min;\n\t\t}, Number.POSITIVE_INFINITY);\n\t};\n\thelpers.sign = Math.sign ?\n\t\tfunction(x) {\n\t\t\treturn Math.sign(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tx = +x; // convert to a number\n\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\treturn x > 0 ? 1 : -1;\n\t\t};\n\thelpers.log10 = Math.log10 ?\n\t\tfunction(x) {\n\t\t\treturn Math.log10(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tvar exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\n\t\t\t// Check for whole powers of 10,\n\t\t\t// which due to floating point rounding error should be corrected.\n\t\t\tvar powerOf10 = Math.round(exponent);\n\t\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\n\n\t\t\treturn isPowerOf10 ? powerOf10 : exponent;\n\t\t};\n\thelpers.toRadians = function(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t};\n\thelpers.toDegrees = function(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t};\n\t// Gets the angle from vertical upright to the point about a centre.\n\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x;\n\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\n\t\tvar radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t}\n\n\t\treturn {\n\t\t\tangle: angle,\n\t\t\tdistance: radialDistanceFromCenter\n\t\t};\n\t};\n\thelpers.distanceBetweenPoints = function(pt1, pt2) {\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t};\n\thelpers.aliasPixel = function(pixelWidth) {\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t};\n\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t// This function must also respect \"skipped\" points\n\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint;\n\t\tvar current = middlePoint;\n\t\tvar next = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\tvar s01 = d01 / (d01 + d12);\n\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t// If all points are the same, s01 & s02 will be inf\n\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\tvar fb = t * s12;\n\n\t\treturn {\n\t\t\tprevious: {\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t},\n\t\t\tnext: {\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t}\n\t\t};\n\t};\n\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\thelpers.splineCurveMonotone = function(points) {\n\t\t// This function calculates Bzier control points in a similar way than |splineCurve|,\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t// between the dataset discrete points due to the interpolation.\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\treturn {\n\t\t\t\tmodel: point._model,\n\t\t\t\tdeltaK: 0,\n\t\t\t\tmK: 0\n\t\t\t};\n\t\t});\n\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\tvar pointsLen = pointsWithTangents.length;\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t}\n\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\tpointCurrent.mK = 0;\n\t\t\t} else {\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t}\n\t\t}\n\n\t\t// Adjust tangents to ensure monotonic properties\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t}\n\n\t\t// Compute control points\n\t\tvar deltaX;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.nextItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t}\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t};\n\thelpers.previousItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t}\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t};\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\thelpers.niceNum = function(range, round) {\n\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\tvar fraction = range / Math.pow(10, exponent);\n\t\tvar niceFraction;\n\n\t\tif (round) {\n\t\t\tif (fraction < 1.5) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction < 3) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction < 7) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\t} else if (fraction <= 1.0) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\n\t\treturn niceFraction * Math.pow(10, exponent);\n\t};\n\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\thelpers.requestAnimFrame = (function() {\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn function(callback) {\n\t\t\t\tcallback();\n\t\t\t};\n\t\t}\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t}());\n\t// -- DOM methods\n\thelpers.getRelativePosition = function(evt, chart) {\n\t\tvar mouseX, mouseY;\n\t\tvar e = evt.originalEvent || evt;\n\t\tvar canvas = evt.currentTarget || evt.srcElement;\n\t\tvar boundingRect = canvas.getBoundingClientRect();\n\n\t\tvar touches = e.touches;\n\t\tif (touches && touches.length > 0) {\n\t\t\tmouseX = touches[0].clientX;\n\t\t\tmouseY = touches[0].clientY;\n\n\t\t} else {\n\t\t\tmouseX = e.clientX;\n\t\t\tmouseY = e.clientY;\n\t\t}\n\n\t\t// Scale mouse coordinates into canvas coordinates\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\n\t\treturn {\n\t\t\tx: mouseX,\n\t\t\ty: mouseY\n\t\t};\n\n\t};\n\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\tvar valueInPixels;\n\t\tif (typeof styleValue === 'string') {\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t// percentage * size in dimension\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t}\n\t\t} else {\n\t\t\tvalueInPixels = styleValue;\n\t\t}\n\n\t\treturn valueInPixels;\n\t}\n\n\t/**\n\t * Returns if the given value contains an effective constraint.\n\t * @private\n\t */\n\tfunction isConstrainedValue(value) {\n\t\treturn value !== undefined && value !== null && value !== 'none';\n\t}\n\n\t// Private helper to get a constraint dimension\n\t// @param domNode : the node to check the constraint on\n\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\tvar view = document.defaultView;\n\t\tvar parentNode = domNode.parentNode;\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\tif (hasCNode || hasCContainer) {\n\t\t\treturn Math.min(\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t}\n\n\t\treturn 'none';\n\t}\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintWidth = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t};\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintHeight = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t};\n\thelpers.getMaximumWidth = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tif (!container) {\n\t\t\treturn domNode.clientWidth;\n\t\t}\n\n\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\treturn isNaN(cw) ? w : Math.min(w, cw);\n\t};\n\thelpers.getMaximumHeight = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tif (!container) {\n\t\t\treturn domNode.clientHeight;\n\t\t}\n\n\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\treturn isNaN(ch) ? h : Math.min(h, ch);\n\t};\n\thelpers.getStyle = function(el, property) {\n\t\treturn el.currentStyle ?\n\t\t\tel.currentStyle[property] :\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t};\n\thelpers.retinaScale = function(chart, forceRatio) {\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;\n\t\tif (pixelRatio === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar canvas = chart.canvas;\n\t\tvar height = chart.height;\n\t\tvar width = chart.width;\n\n\t\tcanvas.height = height * pixelRatio;\n\t\tcanvas.width = width * pixelRatio;\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\tif (!canvas.style.height && !canvas.style.width) {\n\t\t\tcanvas.style.height = height + 'px';\n\t\t\tcanvas.style.width = width + 'px';\n\t\t}\n\t};\n\t// -- Canvas methods\n\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t};\n\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\tcache = cache || {};\n\t\tvar data = cache.data = cache.data || {};\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\tif (cache.font !== font) {\n\t\t\tdata = cache.data = {};\n\t\t\tgc = cache.garbageCollect = [];\n\t\t\tcache.font = font;\n\t\t}\n\n\t\tctx.font = font;\n\t\tvar longest = 0;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t// Undefined strings and arrays should not be measured\n\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\thelpers.each(thing, function(nestedThing) {\n\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar gcLen = gc.length / 2;\n\t\tif (gcLen > arrayOfThings.length) {\n\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\tdelete data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.measureText = function(ctx, data, gc, longest, string) {\n\t\tvar textWidth = data[string];\n\t\tif (!textWidth) {\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\tgc.push(string);\n\t\t}\n\t\tif (textWidth > longest) {\n\t\t\tlongest = textWidth;\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.numberOfLabelLines = function(arrayOfThings) {\n\t\tvar numberOfLines = 1;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn numberOfLines;\n\t};\n\n\thelpers.color = !color ?\n\t\tfunction(value) {\n\t\t\tconsole.error('Color.js not found!');\n\t\t\treturn value;\n\t\t} :\n\t\tfunction(value) {\n\t\t\t/* global CanvasGradient */\n\t\t\tif (value instanceof CanvasGradient) {\n\t\t\t\tvalue = defaults.global.defaultColor;\n\t\t\t}\n\n\t\t\treturn color(value);\n\t\t};\n\n\thelpers.getHoverColor = function(colorValue) {\n\t\t/* global CanvasPattern */\n\t\treturn (colorValue instanceof CanvasPattern) ?\n\t\t\tcolorValue :\n\t\t\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t};\n};\n\n\n/***/ }),\n\n/***/ 1289:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar conversions = __webpack_require__(1290);\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;\n\n/***/ }),\n\n/***/ 1290:\n/***/ (function(module, exports) {\n\n/* MIT license */\n\nmodule.exports = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n}\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n\n\n/***/ }),\n\n/***/ 1291:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* MIT license */\nvar colorNames = __webpack_require__(1292);\n\nmodule.exports = {\n   getRgba: getRgba,\n   getHsla: getHsla,\n   getRgb: getRgb,\n   getHsl: getHsl,\n   getHwb: getHwb,\n   getAlpha: getAlpha,\n\n   hexString: hexString,\n   rgbString: rgbString,\n   rgbaString: rgbaString,\n   percentString: percentString,\n   percentaString: percentaString,\n   hslString: hslString,\n   hslaString: hslaString,\n   hwbString: hwbString,\n   keyword: keyword\n}\n\nfunction getRgba(string) {\n   if (!string) {\n      return;\n   }\n   var abbr =  /^#([a-fA-F0-9]{3})$/i,\n       hex =  /^#([a-fA-F0-9]{6})$/i,\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       keyword = /(\\w+)/;\n\n   var rgb = [0, 0, 0],\n       a = 1,\n       match = string.match(abbr);\n   if (match) {\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n   }\n   else if (match = string.match(hex)) {\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n   }\n   else if (match = string.match(rgba)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i + 1]);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(per)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n         return [0, 0, 0, 0];\n      }\n      rgb = colorNames[match[1]];\n      if (!rgb) {\n         return;\n      }\n   }\n\n   for (var i = 0; i < rgb.length; i++) {\n      rgb[i] = scale(rgb[i], 0, 255);\n   }\n   if (!a && a != 0) {\n      a = 1;\n   }\n   else {\n      a = scale(a, 0, 1);\n   }\n   rgb[3] = a;\n   return rgb;\n}\n\nfunction getHsla(string) {\n   if (!string) {\n      return;\n   }\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hsl);\n   if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]), 0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n   }\n}\n\nfunction getHwb(string) {\n   if (!string) {\n      return;\n   }\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hwb);\n   if (match) {\n    var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]), 0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n   }\n}\n\nfunction getRgb(string) {\n   var rgba = getRgba(string);\n   return rgba && rgba.slice(0, 3);\n}\n\nfunction getHsl(string) {\n  var hsla = getHsla(string);\n  return hsla && hsla.slice(0, 3);\n}\n\nfunction getAlpha(string) {\n   var vals = getRgba(string);\n   if (vals) {\n      return vals[3];\n   }\n   else if (vals = getHsla(string)) {\n      return vals[3];\n   }\n   else if (vals = getHwb(string)) {\n      return vals[3];\n   }\n}\n\n// generators\nfunction hexString(rgb) {\n   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\n              + hexDouble(rgb[2]);\n}\n\nfunction rgbString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return rgbaString(rgba, alpha);\n   }\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n}\n\nfunction rgbaString(rgba, alpha) {\n   if (alpha === undefined) {\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n   }\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n           + \", \" + alpha + \")\";\n}\n\nfunction percentString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return percentaString(rgba, alpha);\n   }\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n}\n\nfunction percentaString(rgba, alpha) {\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n}\n\nfunction hslString(hsla, alpha) {\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n      return hslaString(hsla, alpha);\n   }\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n}\n\nfunction hslaString(hsla, alpha) {\n   if (alpha === undefined) {\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n   }\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n           + alpha + \")\";\n}\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\nfunction hwbString(hwb, alpha) {\n   if (alpha === undefined) {\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\n   }\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n}\n\nfunction keyword(rgb) {\n  return reverseNames[rgb.slice(0, 3)];\n}\n\n// helpers\nfunction scale(num, min, max) {\n   return Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n  var str = num.toString(16).toUpperCase();\n  return (str.length < 2) ? \"0\" + str : str;\n}\n\n\n//create a list of reverse color names\nvar reverseNames = {};\nfor (var name in colorNames) {\n   reverseNames[colorNames[name]] = name;\n}\n\n\n/***/ }),\n\n/***/ 1292:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n\n/***/ }),\n\n/***/ 1293:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('global', {\n\telements: {\n\t\tarc: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: '#fff',\n\t\t\tborderWidth: 2\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tinLabelRange: function(mouseX) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t}\n\t\treturn false;\n\t},\n\n\tinRange: function(chartX, chartY) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});\n\t\t\tvar\tangle = pointRelativePosition.angle;\n\t\t\tvar distance = pointRelativePosition.distance;\n\n\t\t\t// Sanitise angle range\n\t\t\tvar startAngle = vm.startAngle;\n\t\t\tvar endAngle = vm.endAngle;\n\t\t\twhile (endAngle < startAngle) {\n\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle > endAngle) {\n\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle < startAngle) {\n\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t}\n\n\t\t\t// Check if within the range of the open/close angle\n\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle);\n\t\t\tvar withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\n\t\t\treturn (betweenAngles && withinRadius);\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\treturn {\n\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\n\t\tvar rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\n\t\treturn {\n\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t};\n\t},\n\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar sA = vm.startAngle;\n\t\tvar eA = vm.endAngle;\n\n\t\tctx.beginPath();\n\n\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\n\t\tctx.closePath();\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = vm.borderWidth;\n\n\t\tctx.fillStyle = vm.backgroundColor;\n\n\t\tctx.fill();\n\t\tctx.lineJoin = 'bevel';\n\n\t\tif (vm.borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t}\n});\n\n\n/***/ }),\n\n/***/ 1294:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\nvar helpers = __webpack_require__(1213);\n\nvar globalDefaults = defaults.global;\n\ndefaults._set('global', {\n\telements: {\n\t\tline: {\n\t\t\ttension: 0.4,\n\t\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\t\tborderWidth: 3,\n\t\t\tborderColor: globalDefaults.defaultColor,\n\t\t\tborderCapStyle: 'butt',\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0,\n\t\t\tborderJoinStyle: 'miter',\n\t\t\tcapBezierPoints: true,\n\t\t\tfill: true, // do we fill in the area between the line and its base axis\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar vm = me._view;\n\t\tvar ctx = me._chart.ctx;\n\t\tvar spanGaps = vm.spanGaps;\n\t\tvar points = me._children.slice(); // clone array\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\tvar lastDrawnIndex = -1;\n\t\tvar index, current, previous, currentVM;\n\n\t\t// If we are looping, adding the first point again\n\t\tif (me._loop && points.length) {\n\t\t\tpoints.push(points[0]);\n\t\t}\n\n\t\tctx.save();\n\n\t\t// Stroke Line Options\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t// IE 9 and 10 do not support line dash\n\t\tif (ctx.setLineDash) {\n\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t}\n\n\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t// Stroke Line\n\t\tctx.beginPath();\n\t\tlastDrawnIndex = -1;\n\n\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\tcurrent = points[index];\n\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\tcurrentVM = current._view;\n\n\t\t\t// First point moves to it's starting position no matter what\n\t\t\tif (index === 0) {\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\thelpers.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t}\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.stroke();\n\t\tctx.restore();\n\t}\n});\n\n\n/***/ }),\n\n/***/ 1295:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\nvar helpers = __webpack_require__(1213);\n\nvar defaultColor = defaults.global.defaultColor;\n\ndefaults._set('global', {\n\telements: {\n\t\tpoint: {\n\t\t\tradius: 3,\n\t\t\tpointStyle: 'circle',\n\t\t\tbackgroundColor: defaultColor,\n\t\t\tborderColor: defaultColor,\n\t\t\tborderWidth: 1,\n\t\t\t// Hover\n\t\t\thitRadius: 1,\n\t\t\thoverRadius: 4,\n\t\t\thoverBorderWidth: 1\n\t\t}\n\t}\n});\n\nfunction xRange(mouseX) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\n}\n\nfunction yRange(mouseY) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;\n}\n\nmodule.exports = Element.extend({\n\tinRange: function(mouseX, mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t},\n\n\tinLabelRange: xRange,\n\tinXRange: xRange,\n\tinYRange: yRange,\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y,\n\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t};\n\t},\n\n\tdraw: function(chartArea) {\n\t\tvar vm = this._view;\n\t\tvar model = this._model;\n\t\tvar ctx = this._chart.ctx;\n\t\tvar pointStyle = vm.pointStyle;\n\t\tvar radius = vm.radius;\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\t\tvar color = helpers.color;\n\t\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n\t\tvar ratio = 0;\n\n\t\tif (vm.skip) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\tctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);\n\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\n\t\t// Cliping for Points.\n\t\t// going out from inner charArea?\n\t\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right * errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom * errMargin < model.y))) {\n\t\t\t// Point fade out\n\t\t\tif (model.x < chartArea.left) {\n\t\t\t\tratio = (x - model.x) / (chartArea.left - model.x);\n\t\t\t} else if (chartArea.right * errMargin < model.x) {\n\t\t\t\tratio = (model.x - x) / (model.x - chartArea.right);\n\t\t\t} else if (model.y < chartArea.top) {\n\t\t\t\tratio = (y - model.y) / (chartArea.top - model.y);\n\t\t\t} else if (chartArea.bottom * errMargin < model.y) {\n\t\t\t\tratio = (model.y - y) / (model.y - chartArea.bottom);\n\t\t\t}\n\t\t\tratio = Math.round(ratio * 100) / 100;\n\t\t\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n\t\t\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n\t\t}\n\n\t\thelpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);\n\t}\n});\n\n\n/***/ }),\n\n/***/ 1296:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\n\ndefaults._set('global', {\n\telements: {\n\t\trectangle: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: defaults.global.defaultColor,\n\t\t\tborderSkipped: 'bottom',\n\t\t\tborderWidth: 0\n\t\t}\n\t}\n});\n\nfunction isVertical(bar) {\n\treturn bar._view.width !== undefined;\n}\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param bar {Chart.Element.Rectangle} the bar\n * @return {Bounds} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar) {\n\tvar vm = bar._view;\n\tvar x1, x2, y1, y2;\n\n\tif (isVertical(bar)) {\n\t\t// vertical\n\t\tvar halfWidth = vm.width / 2;\n\t\tx1 = vm.x - halfWidth;\n\t\tx2 = vm.x + halfWidth;\n\t\ty1 = Math.min(vm.y, vm.base);\n\t\ty2 = Math.max(vm.y, vm.base);\n\t} else {\n\t\t// horizontal bar\n\t\tvar halfHeight = vm.height / 2;\n\t\tx1 = Math.min(vm.x, vm.base);\n\t\tx2 = Math.max(vm.x, vm.base);\n\t\ty1 = vm.y - halfHeight;\n\t\ty2 = vm.y + halfHeight;\n\t}\n\n\treturn {\n\t\tleft: x1,\n\t\ttop: y1,\n\t\tright: x2,\n\t\tbottom: y2\n\t};\n}\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\tvar borderWidth = vm.borderWidth;\n\n\t\tif (!vm.horizontal) {\n\t\t\t// bar\n\t\t\tleft = vm.x - vm.width / 2;\n\t\t\tright = vm.x + vm.width / 2;\n\t\t\ttop = vm.y;\n\t\t\tbottom = vm.base;\n\t\t\tsignX = 1;\n\t\t\tsignY = bottom > top ? 1 : -1;\n\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tleft = vm.base;\n\t\t\tright = vm.x;\n\t\t\ttop = vm.y - vm.height / 2;\n\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\tsignX = right > left ? 1 : -1;\n\t\t\tsignY = 1;\n\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t}\n\n\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\tif (borderWidth) {\n\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\n\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\tvar borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n\t\t\tvar borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n\t\t\tvar borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n\t\t\t// not become a vertical line?\n\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\ttop = borderTop;\n\t\t\t\tbottom = borderBottom;\n\t\t\t}\n\t\t\t// not become a horizontal line?\n\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\tleft = borderLeft;\n\t\t\t\tright = borderRight;\n\t\t\t}\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.fillStyle = vm.backgroundColor;\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = borderWidth;\n\n\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t// | 1 2 |\n\t\t// | 0 3 |\n\t\tvar corners = [\n\t\t\t[left, bottom],\n\t\t\t[left, top],\n\t\t\t[right, top],\n\t\t\t[right, bottom]\n\t\t];\n\n\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\tif (startCorner === -1) {\n\t\t\tstartCorner = 0;\n\t\t}\n\n\t\tfunction cornerAt(index) {\n\t\t\treturn corners[(startCorner + index) % 4];\n\t\t}\n\n\t\t// Draw rectangle from 'startCorner'\n\t\tvar corner = cornerAt(0);\n\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\tfor (var i = 1; i < 4; i++) {\n\t\t\tcorner = cornerAt(i);\n\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t}\n\n\t\tctx.fill();\n\t\tif (borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\theight: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.base - vm.y;\n\t},\n\n\tinRange: function(mouseX, mouseY) {\n\t\tvar inRange = false;\n\n\t\tif (this._view) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinLabelRange: function(mouseX, mouseY) {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar inRange = false;\n\t\tvar bounds = getBarBounds(me);\n\n\t\tif (isVertical(me)) {\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t} else {\n\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinXRange: function(mouseX) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t},\n\n\tinYRange: function(mouseY) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar x, y;\n\t\tif (isVertical(this)) {\n\t\t\tx = vm.x;\n\t\t\ty = (vm.y + vm.base) / 2;\n\t\t} else {\n\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\ty = vm.y;\n\t\t}\n\n\t\treturn {x: x, y: y};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t}\n});\n\n\n/***/ }),\n\n/***/ 1297:\n/***/ (function(module, exports) {\n\n/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nmodule.exports = {\n\tacquireContext: function(item) {\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\treturn item && item.getContext('2d') || null;\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1298:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Chart.Platform implementation for targeting a web browser\n */\n\n\n\nvar helpers = __webpack_require__(1213);\n\nvar EXPANDO_KEY = '$chartjs';\nvar CSS_PREFIX = 'chartjs-';\nvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\nvar CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\nvar ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nvar EVENT_TYPES = {\n\ttouchstart: 'mousedown',\n\ttouchmove: 'mousemove',\n\ttouchend: 'mouseup',\n\tpointerenter: 'mouseenter',\n\tpointerdown: 'mousedown',\n\tpointermove: 'mousemove',\n\tpointerup: 'mouseup',\n\tpointerleave: 'mouseout',\n\tpointerout: 'mouseout'\n};\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns {Number} Size in pixels or undefined if unknown.\n */\nfunction readUsedSize(element, property) {\n\tvar value = helpers.getStyle(element, property);\n\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\treturn matches ? Number(matches[1]) : undefined;\n}\n\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n */\nfunction initCanvas(canvas, config) {\n\tvar style = canvas.style;\n\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\tvar renderHeight = canvas.getAttribute('height');\n\tvar renderWidth = canvas.getAttribute('width');\n\n\t// Chart.js modifies some canvas values that we want to restore on destroy\n\tcanvas[EXPANDO_KEY] = {\n\t\tinitial: {\n\t\t\theight: renderHeight,\n\t\t\twidth: renderWidth,\n\t\t\tstyle: {\n\t\t\t\tdisplay: style.display,\n\t\t\t\theight: style.height,\n\t\t\t\twidth: style.width\n\t\t\t}\n\t\t}\n\t};\n\n\t// Force canvas to display as block to avoid extra space caused by inline\n\t// elements, which would interfere with the responsive resize process.\n\t// https://github.com/chartjs/Chart.js/issues/2538\n\tstyle.display = style.display || 'block';\n\n\tif (renderWidth === null || renderWidth === '') {\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\tif (displayWidth !== undefined) {\n\t\t\tcanvas.width = displayWidth;\n\t\t}\n\t}\n\n\tif (renderHeight === null || renderHeight === '') {\n\t\tif (canvas.style.height === '') {\n\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t} else {\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.height = displayHeight;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn canvas;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nvar supportsEventListenerOptions = (function() {\n\tvar supports = false;\n\ttry {\n\t\tvar options = Object.defineProperty({}, 'passive', {\n\t\t\tget: function() {\n\t\t\t\tsupports = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener('e', null, options);\n\t} catch (e) {\n\t\t// continue regardless of error\n\t}\n\treturn supports;\n}());\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nvar eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addEventListener(node, type, listener) {\n\tnode.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeEventListener(node, type, listener) {\n\tnode.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction createEvent(type, chart, x, y, nativeEvent) {\n\treturn {\n\t\ttype: type,\n\t\tchart: chart,\n\t\tnative: nativeEvent || null,\n\t\tx: x !== undefined ? x : null,\n\t\ty: y !== undefined ? y : null,\n\t};\n}\n\nfunction fromNativeEvent(event, chart) {\n\tvar type = EVENT_TYPES[event.type] || event.type;\n\tvar pos = helpers.getRelativePosition(event, chart);\n\treturn createEvent(type, chart, pos.x, pos.y, event);\n}\n\nfunction throttled(fn, thisArg) {\n\tvar ticking = false;\n\tvar args = [];\n\n\treturn function() {\n\t\targs = Array.prototype.slice.call(arguments);\n\t\tthisArg = thisArg || this;\n\n\t\tif (!ticking) {\n\t\t\tticking = true;\n\t\t\thelpers.requestAnimFrame.call(window, function() {\n\t\t\t\tticking = false;\n\t\t\t\tfn.apply(thisArg, args);\n\t\t\t});\n\t\t}\n\t};\n}\n\n// Implementation based on https://github.com/marcj/css-element-queries\nfunction createResizer(handler) {\n\tvar resizer = document.createElement('div');\n\tvar cls = CSS_PREFIX + 'size-monitor';\n\tvar maxSize = 1000000;\n\tvar style =\n\t\t'position:absolute;' +\n\t\t'left:0;' +\n\t\t'top:0;' +\n\t\t'right:0;' +\n\t\t'bottom:0;' +\n\t\t'overflow:hidden;' +\n\t\t'pointer-events:none;' +\n\t\t'visibility:hidden;' +\n\t\t'z-index:-1;';\n\n\tresizer.style.cssText = style;\n\tresizer.className = cls;\n\tresizer.innerHTML =\n\t\t'<div class=\"' + cls + '-expand\" style=\"' + style + '\">' +\n\t\t\t'<div style=\"' +\n\t\t\t\t'position:absolute;' +\n\t\t\t\t'width:' + maxSize + 'px;' +\n\t\t\t\t'height:' + maxSize + 'px;' +\n\t\t\t\t'left:0;' +\n\t\t\t\t'top:0\">' +\n\t\t\t'</div>' +\n\t\t'</div>' +\n\t\t'<div class=\"' + cls + '-shrink\" style=\"' + style + '\">' +\n\t\t\t'<div style=\"' +\n\t\t\t\t'position:absolute;' +\n\t\t\t\t'width:200%;' +\n\t\t\t\t'height:200%;' +\n\t\t\t\t'left:0; ' +\n\t\t\t\t'top:0\">' +\n\t\t\t'</div>' +\n\t\t'</div>';\n\n\tvar expand = resizer.childNodes[0];\n\tvar shrink = resizer.childNodes[1];\n\n\tresizer._reset = function() {\n\t\texpand.scrollLeft = maxSize;\n\t\texpand.scrollTop = maxSize;\n\t\tshrink.scrollLeft = maxSize;\n\t\tshrink.scrollTop = maxSize;\n\t};\n\tvar onScroll = function() {\n\t\tresizer._reset();\n\t\thandler();\n\t};\n\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n\n\treturn resizer;\n}\n\n// https://davidwalsh.name/detect-node-insertion\nfunction watchForRender(node, handler) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\tvar proxy = expando.renderProxy = function(e) {\n\t\tif (e.animationName === CSS_RENDER_ANIMATION) {\n\t\t\thandler();\n\t\t}\n\t};\n\n\thelpers.each(ANIMATION_START_EVENTS, function(type) {\n\t\taddEventListener(node, type, proxy);\n\t});\n\n\t// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\n\t// is removed then added back immediately (same animation frame?). Accessing the\n\t// `offsetParent` property will force a reflow and re-evaluate the CSS animation.\n\t// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\n\t// https://github.com/chartjs/Chart.js/issues/4737\n\texpando.reflow = !!node.offsetParent;\n\n\tnode.classList.add(CSS_RENDER_MONITOR);\n}\n\nfunction unwatchForRender(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar proxy = expando.renderProxy;\n\n\tif (proxy) {\n\t\thelpers.each(ANIMATION_START_EVENTS, function(type) {\n\t\t\tremoveEventListener(node, type, proxy);\n\t\t});\n\n\t\tdelete expando.renderProxy;\n\t}\n\n\tnode.classList.remove(CSS_RENDER_MONITOR);\n}\n\nfunction addResizeListener(node, listener, chart) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\n\t// Let's keep track of this added resizer and thus avoid DOM query when removing it.\n\tvar resizer = expando.resizer = createResizer(throttled(function() {\n\t\tif (expando.resizer) {\n\t\t\treturn listener(createEvent('resize', chart));\n\t\t}\n\t}));\n\n\t// The resizer needs to be attached to the node parent, so we first need to be\n\t// sure that `node` is attached to the DOM before injecting the resizer element.\n\twatchForRender(node, function() {\n\t\tif (expando.resizer) {\n\t\t\tvar container = node.parentNode;\n\t\t\tif (container && container !== resizer.parentNode) {\n\t\t\t\tcontainer.insertBefore(resizer, container.firstChild);\n\t\t\t}\n\n\t\t\t// The container size might have changed, let's reset the resizer state.\n\t\t\tresizer._reset();\n\t\t}\n\t});\n}\n\nfunction removeResizeListener(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar resizer = expando.resizer;\n\n\tdelete expando.resizer;\n\tunwatchForRender(node);\n\n\tif (resizer && resizer.parentNode) {\n\t\tresizer.parentNode.removeChild(resizer);\n\t}\n}\n\nfunction injectCSS(platform, css) {\n\t// http://stackoverflow.com/q/3922139\n\tvar style = platform._style || document.createElement('style');\n\tif (!platform._style) {\n\t\tplatform._style = style;\n\t\tcss = '/* Chart.js */\\n' + css;\n\t\tstyle.setAttribute('type', 'text/css');\n\t\tdocument.getElementsByTagName('head')[0].appendChild(style);\n\t}\n\n\tstyle.appendChild(document.createTextNode(css));\n}\n\nmodule.exports = {\n\t/**\n\t * This property holds whether this platform is enabled for the current environment.\n\t * Currently used by platform.js to select the proper implementation.\n\t * @private\n\t */\n\t_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n\tinitialize: function() {\n\t\tvar keyframes = 'from{opacity:0.99}to{opacity:1}';\n\n\t\tinjectCSS(this,\n\t\t\t// DOM rendering detection\n\t\t\t// https://davidwalsh.name/detect-node-insertion\n\t\t\t'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +\n\t\t\t'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +\n\t\t\t'.' + CSS_RENDER_MONITOR + '{' +\n\t\t\t\t'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +\n\t\t\t\t'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +\n\t\t\t'}'\n\t\t);\n\t},\n\n\tacquireContext: function(item, config) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.getElementById(item);\n\t\t} else if (item.length) {\n\t\t\t// Support for array based queries (such as jQuery)\n\t\t\titem = item[0];\n\t\t}\n\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\tvar context = item && item.getContext && item.getContext('2d');\n\n\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n\t\t// inside an iframe or when running in a protected environment. We could guess the\n\t\t// types from their toString() value but let's keep things flexible and assume it's\n\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\n\t\t// https://github.com/chartjs/Chart.js/issues/3887\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\n\t\t// https://github.com/chartjs/Chart.js/issues/4152\n\t\tif (context && context.canvas === item) {\n\t\t\tinitCanvas(item, config);\n\t\t\treturn context;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\treleaseContext: function(context) {\n\t\tvar canvas = context.canvas;\n\t\tif (!canvas[EXPANDO_KEY]) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar initial = canvas[EXPANDO_KEY].initial;\n\t\t['height', 'width'].forEach(function(prop) {\n\t\t\tvar value = initial[prop];\n\t\t\tif (helpers.isNullOrUndef(value)) {\n\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t} else {\n\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(initial.style || {}, function(value, key) {\n\t\t\tcanvas.style[key] = value;\n\t\t});\n\n\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\tcanvas.width = canvas.width;\n\n\t\tdelete canvas[EXPANDO_KEY];\n\t},\n\n\taddEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\taddResizeListener(canvas, listener, chart);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n\t\tvar proxies = expando.proxies || (expando.proxies = {});\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t};\n\n\t\taddEventListener(canvas, type, proxy);\n\t},\n\n\tremoveEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\tremoveResizeListener(canvas, listener);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || {};\n\t\tvar proxies = expando.proxies || {};\n\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\tif (!proxy) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveEventListener(canvas, type, proxy);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use EventTarget.addEventListener instead.\n * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n * @function Chart.helpers.addEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.addEvent = addEventListener;\n\n/**\n * Provided for backward compatibility, use EventTarget.removeEventListener instead.\n * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n * @function Chart.helpers.removeEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.removeEvent = removeEventListener;\n\n\n/***/ }),\n\n/***/ 1299:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* global window: false */\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('global', {\n\tanimation: {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.Animation = Element.extend({\n\t\tchart: null, // the animation associated chart instance\n\t\tcurrentStep: 0, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\n\t});\n\n\tChart.animationService = {\n\t\tframeDuration: 17,\n\t\tanimations: [],\n\t\tdropFrames: 0,\n\t\trequest: null,\n\n\t\t/**\n\t\t * @param {Chart} chart - The chart to animate.\n\t\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t\t * @param {Number} duration - The animation duration in ms.\n\t\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chart, animation, duration, lazy) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar i, ilen;\n\n\t\t\tanimation.chart = chart;\n\n\t\t\tif (!lazy) {\n\t\t\t\tchart.animating = true;\n\t\t\t}\n\n\t\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\n\t\t\t\tif (animations[i].chart === chart) {\n\t\t\t\t\tanimations[i] = animation;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(animation);\n\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (animations.length === 1) {\n\t\t\t\tthis.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\tcancelAnimation: function(chart) {\n\t\t\tvar index = helpers.findIndex(this.animations, function(animation) {\n\t\t\t\treturn animation.chart === chart;\n\t\t\t});\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchart.animating = false;\n\t\t\t}\n\t\t},\n\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\t\t\tvar startTime = Date.now();\n\t\t\tvar framesToDrop = 0;\n\n\t\t\tif (me.dropFrames > 1) {\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t}\n\n\t\t\tme.advance(1 + framesToDrop);\n\n\t\t\tvar endTime = Date.now();\n\n\t\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\n\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tadvance: function(count) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar animation, chart;\n\t\t\tvar i = 0;\n\n\t\t\twhile (i < animations.length) {\n\t\t\t\tanimation = animations[i];\n\t\t\t\tchart = animation.chart;\n\n\t\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\n\t\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n\n\t\t\t\thelpers.callback(animation.render, [chart, animation], chart);\n\t\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\n\n\t\t\t\tif (animation.currentStep >= animation.numSteps) {\n\t\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\t\tchart.animating = false;\n\t\t\t\t\tanimations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation instead\n\t * @prop Chart.Animation#animationObject\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'animationObject', {\n\t\tget: function() {\n\t\t\treturn this;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation#chart instead\n\t * @prop Chart.Animation#chartInstance\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'chartInstance', {\n\t\tget: function() {\n\t\t\treturn this.chart;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.chart = value;\n\t\t}\n\t});\n\n};\n\n\n/***/ }),\n\n/***/ 1300:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar helpers = __webpack_require__(1213);\nvar Interaction = __webpack_require__(1267);\nvar layouts = __webpack_require__(1233);\nvar platform = __webpack_require__(1268);\nvar plugins = __webpack_require__(1269);\n\nmodule.exports = function(Chart) {\n\n\t// Create a dictionary of chart types, to allow for extension of existing types\n\tChart.types = {};\n\n\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\tChart.instances = {};\n\n\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\tChart.controllers = {};\n\n\t/**\n\t * Initializes the given config with global and chart default values.\n\t */\n\tfunction initConfig(config) {\n\t\tconfig = config || {};\n\n\t\t// Do NOT use configMerge() for the data object because this method merges arrays\n\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\tvar data = config.data = config.data || {};\n\t\tdata.datasets = data.datasets || [];\n\t\tdata.labels = data.labels || [];\n\n\t\tconfig.options = helpers.configMerge(\n\t\t\tdefaults.global,\n\t\t\tdefaults[config.type],\n\t\t\tconfig.options || {});\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Updates the config of the chart\n\t * @param chart {Chart} chart to update the options for\n\t */\n\tfunction updateConfig(chart) {\n\t\tvar newOptions = chart.options;\n\n\t\thelpers.each(chart.scales, function(scale) {\n\t\t\tlayouts.removeBox(chart, scale);\n\t\t});\n\n\t\tnewOptions = helpers.configMerge(\n\t\t\tChart.defaults.global,\n\t\t\tChart.defaults[chart.config.type],\n\t\t\tnewOptions);\n\n\t\tchart.options = chart.config.options = newOptions;\n\t\tchart.ensureScalesHaveIDs();\n\t\tchart.buildOrUpdateScales();\n\t\t// Tooltip\n\t\tchart.tooltip._options = newOptions.tooltips;\n\t\tchart.tooltip.initialize();\n\t}\n\n\tfunction positionIsHorizontal(position) {\n\t\treturn position === 'top' || position === 'bottom';\n\t}\n\n\thelpers.extend(Chart.prototype, /** @lends Chart */ {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tconstruct: function(item, config) {\n\t\t\tvar me = this;\n\n\t\t\tconfig = initConfig(config);\n\n\t\t\tvar context = platform.acquireContext(item, config);\n\t\t\tvar canvas = context && context.canvas;\n\t\t\tvar height = canvas && canvas.height;\n\t\t\tvar width = canvas && canvas.width;\n\n\t\t\tme.id = helpers.uid();\n\t\t\tme.ctx = context;\n\t\t\tme.canvas = canvas;\n\t\t\tme.config = config;\n\t\t\tme.width = width;\n\t\t\tme.height = height;\n\t\t\tme.aspectRatio = height ? width / height : null;\n\t\t\tme.options = config.options;\n\t\t\tme._bufferedRender = false;\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n\t\t\t * the \"instance\" still need to be defined since it might be called from plugins.\n\t\t\t * @prop Chart#chart\n\t\t\t * @deprecated since version 2.6.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tme.chart = me;\n\t\t\tme.controller = me; // chart.chart.controller #inception\n\n\t\t\t// Add the chart instance to the global namespace\n\t\t\tChart.instances[me.id] = me;\n\n\t\t\t// Define alias to the config data: `chart.data === chart.config.data`\n\t\t\tObject.defineProperty(me, 'data', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn me.config.data;\n\t\t\t\t},\n\t\t\t\tset: function(value) {\n\t\t\t\t\tme.config.data = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!context || !canvas) {\n\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tme.initialize();\n\t\t\tme.update();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\n\t\t\t// Before init plugin notification\n\t\t\tplugins.notify(me, 'beforeInit');\n\n\t\t\thelpers.retinaScale(me, me.options.devicePixelRatio);\n\n\t\t\tme.bindEvents();\n\n\t\t\tif (me.options.responsive) {\n\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\tme.resize(true);\n\t\t\t}\n\n\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\tme.ensureScalesHaveIDs();\n\t\t\tme.buildOrUpdateScales();\n\t\t\tme.initToolTip();\n\n\t\t\t// After init plugin notification\n\t\t\tplugins.notify(me, 'afterInit');\n\n\t\t\treturn me;\n\t\t},\n\n\t\tclear: function() {\n\t\t\thelpers.canvas.clear(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tstop: function() {\n\t\t\t// Stops any current animation loop occurring\n\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tresize: function(silent) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n\n\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\n\t\t\t// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased\n\t\t\tvar newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));\n\t\t\tvar newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));\n\n\t\t\tif (me.width === newWidth && me.height === newHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcanvas.width = me.width = newWidth;\n\t\t\tcanvas.height = me.height = newHeight;\n\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\tcanvas.style.height = newHeight + 'px';\n\n\t\t\thelpers.retinaScale(me, options.devicePixelRatio);\n\n\t\t\tif (!silent) {\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tplugins.notify(me, 'resize', [newSize]);\n\n\t\t\t\t// Notify of resize\n\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t}\n\n\t\t\t\tme.stop();\n\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t}\n\t\t},\n\n\t\tensureScalesHaveIDs: function() {\n\t\t\tvar options = this.options;\n\t\t\tvar scalesOptions = options.scales || {};\n\t\t\tvar scaleOptions = options.scale;\n\n\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t});\n\n\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t});\n\n\t\t\tif (scaleOptions) {\n\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t */\n\t\tbuildOrUpdateScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar scales = me.scales || {};\n\t\t\tvar items = [];\n\t\t\tvar updated = Object.keys(scales).reduce(function(obj, id) {\n\t\t\t\tobj[id] = false;\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\n\t\t\tif (options.scales) {\n\t\t\t\titems = items.concat(\n\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n\t\t\t\t\t}),\n\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (options.scale) {\n\t\t\t\titems.push({\n\t\t\t\t\toptions: options.scale,\n\t\t\t\t\tdtype: 'radialLinear',\n\t\t\t\t\tisDefault: true,\n\t\t\t\t\tdposition: 'chartArea'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(items, function(item) {\n\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\tvar id = scaleOptions.id;\n\t\t\t\tvar scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);\n\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t\t}\n\n\t\t\t\tupdated[id] = true;\n\t\t\t\tvar scale = null;\n\t\t\t\tif (id in scales && scales[id].type === scaleType) {\n\t\t\t\t\tscale = scales[id];\n\t\t\t\t\tscale.options = scaleOptions;\n\t\t\t\t\tscale.ctx = me.ctx;\n\t\t\t\t\tscale.chart = me;\n\t\t\t\t} else {\n\t\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\t\tif (!scaleClass) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tscale = new scaleClass({\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: scaleType,\n\t\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\t\tchart: me\n\t\t\t\t\t});\n\t\t\t\t\tscales[scale.id] = scale;\n\t\t\t\t}\n\n\t\t\t\tscale.mergeTicksOptions();\n\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\tif (item.isDefault) {\n\t\t\t\t\tme.scale = scale;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// clear up discarded scales\n\t\t\thelpers.each(updated, function(hasUpdated, id) {\n\t\t\t\tif (!hasUpdated) {\n\t\t\t\t\tdelete scales[id];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.scales = scales;\n\n\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t},\n\n\t\tbuildOrUpdateControllers: function() {\n\t\t\tvar me = this;\n\t\t\tvar types = [];\n\t\t\tvar newControllers = [];\n\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\tvar type = dataset.type || me.config.type;\n\n\t\t\t\tif (meta.type && meta.type !== type) {\n\t\t\t\t\tme.destroyDatasetMeta(datasetIndex);\n\t\t\t\t\tmeta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t}\n\t\t\t\tmeta.type = type;\n\n\t\t\t\ttypes.push(meta.type);\n\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t\tmeta.controller.linkScales();\n\t\t\t\t} else {\n\t\t\t\t\tvar ControllerClass = Chart.controllers[meta.type];\n\t\t\t\t\tif (ControllerClass === undefined) {\n\t\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.controller = new ControllerClass(me, datasetIndex);\n\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\treturn newControllers;\n\t\t},\n\n\t\t/**\n\t\t * Reset the elements of all datasets\n\t\t * @private\n\t\t */\n\t\tresetElements: function() {\n\t\t\tvar me = this;\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t* Resets the chart back to it's state before the initial animation\n\t\t*/\n\t\treset: function() {\n\t\t\tthis.resetElements();\n\t\t\tthis.tooltip.initialize();\n\t\t},\n\n\t\tupdate: function(config) {\n\t\t\tvar me = this;\n\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tupdateConfig(me);\n\n\t\t\t// plugins options references might have change, let's invalidate the cache\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t\t\tplugins._invalidate(me);\n\n\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case the entire data object changed\n\t\t\tme.tooltip._data = me.data;\n\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t}, me);\n\n\t\t\tme.updateLayout();\n\n\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\tif (me.options.animation && me.options.animation.duration) {\n\t\t\t\thelpers.each(newControllers, function(controller) {\n\t\t\t\t\tcontroller.reset();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.updateDatasets();\n\n\t\t\t// Need to reset tooltip in case it is displayed with elements that are removed\n\t\t\t// after update.\n\t\t\tme.tooltip.initialize();\n\n\t\t\t// Last active contains items that were previously in the tooltip.\n\t\t\t// When we reset the tooltip, we need to clear it\n\t\t\tme.lastActive = [];\n\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\tplugins.notify(me, 'afterUpdate');\n\n\t\t\tif (me._bufferedRender) {\n\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\tduration: config.duration,\n\t\t\t\t\teasing: config.easing,\n\t\t\t\t\tlazy: config.lazy\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tme.render(config);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t\t * @private\n\t\t */\n\t\tupdateLayout: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlayouts.update(this, this.width, this.height);\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t\t * @method IPlugin#afterScaleUpdate\n\t\t\t * @deprecated since version 2.5.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tplugins.notify(me, 'afterScaleUpdate');\n\t\t\tplugins.notify(me, 'afterLayout');\n\t\t},\n\n\t\t/**\n\t\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDatasets: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.updateDataset(i);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsUpdate');\n\t\t},\n\n\t\t/**\n\t\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDataset: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.update();\n\n\t\t\tplugins.notify(me, 'afterDatasetUpdate', [args]);\n\t\t},\n\n\t\trender: function(config) {\n\t\t\tvar me = this;\n\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar duration = config.duration;\n\t\t\tvar lazy = config.lazy;\n\n\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar animationOptions = me.options.animation;\n\t\t\tvar onComplete = function(animation) {\n\t\t\t\tplugins.notify(me, 'afterRender');\n\t\t\t\thelpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\n\t\t\t};\n\n\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n\t\t\t\tvar animation = new Chart.Animation({\n\t\t\t\t\tnumSteps: (duration || animationOptions.duration) / 16.66, // 60 fps\n\t\t\t\t\teasing: config.easing || animationOptions.easing,\n\n\t\t\t\t\trender: function(chart, animationObject) {\n\t\t\t\t\t\tvar easingFunction = helpers.easing.effects[animationObject.easing];\n\t\t\t\t\t\tvar currentStep = animationObject.currentStep;\n\t\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\n\n\t\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n\t\t\t\t\t},\n\n\t\t\t\t\tonAnimationProgress: animationOptions.onProgress,\n\t\t\t\t\tonAnimationComplete: onComplete\n\t\t\t\t});\n\n\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t} else {\n\t\t\t\tme.draw();\n\n\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\n\t\t\t\tonComplete(new Chart.Animation({numSteps: 0, chart: me}));\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\n\t\tdraw: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tme.clear();\n\n\t\t\tif (helpers.isNullOrUndef(easingValue)) {\n\t\t\t\teasingValue = 1;\n\t\t\t}\n\n\t\t\tme.transition(easingValue);\n\n\t\t\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw all the scales\n\t\t\thelpers.each(me.boxes, function(box) {\n\t\t\t\tbox.draw(me.chartArea);\n\t\t\t}, me);\n\n\t\t\tif (me.scale) {\n\t\t\t\tme.scale.draw();\n\t\t\t}\n\n\t\t\tme.drawDatasets(easingValue);\n\t\t\tme._drawTooltip(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\ttransition: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tfor (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.tooltip.transition(easingValue);\n\t\t},\n\n\t\t/**\n\t\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDatasets: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw datasets reversed to support proper line stacking\n\t\t\tfor (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.drawDataset(i, easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDataset: function(index, easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.draw(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDatasetDraw', [args]);\n\t\t},\n\n\t\t/**\n\t\t * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\n\t\t * hook, in which case, plugins will not be called on `afterTooltipDraw`.\n\t\t * @private\n\t\t */\n\t\t_drawTooltip: function(easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\t\t\tvar args = {\n\t\t\t\ttooltip: tooltip,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttooltip.draw();\n\n\t\t\tplugins.notify(me, 'afterTooltipDraw', [args]);\n\t\t},\n\n\t\t// Get the single element that was clicked on\n\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\tgetElementAtEvent: function(e) {\n\t\t\treturn Interaction.modes.single(this, e);\n\t\t},\n\n\t\tgetElementsAtEvent: function(e) {\n\t\t\treturn Interaction.modes.label(this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtXAxis: function(e) {\n\t\t\treturn Interaction.modes['x-axis'](this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\t\tvar method = Interaction.modes[mode];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\treturn method(this, e, options);\n\t\t\t}\n\n\t\t\treturn [];\n\t\t},\n\n\t\tgetDatasetAtEvent: function(e) {\n\t\t\treturn Interaction.modes.dataset(this, e, {intersect: true});\n\t\t},\n\n\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\tif (!dataset._meta) {\n\t\t\t\tdataset._meta = {};\n\t\t\t}\n\n\t\t\tvar meta = dataset._meta[me.id];\n\t\t\tif (!meta) {\n\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tdata: [],\n\t\t\t\t\tdataset: null,\n\t\t\t\t\tcontroller: null,\n\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\txAxisID: null,\n\t\t\t\t\tyAxisID: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn meta;\n\t\t},\n\n\t\tgetVisibleDatasetCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t},\n\n\t\tgenerateLegend: function() {\n\t\t\treturn this.options.legendCallback(this);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroyDatasetMeta: function(datasetIndex) {\n\t\t\tvar id = this.id;\n\t\t\tvar dataset = this.data.datasets[datasetIndex];\n\t\t\tvar meta = dataset._meta && dataset._meta[id];\n\n\t\t\tif (meta) {\n\t\t\t\tmeta.controller.destroy();\n\t\t\t\tdelete dataset._meta[id];\n\t\t\t}\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tvar me = this;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar i, ilen;\n\n\t\t\tme.stop();\n\n\t\t\t// dataset controllers need to cleanup associated data\n\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.destroyDatasetMeta(i);\n\t\t\t}\n\n\t\t\tif (canvas) {\n\t\t\t\tme.unbindEvents();\n\t\t\t\thelpers.canvas.clear(me);\n\t\t\t\tplatform.releaseContext(me.ctx);\n\t\t\t\tme.canvas = null;\n\t\t\t\tme.ctx = null;\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'destroy');\n\n\t\t\tdelete Chart.instances[me.id];\n\t\t},\n\n\t\ttoBase64Image: function() {\n\t\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\n\t\t},\n\n\t\tinitToolTip: function() {\n\t\t\tvar me = this;\n\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t_chart: me,\n\t\t\t\t_chartInstance: me, // deprecated, backward compatibility\n\t\t\t\t_data: me.data,\n\t\t\t\t_options: me.options.tooltips\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners = {};\n\t\t\tvar listener = function() {\n\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t};\n\n\t\t\thelpers.each(me.options.events, function(type) {\n\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\tlisteners[type] = listener;\n\t\t\t});\n\n\t\t\t// Elements used to detect size change should not be injected for non responsive charts.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\tif (me.options.responsive) {\n\t\t\t\tlistener = function() {\n\t\t\t\t\tme.resize();\n\t\t\t\t};\n\n\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\tlisteners.resize = listener;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tunbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners;\n\t\t\tif (!listeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete me._listeners;\n\t\t\thelpers.each(listeners, function(listener, type) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t});\n\t\t},\n\n\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\tvar method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\tvar element, i, ilen;\n\n\t\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\t\telement = elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\teventHandler: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\n\t\t\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\tme._bufferedRender = true;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\tvar changed = me.handleEvent(e);\n\t\t\t// for smooth tooltip animations issue #4989\n\t\t\t// the tooltip should be the source of change\n\t\t\t// Animation check workaround:\n\t\t\t// tooltip._start will be null when tooltip isn't animating\n\t\t\tif (tooltip) {\n\t\t\t\tchanged = tooltip._start\n\t\t\t\t\t? tooltip.handleEvent(e)\n\t\t\t\t\t: changed | tooltip.handleEvent(e);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterEvent', [e]);\n\n\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\tif (bufferedRequest) {\n\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\tme.render(bufferedRequest);\n\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\tme.stop();\n\n\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\tme.render(me.options.hover.animationDuration, true);\n\t\t\t}\n\n\t\t\tme._bufferedRender = false;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\treturn me;\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event the event to handle\n\t\t * @return {Boolean} true if the chart needs to re-render\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options || {};\n\t\t\tvar hoverOptions = options.hover;\n\t\t\tvar changed = false;\n\n\t\t\tme.lastActive = me.lastActive || [];\n\n\t\t\t// Find Active Elements for hover and tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme.active = [];\n\t\t\t} else {\n\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t}\n\n\t\t\t// Invoke onHover hook\n\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\thelpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\n\n\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\tif (options.onClick) {\n\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\tif (me.lastActive.length) {\n\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t}\n\n\t\t\t// Built in hover styling\n\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t}\n\n\t\t\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\n\n\t\t\t// Remember Last Actives\n\t\t\tme.lastActive = me.active;\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart instead.\n\t * @class Chart.Controller\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.Controller = Chart;\n};\n\n\n/***/ }),\n\n/***/ 1301:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1213);\n\nmodule.exports = function(Chart) {\n\n\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n\t/**\n\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n\t */\n\tfunction listenArrayEvents(array, listener) {\n\t\tif (array._chartjs) {\n\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\treturn;\n\t\t}\n\n\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: {\n\t\t\t\tlisteners: [listener]\n\t\t\t}\n\t\t});\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\tvar base = array[key];\n\n\t\t\tObject.defineProperty(array, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\t\thelpers.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the given array event listener and cleanup extra attached properties (such as\n\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n\t */\n\tfunction unlistenArrayEvents(array, listener) {\n\t\tvar stub = array._chartjs;\n\t\tif (!stub) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar listeners = stub.listeners;\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\tif (listeners.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tdelete array[key];\n\t\t});\n\n\t\tdelete array._chartjs;\n\t}\n\n\t// Base class for all dataset controllers (line, bar, etc)\n\tChart.DatasetController = function(chart, datasetIndex) {\n\t\tthis.initialize(chart, datasetIndex);\n\t};\n\n\thelpers.extend(Chart.DatasetController.prototype, {\n\n\t\t/**\n\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdatasetElementType: null,\n\n\t\t/**\n\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdataElementType: null,\n\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tme.chart = chart;\n\t\t\tme.index = datasetIndex;\n\t\t\tme.linkScales();\n\t\t\tme.addElements();\n\t\t},\n\n\t\tupdateIndex: function(datasetIndex) {\n\t\t\tthis.index = datasetIndex;\n\t\t},\n\n\t\tlinkScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\tif (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {\n\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t}\n\t\t\tif (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {\n\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t}\n\t\t},\n\n\t\tgetDataset: function() {\n\t\t\treturn this.chart.data.datasets[this.index];\n\t\t},\n\n\t\tgetMeta: function() {\n\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t},\n\n\t\tgetScaleForId: function(scaleID) {\n\t\t\treturn this.chart.scales[scaleID];\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.update(true);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._data) {\n\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t}\n\t\t},\n\n\t\tcreateMetaDataset: function() {\n\t\t\tvar me = this;\n\t\t\tvar type = me.datasetElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index\n\t\t\t});\n\t\t},\n\n\t\tcreateMetaData: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar type = me.dataElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index\n\t\t\t});\n\t\t},\n\n\t\taddElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data || [];\n\t\t\tvar metaData = meta.data;\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t}\n\n\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t},\n\n\t\taddElementAndReset: function(index) {\n\t\t\tvar element = this.createMetaData(index);\n\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\tthis.updateElement(element, index, true);\n\t\t},\n\n\t\tbuildOrUpdateElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t// the internal meta data accordingly.\n\t\t\tif (me._data !== data) {\n\t\t\t\tif (me._data) {\n\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t}\n\n\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\tme._data = data;\n\t\t\t}\n\n\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\tme.resyncElements();\n\t\t},\n\n\t\tupdate: helpers.noop,\n\n\t\ttransition: function(easingValue) {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].transition(easingValue);\n\t\t\t}\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.transition(easingValue);\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].draw();\n\t\t\t}\n\t\t},\n\n\t\tremoveHoverStyle: function(element, elementOpts) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar valueOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\tvar model = element._model;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t},\n\n\t\tsetHoverStyle: function(element) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar valueOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\tvar getHoverColor = helpers.getHoverColor;\n\t\t\tvar model = element._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tresyncElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data;\n\t\t\tvar numMeta = meta.data.length;\n\t\t\tvar numData = data.length;\n\n\t\t\tif (numData < numMeta) {\n\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t} else if (numData > numMeta) {\n\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinsertElements: function(start, count) {\n\t\t\tfor (var i = 0; i < count; ++i) {\n\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPush: function() {\n\t\t\tthis.insertElements(this.getDataset().data.length - 1, arguments.length);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPop: function() {\n\t\t\tthis.getMeta().data.pop();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataShift: function() {\n\t\t\tthis.getMeta().data.shift();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataSplice: function(start, count) {\n\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataUnshift: function() {\n\t\t\tthis.insertElements(0, arguments.length);\n\t\t}\n\t});\n\n\tChart.DatasetController.extend = helpers.inherits;\n};\n\n\n/***/ }),\n\n/***/ 1302:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar helpers = __webpack_require__(1213);\nvar layouts = __webpack_require__(1233);\n\nmodule.exports = function(Chart) {\n\n\tChart.scaleService = {\n\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t// use the new chart options to grab the correct scale\n\t\tconstructors: {},\n\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t// old browsers\n\n\t\t// Scale config defaults\n\t\tdefaults: {},\n\t\tregisterScaleType: function(type, scaleConstructor, scaleDefaults) {\n\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\tthis.defaults[type] = helpers.clone(scaleDefaults);\n\t\t},\n\t\tgetScaleConstructor: function(type) {\n\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t},\n\t\tgetScaleDefaults: function(type) {\n\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};\n\t\t},\n\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\tvar me = this;\n\t\t\tif (me.defaults.hasOwnProperty(type)) {\n\t\t\t\tme.defaults[type] = helpers.extend(me.defaults[type], additions);\n\t\t\t}\n\t\t},\n\t\taddScalesToLayout: function(chart) {\n\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\thelpers.each(chart.scales, function(scale) {\n\t\t\t\t// Set ILayoutItem parameters for backwards compatibility\n\t\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\t\tscale.position = scale.options.position;\n\t\t\t\tscale.weight = scale.options.weight;\n\t\t\t\tlayouts.addBox(chart, scale);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 1303:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\nvar helpers = __webpack_require__(1213);\nvar Ticks = __webpack_require__(1234);\n\ndefaults._set('scale', {\n\tdisplay: true,\n\tposition: 'left',\n\toffset: false,\n\n\t// grid line settings\n\tgridLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\tlineWidth: 1,\n\t\tdrawBorder: true,\n\t\tdrawOnChartArea: true,\n\t\tdrawTicks: true,\n\t\ttickMarkLength: 10,\n\t\tzeroLineWidth: 1,\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\tzeroLineBorderDash: [],\n\t\tzeroLineBorderDashOffset: 0.0,\n\t\toffsetGridLines: false,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\n\t// scale label\n\tscaleLabel: {\n\t\t// display property\n\t\tdisplay: false,\n\n\t\t// actual label\n\t\tlabelString: '',\n\n\t\t// line height\n\t\tlineHeight: 1.2,\n\n\t\t// top/bottom padding\n\t\tpadding: {\n\t\t\ttop: 4,\n\t\t\tbottom: 4\n\t\t}\n\t},\n\n\t// label settings\n\tticks: {\n\t\tbeginAtZero: false,\n\t\tminRotation: 0,\n\t\tmaxRotation: 50,\n\t\tmirror: false,\n\t\tpadding: 0,\n\t\treverse: false,\n\t\tdisplay: true,\n\t\tautoSkip: true,\n\t\tautoSkipPadding: 0,\n\t\tlabelOffset: 0,\n\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\tcallback: Ticks.formatters.values,\n\t\tminor: {},\n\t\tmajor: {}\n\t}\n});\n\nfunction labelsFromTicks(ticks) {\n\tvar labels = [];\n\tvar i, ilen;\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tlabels.push(ticks[i].label);\n\t}\n\n\treturn labels;\n}\n\nfunction getLineValue(scale, index, offsetGridLines) {\n\tvar lineValue = scale.getPixelForTick(index);\n\n\tif (offsetGridLines) {\n\t\tif (index === 0) {\n\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t}\n\t}\n\treturn lineValue;\n}\n\nmodule.exports = function(Chart) {\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar globalDefaults = defaults.global;\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tfunction parseLineHeight(options) {\n\t\treturn helpers.options.toLineHeight(\n\t\t\thelpers.valueOrDefault(options.lineHeight, 1.2),\n\t\t\thelpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));\n\t}\n\n\tChart.Scale = Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Returns the scale tick objects ({label, major})\n\t\t * @since 2.7\n\t\t */\n\t\tgetTicks: function() {\n\t\t\treturn this._ticks;\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tmergeTicksOptions: function() {\n\t\t\tvar ticks = this.options.ticks;\n\t\t\tif (ticks.minor === false) {\n\t\t\t\tticks.minor = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (ticks.major === false) {\n\t\t\t\tticks.major = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var key in ticks) {\n\t\t\t\tif (key !== 'major' && key !== 'minor') {\n\t\t\t\t\tif (typeof ticks.minor[key] === 'undefined') {\n\t\t\t\t\t\tticks.minor[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof ticks.major[key] === 'undefined') {\n\t\t\t\t\t\tticks.major[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\t\t\tvar i, ilen, labels, label, ticks, tick;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks - `this.ticks` is now DEPRECATED!\n\t\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n\t\t\t// and must not be accessed directly from outside this class. `this.ticks` being\n\t\t\t// around for long time and not marked as private, we can't change its structure\n\t\t\t// without unexpected breaking changes. If you need to access the scale ticks,\n\t\t\t// use scale.getTicks() instead.\n\n\t\t\tme.beforeBuildTicks();\n\n\t\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\n\t\t\t// we still support no return (`this.ticks` internally set by calling this method).\n\t\t\tticks = me.buildTicks() || [];\n\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\n\t\t\t// New implementations should return the formatted tick labels but for BACKWARD\n\t\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\n\t\t\t// this method and supposed to contain only string values).\n\t\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\n\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\n\n\t\t\t// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n\n\t\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\t\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\t\tlabel = labels[i];\n\t\t\t\ttick = ticks[i];\n\t\t\t\tif (!tick) {\n\t\t\t\t\tticks.push(tick = {\n\t\t\t\t\t\tlabel: label,\n\t\t\t\t\t\tmajor: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttick.label = label;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme._ticks = ticks;\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (labels.length && me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation, sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tvar scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);\n\t\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n\t\t\t\tvar deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += deltaHeight;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += deltaHeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\t\t\t\tvar tickPadding = me.options.ticks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * (tallestLabelHeightInLines - 1))\n\t\t\t\t\t\t+ lineSpace; // padding\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n\t\t\t\t\t// which means that the right padding is dominated by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\n\t\t\t\t\t// dominant factor here, so get that length first and account for padding\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// use lineSpace for consistency with horizontal axis\n\t\t\t\t\t\t// tickPadding is not implemented for horizontal\n\t\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\n\t\t\t\t\t}\n\n\t\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (helpers.isNullOrUndef(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof rawValue === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (rawValue) {\n\t\t\t\tif (this.isHorizontal()) {\n\t\t\t\t\tif (rawValue.x !== undefined) {\n\t\t\t\t\t\treturn this.getRightValue(rawValue.x);\n\t\t\t\t\t}\n\t\t\t\t} else if (rawValue.y !== undefined) {\n\t\t\t\t\treturn this.getRightValue(rawValue.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t/**\n\t\t * Used to get the value to display in the tooltip for the data at the given index\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param value\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t/**\n\t\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param pixel\n\t\t */\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the tick at the given index\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (offset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me._ticks.length - 1)));\n\t\t},\n\n\t\t/**\n\t\t * Utility for getting the pixel location of a percentage of scale\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForDecimal: function(decimal) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\t/**\n\t\t * Returns the pixel for the minimum chart value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t/**\n\t\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\n\t\t * @private\n\t\t */\n\t\t_autoSkip: function(ticks) {\n\t\t\tvar skipRatio;\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar optionTicks = me.options.ticks.minor;\n\t\t\tvar tickCount = ticks.length;\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\t\t\tvar result = [];\n\t\t\tvar i, tick, shouldSkip;\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && tickCount > maxTicks) {\n\t\t\t\t\tskipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < tickCount; i++) {\n\t\t\t\ttick = ticks[i];\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tshouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);\n\t\t\t\tif (shouldSkip && i !== tickCount - 1) {\n\t\t\t\t\t// leave tick in place but make sure it's not displayed (#4635)\n\t\t\t\t\tdelete tick.label;\n\t\t\t\t}\n\t\t\t\tresult.push(tick);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = defaults.global;\n\t\t\tvar optionTicks = options.ticks.minor;\n\t\t\tvar optionMajorTicks = options.ticks.major || optionTicks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n\t\t\tvar tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\t\t\tvar majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar majorTickFont = parseFontOptions(optionMajorTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\t\tvar scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tvar axisWidth = me.options.gridLines.lineWidth;\n\t\t\tvar xTickStart = options.position === 'right' ? me.right : me.right - axisWidth - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.right + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;\n\n\t\t\thelpers.each(ticks, function(tick, index) {\n\t\t\t\t// autoskipper skipped this tick (#4635)\n\t\t\t\tif (helpers.isNullOrUndef(tick.label)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar label = tick.label;\n\t\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\tborderDash = gridLines.zeroLineBorderDash;\n\t\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\tborderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\t\tborderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\t\t\t\tvar tickPadding = optionTicks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tvar labelYOffset = tl + tickPadding;\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'top' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\t\tlabelY = me.top + labelYOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'bottom' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\t\tlabelY = me.bottom - labelYOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (xLineValue < me.left) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\txLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom + axisWidth;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (yLineValue < me.top) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelY = me.getPixelForTick(index) + optionTicks.labelOffset;\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right + axisWidth;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tmajor: tick.major,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = itemToDraw.major ? majorTickFont.font : tickFont.font;\n\t\t\t\t\tcontext.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tvar lineCount = label.length;\n\t\t\t\t\t\tvar lineHeight = tickFont.size * 1.5;\n\t\t\t\t\t\tvar y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;\n\n\t\t\t\t\t\tfor (var i = 0; i < lineCount; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\t\t\t\tvar halfLineHeight = parseLineHeight(scaleLabel) / 2;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom'\n\t\t\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\n\t\t\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft\n\t\t\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left;\n\t\t\t\tvar x2 = me.right + axisWidth;\n\t\t\t\tvar y1 = me.top;\n\t\t\t\tvar y2 = me.bottom + axisWidth;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 1304:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('global', {\n\ttooltips: {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFontStyle: 'bold',\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleFontColor: '#fff',\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFontColor: '#fff',\n\t\tbodyAlign: 'left',\n\t\tfooterFontStyle: 'bold',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFontColor: '#fff',\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretPadding: 2,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tborderColor: 'rgba(0,0,0,0)',\n\t\tborderWidth: 0,\n\t\tcallbacks: {\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeTitle: helpers.noop,\n\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\t\t\t\tvar labels = data.labels;\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tvar item = tooltipItems[0];\n\n\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\t\t\tafterTitle: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tbeforeLabel: helpers.noop,\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel += ': ';\n\t\t\t\t}\n\t\t\t\tlabel += tooltipItem.yLabel;\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tlabelColor: function(tooltipItem, chart) {\n\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\tvar view = activeElement._view;\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tlabelTextColor: function() {\n\t\t\t\treturn this._options.bodyFontColor;\n\t\t\t},\n\t\t\tafterLabel: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tafterBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeFooter: helpers.noop,\n\t\t\tfooter: helpers.noop,\n\t\t\tafterFooter: helpers.noop\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\t/**\n \t * Helper method to merge the opacity into a color\n \t */\n\tfunction mergeOpacity(colorString, opacity) {\n\t\tvar color = helpers.color(colorString);\n\t\treturn color.alpha(opacity * color.alpha()).rgbaString();\n\t}\n\n\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\tfunction pushOrConcat(base, toPush) {\n\t\tif (toPush) {\n\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t// base = base.concat(toPush);\n\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t} else {\n\t\t\t\tbase.push(toPush);\n\t\t\t}\n\t\t}\n\n\t\treturn base;\n\t}\n\n\t// Private helper to create a tooltip item model\n\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t// @return : new tooltip item\n\tfunction createTooltipItem(element) {\n\t\tvar xScale = element._xScale;\n\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\tvar index = element._index;\n\t\tvar datasetIndex = element._datasetIndex;\n\n\t\treturn {\n\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tindex: index,\n\t\t\tdatasetIndex: datasetIndex,\n\t\t\tx: element._model.x,\n\t\t\ty: element._model.y\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the reset model for the tooltip\n\t * @param tooltipOpts {Object} the tooltip options\n\t */\n\tfunction getBaseModel(tooltipOpts) {\n\t\tvar globalDefaults = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\treturn {\n\t\t\t// Positioning\n\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t\t// Body\n\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\tbodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t\t// Title\n\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\ttitleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t\t// Footer\n\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\tfooterFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t\t// Appearance\n\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\topacity: 0,\n\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\tdisplayColors: tooltipOpts.displayColors,\n\t\t\tborderColor: tooltipOpts.borderColor,\n\t\t\tborderWidth: tooltipOpts.borderWidth\n\t\t};\n\t}\n\n\t/**\n\t * Get the size of the tooltip\n\t */\n\tfunction getTooltipSize(tooltip, model) {\n\t\tvar ctx = tooltip._chart.ctx;\n\n\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\tvar width = 0;\n\n\t\t// Count of all lines in the body\n\t\tvar body = model.body;\n\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t}, 0);\n\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\t\tvar titleLineCount = model.title.length;\n\t\tvar footerLineCount = model.footer.length;\n\t\tvar titleFontSize = model.titleFontSize;\n\t\tvar bodyFontSize = model.bodyFontSize;\n\t\tvar footerFontSize = model.footerFontSize;\n\n\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\theight += footerLineCount * (footerFontSize); // Footer Lines\n\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t\t// Title width\n\t\tvar widthPadding = 0;\n\t\tvar maxLineWidth = function(line) {\n\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t};\n\n\t\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\thelpers.each(model.title, maxLineWidth);\n\n\t\t// Body width\n\t\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t\t// Body lines may include some extra width due to the color box\n\t\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\t\thelpers.each(body, function(bodyItem) {\n\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t});\n\n\t\t// Reset back to 0\n\t\twidthPadding = 0;\n\n\t\t// Footer width\n\t\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\thelpers.each(model.footer, maxLineWidth);\n\n\t\t// Add padding\n\t\twidth += 2 * model.xPadding;\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the alignment of a tooltip given the size\n\t */\n\tfunction determineAlignment(tooltip, size) {\n\t\tvar model = tooltip._model;\n\t\tvar chart = tooltip._chart;\n\t\tvar chartArea = tooltip._chart.chartArea;\n\t\tvar xAlign = 'center';\n\t\tvar yAlign = 'center';\n\n\t\tif (model.y < size.height) {\n\t\t\tyAlign = 'top';\n\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\tyAlign = 'bottom';\n\t\t}\n\n\t\tvar lf, rf; // functions to determine left, right alignment\n\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\t\tif (yAlign === 'center') {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= midX;\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x > midX;\n\t\t\t};\n\t\t} else {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= (size.width / 2);\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t};\n\t\t}\n\n\t\tolf = function(x) {\n\t\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\n\t\t};\n\t\torf = function(x) {\n\t\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\n\t\t};\n\t\tyf = function(y) {\n\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t};\n\n\t\tif (lf(model.x)) {\n\t\t\txAlign = 'left';\n\n\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\tif (olf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t} else if (rf(model.x)) {\n\t\t\txAlign = 'right';\n\n\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\tif (orf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t}\n\n\t\tvar opts = tooltip._options;\n\t\treturn {\n\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t};\n\t}\n\n\t/**\n\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n\t */\n\tfunction getBackgroundPoint(vm, size, alignment, chart) {\n\t\t// Background Position\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\n\t\tvar caretSize = vm.caretSize;\n\t\tvar caretPadding = vm.caretPadding;\n\t\tvar cornerRadius = vm.cornerRadius;\n\t\tvar xAlign = alignment.xAlign;\n\t\tvar yAlign = alignment.yAlign;\n\t\tvar paddingAndSize = caretSize + caretPadding;\n\t\tvar radiusAndPadding = cornerRadius + caretPadding;\n\n\t\tif (xAlign === 'right') {\n\t\t\tx -= size.width;\n\t\t} else if (xAlign === 'center') {\n\t\t\tx -= (size.width / 2);\n\t\t\tif (x + size.width > chart.width) {\n\t\t\t\tx = chart.width - size.width;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (yAlign === 'top') {\n\t\t\ty += paddingAndSize;\n\t\t} else if (yAlign === 'bottom') {\n\t\t\ty -= size.height + paddingAndSize;\n\t\t} else {\n\t\t\ty -= (size.height / 2);\n\t\t}\n\n\t\tif (yAlign === 'center') {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx += paddingAndSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx -= paddingAndSize;\n\t\t\t}\n\t\t} else if (xAlign === 'left') {\n\t\t\tx -= radiusAndPadding;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx += radiusAndPadding;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\tChart.Tooltip = Element.extend({\n\t\tinitialize: function() {\n\t\t\tthis._model = getBaseModel(this._options);\n\t\t\tthis._lastActive = [];\n\t\t},\n\n\t\t// Get the title\n\t\t// Args are: (tooltipItem, data)\n\t\tgetTitle: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\t\tvar callbacks = opts.callbacks;\n\n\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n\t\t\tvar title = callbacks.title.apply(me, arguments);\n\t\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\tlines = pushOrConcat(lines, title);\n\t\t\tlines = pushOrConcat(lines, afterTitle);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBeforeBody: function() {\n\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBody: function(tooltipItems, data) {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\t\tvar bodyItems = [];\n\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tvar bodyItem = {\n\t\t\t\t\tbefore: [],\n\t\t\t\t\tlines: [],\n\t\t\t\t\tafter: []\n\t\t\t\t};\n\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\n\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t});\n\n\t\t\treturn bodyItems;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetAfterBody: function() {\n\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t// Args are: (tooltipItem, data)\n\t\tgetFooter: function() {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\n\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\tlines = pushOrConcat(lines, afterFooter);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\tupdate: function(changed) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\n\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t// which breaks any animations.\n\t\t\tvar existingModel = me._model;\n\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\tvar active = me._active;\n\n\t\t\tvar data = me._data;\n\n\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\tvar alignment = {\n\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t};\n\t\t\tvar backgroundPoint = {\n\t\t\t\tx: existingModel.x,\n\t\t\t\ty: existingModel.y\n\t\t\t};\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: existingModel.width,\n\t\t\t\theight: existingModel.height\n\t\t\t};\n\t\t\tvar tooltipPosition = {\n\t\t\t\tx: existingModel.caretX,\n\t\t\t\ty: existingModel.caretY\n\t\t\t};\n\n\t\t\tvar i, len;\n\n\t\t\tif (active.length) {\n\t\t\t\tmodel.opacity = 1;\n\n\t\t\t\tvar labelColors = [];\n\t\t\t\tvar labelTextColors = [];\n\t\t\t\ttooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);\n\n\t\t\t\tvar tooltipItems = [];\n\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\tif (opts.filter) {\n\t\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Determine colors for boxes\n\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n\t\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n\t\t\t\t});\n\n\n\t\t\t\t// Build the Text Lines\n\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t\t// Initial positioning and colors\n\t\t\t\tmodel.x = Math.round(tooltipPosition.x);\n\t\t\t\tmodel.y = Math.round(tooltipPosition.y);\n\t\t\t\tmodel.caretPadding = opts.caretPadding;\n\t\t\t\tmodel.labelColors = labelColors;\n\t\t\t\tmodel.labelTextColors = labelTextColors;\n\n\t\t\t\t// data points\n\t\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t// Final Size and Position\n\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n\t\t\t} else {\n\t\t\t\tmodel.opacity = 0;\n\t\t\t}\n\n\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\tmodel.x = backgroundPoint.x;\n\t\t\tmodel.y = backgroundPoint.y;\n\t\t\tmodel.width = tooltipSize.width;\n\t\t\tmodel.height = tooltipSize.height;\n\n\t\t\t// Point where the caret on the tooltip points to\n\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\tmodel.caretY = tooltipPosition.y;\n\n\t\t\tme._model = model;\n\n\t\t\tif (changed && opts.custom) {\n\t\t\t\topts.custom.call(me, model);\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\t\tdrawCaret: function(tooltipPoint, size) {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n\n\t\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t\t},\n\t\tgetCaretPosition: function(tooltipPoint, size, vm) {\n\t\t\tvar x1, x2, x3, y1, y2, y3;\n\t\t\tvar caretSize = vm.caretSize;\n\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar ptX = tooltipPoint.x;\n\t\t\tvar ptY = tooltipPoint.y;\n\t\t\tvar width = size.width;\n\t\t\tvar height = size.height;\n\n\t\t\tif (yAlign === 'center') {\n\t\t\t\ty2 = ptY + (height / 2);\n\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\t\ty3 = y2 - caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx2 = vm.caretX;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t}\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\ty1 = ptY;\n\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t\t// invert drawing order\n\t\t\t\t\tvar tmp = x3;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t\tx1 = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n\t\t},\n\t\tdrawTitle: function(pt, vm, ctx, opacity) {\n\t\t\tvar title = vm.title;\n\n\t\t\tif (title.length) {\n\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tvar titleFontSize = vm.titleFontSize;\n\t\t\t\tvar titleSpacing = vm.titleSpacing;\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\t\tvar i, len;\n\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdrawBody: function(pt, vm, ctx, opacity) {\n\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\tvar body = vm.body;\n\n\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\tctx.textBaseline = 'top';\n\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\t\t// Before Body\n\t\t\tvar xLinePadding = 0;\n\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t};\n\n\t\t\t// Before body lines\n\t\t\tctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);\n\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\n\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n\n\t\t\t// Draw body lines now\n\t\t\thelpers.each(body, function(bodyItem, i) {\n\t\t\t\tvar textColor = mergeOpacity(vm.labelTextColors[i], opacity);\n\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\n\t\t\t\thelpers.each(bodyItem.lines, function(line) {\n\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Border\n\t\t\t\t\t\tctx.lineWidth = 1;\n\t\t\t\t\t\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t});\n\n\t\t\t// Reset back to 0 for after body\n\t\t\txLinePadding = 0;\n\n\t\t\t// After body lines\n\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t},\n\t\tdrawFooter: function(pt, vm, ctx, opacity) {\n\t\t\tvar footer = vm.footer;\n\n\t\t\tif (footer.length) {\n\t\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\t\thelpers.each(footer, function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\n\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\tctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);\n\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar x = pt.x;\n\t\t\tvar y = pt.y;\n\t\t\tvar width = tooltipSize.width;\n\t\t\tvar height = tooltipSize.height;\n\t\t\tvar radius = vm.cornerRadius;\n\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\tif (yAlign === 'top') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\tif (yAlign === 'bottom') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.closePath();\n\n\t\t\tctx.fill();\n\n\t\t\tif (vm.borderWidth > 0) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm.opacity === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: vm.width,\n\t\t\t\theight: vm.height\n\t\t\t};\n\t\t\tvar pt = {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\n\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t\t// Truthy/falsey value for empty tooltip\n\t\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n\t\t\tif (this._options.enabled && hasTooltipContent) {\n\t\t\t\t// Draw Background\n\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n\n\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\tpt.y += vm.yPadding;\n\n\t\t\t\t// Titles\n\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\n\t\t\t\t// Body\n\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\n\t\t\t\t// Footer\n\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @returns {Boolean} true if the tooltip changed\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me._options;\n\t\t\tvar changed = false;\n\n\t\t\tme._lastActive = me._lastActive || [];\n\n\t\t\t// Find Active Elements for tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme._active = [];\n\t\t\t} else {\n\t\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t}\n\n\t\t\t// Remember Last Actives\n\t\t\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\n\n\t\t\t// Only handle target event on tooltip change\n\t\t\tif (changed) {\n\t\t\t\tme._lastActive = me._active;\n\n\t\t\t\tif (options.enabled || options.custom) {\n\t\t\t\t\tme._eventPosition = {\n\t\t\t\t\t\tx: e.x,\n\t\t\t\t\t\ty: e.y\n\t\t\t\t\t};\n\n\t\t\t\t\tme.update(true);\n\t\t\t\t\tme.pivot();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * @namespace Chart.Tooltip.positioners\n\t */\n\tChart.Tooltip.positioners = {\n\t\t/**\n\t\t * Average mode places the tooltip at the average position of the elements shown\n\t\t * @function Chart.Tooltip.positioners.average\n\t\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t\t * @returns {Point} tooltip position\n\t\t */\n\t\taverage: function(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, len;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar count = 0;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\tx += pos.x;\n\t\t\t\t\ty += pos.y;\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: Math.round(x / count),\n\t\t\t\ty: Math.round(y / count)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Gets the tooltip position nearest of the item nearest to the event position\n\t\t * @function Chart.Tooltip.positioners.nearest\n\t\t * @param elements {Chart.Element[]} the tooltip elements\n\t\t * @param eventPosition {Point} the position of the event in canvas coordinates\n\t\t * @returns {Point} the tooltip position\n\t\t */\n\t\tnearest: function(elements, eventPosition) {\n\t\t\tvar x = eventPosition.x;\n\t\t\tvar y = eventPosition.y;\n\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\tvar i, len, nearestElement;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nearestElement) {\n\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\tx = tp.x;\n\t\t\t\ty = tp.y;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 1305:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1213);\n\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t// for details.\n\n\tvar spacing;\n\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\tspacing = generationOptions.stepSize;\n\t} else {\n\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t}\n\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t// If very close to our whole number, use it.\n\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\tniceMin = generationOptions.min;\n\t\t\tniceMax = generationOptions.max;\n\t\t}\n\t}\n\n\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t// If very close to our rounded value, use it.\n\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\tnumSpaces = Math.round(numSpaces);\n\t} else {\n\t\tnumSpaces = Math.ceil(numSpaces);\n\t}\n\n\tvar precision = 1;\n\tif (spacing < 1) {\n\t\tprecision = Math.pow(10, spacing.toString().length - 2);\n\t\tniceMin = Math.round(niceMin * precision) / precision;\n\t\tniceMax = Math.round(niceMax * precision) / precision;\n\t}\n\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\tfor (var j = 1; j < numSpaces; ++j) {\n\t\tticks.push(Math.round((niceMin + j * spacing) * precision) / precision);\n\t}\n\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar noop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\tgetRightValue: function(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn +value;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, value);\n\t\t},\n\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (setMin !== setMax) {\n\t\t\t\t// We set the min or the max but not both.\n\t\t\t\t// So ensure that our range is good\n\t\t\t\t// Inverted or 0 length range can happen when\n\t\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\t\tif (me.min >= me.max) {\n\t\t\t\t\tif (setMin) {\n\t\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 1306:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);\n\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (offset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (offset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (offset) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value + me.minIndex;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 1307:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar helpers = __webpack_require__(1213);\nvar Ticks = __webpack_require__(1234);\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar DEFAULT_MIN = 0;\n\t\t\tvar DEFAULT_MAX = 1;\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n\t\t\tme.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t} else {\n\t\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 1308:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar helpers = __webpack_require__(1213);\nvar Ticks = __webpack_require__(1234);\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t// Figure out what the max number of ticks we can support it is based on the size of\n\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t// the graph\n\tvar tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\tvar exp, significand;\n\n\tif (tickVal === 0) {\n\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\tticks.push(tickVal);\n\t\ttickVal = significand * Math.pow(10, exp);\n\t} else {\n\t\texp = Math.floor(helpers.log10(tickVal));\n\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t}\n\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n\tdo {\n\t\tticks.push(tickVal);\n\n\t\t++significand;\n\t\tif (significand === 10) {\n\t\t\tsignificand = 1;\n\t\t\t++exp;\n\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t}\n\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\tvar lastTick = valueOrDefault(generationOptions.max, tickVal);\n\tticks.push(lastTick);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tif (valuesForType.length > 0) {\n\t\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar DEFAULT_MIN = 1;\n\t\t\tvar DEFAULT_MAX = 10;\n\n\t\t\tme.min = valueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = valueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = DEFAULT_MIN;\n\t\t\t\t\tme.max = DEFAULT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n\t\t\t}\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = me.min !== 0\n\t\t\t\t\t? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)\n\t\t\t\t\t: DEFAULT_MAX;\n\t\t\t}\n\t\t\tif (me.minNotZero === null) {\n\t\t\t\tif (me.min > 0) {\n\t\t\t\t\tme.minNotZero = me.min;\n\t\t\t\t} else if (me.max < 1) {\n\t\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n\t\t\t\t} else {\n\t\t\t\t\tme.minNotZero = DEFAULT_MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar reverse = !me.isHorizontal();\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(generationOptions, me);\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\treverse = !reverse;\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t\tif (reverse) {\n\t\t\t\tticks.reverse();\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\t/**\n\t\t * Returns the value of the first tick.\n\t\t * @param {Number} value - The minimum not zero value.\n\t\t * @return {Number} The first tick value.\n\t\t * @private\n\t\t */\n\t\t_getFirstTickValue: function(value) {\n\t\t\tvar exp = Math.floor(helpers.log10(value));\n\t\t\tvar significand = Math.floor(value / Math.pow(10, exp));\n\n\t\t\treturn significand * Math.pow(10, exp);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar offset = 0;\n\t\t\tvar innerDimension, pixel, start, end, sign;\n\n\t\t\tvalue = +me.getRightValue(value);\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t\tsign = -1;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t\tsign = 1;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tpixel = reverse ? me.right : me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tsign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\t\t\t\tpixel = reverse ? me.top : me.bottom;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\toffset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\toffset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n\t\t\t\t}\n\t\t\t\tpixel += sign * offset;\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar innerDimension, start, end, value;\n\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = reverse ? me.right - pixel : pixel - me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = reverse ? pixel - me.top : me.bottom - pixel;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\tvar offset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tvalue -= offset;\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tvalue *= log10(end) - log10(start);\n\t\t\t\tvalue /= innerDimension;\n\t\t\t\tvalue = Math.pow(10, log10(start) + value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 1309:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar helpers = __webpack_require__(1213);\nvar Ticks = __webpack_require__(1234);\n\nmodule.exports = function(Chart) {\n\n\tvar globalDefaults = defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\tgridLines: {\n\t\t\tcircular: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Boolean - if true, show point labels\n\t\t\tdisplay: true,\n\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\tvar opts = scale.options;\n\t\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tr: scale.width,\n\t\t\tl: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i, textSize, pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty += spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tif (pointLabelOpts.display) {\n\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);\n\t\t\t\tctx.font = plFont.font;\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.gridLines.circular) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.pointLabels.display) {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t} else {\n\t\t\t\tfit(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\n\t\t\tvar maxLeft = leftMovement + me.drawingArea;\n\t\t\tvar maxTop = topMovement + me.drawingArea;\n\t\t\tvar maxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.ticks.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\t\t\t\tvar startAngle = this.getIndexAngle(0);\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || tickOpts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\n\t\t\t\t\t\t\tctx.rotate(startAngle);\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\t-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 1310:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* global window: false */\n\n\nvar moment = __webpack_require__(24);\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nvar defaults = __webpack_require__(1217);\nvar helpers = __webpack_require__(1213);\n\n// Integer constants are from the ES6 spec.\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nvar INTERVALS = {\n\tmillisecond: {\n\t\tcommon: true,\n\t\tsize: 1,\n\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t},\n\tsecond: {\n\t\tcommon: true,\n\t\tsize: 1000,\n\t\tsteps: [1, 2, 5, 10, 30]\n\t},\n\tminute: {\n\t\tcommon: true,\n\t\tsize: 60000,\n\t\tsteps: [1, 2, 5, 10, 30]\n\t},\n\thour: {\n\t\tcommon: true,\n\t\tsize: 3600000,\n\t\tsteps: [1, 2, 3, 6, 12]\n\t},\n\tday: {\n\t\tcommon: true,\n\t\tsize: 86400000,\n\t\tsteps: [1, 2, 5]\n\t},\n\tweek: {\n\t\tcommon: false,\n\t\tsize: 604800000,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tmonth: {\n\t\tcommon: true,\n\t\tsize: 2.628e9,\n\t\tsteps: [1, 2, 3]\n\t},\n\tquarter: {\n\t\tcommon: false,\n\t\tsize: 7.884e9,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tyear: {\n\t\tcommon: true,\n\t\tsize: 3.154e10\n\t}\n};\n\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n\treturn a - b;\n}\n\nfunction arrayUnique(items) {\n\tvar hash = {};\n\tvar out = [];\n\tvar i, ilen, item;\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\titem = items[i];\n\t\tif (!hash[item]) {\n\t\t\thash[item] = true;\n\t\t\tout.push(item);\n\t\t}\n\t}\n\n\treturn out;\n}\n\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\nfunction buildLookupTable(timestamps, min, max, distribution) {\n\tif (distribution === 'linear' || !timestamps.length) {\n\t\treturn [\n\t\t\t{time: min, pos: 0},\n\t\t\t{time: max, pos: 1}\n\t\t];\n\t}\n\n\tvar table = [];\n\tvar items = [min];\n\tvar i, ilen, prev, curr, next;\n\n\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\tcurr = timestamps[i];\n\t\tif (curr > min && curr < max) {\n\t\t\titems.push(curr);\n\t\t}\n\t}\n\n\titems.push(max);\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\tnext = items[i + 1];\n\t\tprev = items[i - 1];\n\t\tcurr = items[i];\n\n\t\t// only add points that breaks the scale linearity\n\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\n\t\t}\n\t}\n\n\treturn table;\n}\n\n// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\nfunction lookup(table, key, value) {\n\tvar lo = 0;\n\tvar hi = table.length - 1;\n\tvar mid, i0, i1;\n\n\twhile (lo >= 0 && lo <= hi) {\n\t\tmid = (lo + hi) >> 1;\n\t\ti0 = table[mid - 1] || null;\n\t\ti1 = table[mid];\n\n\t\tif (!i0) {\n\t\t\t// given value is outside table (before first item)\n\t\t\treturn {lo: null, hi: i1};\n\t\t} else if (i1[key] < value) {\n\t\t\tlo = mid + 1;\n\t\t} else if (i0[key] > value) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\treturn {lo: i0, hi: i1};\n\t\t}\n\t}\n\n\t// given value is outside table (after last item)\n\treturn {lo: i1, hi: null};\n}\n\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\nfunction interpolate(table, skey, sval, tkey) {\n\tvar range = lookup(table, skey, sval);\n\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n\n\tvar span = next[skey] - prev[skey];\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\n\n\treturn prev[tkey] + offset;\n}\n\n/**\n * Convert the given value to a moment object using the given time options.\n * @see http://momentjs.com/docs/#/parsing/\n */\nfunction momentify(value, options) {\n\tvar parser = options.parser;\n\tvar format = options.parser || options.format;\n\n\tif (typeof parser === 'function') {\n\t\treturn parser(value);\n\t}\n\n\tif (typeof value === 'string' && typeof format === 'string') {\n\t\treturn moment(value, format);\n\t}\n\n\tif (!(value instanceof moment)) {\n\t\tvalue = moment(value);\n\t}\n\n\tif (value.isValid()) {\n\t\treturn value;\n\t}\n\n\t// Labels are in an incompatible moment format and no `parser` has been provided.\n\t// The user might still use the deprecated `format` option to convert his inputs.\n\tif (typeof format === 'function') {\n\t\treturn format(value);\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, scale) {\n\tif (helpers.isNullOrUndef(input)) {\n\t\treturn null;\n\t}\n\n\tvar options = scale.options.time;\n\tvar value = momentify(scale.getRightValue(input), options);\n\tif (!value.isValid()) {\n\t\treturn null;\n\t}\n\n\tif (options.round) {\n\t\tvalue.startOf(options.round);\n\t}\n\n\treturn value.valueOf();\n}\n\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\nfunction determineStepSize(min, max, unit, capacity) {\n\tvar range = max - min;\n\tvar interval = INTERVALS[unit];\n\tvar milliseconds = interval.size;\n\tvar steps = interval.steps;\n\tvar i, ilen, factor;\n\n\tif (!steps) {\n\t\treturn Math.ceil(range / (capacity * milliseconds));\n\t}\n\n\tfor (i = 0, ilen = steps.length; i < ilen; ++i) {\n\t\tfactor = steps[i];\n\t\tif (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn factor;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\tvar ilen = UNITS.length;\n\tvar i, interval, factor;\n\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\tinterval = INTERVALS[UNITS[i]];\n\t\tfactor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n\n\treturn UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n */\nfunction determineUnitForFormatting(ticks, minUnit, min, max) {\n\tvar duration = moment.duration(moment(max).diff(moment(min)));\n\tvar ilen = UNITS.length;\n\tvar i, unit;\n\n\tfor (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\tunit = UNITS[i];\n\t\tif (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {\n\t\t\treturn unit;\n\t\t}\n\t}\n\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n}\n\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\nfunction generate(min, max, capacity, options) {\n\tvar timeOpts = options.time;\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n\tvar major = determineMajorUnit(minor);\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\tvar majorTicksEnabled = options.ticks.major.enabled;\n\tvar interval = INTERVALS[minor];\n\tvar first = moment(min);\n\tvar last = moment(max);\n\tvar ticks = [];\n\tvar time;\n\n\tif (!stepSize) {\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\n\t}\n\n\t// For 'week' unit, handle the first day of week option\n\tif (weekday) {\n\t\tfirst = first.isoWeekday(weekday);\n\t\tlast = last.isoWeekday(weekday);\n\t}\n\n\t// Align first/last ticks on unit\n\tfirst = first.startOf(weekday ? 'day' : minor);\n\tlast = last.startOf(weekday ? 'day' : minor);\n\n\t// Make sure that the last tick include max\n\tif (last < max) {\n\t\tlast.add(1, minor);\n\t}\n\n\ttime = moment(first);\n\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\n\t\t// we first aligned time on the previous `major` unit then add the number of full\n\t\t// stepSize there is between first and the previous major time.\n\t\ttime.startOf(major);\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n\t}\n\n\tfor (; time < last; time.add(stepSize, minor)) {\n\t\tticks.push(+time);\n\t}\n\n\tticks.push(+time);\n\n\treturn ticks;\n}\n\n/**\n * Returns the right and left offsets from edges in the form of {left, right}.\n * Offsets are added when the `offset` option is true.\n */\nfunction computeOffsets(table, ticks, min, max, options) {\n\tvar left = 0;\n\tvar right = 0;\n\tvar upper, lower;\n\n\tif (options.offset && ticks.length) {\n\t\tif (!options.time.min) {\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\n\t\t\tlower = ticks[0];\n\t\t\tleft = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t\tif (!options.time.max) {\n\t\t\tupper = ticks[ticks.length - 1];\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\n\t\t\tright = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t}\n\n\treturn {left: left, right: right};\n}\n\nfunction ticksFromTimestamps(values, majorUnit) {\n\tvar ticks = [];\n\tvar i, ilen, value, major;\n\n\tfor (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\tvalue = values[i];\n\t\tmajor = majorUnit ? value === +moment(value).startOf(majorUnit) : false;\n\n\t\tticks.push({\n\t\t\tvalue: value,\n\t\t\tmajor: major\n\t\t});\n\t}\n\n\treturn ticks;\n}\n\nfunction determineLabelFormat(data, timeOpts) {\n\tvar i, momentDate, hasTime;\n\tvar ilen = data.length;\n\n\t// find the label with the most parts (milliseconds, minutes, etc.)\n\t// format all labels with the same level of detail as the most specific label\n\tfor (i = 0; i < ilen; i++) {\n\t\tmomentDate = momentify(data[i], timeOpts);\n\t\tif (momentDate.millisecond() !== 0) {\n\t\t\treturn 'MMM D, YYYY h:mm:ss.SSS a';\n\t\t}\n\t\tif (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\n\t\t\thasTime = true;\n\t\t}\n\t}\n\tif (hasTime) {\n\t\treturn 'MMM D, YYYY h:mm:ss a';\n\t}\n\treturn 'MMM D, YYYY';\n}\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\t/**\n\t\t * Data distribution along the scale:\n\t\t * - 'linear': data are spread according to their time (distances can vary),\n\t\t * - 'series': data are spread at the same distance from each other.\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t * @since 2.7.0\n\t\t */\n\t\tdistribution: 'linear',\n\n\t\t/**\n\t\t * Scale boundary strategy (bypassed by min/max time options)\n\t\t * - `data`: make sure data are fully visible, ticks outside are removed\n\t\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4556\n\t\t * @since 2.7.0\n\t\t */\n\t\tbounds: 'data',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm a', // 11:20 AM\n\t\t\t\thour: 'hA', // 5PM\n\t\t\t\tday: 'MMM D', // Sep 4\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t},\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false,\n\n\t\t\t/**\n\t\t\t * Ticks generation input values:\n\t\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n\t\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n\t\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\n\t\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t\t * @since 2.7.0\n\t\t\t */\n\t\t\tsource: 'auto',\n\n\t\t\tmajor: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t}\n\t};\n\n\tvar TimeScale = Chart.Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tthis.mergeTicksOptions();\n\n\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t},\n\n\t\tupdate: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\n\t\t\t// DEPRECATIONS: output a message only one time per update\n\t\t\tif (options.time && options.time.format) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\t}\n\n\t\t\treturn Chart.Scale.prototype.update.apply(me, arguments);\n\t\t},\n\n\t\t/**\n\t\t * Allows data to be referenced via 't' attribute\n\t\t */\n\t\tgetRightValue: function(rawValue) {\n\t\t\tif (rawValue && rawValue.t !== undefined) {\n\t\t\t\trawValue = rawValue.t;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, rawValue);\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar unit = timeOpts.unit || 'day';\n\t\t\tvar min = MAX_INTEGER;\n\t\t\tvar max = MIN_INTEGER;\n\t\t\tvar timestamps = [];\n\t\t\tvar datasets = [];\n\t\t\tvar labels = [];\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\n\n\t\t\t// Convert labels to timestamps\n\t\t\tfor (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(parse(chart.data.labels[i], me));\n\t\t\t}\n\n\t\t\t// Convert data to timestamps\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tdata = chart.data.datasets[i].data;\n\n\t\t\t\t\t// Let's consider that all data have the same format.\n\t\t\t\t\tif (helpers.isObject(data[0])) {\n\t\t\t\t\t\tdatasets[i] = [];\n\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdatasets[i] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (labels.length) {\n\t\t\t\t// Sort labels **after** data have been converted\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\n\t\t\t\tmin = Math.min(min, labels[0]);\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\n\t\t\t}\n\n\t\t\tif (timestamps.length) {\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\n\t\t\t\tmin = Math.min(min, timestamps[0]);\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\n\t\t\t}\n\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\n\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\n\t\t\tme.min = Math.min(min, max);\n\t\t\tme.max = Math.max(min + 1, max);\n\n\t\t\t// PRIVATE\n\t\t\tme._horizontal = me.isHorizontal();\n\t\t\tme._table = [];\n\t\t\tme._timestamps = {\n\t\t\t\tdata: timestamps,\n\t\t\t\tdatasets: datasets,\n\t\t\t\tlabels: labels\n\t\t\t};\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\t\tvar options = me.options;\n\t\t\tvar timeOpts = options.time;\n\t\t\tvar timestamps = [];\n\t\t\tvar ticks = [];\n\t\t\tvar i, ilen, timestamp;\n\n\t\t\tswitch (options.ticks.source) {\n\t\t\tcase 'data':\n\t\t\t\ttimestamps = me._timestamps.data;\n\t\t\t\tbreak;\n\t\t\tcase 'labels':\n\t\t\t\ttimestamps = me._timestamps.labels;\n\t\t\t\tbreak;\n\t\t\tcase 'auto':\n\t\t\tdefault:\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\n\t\t\t}\n\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\t\tmin = timestamps[0];\n\t\t\t\tmax = timestamps[timestamps.length - 1];\n\t\t\t}\n\n\t\t\t// Enforce limits with user min/max options\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// Remove ticks outside the min/max range\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\t\ttimestamp = timestamps[i];\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\n\t\t\t\t\tticks.push(timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.min = min;\n\t\t\tme.max = max;\n\n\t\t\t// PRIVATE\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\n\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\n\n\t\t\tif (helpers.isObject(value)) {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\t\t\tif (timeOpts.tooltipFormat) {\n\t\t\t\treturn momentify(label, timeOpts).format(timeOpts.tooltipFormat);\n\t\t\t}\n\t\t\tif (typeof label === 'string') {\n\t\t\t\treturn label;\n\t\t\t}\n\n\t\t\treturn momentify(label, timeOpts).format(me._labelFormat);\n\t\t},\n\n\t\t/**\n\t\t * Function to format an individual tick mark\n\t\t * @private\n\t\t */\n\t\ttickFormatFunction: function(tick, index, ticks, formatOverride) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar time = tick.valueOf();\n\t\t\tvar formats = options.time.displayFormats;\n\t\t\tvar minorFormat = formats[me._unit];\n\t\t\tvar majorUnit = me._majorUnit;\n\t\t\tvar majorFormat = formats[majorUnit];\n\t\t\tvar majorTime = tick.clone().startOf(majorUnit).valueOf();\n\t\t\tvar majorTickOpts = options.ticks.major;\n\t\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\t\tvar label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);\n\t\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\t\tvar formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t\t},\n\n\t\tconvertTicksToLabels: function(ticks) {\n\t\t\tvar labels = [];\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetPixelForOffset: function(time) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = interpolate(me._table, 'time', time, 'pos');\n\n\t\t\treturn start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);\n\t\t},\n\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar time = null;\n\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\n\t\t\t}\n\n\t\t\tif (time === null) {\n\t\t\t\ttime = parse(value, me);\n\t\t\t}\n\n\t\t\tif (time !== null) {\n\t\t\t\treturn me.getPixelForOffset(time);\n\t\t\t}\n\t\t},\n\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar ticks = this.getTicks();\n\t\t\treturn index >= 0 && index < ticks.length ?\n\t\t\t\tthis.getPixelForOffset(ticks[index].value) :\n\t\t\t\tnull;\n\t\t},\n\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;\n\t\t\tvar time = interpolate(me._table, 'pos', pos, 'time');\n\n\t\t\treturn moment(time);\n\t\t},\n\n\t\t/**\n\t\t * Crude approximation of what the label width might be\n\t\t * @private\n\t\t */\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticksOpts = me.options.ticks;\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar angle = helpers.toRadians(ticksOpts.maxRotation);\n\t\t\tvar cosRotation = Math.cos(angle);\n\t\t\tvar sinRotation = Math.sin(angle);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\n\t\t\tvar formatOverride = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n\n\t\t\tvar exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\tvar capacity = Math.floor(innerWidth / tickLabelWidth);\n\t\t\treturn capacity > 0 ? capacity : 1;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n};\n\n\n/***/ }),\n\n/***/ 1311:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar elements = __webpack_require__(1225);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('bar', {\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\ttype: 'linear'\n\t\t}]\n\t}\n});\n\ndefaults._set('horizontalBar', {\n\thover: {\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'bottom'\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\tposition: 'left',\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Horizontal Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}]\n\t},\n\n\telements: {\n\t\trectangle: {\n\t\t\tborderSkipped: 'left'\n\t\t}\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function(item, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\n\t\t\t\tif (item.length > 0) {\n\t\t\t\t\tif (item[0].yLabel) {\n\t\t\t\t\t\ttitle = item[0].yLabel;\n\t\t\t\t\t} else if (data.labels.length > 0 && item[0].index < data.labels.length) {\n\t\t\t\t\t\ttitle = data.labels[item[0].index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\treturn datasetLabel + ': ' + item.xLabel;\n\t\t\t}\n\t\t},\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t}\n});\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(scale, pixels) {\n\tvar min = scale.isHorizontal() ? scale.width : scale.height;\n\tvar ticks = scale.getTicks();\n\tvar prev, curr, i, ilen;\n\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\tmin = Math.min(min, pixels[i] - pixels[i - 1]);\n\t}\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tcurr = scale.getPixelForTick(i);\n\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\n\t\tprev = curr;\n\t}\n\n\treturn min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options) {\n\tvar thickness = options.barThickness;\n\tvar count = ruler.stackCount;\n\tvar curr = ruler.pixels[index];\n\tvar size, ratio;\n\n\tif (helpers.isNullOrUndef(thickness)) {\n\t\tsize = ruler.min * options.categoryPercentage;\n\t\tratio = options.barPercentage;\n\t} else {\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\n\t\tsize = thickness * count;\n\t\tratio = 1;\n\t}\n\n\treturn {\n\t\tchunk: size / count,\n\t\tratio: ratio,\n\t\tstart: curr - (size / 2)\n\t};\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options) {\n\tvar pixels = ruler.pixels;\n\tvar curr = pixels[index];\n\tvar prev = index > 0 ? pixels[index - 1] : null;\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\tvar percent = options.categoryPercentage;\n\tvar start, size;\n\n\tif (prev === null) {\n\t\t// first data: its size is double based on the next point or,\n\t\t// if it's also the last data, we use the scale end extremity.\n\t\tprev = curr - (next === null ? ruler.end - curr : next - curr);\n\t}\n\n\tif (next === null) {\n\t\t// last data: its size is also double based on the previous point.\n\t\tnext = curr + curr - prev;\n\t}\n\n\tstart = curr - ((curr - prev) / 2) * percent;\n\tsize = ((next - prev) / 2) * percent;\n\n\treturn {\n\t\tchunk: size / ruler.stackCount,\n\t\tratio: options.barPercentage,\n\t\tstart: start\n\t};\n}\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Rectangle,\n\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\n\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar i, ilen;\n\n\t\t\tme._ruler = me.getRuler();\n\n\t\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(rects[i], i, reset);\n\t\t\t}\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\trectangle._model = {\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: chart.data.labels[index],\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n\t\t\t};\n\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me.getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset ? base : vpixels.base;\n\t\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n\t\t\tmodel.height = horizontal ? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal ? undefined : ipixels.size;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScale: function() {\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScale: function() {\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\n\t\t},\n\n\t\t/**\n\t\t * Returns the stacks based on groups and bar visibility.\n\t\t * @param {Number} [last] - The dataset index\n\t\t * @returns {Array} The stack list\n\t\t * @private\n\t\t */\n\t\t_getStacks: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks;\n\t\t},\n\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function() {\n\t\t\treturn this._getStacks().length;\n\t\t},\n\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @param {Number} [datasetIndex] - The dataset index\n\t\t * @param {String} [name] - The stack name to find\n\t\t * @returns {Number} The stack index\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex, name) {\n\t\t\tvar stacks = this._getStacks(datasetIndex);\n\t\t\tvar index = (name !== undefined)\n\t\t\t\t? stacks.indexOf(name)\n\t\t\t\t: -1; // indexOf returns -1 if element is not present\n\n\t\t\treturn (index === -1)\n\t\t\t\t? stacks.length - 1\n\t\t\t\t: index;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar isHorizontal = scale.isHorizontal();\n\t\t\tvar start = isHorizontal ? scale.left : scale.top;\n\t\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\n\t\t\tvar pixels = [];\n\t\t\tvar i, ilen, min;\n\n\t\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n\t\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\n\t\t\t}\n\n\t\t\tmin = helpers.isNullOrUndef(scale.options.barThickness)\n\t\t\t\t? computeMinSampleSize(scale, pixels)\n\t\t\t\t: -1;\n\n\t\t\treturn {\n\t\t\t\tmin: min,\n\t\t\t\tpixels: pixels,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tstackCount: stackCount,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = scale.getRightValue(datasets[datasetIndex].data[index]);\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\t\tivalue = scale.getRightValue(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = (head - base) / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar options = ruler.scale.options;\n\t\t\tvar range = options.barThickness === 'flex'\n\t\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n\t\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\t\tvar size = Math.min(\n\t\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\n\t\t\t\trange.chunk * range.ratio);\n\n\t\t\treturn {\n\t\t\t\tbase: center - size / 2,\n\t\t\t\thead: center + size / 2,\n\t\t\t\tcenter: center,\n\t\t\t\tsize: size\n\t\t\t};\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = rects.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\n\t\t\t\t\trects[i].draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\t\t},\n\n\t\tsetHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t}\n\t});\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 1312:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar elements = __webpack_require__(1225);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('bubble', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\tposition: 'bottom',\n\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\n\t\t\t\treturn datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bubble = Chart.DatasetController.extend({\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tdataElementType: elements.Point,\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data;\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar options = me._resolveElementOptions(point, index);\n\t\t\tvar data = me.getDataset().data[index];\n\t\t\tvar dsIndex = me.index;\n\n\t\t\tvar x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n\t\t\tvar y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._options = options;\n\t\t\tpoint._datasetIndex = dsIndex;\n\t\t\tpoint._index = index;\n\t\t\tpoint._model = {\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\thitRadius: options.hitRadius,\n\t\t\t\tpointStyle: options.pointStyle,\n\t\t\t\tradius: reset ? 0 : options.radius,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t};\n\n\t\t\tpoint.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\n\t\t\tmodel.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n\t\t\tmodel.radius = options.radius + options.hoverRadius;\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\n\t\t\tmodel.backgroundColor = options.backgroundColor;\n\t\t\tmodel.borderColor = options.borderColor;\n\t\t\tmodel.borderWidth = options.borderWidth;\n\t\t\tmodel.radius = options.radius;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveElementOptions: function(point, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar dataset = datasets[me.index];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar options = chart.options.elements.point;\n\t\t\tvar resolve = helpers.options.resolve;\n\t\t\tvar data = dataset.data[index];\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'hoverBackgroundColor',\n\t\t\t\t'hoverBorderColor',\n\t\t\t\t'hoverBorderWidth',\n\t\t\t\t'hoverRadius',\n\t\t\t\t'hitRadius',\n\t\t\t\t'pointStyle'\n\t\t\t];\n\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\n\t\t\t// Custom radius resolution\n\t\t\tvalues.radius = resolve([\n\t\t\t\tcustom.radius,\n\t\t\t\tdata ? data.r : undefined,\n\t\t\t\tdataset.radius,\n\t\t\t\toptions.radius\n\t\t\t], context, index);\n\n\t\t\treturn values;\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 1313:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar elements = __webpack_require__(1225);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('doughnut', {\n\tanimation: {\n\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\tanimateRotate: true,\n\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\tanimateScale: false\n\t},\n\thover: {\n\t\tmode: 'single'\n\t},\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t// toggle visibility of index if exists\n\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// The percentage of the chart that we cut out of the middle.\n\tcutoutPercentage: 50,\n\n\t// The rotation of the chart, where the first data arc begins.\n\trotation: Math.PI * -0.5,\n\n\t// The total circumference of the chart.\n\tcircumference: Math.PI * 2.0,\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\tif (helpers.isArray(dataLabel)) {\n\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t} else {\n\t\t\t\t\tdataLabel += value;\n\t\t\t\t}\n\n\t\t\t\treturn dataLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\ndefaults._set('pie', helpers.clone(defaults.doughnut));\ndefaults._set('pie', {\n\tcutoutPercentage: 0\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\tgetRingIndex: function(datasetIndex) {\n\t\t\tvar ringIndex = 0;\n\n\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t++ringIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ringIndex;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;\n\t\t\tvar availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;\n\t\t\tvar minSize = Math.min(availableWidth, availableHeight);\n\t\t\tvar offset = {x: 0, y: 0};\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar cutoutPercentage = opts.cutoutPercentage;\n\t\t\tvar circumference = opts.circumference;\n\n\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\tvar contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t}\n\n\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\t\tmeta.total = me.calculateTotal();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\n\t\t\tvar centerY = (chartArea.top + chartArea.bottom) / 2;\n\t\t\tvar startAngle = opts.rotation; // non reset case handled later\n\t\t\tvar endAngle = opts.rotation; // non reset case handled later\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));\n\t\t\tvar innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n\t\t\tvar outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar model = arc._model;\n\t\t\t// Resets the visual styles\n\t\t\tthis.removeHoverStyle(arc);\n\n\t\t\t// Set correct angles if not resetting\n\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t} else {\n\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t}\n\n\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t}\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcalculateTotal: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar total = 0;\n\t\t\tvar value;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tvalue = dataset.data[index];\n\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* if (total === 0) {\n\t\t\t\ttotal = NaN;\n\t\t\t}*/\n\n\t\t\treturn total;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar total = this.getMeta().total;\n\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\treturn (Math.PI * 2.0) * (Math.abs(value) / total);\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// gets the max border or hover width to properly scale pie charts\n\t\tgetMaxBorderWidth: function(arcs) {\n\t\t\tvar max = 0;\n\t\t\tvar index = this.index;\n\t\t\tvar length = arcs.length;\n\t\t\tvar borderWidth;\n\t\t\tvar hoverWidth;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tborderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;\n\t\t\t\thoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 1314:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar elements = __webpack_require__(1225);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('line', {\n\tshowLines: true,\n\tspanGaps: false,\n\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\t\t\tid: 'x-axis-0'\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tfunction lineEnabled(dataset, options) {\n\t\treturn helpers.valueOrDefault(dataset.showLine, options.showLines);\n\t}\n\n\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar options = me.chart.options;\n\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar i, ilen, custom;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = {\n\t\t\t\t\t// Appearance\n\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t};\n\n\t\t\t\tline.pivot();\n\t\t\t}\n\n\t\t\t// Update Points\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\n\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.backgroundColor) {\n\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\tbackgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t}\n\n\t\t\treturn backgroundColor;\n\t\t},\n\n\t\tgetPointBorderColor: function(point, index) {\n\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.borderColor) {\n\t\t\t\tborderColor = custom.borderColor;\n\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\tborderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t} else if (dataset.borderColor) {\n\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t}\n\n\t\t\treturn borderColor;\n\t\t},\n\n\t\tgetPointBorderWidth: function(point, index) {\n\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {\n\t\t\t\tborderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t}\n\n\t\t\treturn borderWidth;\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\tvar x, y;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\tpointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t};\n\t\t},\n\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = (meta.data || []);\n\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\n\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tmodel = point._model;\n\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar ilen = points.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, area);\n\n\t\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\n\t\t\t// Draw the points\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tpoints[i].draw(area);\n\t\t\t}\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\n\t\t\tmodel.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 1315:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar elements = __webpack_require__(1225);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('polarArea', {\n\tscale: {\n\t\ttype: 'radialLinear',\n\t\tangleLines: {\n\t\t\tdisplay: false\n\t\t},\n\t\tgridLines: {\n\t\t\tcircular: true\n\t\t},\n\t\tpointLabels: {\n\t\t\tdisplay: false\n\t\t},\n\t\tticks: {\n\t\t\tbeginAtZero: true\n\t\t}\n\t},\n\n\t// Boolean - Whether to animate the rotation of the chart\n\tanimation: {\n\t\tanimateRotate: true,\n\t\tanimateScale: true\n\t},\n\n\tstartAngle: -0.5 * Math.PI,\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\n\t\t\tmeta.count = me.countVisibleElements();\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar scale = chart.scale;\n\t\t\tvar labels = chart.data.labels;\n\n\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\tvar centerX = scale.xCenter;\n\t\t\tvar centerY = scale.yCenter;\n\n\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\tvar visibleCount = 0;\n\t\t\tvar meta = me.getMeta();\n\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t++visibleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\n\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\n\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX,\n\t\t\t\t\ty: centerY,\n\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\tlabel: helpers.valueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply border and fill style\n\t\t\tme.removeHoverStyle(arc);\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcountVisibleElements: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar count = 0;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn count;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar count = this.getMeta().count;\n\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\treturn (2 * Math.PI) / count;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 1316:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar elements = __webpack_require__(1225);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('radar', {\n\tscale: {\n\t\ttype: 'radialLinear'\n\t},\n\telements: {\n\t\tline: {\n\t\t\ttension: 0 // no bezier in radar\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.radar = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data;\n\t\t\tvar custom = line.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\tvar scale = me.chart.scale;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\n\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_scale: scale,\n\t\t\t\t// Data\n\t\t\t\t_children: points,\n\t\t\t\t_loop: true,\n\t\t\t\t// Model\n\t\t\t\t_model: {\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmeta.dataset.pivot();\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t}, me);\n\n\t\t\t// Update bezier control points\n\t\t\tme.updateBezierControlPoints();\n\t\t},\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n\t\t},\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\tvar meta = this.getMeta();\n\n\t\t\thelpers.each(meta.data, function(point, index) {\n\t\t\t\tvar model = point._model;\n\t\t\t\tvar controlPoints = helpers.splineCurve(\n\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel.tension\n\t\t\t\t);\n\n\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t// Now pivot the point for animation\n\t\t\t\tpoint.pivot();\n\t\t\t});\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 1317:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\n\ndefaults._set('scatter', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\n\t\t\ttype: 'linear',    // scatter should not use a category axis\n\t\t\tposition: 'bottom'\n\t\t}],\n\t\tyAxes: [{\n\t\t\tid: 'y-axis-1',\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left'\n\t\t}]\n\t},\n\n\tshowLines: false,\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';     // doesn't make sense for scatter since data are formatted as a point\n\t\t\t},\n\t\t\tlabel: function(item) {\n\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\t// Scatter charts use line controllers\n\tChart.controllers.scatter = Chart.controllers.line;\n\n};\n\n\n/***/ }),\n\n/***/ 1318:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Bar = function(context, config) {\n\t\tconfig.type = 'bar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 1319:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Bubble = function(context, config) {\n\t\tconfig.type = 'bubble';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 1320:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Doughnut = function(context, config) {\n\t\tconfig.type = 'doughnut';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 1321:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Line = function(context, config) {\n\t\tconfig.type = 'line';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 1322:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.PolarArea = function(context, config) {\n\t\tconfig.type = 'polarArea';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 1323:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Radar = function(context, config) {\n\t\tconfig.type = 'radar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 1324:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\tChart.Scatter = function(context, config) {\n\t\tconfig.type = 'scatter';\n\t\treturn new Chart(context, config);\n\t};\n};\n\n\n/***/ }),\n\n/***/ 1325:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {};\nmodule.exports.filler = __webpack_require__(1326);\nmodule.exports.legend = __webpack_require__(1327);\nmodule.exports.title = __webpack_require__(1328);\n\n\n/***/ }),\n\n/***/ 1326:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\n\n\nvar defaults = __webpack_require__(1217);\nvar elements = __webpack_require__(1225);\nvar helpers = __webpack_require__(1213);\n\ndefaults._set('global', {\n\tplugins: {\n\t\tfiller: {\n\t\t\tpropagate: true\n\t\t}\n\t}\n});\n\nvar mappers = {\n\tdataset: function(source) {\n\t\tvar index = source.fill;\n\t\tvar chart = source.chart;\n\t\tvar meta = chart.getDatasetMeta(index);\n\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\tvar points = (visible && meta.dataset._children) || [];\n\t\tvar length = points.length || 0;\n\n\t\treturn !length ? null : function(point, i) {\n\t\t\treturn (i < length && points[i]._view) || null;\n\t\t};\n\t},\n\n\tboundary: function(source) {\n\t\tvar boundary = source.boundary;\n\t\tvar x = boundary ? boundary.x : null;\n\t\tvar y = boundary ? boundary.y : null;\n\n\t\treturn function(point) {\n\t\t\treturn {\n\t\t\t\tx: x === null ? point.x : x,\n\t\t\t\ty: y === null ? point.y : y,\n\t\t\t};\n\t\t};\n\t}\n};\n\n// @todo if (fill[0] === '#')\nfunction decodeFill(el, index, count) {\n\tvar model = el._model || {};\n\tvar fill = model.fill;\n\tvar target;\n\n\tif (fill === undefined) {\n\t\tfill = !!model.backgroundColor;\n\t}\n\n\tif (fill === false || fill === null) {\n\t\treturn false;\n\t}\n\n\tif (fill === true) {\n\t\treturn 'origin';\n\t}\n\n\ttarget = parseFloat(fill, 10);\n\tif (isFinite(target) && Math.floor(target) === target) {\n\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\ttarget = index + target;\n\t\t}\n\n\t\tif (target === index || target < 0 || target >= count) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tswitch (fill) {\n\t// compatibility\n\tcase 'bottom':\n\t\treturn 'start';\n\tcase 'top':\n\t\treturn 'end';\n\tcase 'zero':\n\t\treturn 'origin';\n\t// supported boundaries\n\tcase 'origin':\n\tcase 'start':\n\tcase 'end':\n\t\treturn fill;\n\t// invalid fill values\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nfunction computeBoundary(source) {\n\tvar model = source.el._model || {};\n\tvar scale = source.el._scale || {};\n\tvar fill = source.fill;\n\tvar target = null;\n\tvar horizontal;\n\n\tif (isFinite(fill)) {\n\t\treturn null;\n\t}\n\n\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t// controllers might still use it (e.g. the Smith chart).\n\n\tif (fill === 'start') {\n\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n\t} else if (fill === 'end') {\n\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\n\t} else if (model.scaleZero !== undefined) {\n\t\ttarget = model.scaleZero;\n\t} else if (scale.getBasePosition) {\n\t\ttarget = scale.getBasePosition();\n\t} else if (scale.getBasePixel) {\n\t\ttarget = scale.getBasePixel();\n\t}\n\n\tif (target !== undefined && target !== null) {\n\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\treturn target;\n\t\t}\n\n\t\tif (typeof target === 'number' && isFinite(target)) {\n\t\t\thorizontal = scale.isHorizontal();\n\t\t\treturn {\n\t\t\t\tx: horizontal ? target : null,\n\t\t\t\ty: horizontal ? null : target\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n\tvar source = sources[index];\n\tvar fill = source.fill;\n\tvar visited = [index];\n\tvar target;\n\n\tif (!propagate) {\n\t\treturn fill;\n\t}\n\n\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\tif (!isFinite(fill)) {\n\t\t\treturn fill;\n\t\t}\n\n\t\ttarget = sources[fill];\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (target.visible) {\n\t\t\treturn fill;\n\t\t}\n\n\t\tvisited.push(fill);\n\t\tfill = target.fill;\n\t}\n\n\treturn false;\n}\n\nfunction createMapper(source) {\n\tvar fill = source.fill;\n\tvar type = 'dataset';\n\n\tif (fill === false) {\n\t\treturn null;\n\t}\n\n\tif (!isFinite(fill)) {\n\t\ttype = 'boundary';\n\t}\n\n\treturn mappers[type](source);\n}\n\nfunction isDrawable(point) {\n\treturn point && !point.skip;\n}\n\nfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\tvar i;\n\n\tif (!len0 || !len1) {\n\t\treturn;\n\t}\n\n\t// building first area curve (normal)\n\tctx.moveTo(curve0[0].x, curve0[0].y);\n\tfor (i = 1; i < len0; ++i) {\n\t\thelpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n\t}\n\n\t// joining the two area curves\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n\n\t// building opposite area curve (reverse)\n\tfor (i = len1 - 1; i > 0; --i) {\n\t\thelpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n\t}\n}\n\nfunction doFill(ctx, points, mapper, view, color, loop) {\n\tvar count = points.length;\n\tvar span = view.spanGaps;\n\tvar curve0 = [];\n\tvar curve1 = [];\n\tvar len0 = 0;\n\tvar len1 = 0;\n\tvar i, ilen, index, p0, p1, d0, d1;\n\n\tctx.beginPath();\n\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\tindex = i % count;\n\t\tp0 = points[index]._view;\n\t\tp1 = mapper(p0, index, view);\n\t\td0 = isDrawable(p0);\n\t\td1 = isDrawable(p1);\n\n\t\tif (d0 && d1) {\n\t\t\tlen0 = curve0.push(p0);\n\t\t\tlen1 = curve1.push(p1);\n\t\t} else if (len0 && len1) {\n\t\t\tif (!span) {\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\tlen0 = len1 = 0;\n\t\t\t\tcurve0 = [];\n\t\t\t\tcurve1 = [];\n\t\t\t} else {\n\t\t\t\tif (d0) {\n\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t}\n\t\t\t\tif (d1) {\n\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\tctx.closePath();\n\tctx.fillStyle = color;\n\tctx.fill();\n}\n\nmodule.exports = {\n\tid: 'filler',\n\n\tafterDatasetsUpdate: function(chart, options) {\n\t\tvar count = (chart.data.datasets || []).length;\n\t\tvar propagate = options.propagate;\n\t\tvar sources = [];\n\t\tvar meta, i, el, source;\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tel = meta.dataset;\n\t\t\tsource = null;\n\n\t\t\tif (el && el._model && el instanceof elements.Line) {\n\t\t\t\tsource = {\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\tchart: chart,\n\t\t\t\t\tel: el\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tmeta.$filler = source;\n\t\t\tsources.push(source);\n\t\t}\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!source) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\tsource.boundary = computeBoundary(source);\n\t\t\tsource.mapper = createMapper(source);\n\t\t}\n\t},\n\n\tbeforeDatasetDraw: function(chart, args) {\n\t\tvar meta = args.meta.$filler;\n\t\tif (!meta) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctx = chart.ctx;\n\t\tvar el = meta.el;\n\t\tvar view = el._view;\n\t\tvar points = el._children || [];\n\t\tvar mapper = meta.mapper;\n\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\n\n\t\tif (mapper && color && points.length) {\n\t\t\thelpers.canvas.clipArea(ctx, chart.chartArea);\n\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\n\t\t\thelpers.canvas.unclipArea(ctx);\n\t\t}\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1327:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\nvar helpers = __webpack_require__(1213);\nvar layouts = __webpack_require__(1233);\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\tlegend: {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t},\n\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t}\n\t\t\ttext.push('</li>');\n\t\t}\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t}\n});\n\n/**\n * Helper function to get the box width based on the usePointStyle option\n * @param labelopts {Object} the label options on the legend\n * @param fontSize {Number} the label font size\n * @return {Number} width of the color box area\n */\nfunction getBoxWidth(labelOpts, fontSize) {\n\treturn labelOpts.usePointStyle ?\n\t\tfontSize * Math.SQRT2 :\n\t\tlabelOpts.boxWidth;\n}\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Legend = Element.extend({\n\n\tinitialize: function(config) {\n\t\thelpers.extend(this, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tthis.legendHitBoxes = [];\n\n\t\t// Are we in doughnut mode which has a different data type\n\t\tthis.doughnutMode = false;\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\t// Any function defined here is inherited by all legend types.\n\t// Any function can be extended by the legend type\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: function() {\n\t\tvar me = this;\n\t\tvar labelOpts = me.options.labels || {};\n\t\tvar legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n\t\tif (labelOpts.filter) {\n\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t});\n\t\t}\n\n\t\tif (me.options.reverse) {\n\t\t\tlegendItems.reverse();\n\t\t}\n\n\t\tme.legendItems = legendItems;\n\t},\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar display = opts.display;\n\n\t\tvar ctx = me.ctx;\n\n\t\tvar globalDefault = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t// Reset hit boxes\n\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\tvar minSize = me.minSize;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tif (isHorizontal) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = display ? 10 : 0;\n\t\t} else {\n\t\t\tminSize.width = display ? 10 : 0;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\t// Increase sizes here\n\t\tif (display) {\n\t\t\tctx.font = labelFont;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\t// Labels\n\n\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\n\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t});\n\n\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t} else {\n\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\tvar currentColWidth = 0;\n\t\t\t\tvar currentColHeight = 0;\n\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get max width\n\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\tminSize.width += totalWidth;\n\t\t\t}\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t},\n\n\t// Actually draw the legend on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar globalDefault = defaults.global;\n\t\tvar lineDefault = globalDefault.elements.line;\n\t\tvar legendWidth = me.width;\n\t\tvar lineWidths = me.lineWidths;\n\n\t\tif (opts.display) {\n\t\t\tvar ctx = me.ctx;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);\n\t\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar cursor;\n\n\t\t\t// Canvas setup\n\t\t\tctx.textAlign = 'left';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.lineWidth = 0.5;\n\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\tctx.font = labelFont;\n\n\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\tvar hitboxes = me.legendHitBoxes;\n\n\t\t\t// current position\n\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the ctx for the box\n\t\t\t\tctx.save();\n\n\t\t\t\tctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\tctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\tctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\tctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\tctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\tctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\tvar isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\tctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t}\n\n\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\thelpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t} else {\n\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t}\n\n\t\t\t\tctx.restore();\n\t\t\t};\n\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\tvar halfFontSize = fontSize / 2;\n\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\n\t\t\t\tvar yMiddle = y + halfFontSize;\n\n\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\n\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Horizontal\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tif (isHorizontal) {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\t\tvar x = cursor.x;\n\t\t\t\tvar y = cursor.y;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t}\n\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\tcursor.line++;\n\t\t\t\t}\n\n\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\thitboxes[i].left = x;\n\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t// Fill the actual label\n\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t} else {\n\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Handle an event\n\t * @private\n\t * @param {IEvent} event - The event to handle\n\t * @return {Boolean} true if a change occured\n\t */\n\thandleEvent: function(e) {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\tvar changed = false;\n\n\t\tif (type === 'mousemove') {\n\t\t\tif (!opts.onHover) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (type === 'click') {\n\t\t\tif (!opts.onClick) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// Chart event already has relative position in it\n\t\tvar x = e.x;\n\t\tvar y = e.y;\n\n\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t// See if we are touching one of the dataset boxes\n\t\t\tvar lh = me.legendHitBoxes;\n\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t// Touching an element\n\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n});\n\nfunction createNewLegendAndAttach(chart, legendOpts) {\n\tvar legend = new Legend({\n\t\tctx: chart.ctx,\n\t\toptions: legendOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, legend, legendOpts);\n\tlayouts.addBox(chart, legend);\n\tchart.legend = legend;\n}\n\nmodule.exports = {\n\tid: 'legend',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n\t * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Legend,\n\n\tbeforeInit: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\n\t\tif (legendOpts) {\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\t\tvar legend = chart.legend;\n\n\t\tif (legendOpts) {\n\t\t\thelpers.mergeIf(legendOpts, defaults.global.legend);\n\n\t\t\tif (legend) {\n\t\t\t\tlayouts.configure(chart, legend, legendOpts);\n\t\t\t\tlegend.options = legendOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t} else if (legend) {\n\t\t\tlayouts.removeBox(chart, legend);\n\t\t\tdelete chart.legend;\n\t\t}\n\t},\n\n\tafterEvent: function(chart, e) {\n\t\tvar legend = chart.legend;\n\t\tif (legend) {\n\t\t\tlegend.handleEvent(e);\n\t\t}\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1328:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1217);\nvar Element = __webpack_require__(1224);\nvar helpers = __webpack_require__(1213);\nvar layouts = __webpack_require__(1233);\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\ttitle: {\n\t\tdisplay: false,\n\t\tfontStyle: 'bold',\n\t\tfullWidth: true,\n\t\tlineHeight: 1.2,\n\t\tpadding: 10,\n\t\tposition: 'top',\n\t\ttext: '',\n\t\tweight: 2000         // by default greater than legend (1000) to be above\n\t}\n});\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Title = Element.extend({\n\tinitialize: function(config) {\n\t\tvar me = this;\n\t\thelpers.extend(me, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tme.legendHitBoxes = [];\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: noop,\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar opts = me.options;\n\t\tvar display = opts.display;\n\t\tvar fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);\n\t\tvar minSize = me.minSize;\n\t\tvar lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;\n\t\tvar lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);\n\t\tvar textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;\n\n\t\tif (me.isHorizontal()) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = textSize;\n\t\t} else {\n\t\t\tminSize.width = textSize;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\tvar pos = this.options.position;\n\t\treturn pos === 'top' || pos === 'bottom';\n\t},\n\n\t// Actually draw the title block on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar ctx = me.ctx;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar opts = me.options;\n\t\tvar globalDefaults = defaults.global;\n\n\t\tif (opts.display) {\n\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\tvar titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);\n\t\t\tvar offset = lineHeight / 2 + opts.padding;\n\t\t\tvar rotation = 0;\n\t\t\tvar top = me.top;\n\t\t\tvar left = me.left;\n\t\t\tvar bottom = me.bottom;\n\t\t\tvar right = me.right;\n\t\t\tvar maxWidth, titleX, titleY;\n\n\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\tctx.font = titleFont;\n\n\t\t\t// Horizontal\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\ttitleY = top + offset;\n\t\t\t\tmaxWidth = right - left;\n\t\t\t} else {\n\t\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\n\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t}\n\n\t\t\tctx.save();\n\t\t\tctx.translate(titleX, titleY);\n\t\t\tctx.rotate(rotation);\n\t\t\tctx.textAlign = 'center';\n\t\t\tctx.textBaseline = 'middle';\n\n\t\t\tvar text = opts.text;\n\t\t\tif (helpers.isArray(text)) {\n\t\t\t\tvar y = 0;\n\t\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\t\tctx.fillText(text[i], 0, y, maxWidth);\n\t\t\t\t\ty += lineHeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tctx.fillText(text, 0, 0, maxWidth);\n\t\t\t}\n\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\tvar title = new Title({\n\t\tctx: chart.ctx,\n\t\toptions: titleOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, title, titleOpts);\n\tlayouts.addBox(chart, title);\n\tchart.titleBlock = title;\n}\n\nmodule.exports = {\n\tid: 'title',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\n\t * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Title,\n\n\tbeforeInit: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\n\t\tif (titleOpts) {\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\t\tvar titleBlock = chart.titleBlock;\n\n\t\tif (titleOpts) {\n\t\t\thelpers.mergeIf(titleOpts, defaults.global.title);\n\n\t\t\tif (titleBlock) {\n\t\t\t\tlayouts.configure(chart, titleBlock, titleOpts);\n\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t} else if (titleBlock) {\n\t\t\tlayouts.removeBox(chart, titleBlock);\n\t\t\tdelete chart.titleBlock;\n\t\t}\n\t}\n};\n\n\n/***/ }),\n\n/***/ 1329:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_responsive_carousel__ = __webpack_require__(1330);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_responsive_carousel___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_responsive_carousel__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_styled_components__ = __webpack_require__(29);\nvar _templateObject=_taggedTemplateLiteral(['\\n  & .carousel .slide {\\n    margin: auto 0;\\n    border: solid 3px white;\\n  }\\n  \\n  & .carousel:hover .slide .legend {\\n    opacity: 1 !important;\\n  }\\n\\n  & .legend {\\n    opacity: 0.15 !important;\\n  }\\n\\n  & .legend:hover {\\n    opacity: 1 !important;\\n  }\\n'],['\\n  & .carousel .slide {\\n    margin: auto 0;\\n    border: solid 3px white;\\n  }\\n  \\n  & .carousel:hover .slide .legend {\\n    opacity: 1 !important;\\n  }\\n\\n  & .legend {\\n    opacity: 0.15 !important;\\n  }\\n\\n  & .legend:hover {\\n    opacity: 1 !important;\\n  }\\n']),_templateObject2=_taggedTemplateLiteral(['\\n  margin: auto 0;\\n  max-height: 60vh;\\n  overflow: auto;\\n'],['\\n  margin: auto 0;\\n  max-height: 60vh;\\n  overflow: auto;\\n']);function _taggedTemplateLiteral(strings,raw){return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}var CarouselResponsiveStyle=Object(__WEBPACK_IMPORTED_MODULE_2_styled_components__[\"c\" /* default */])(__WEBPACK_IMPORTED_MODULE_1_react_responsive_carousel__[\"Carousel\"])(_templateObject);var Slider=__WEBPACK_IMPORTED_MODULE_2_styled_components__[\"c\" /* default */].div(_templateObject2);function Carousel(_ref){var data=_ref.data;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',null,data.document&&data.document.length===0?__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('span',null,'No hay im\\xE1genes configuradas.'):null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(CarouselResponsiveStyle,{showArrows:false,autoPlay:true,infiniteLoop:true,stopOnHover:true,interval:data.rotationTime*1000,showStatus:false},data.document&&data.document.map(function(element){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Slider,{key:element.id},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('img',{src:element.url,alt:element.name}),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{className:'legend'},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('span',null,data.title),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('p',null,data.content))));})));}/* harmony default export */ __webpack_exports__[\"a\"] = (Carousel);\n\n/***/ }),\n\n/***/ 1330:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Thumbs = exports.Carousel = undefined;\n\nvar _Carousel = __webpack_require__(1331);\n\nvar _Carousel2 = _interopRequireDefault(_Carousel);\n\nvar _Thumbs = __webpack_require__(1273);\n\nvar _Thumbs2 = _interopRequireDefault(_Thumbs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Carousel = _Carousel2.default;\nexports.Thumbs = _Thumbs2.default;\n\n/***/ }),\n\n/***/ 1331:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(9);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = __webpack_require__(5);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _cssClasses = __webpack_require__(1270);\n\nvar _cssClasses2 = _interopRequireDefault(_cssClasses);\n\nvar _CSSTranslate = __webpack_require__(1271);\n\nvar _CSSTranslate2 = _interopRequireDefault(_CSSTranslate);\n\nvar _reactEasySwipe = __webpack_require__(1272);\n\nvar _reactEasySwipe2 = _interopRequireDefault(_reactEasySwipe);\n\nvar _Thumbs = __webpack_require__(1273);\n\nvar _Thumbs2 = _interopRequireDefault(_Thumbs);\n\nvar _customPropTypes = __webpack_require__(1334);\n\nvar customPropTypes = _interopRequireWildcard(_customPropTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar noop = function noop() {};\n\nvar defaultStatusFormatter = function defaultStatusFormatter(current, total) {\n    return current + ' of ' + total;\n};\n\nvar Carousel = function (_Component) {\n    _inherits(Carousel, _Component);\n\n    function Carousel(props) {\n        _classCallCheck(this, Carousel);\n\n        var _this = _possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call(this, props));\n\n        _this.setThumbsRef = function (node) {\n            _this.thumbsRef = node;\n        };\n\n        _this.setCarouselWrapperRef = function (node) {\n            _this.carouselWrapperRef = node;\n        };\n\n        _this.setListRef = function (node) {\n            _this.listRef = node;\n        };\n\n        _this.setItemsWrapperRef = function (node) {\n            _this.itemsWrapperRef = node;\n        };\n\n        _this.setItemsRef = function (node, index) {\n            if (!_this.itemsRef) {\n                _this.itemsRef = [];\n            }\n            _this.itemsRef[index] = node;\n        };\n\n        _this.autoPlay = function () {\n            if (!_this.props.autoPlay || _react.Children.count(_this.props.children) <= 1) {\n                return;\n            }\n\n            clearTimeout(_this.timer);\n            _this.timer = setTimeout(function () {\n                _this.increment();\n            }, _this.props.interval);\n        };\n\n        _this.clearAutoPlay = function () {\n            if (!_this.props.autoPlay) {\n                return;\n            }\n\n            clearTimeout(_this.timer);\n        };\n\n        _this.resetAutoPlay = function () {\n            _this.clearAutoPlay();\n            _this.autoPlay();\n        };\n\n        _this.stopOnHover = function () {\n            _this.setState({ isMouseEntered: true });\n            _this.clearAutoPlay();\n        };\n\n        _this.startOnLeave = function () {\n            _this.setState({ isMouseEntered: false });\n            _this.autoPlay();\n        };\n\n        _this.navigateWithKeyboard = function (e) {\n            var axis = _this.props.axis;\n\n            var isHorizontal = axis === 'horizontal';\n            var keyNames = {\n                ArrowUp: 38,\n                ArrowRight: 39,\n                ArrowDown: 40,\n                ArrowLeft: 37\n            };\n\n            var nextKey = isHorizontal ? keyNames.ArrowRight : keyNames.ArrowDown;\n            var prevKey = isHorizontal ? keyNames.ArrowLeft : keyNames.ArrowUp;\n\n            if (nextKey === e.keyCode) {\n                _this.increment();\n            } else if (prevKey === e.keyCode) {\n                _this.decrement();\n            }\n        };\n\n        _this.updateSizes = function () {\n            if (!_this.state.initialized) {\n                return;\n            }\n\n            var isHorizontal = _this.props.axis === 'horizontal';\n            var firstItem = _this.itemsRef[0];\n            var itemSize = isHorizontal ? firstItem.clientWidth : firstItem.clientHeight;\n\n            _this.setState({\n                itemSize: itemSize,\n                wrapperSize: isHorizontal ? itemSize * _react.Children.count(_this.props.children) : itemSize\n            });\n\n            if (_this.thumbsRef) {\n                _this.thumbsRef.updateSizes();\n            }\n        };\n\n        _this.setMountState = function () {\n            _this.setState({ hasMount: true });\n            _this.updateSizes();\n        };\n\n        _this.handleClickItem = function (index, item) {\n            if (_react.Children.count(_this.props.children) <= 1) {\n                return;\n            }\n\n            if (_this.state.cancelClick) {\n                _this.setState({\n                    cancelClick: false\n                });\n\n                return;\n            }\n\n            _this.props.onClickItem(index, item);\n\n            if (index !== _this.state.selectedItem) {\n                _this.setState({\n                    selectedItem: index\n                });\n            }\n        };\n\n        _this.handleOnChange = function (index, item) {\n            if (_react.Children.count(_this.props.children) <= 1) {\n                return;\n            }\n\n            _this.props.onChange(index, item);\n        };\n\n        _this.handleClickThumb = function (index, item) {\n            _this.props.onClickThumb(index, item);\n\n            _this.selectItem({\n                selectedItem: index\n            });\n        };\n\n        _this.onSwipeStart = function () {\n            _this.setState({\n                swiping: true\n            });\n            _this.clearAutoPlay();\n        };\n\n        _this.onSwipeEnd = function () {\n            _this.resetPosition();\n            _this.setState({\n                swiping: false\n            });\n            _this.autoPlay();\n        };\n\n        _this.onSwipeMove = function (delta) {\n            var isHorizontal = _this.props.axis === 'horizontal';\n\n            var initialBoundry = 0;\n\n            var currentPosition = _this.getPosition(_this.state.selectedItem);\n            var finalBoundry = _this.getPosition(_react.Children.count(_this.props.children) - 1);\n\n            var axisDelta = isHorizontal ? delta.x : delta.y;\n            var handledDelta = axisDelta;\n\n            // prevent user from swiping left out of boundaries\n            if (currentPosition === initialBoundry && axisDelta > 0) {\n                handledDelta = 0;\n            }\n\n            // prevent user from swiping right out of boundaries\n            if (currentPosition === finalBoundry && axisDelta < 0) {\n                handledDelta = 0;\n            }\n\n            var position = currentPosition + 100 / (_this.state.itemSize / handledDelta) + '%';\n\n            _this.setPosition(position);\n\n            // allows scroll if the swipe was within the tolerance\n            var hasMoved = Math.abs(axisDelta) > _this.props.swipeScrollTolerance;\n\n            if (hasMoved && !_this.state.cancelClick) {\n                _this.setState({\n                    cancelClick: true\n                });\n            }\n\n            return hasMoved;\n        };\n\n        _this.resetPosition = function () {\n            var currentPosition = _this.getPosition(_this.state.selectedItem) + '%';\n            _this.setPosition(currentPosition);\n        };\n\n        _this.setPosition = function (position) {\n            var list = _reactDom2.default.findDOMNode(_this.listRef);\n            ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {\n                list.style[prop] = (0, _CSSTranslate2.default)(position, _this.props.axis);\n            });\n        };\n\n        _this.decrement = function (positions) {\n            _this.moveTo(_this.state.selectedItem - (typeof positions === 'Number' ? positions : 1));\n        };\n\n        _this.increment = function (positions) {\n            _this.moveTo(_this.state.selectedItem + (typeof positions === 'Number' ? positions : 1));\n        };\n\n        _this.moveTo = function (position) {\n            var lastPosition = _react.Children.count(_this.props.children) - 1;\n\n            if (position < 0) {\n                position = _this.props.infiniteLoop ? lastPosition : 0;\n            }\n\n            if (position > lastPosition) {\n                position = _this.props.infiniteLoop ? 0 : lastPosition;\n            }\n\n            _this.selectItem({\n                // if it's not a slider, we don't need to set position here\n                selectedItem: position\n            });\n\n            // don't reset auto play when stop on hover is enabled, doing so will trigger a call to auto play more than once\n            // and will result in the interval function not being cleared correctly.\n            if (_this.props.autoPlay && _this.state.isMouseEntered === false) {\n                _this.resetAutoPlay();\n            }\n        };\n\n        _this.changeItem = function (e) {\n            var newIndex = e.target.value;\n\n            _this.selectItem({\n                selectedItem: newIndex\n            });\n        };\n\n        _this.selectItem = function (state) {\n            _this.setState(state);\n            _this.handleOnChange(state.selectedItem, _react.Children.toArray(_this.props.children)[state.selectedItem]);\n        };\n\n        _this.getInitialImage = function () {\n            var selectedItem = _this.props.selectedItem;\n            var item = _this.itemsRef && _this.itemsRef[selectedItem];\n            var images = item && item.getElementsByTagName('img');\n            return images && images[selectedItem];\n        };\n\n        _this.getVariableImageHeight = function (position) {\n            var item = _this.itemsRef && _this.itemsRef[position];\n            var images = item && item.getElementsByTagName('img');\n            if (_this.state.hasMount && images.length > 0) {\n                var image = images[0];\n\n                if (!image.complete) {\n                    // if the image is still loading, the size won't be available so we trigger a new render after it's done\n                    var onImageLoad = function onImageLoad() {\n                        _this.forceUpdate();\n                        image.removeEventListener('load', onImageLoad);\n                    };\n\n                    image.addEventListener('load', onImageLoad);\n                }\n\n                var height = image.clientHeight;\n                return height > 0 ? height : null;\n            }\n\n            return null;\n        };\n\n        _this.state = {\n            initialized: false,\n            selectedItem: props.selectedItem,\n            hasMount: false,\n            isMouseEntered: false\n        };\n        return _this;\n    }\n\n    _createClass(Carousel, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            if (!this.props.children) {\n                return;\n            }\n\n            this.setupCarousel();\n        }\n    }, {\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(nextProps) {\n            if (nextProps.selectedItem !== this.state.selectedItem) {\n                this.updateSizes();\n                this.moveTo(nextProps.selectedItem);\n            }\n\n            if (nextProps.autoPlay !== this.props.autoPlay) {\n                if (nextProps.autoPlay) {\n                    this.setupAutoPlay();\n                } else {\n                    this.destroyAutoPlay();\n                }\n            }\n        }\n    }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate(prevProps) {\n            if (!prevProps.children && this.props.children && !this.state.initialized) {\n                this.setupCarousel();\n            }\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            this.destroyCarousel();\n        }\n    }, {\n        key: 'setupCarousel',\n        value: function setupCarousel() {\n            this.bindEvents();\n\n            if (this.props.autoPlay && _react.Children.count(this.props.children) > 1) {\n                this.setupAutoPlay();\n            }\n\n            this.setState({\n                initialized: true\n            });\n\n            var initialImage = this.getInitialImage();\n            if (initialImage) {\n                // if it's a carousel of images, we set the mount state after the first image is loaded\n                initialImage.addEventListener('load', this.setMountState);\n            } else {\n                this.setMountState();\n            }\n        }\n    }, {\n        key: 'destroyCarousel',\n        value: function destroyCarousel() {\n            if (this.state.initialized) {\n                this.unbindEvents();\n                this.destroyAutoPlay();\n            }\n        }\n    }, {\n        key: 'setupAutoPlay',\n        value: function setupAutoPlay() {\n            this.autoPlay();\n            var carouselWrapper = this.carouselWrapperRef;\n\n            if (this.props.stopOnHover && carouselWrapper) {\n                carouselWrapper.addEventListener('mouseenter', this.stopOnHover);\n                carouselWrapper.addEventListener('mouseleave', this.startOnLeave);\n            }\n        }\n    }, {\n        key: 'destroyAutoPlay',\n        value: function destroyAutoPlay() {\n            this.clearAutoPlay();\n            var carouselWrapper = this.carouselWrapperRef;\n\n            if (this.props.stopOnHover && carouselWrapper) {\n                carouselWrapper.removeEventListener('mouseenter', this.stopOnHover);\n                carouselWrapper.removeEventListener('mouseleave', this.startOnLeave);\n            }\n        }\n    }, {\n        key: 'bindEvents',\n        value: function bindEvents() {\n            // as the widths are calculated, we need to resize\n            // the carousel when the window is resized\n            window.addEventListener(\"resize\", this.updateSizes);\n            // issue #2 - image loading smaller\n            window.addEventListener(\"DOMContentLoaded\", this.updateSizes);\n\n            if (this.props.useKeyboardArrows) {\n                document.addEventListener(\"keydown\", this.navigateWithKeyboard);\n            }\n        }\n    }, {\n        key: 'unbindEvents',\n        value: function unbindEvents() {\n            // removing listeners\n            window.removeEventListener(\"resize\", this.updateSizes);\n            window.removeEventListener(\"DOMContentLoaded\", this.updateSizes);\n\n            var initialImage = this.getInitialImage();\n            if (initialImage) {\n                initialImage.removeEventListener(\"load\", this.setMountState);\n            }\n\n            if (this.props.useKeyboardArrows) {\n                document.removeEventListener(\"keydown\", this.navigateWithKeyboard);\n            }\n        }\n    }, {\n        key: 'getPosition',\n        value: function getPosition(index) {\n            if (this.props.centerMode && this.props.axis === 'horizontal') {\n                var currentPosition = -index * this.props.centerSlidePercentage;\n                var lastPosition = _react.Children.count(this.props.children) - 1;\n\n                if (index && index !== lastPosition) {\n                    currentPosition += (100 - this.props.centerSlidePercentage) / 2;\n                } else if (index === lastPosition) {\n                    currentPosition += 100 - this.props.centerSlidePercentage;\n                }\n\n                return currentPosition;\n            }\n\n            return -index * 100;\n        }\n    }, {\n        key: 'renderItems',\n        value: function renderItems() {\n            var _this2 = this;\n\n            return _react.Children.map(this.props.children, function (item, index) {\n                var itemClass = _cssClasses2.default.ITEM(true, index === _this2.state.selectedItem);\n                var slideProps = {\n                    ref: function ref(e) {\n                        return _this2.setItemsRef(e, index);\n                    },\n                    key: 'itemKey' + index,\n                    className: _cssClasses2.default.ITEM(true, index === _this2.state.selectedItem),\n                    onClick: _this2.handleClickItem.bind(_this2, index, item)\n                };\n\n                if (_this2.props.centerMode && _this2.props.axis === 'horizontal') {\n                    slideProps.style = {\n                        minWidth: _this2.props.centerSlidePercentage + '%'\n                    };\n                }\n\n                return _react2.default.createElement(\n                    'li',\n                    slideProps,\n                    item\n                );\n            });\n        }\n    }, {\n        key: 'renderControls',\n        value: function renderControls() {\n            var _this3 = this;\n\n            if (!this.props.showIndicators) {\n                return null;\n            }\n\n            return _react2.default.createElement(\n                'ul',\n                { className: 'control-dots' },\n                _react.Children.map(this.props.children, function (item, index) {\n                    return _react2.default.createElement('li', { className: _cssClasses2.default.DOT(index === _this3.state.selectedItem), onClick: _this3.changeItem, value: index, key: index });\n                })\n            );\n        }\n    }, {\n        key: 'renderStatus',\n        value: function renderStatus() {\n            if (!this.props.showStatus) {\n                return null;\n            }\n\n            return _react2.default.createElement(\n                'p',\n                { className: 'carousel-status' },\n                this.props.statusFormatter(this.state.selectedItem + 1, _react.Children.count(this.props.children))\n            );\n        }\n    }, {\n        key: 'renderThumbs',\n        value: function renderThumbs() {\n            if (!this.props.showThumbs || _react.Children.count(this.props.children) === 0) {\n                return null;\n            }\n\n            return _react2.default.createElement(\n                _Thumbs2.default,\n                { ref: this.setThumbsRef, onSelectItem: this.handleClickThumb, selectedItem: this.state.selectedItem, transitionTime: this.props.transitionTime, thumbWidth: this.props.thumbWidth },\n                this.props.children\n            );\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            if (!this.props.children || _react.Children.count(this.props.children) === 0) {\n                return null;\n            }\n\n            var itemsLength = _react.Children.count(this.props.children);\n\n            var isHorizontal = this.props.axis === 'horizontal';\n\n            var canShowArrows = this.props.showArrows && itemsLength > 1;\n\n            // show left arrow?\n            var hasPrev = canShowArrows && (this.state.selectedItem > 0 || this.props.infiniteLoop);\n            // show right arrow\n            var hasNext = canShowArrows && (this.state.selectedItem < itemsLength - 1 || this.props.infiniteLoop);\n            // obj to hold the transformations and styles\n            var itemListStyles = {};\n\n            var currentPosition = this.getPosition(this.state.selectedItem);\n\n            // if 3d is available, let's take advantage of the performance of transform\n            var transformProp = (0, _CSSTranslate2.default)(currentPosition + '%', this.props.axis);\n\n            var transitionTime = this.props.transitionTime + 'ms';\n\n            itemListStyles = {\n                'WebkitTransform': transformProp,\n                'MozTransform': transformProp,\n                'MsTransform': transformProp,\n                'OTransform': transformProp,\n                'transform': transformProp,\n                'msTransform': transformProp\n            };\n\n            if (!this.state.swiping) {\n                itemListStyles = _extends({}, itemListStyles, {\n                    'WebkitTransitionDuration': transitionTime,\n                    'MozTransitionDuration': transitionTime,\n                    'MsTransitionDuration': transitionTime,\n                    'OTransitionDuration': transitionTime,\n                    'transitionDuration': transitionTime,\n                    'msTransitionDuration': transitionTime\n                });\n            }\n\n            var swiperProps = {\n                selectedItem: this.state.selectedItem,\n                className: _cssClasses2.default.SLIDER(true, this.state.swiping),\n                onSwipeMove: this.onSwipeMove,\n                onSwipeStart: this.onSwipeStart,\n                onSwipeEnd: this.onSwipeEnd,\n                style: itemListStyles,\n                tolerance: this.props.swipeScrollTolerance\n            };\n\n            var containerStyles = {};\n\n            if (isHorizontal) {\n                swiperProps.onSwipeLeft = this.increment;\n                swiperProps.onSwipeRight = this.decrement;\n\n                if (this.props.dynamicHeight) {\n                    var itemHeight = this.getVariableImageHeight(this.state.selectedItem);\n                    swiperProps.style.height = itemHeight || 'auto';\n                    containerStyles.height = itemHeight || 'auto';\n                }\n            } else {\n                swiperProps.onSwipeUp = this.props.verticalSwipe === 'natural' ? this.increment : this.decrement;\n                swiperProps.onSwipeDown = this.props.verticalSwipe === 'natural' ? this.decrement : this.increment;\n                swiperProps.style.height = this.state.itemSize;\n                containerStyles.height = this.state.itemSize;\n            }\n            return _react2.default.createElement(\n                'div',\n                { className: this.props.className, ref: this.setCarouselWrapperRef },\n                _react2.default.createElement(\n                    'div',\n                    { className: _cssClasses2.default.CAROUSEL(true), style: { width: this.props.width } },\n                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_PREV(!hasPrev), onClick: this.decrement }),\n                    _react2.default.createElement(\n                        'div',\n                        { className: _cssClasses2.default.WRAPPER(true, this.props.axis), style: containerStyles, ref: this.setItemsWrapperRef },\n                        this.props.swipeable ? _react2.default.createElement(\n                            _reactEasySwipe2.default,\n                            _extends({\n                                tagName: 'ul',\n                                ref: this.setListRef\n                            }, swiperProps, {\n                                allowMouseEvents: this.props.emulateTouch }),\n                            this.renderItems()\n                        ) : _react2.default.createElement(\n                            'ul',\n                            {\n                                className: _cssClasses2.default.SLIDER(true, this.state.swiping),\n                                style: itemListStyles },\n                            this.renderItems()\n                        )\n                    ),\n                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_NEXT(!hasNext), onClick: this.increment }),\n                    this.renderControls(),\n                    this.renderStatus()\n                ),\n                this.renderThumbs()\n            );\n        }\n    }]);\n\n    return Carousel;\n}(_react.Component);\n\nCarousel.displayName = 'Carousel';\nCarousel.propTypes = {\n    className: _propTypes2.default.string,\n    children: _propTypes2.default.node,\n    showArrows: _propTypes2.default.bool,\n    showStatus: _propTypes2.default.bool,\n    showIndicators: _propTypes2.default.bool,\n    infiniteLoop: _propTypes2.default.bool,\n    showThumbs: _propTypes2.default.bool,\n    thumbWidth: _propTypes2.default.number,\n    selectedItem: _propTypes2.default.number,\n    onClickItem: _propTypes2.default.func.isRequired,\n    onClickThumb: _propTypes2.default.func.isRequired,\n    onChange: _propTypes2.default.func.isRequired,\n    axis: _propTypes2.default.oneOf(['horizontal', 'vertical']),\n    verticalSwipe: _propTypes2.default.oneOf(['natural', 'standard']),\n    width: customPropTypes.unit,\n    useKeyboardArrows: _propTypes2.default.bool,\n    autoPlay: _propTypes2.default.bool,\n    stopOnHover: _propTypes2.default.bool,\n    interval: _propTypes2.default.number,\n    transitionTime: _propTypes2.default.number,\n    swipeScrollTolerance: _propTypes2.default.number,\n    swipeable: _propTypes2.default.bool,\n    dynamicHeight: _propTypes2.default.bool,\n    emulateTouch: _propTypes2.default.bool,\n    statusFormatter: _propTypes2.default.func.isRequired,\n    centerMode: _propTypes2.default.bool,\n    centerSlidePercentage: _propTypes2.default.number\n};\nCarousel.defaultProps = {\n    showIndicators: true,\n    showArrows: true,\n    showStatus: true,\n    showThumbs: true,\n    infiniteLoop: false,\n    selectedItem: 0,\n    axis: 'horizontal',\n    verticalSwipe: 'standard',\n    width: '100%',\n    useKeyboardArrows: false,\n    autoPlay: false,\n    stopOnHover: true,\n    interval: 3000,\n    transitionTime: 350,\n    swipeScrollTolerance: 5,\n    swipeable: true,\n    dynamicHeight: false,\n    emulateTouch: false,\n    onClickItem: noop,\n    onClickThumb: noop,\n    onChange: noop,\n    statusFormatter: defaultStatusFormatter,\n    centerMode: false,\n    centerSlidePercentage: 80\n};\nexports.default = Carousel;\n\n/***/ }),\n\n/***/ 1332:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(0), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('react'), require('prop-types'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.react, global.propTypes);\n    global.reactSwipe = mod.exports;\n  }\n})(this, function (exports, _react, _propTypes) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.setHasSupportToCaptureOption = setHasSupportToCaptureOption;\n\n  var _react2 = _interopRequireDefault(_react);\n\n  var _propTypes2 = _interopRequireDefault(_propTypes);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var supportsCaptureOption = false;\n  function setHasSupportToCaptureOption(hasSupport) {\n    supportsCaptureOption = hasSupport;\n  }\n\n  try {\n    addEventListener(\"test\", null, Object.defineProperty({}, 'capture', { get: function get() {\n        setHasSupportToCaptureOption(true);\n      } }));\n  } catch (e) {}\n\n  function getSafeEventHandlerOpts() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { capture: true };\n\n    return supportsCaptureOption ? options : options.capture;\n  }\n\n  /**\n   * [getPosition returns a position element that works for mouse or touch events]\n   * @param  {[Event]} event [the received event]\n   * @return {[Object]}      [x and y coords]\n   */\n  function getPosition(event) {\n    if ('touches' in event) {\n      var _event$touches$ = event.touches[0],\n          pageX = _event$touches$.pageX,\n          pageY = _event$touches$.pageY;\n\n      return { x: pageX, y: pageY };\n    }\n\n    var screenX = event.screenX,\n        screenY = event.screenY;\n\n    return { x: screenX, y: screenY };\n  }\n\n  var ReactSwipe = function (_Component) {\n    _inherits(ReactSwipe, _Component);\n\n    function ReactSwipe() {\n      var _ref;\n\n      _classCallCheck(this, ReactSwipe);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var _this = _possibleConstructorReturn(this, (_ref = ReactSwipe.__proto__ || Object.getPrototypeOf(ReactSwipe)).call.apply(_ref, [this].concat(args)));\n\n      _this._handleSwipeStart = _this._handleSwipeStart.bind(_this);\n      _this._handleSwipeMove = _this._handleSwipeMove.bind(_this);\n      _this._handleSwipeEnd = _this._handleSwipeEnd.bind(_this);\n\n      _this._onMouseDown = _this._onMouseDown.bind(_this);\n      _this._onMouseMove = _this._onMouseMove.bind(_this);\n      _this._onMouseUp = _this._onMouseUp.bind(_this);\n      return _this;\n    }\n\n    _createClass(ReactSwipe, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (this.swiper) {\n          this.swiper.addEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({\n            capture: true,\n            passive: false\n          }));\n        }\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        if (this.swiper) {\n          this.swiper.removeEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({\n            capture: true,\n            passive: false\n          }));\n        }\n      }\n    }, {\n      key: '_onMouseDown',\n      value: function _onMouseDown(event) {\n        if (!this.props.allowMouseEvents) {\n          return;\n        }\n\n        this.mouseDown = true;\n\n        document.addEventListener('mouseup', this._onMouseUp);\n        document.addEventListener('mousemove', this._onMouseMove);\n\n        this._handleSwipeStart(event);\n      }\n    }, {\n      key: '_onMouseMove',\n      value: function _onMouseMove(event) {\n        if (!this.mouseDown) {\n          return;\n        }\n\n        this._handleSwipeMove(event);\n      }\n    }, {\n      key: '_onMouseUp',\n      value: function _onMouseUp(event) {\n        this.mouseDown = false;\n\n        document.removeEventListener('mouseup', this._onMouseUp);\n        document.removeEventListener('mousemove', this._onMouseMove);\n\n        this._handleSwipeEnd(event);\n      }\n    }, {\n      key: '_handleSwipeStart',\n      value: function _handleSwipeStart(event) {\n        var _getPosition = getPosition(event),\n            x = _getPosition.x,\n            y = _getPosition.y;\n\n        this.moveStart = { x: x, y: y };\n        this.props.onSwipeStart(event);\n      }\n    }, {\n      key: '_handleSwipeMove',\n      value: function _handleSwipeMove(event) {\n        if (!this.moveStart) {\n          return;\n        }\n\n        var _getPosition2 = getPosition(event),\n            x = _getPosition2.x,\n            y = _getPosition2.y;\n\n        var deltaX = x - this.moveStart.x;\n        var deltaY = y - this.moveStart.y;\n        this.moving = true;\n\n        // handling the responsability of cancelling the scroll to\n        // the component handling the event\n        var shouldPreventDefault = this.props.onSwipeMove({\n          x: deltaX,\n          y: deltaY\n        }, event);\n\n        if (shouldPreventDefault) {\n          event.preventDefault();\n        }\n\n        this.movePosition = { deltaX: deltaX, deltaY: deltaY };\n      }\n    }, {\n      key: '_handleSwipeEnd',\n      value: function _handleSwipeEnd(event) {\n        this.props.onSwipeEnd(event);\n\n        var tolerance = this.props.tolerance;\n\n\n        if (this.moving && this.movePosition) {\n          if (this.movePosition.deltaX < -tolerance) {\n            this.props.onSwipeLeft(1, event);\n          } else if (this.movePosition.deltaX > tolerance) {\n            this.props.onSwipeRight(1, event);\n          }\n          if (this.movePosition.deltaY < -tolerance) {\n            this.props.onSwipeUp(1, event);\n          } else if (this.movePosition.deltaY > tolerance) {\n            this.props.onSwipeDown(1, event);\n          }\n        }\n\n        this.moveStart = null;\n        this.moving = false;\n        this.movePosition = null;\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _this2 = this;\n\n        return _react2.default.createElement(\n          this.props.tagName,\n          {\n            ref: function ref(node) {\n              return _this2.swiper = node;\n            },\n            onMouseDown: this._onMouseDown,\n            onTouchStart: this._handleSwipeStart,\n            onTouchEnd: this._handleSwipeEnd,\n            className: this.props.className,\n            style: this.props.style\n          },\n          this.props.children\n        );\n      }\n    }]);\n\n    return ReactSwipe;\n  }(_react.Component);\n\n  ReactSwipe.displayName = 'ReactSwipe';\n  ReactSwipe.propTypes = {\n    tagName: _propTypes2.default.string,\n    className: _propTypes2.default.string,\n    style: _propTypes2.default.object,\n    children: _propTypes2.default.node,\n    allowMouseEvents: _propTypes2.default.bool,\n    onSwipeUp: _propTypes2.default.func,\n    onSwipeDown: _propTypes2.default.func,\n    onSwipeLeft: _propTypes2.default.func,\n    onSwipeRight: _propTypes2.default.func,\n    onSwipeStart: _propTypes2.default.func,\n    onSwipeMove: _propTypes2.default.func,\n    onSwipeEnd: _propTypes2.default.func,\n    tolerance: _propTypes2.default.number.isRequired\n  };\n  ReactSwipe.defaultProps = {\n    tagName: 'div',\n    allowMouseEvents: false,\n    onSwipeUp: function onSwipeUp() {},\n    onSwipeDown: function onSwipeDown() {},\n    onSwipeLeft: function onSwipeLeft() {},\n    onSwipeRight: function onSwipeRight() {},\n    onSwipeStart: function onSwipeStart() {},\n    onSwipeMove: function onSwipeMove() {},\n    onSwipeEnd: function onSwipeEnd() {},\n\n    tolerance: 0\n  };\n  exports.default = ReactSwipe;\n});\n\n/***/ }),\n\n/***/ 1333:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nvar outerWidth = exports.outerWidth = function outerWidth(el) {\n\tvar width = el.offsetWidth;\n\tvar style = getComputedStyle(el);\n\n\twidth += parseInt(style.marginLeft) + parseInt(style.marginRight);\n\treturn width;\n};\n\n/***/ }),\n\n/***/ 1334:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar unit = exports.unit = function unit(props, propName, componentName) {\n    if (!/(pt|px|em|rem|vw|vh|%)$/.test(props[propName])) {\n        return new Error('Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed. It needs to be a size unit like pt, px, em, rem, vw, %');\n    }\n};\n\n/***/ }),\n\n/***/ 1335:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux__ = __webpack_require__(129);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_router_dom__ = __webpack_require__(101);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_antd__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__state_ManagerTeamSurvey_action__ = __webpack_require__(408);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shared_FormattedMessage__ = __webpack_require__(55);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Column=__WEBPACK_IMPORTED_MODULE_3_antd__[\"w\" /* Table */].Column;var PendingsManager=function(_Component){_inherits(PendingsManager,_Component);function PendingsManager(){var _ref;var _temp,_this,_ret;_classCallCheck(this,PendingsManager);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=PendingsManager.__proto__||Object.getPrototypeOf(PendingsManager)).call.apply(_ref,[this].concat(args))),_this),_this.getPendingsColumns=function(){var data=_this.props.data;var masters=data.masters;var columns=[{title:'Supplier.supplier',key:'businessName'},{title:'Supplier.supplyType',key:'idSupply',render:function render(text,record){return masters.Supply.find(function(supply){return supply.id===record.idSupply;}).name;}},{title:'Supplier.idCompanySize',key:'idCompanySize',render:function render(text,record){var companySize=masters.CompanySize.find(function(element){return element.id===record.idCompanySize;});return companySize?companySize.name:'';}},{title:'Supplier.action',key:'linkManager',render:function render(text,record){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2_react_router_dom__[\"b\" /* Link */],{to:'/managerTeamSurvey/'+record.id},'Ver');}}];return columns.map(function(column){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Column,{title:__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__shared_FormattedMessage__[\"a\" /* default */],{id:column.title}),key:column.key,dataIndex:column.key,render:column.render});});},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(PendingsManager,[{key:'componentDidMount',value:function componentDidMount(){this.props.getManagerTeamSurvey();}},{key:'render',value:function render(){var _props=this.props,data=_props.data,loading=_props.loading;var suppliers=data.suppliers;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"u\" /* Spin */],{spinning:loading},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"w\" /* Table */],{rowKey:function rowKey(record){return record.id;},dataSource:suppliers&&suppliers.filter(function(x){return x.state==='NOT_STARTED_MANAGER_TEAM';})},this.getPendingsColumns()));}}]);return PendingsManager;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);var mapStateToProps=function mapStateToProps(state){return{data:state.managerTeamSurvey.data,loading:state.managerTeamSurvey.loading};};/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1_react_redux__[\"b\" /* connect */])(mapStateToProps,__WEBPACK_IMPORTED_MODULE_4__state_ManagerTeamSurvey_action__)(PendingsManager));\n\n/***/ }),\n\n/***/ 1336:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux__ = __webpack_require__(129);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_router_dom__ = __webpack_require__(101);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_antd__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__state_TechnicalTeamSurvey_action__ = __webpack_require__(1253);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shared_FormattedMessage__ = __webpack_require__(55);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Column=__WEBPACK_IMPORTED_MODULE_3_antd__[\"w\" /* Table */].Column;var PendingsTechnical=function(_Component){_inherits(PendingsTechnical,_Component);function PendingsTechnical(){var _ref;var _temp,_this,_ret;_classCallCheck(this,PendingsTechnical);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=PendingsTechnical.__proto__||Object.getPrototypeOf(PendingsTechnical)).call.apply(_ref,[this].concat(args))),_this),_this.getPendingsColumns=function(){var data=_this.props.data;var masters=data.masters;var columns=[{title:'Supplier.supplier',key:'businessName'},{title:'Supplier.supplyType',key:'idSupply',render:function render(text,record){return masters.Supply.find(function(supply){return supply.id===record.idSupply;}).name;}},{title:'Supplier.idCompanySize',key:'idCompanySize',render:function render(text,record){var companySize=masters.CompanySize.find(function(element){return element.id===record.idCompanySize;});return companySize?companySize.name:'';}},{title:'Supplier.action',key:'linkTechnical',render:function render(text,record){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2_react_router_dom__[\"b\" /* Link */],{to:'/TechnicalTeamSurvey/'+record.id},'Ver');}}];return columns.map(function(column){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Column,{title:__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__shared_FormattedMessage__[\"a\" /* default */],{id:column.title}),key:column.key,dataIndex:column.key,render:column.render});});},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(PendingsTechnical,[{key:'componentDidMount',value:function componentDidMount(){this.props.getTechnicalTeamSurvey();}},{key:'render',value:function render(){var _props=this.props,data=_props.data,loading=_props.loading;var suppliers=data.suppliers;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"u\" /* Spin */],{spinning:loading},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"w\" /* Table */],{rowKey:function rowKey(record){return record.id;},dataSource:suppliers&&suppliers.filter(function(x){return x.state!=='ENDED_TECHNICAL_TEAM';})},this.getPendingsColumns()));}}]);return PendingsTechnical;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);var mapStateToProps=function mapStateToProps(state){return{data:state.technicalTeamSurvey.data,loading:state.technicalTeamSurvey.loading};};/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1_react_redux__[\"b\" /* connect */])(mapStateToProps,__WEBPACK_IMPORTED_MODULE_4__state_TechnicalTeamSurvey_action__)(PendingsTechnical));\n\n/***/ }),\n\n/***/ 1337:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux__ = __webpack_require__(129);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_router_dom__ = __webpack_require__(101);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_antd__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__state_Pendings_action__ = __webpack_require__(1255);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shared_FormattedMessage__ = __webpack_require__(55);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Column=__WEBPACK_IMPORTED_MODULE_3_antd__[\"w\" /* Table */].Column;var PendingsEvaluator=function(_Component){_inherits(PendingsEvaluator,_Component);function PendingsEvaluator(){var _ref;var _temp,_this,_ret;_classCallCheck(this,PendingsEvaluator);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=PendingsEvaluator.__proto__||Object.getPrototypeOf(PendingsEvaluator)).call.apply(_ref,[this].concat(args))),_this),_this.getPendingsColumns=function(){var data=_this.props.data;var suppliersByCall=data.suppliersByCall,masters=data.masters;var columns=[{title:'Supplier.supplier',key:'businessName'},{title:'Supplier.supplyType',key:'idSupply',render:function render(text,record){return masters.Supply.find(function(supply){return supply.id===record.idSupply;}).name;}},{title:'Supplier.idCompanySize',key:'idCompanySize',render:function render(text,record){var companySize=masters.CompanySize.find(function(element){return element.id===record.idCompanySize;});return companySize?companySize.name:'';}},{title:'Supplier.action',key:'linkManager',render:function render(text,record){var idSupplierByCall=suppliersByCall.find(function(item){return item.idSupplier===record.id;}).id;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2_react_router_dom__[\"b\" /* Link */],{to:'/supplier/'+record.id+'/'+idSupplierByCall},'Ver');}}];return columns.map(function(column){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Column,{title:__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__shared_FormattedMessage__[\"a\" /* default */],{id:column.title}),key:column.key,dataIndex:column.key,render:column.render});});},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(PendingsEvaluator,[{key:'componentDidMount',value:function componentDidMount(){this.props.getPendings();}},{key:'render',value:function render(){var _props=this.props,data=_props.data,loading=_props.loading;var suppliers=data.suppliers,suppliersByCall=data.suppliersByCall,states=data.states;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"u\" /* Spin */],{spinning:loading},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"w\" /* Table */],{rowKey:function rowKey(record){return record.id;},dataSource:suppliers&&suppliers.filter(function(x){var idStateSupplier=suppliersByCall.find(function(element){return element.idSupplier===x.id;}).idState;var stateName=states.find(function(state){return state.id===idStateSupplier;}).shortName;return stateName!=='ENDED_EVALUATOR';})},this.getPendingsColumns()));}}]);return PendingsEvaluator;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);var mapStateToProps=function mapStateToProps(state){return{data:state.pendings.data,loading:state.pendings.loading};};/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1_react_redux__[\"b\" /* connect */])(mapStateToProps,__WEBPACK_IMPORTED_MODULE_4__state_Pendings_action__)(PendingsEvaluator));\n\n/***/ }),\n\n/***/ 1338:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux__ = __webpack_require__(129);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_router_dom__ = __webpack_require__(101);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_antd__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shared_FormattedMessage__ = __webpack_require__(55);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Column=__WEBPACK_IMPORTED_MODULE_3_antd__[\"w\" /* Table */].Column;var PendingsSupplier=function(_Component){_inherits(PendingsSupplier,_Component);function PendingsSupplier(){var _ref;var _temp,_this,_ret;_classCallCheck(this,PendingsSupplier);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=PendingsSupplier.__proto__||Object.getPrototypeOf(PendingsSupplier)).call.apply(_ref,[this].concat(args))),_this),_this.getPendingsColumns=function(){var columns=[{title:'Supplier.supplier',key:'name'},{title:'Supplier.supplyType',key:'supply'},{title:'Supplier.idCompanySize',key:'company_size'},{title:'Supplier.action',key:'linkManager',render:function render(){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2_react_router_dom__[\"b\" /* Link */],{to:'/supplier'},'Ver');}}];return columns.map(function(column){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Column,{title:__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__shared_FormattedMessage__[\"a\" /* default */],{id:column.title}),key:column.key,dataIndex:column.key,render:column.render});});},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(PendingsSupplier,[{key:'render',value:function render(){var _props=this.props,data=_props.data,loading=_props.loading;var userInfo=data.userInfo;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"u\" /* Spin */],{spinning:loading},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_antd__[\"w\" /* Table */],{rowKey:function rowKey(record){return record.id;},dataSource:[userInfo]},this.getPendingsColumns()));}}]);return PendingsSupplier;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);var mapStateToProps=function mapStateToProps(state){return{data:state.main.data,loading:state.main.loading};};/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1_react_redux__[\"b\" /* connect */])(mapStateToProps)(PendingsSupplier));\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/6.6a376720.chunk.js","import React from 'react';\r\nimport HomeContainer from '../components/Home/HomeContainer';\r\n\r\nfunction Home() {\r\n  return (\r\n    <HomeContainer />\r\n  );\r\n}\r\n\r\nexport default Home;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/Home.js","'use strict';\n\nmodule.exports = require('./helpers.core');\nmodule.exports.easing = require('./helpers.easing');\nmodule.exports.canvas = require('./helpers.canvas');\nmodule.exports.options = require('./helpers.options');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/helpers/index.js\n// module id = 1213\n// module chunks = 6","'use strict';\n\nvar helpers = require('../helpers/index');\n\nmodule.exports = {\n\t/**\n\t * @private\n\t */\n\t_set: function(scope, values) {\n\t\treturn helpers.merge(this[scope] || (this[scope] = {}), values);\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.defaults.js\n// module id = 1217\n// module chunks = 6","'use strict';\n\nvar color = require('chartjs-color');\nvar helpers = require('../helpers/index');\n\nfunction interpolate(start, view, model, ease) {\n\tvar keys = Object.keys(model);\n\tvar i, ilen, key, actual, origin, target, type, c0, c1;\n\n\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\tkey = keys[i];\n\n\t\ttarget = model[key];\n\n\t\t// if a value is added to the model after pivot() has been called, the view\n\t\t// doesn't contain it, so let's initialize the view to the target value.\n\t\tif (!view.hasOwnProperty(key)) {\n\t\t\tview[key] = target;\n\t\t}\n\n\t\tactual = view[key];\n\n\t\tif (actual === target || key[0] === '_') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!start.hasOwnProperty(key)) {\n\t\t\tstart[key] = actual;\n\t\t}\n\n\t\torigin = start[key];\n\n\t\ttype = typeof target;\n\n\t\tif (type === typeof origin) {\n\t\t\tif (type === 'string') {\n\t\t\t\tc0 = color(origin);\n\t\t\t\tif (c0.valid) {\n\t\t\t\t\tc1 = color(target);\n\t\t\t\t\tif (c1.valid) {\n\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'number' && isFinite(origin) && isFinite(target)) {\n\t\t\t\tview[key] = origin + (target - origin) * ease;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tview[key] = target;\n\t}\n}\n\nvar Element = function(configuration) {\n\thelpers.extend(this, configuration);\n\tthis.initialize.apply(this, arguments);\n};\n\nhelpers.extend(Element.prototype, {\n\n\tinitialize: function() {\n\t\tthis.hidden = false;\n\t},\n\n\tpivot: function() {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\tme._view = helpers.clone(me._model);\n\t\t}\n\t\tme._start = {};\n\t\treturn me;\n\t},\n\n\ttransition: function(ease) {\n\t\tvar me = this;\n\t\tvar model = me._model;\n\t\tvar start = me._start;\n\t\tvar view = me._view;\n\n\t\t// No animation -> No Transition\n\t\tif (!model || ease === 1) {\n\t\t\tme._view = model;\n\t\t\tme._start = null;\n\t\t\treturn me;\n\t\t}\n\n\t\tif (!view) {\n\t\t\tview = me._view = {};\n\t\t}\n\n\t\tif (!start) {\n\t\t\tstart = me._start = {};\n\t\t}\n\n\t\tinterpolate(start, view, model, ease);\n\n\t\treturn me;\n\t},\n\n\ttooltipPosition: function() {\n\t\treturn {\n\t\t\tx: this._model.x,\n\t\t\ty: this._model.y\n\t\t};\n\t},\n\n\thasValue: function() {\n\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t}\n});\n\nElement.extend = helpers.inherits;\n\nmodule.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.element.js\n// module id = 1224\n// module chunks = 6","'use strict';\n\nmodule.exports = {};\nmodule.exports.Arc = require('./element.arc');\nmodule.exports.Line = require('./element.line');\nmodule.exports.Point = require('./element.point');\nmodule.exports.Rectangle = require('./element.rectangle');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/elements/index.js\n// module id = 1225\n// module chunks = 6","'use strict';\n\nvar helpers = require('../helpers/index');\n\nfunction filterByPosition(array, position) {\n\treturn helpers.where(array, function(v) {\n\t\treturn v.position === position;\n\t});\n}\n\nfunction sortByWeight(array, reverse) {\n\tarray.forEach(function(v, i) {\n\t\tv._tmpIndex_ = i;\n\t\treturn v;\n\t});\n\tarray.sort(function(a, b) {\n\t\tvar v0 = reverse ? b : a;\n\t\tvar v1 = reverse ? a : b;\n\t\treturn v0.weight === v1.weight ?\n\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\tv0.weight - v1.weight;\n\t});\n\tarray.forEach(function(v) {\n\t\tdelete v._tmpIndex_;\n\t});\n}\n\n/**\n * @interface ILayoutItem\n * @prop {String} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n * @prop {Function} getPadding -  Returns an object with padding on the edges\n * @prop {Number} width - Width of item. Must be valid after update()\n * @prop {Number} height - Height of item. Must be valid after update()\n * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nmodule.exports = {\n\tdefaults: {},\n\n\t/**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {ILayoutItem} item - the item to add to be layed out\n\t */\n\taddBox: function(chart, item) {\n\t\tif (!chart.boxes) {\n\t\t\tchart.boxes = [];\n\t\t}\n\n\t\t// initialize item with default values\n\t\titem.fullWidth = item.fullWidth || false;\n\t\titem.position = item.position || 'top';\n\t\titem.weight = item.weight || 0;\n\n\t\tchart.boxes.push(item);\n\t},\n\n\t/**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {Object} layoutItem - the item to remove from the layout\n\t */\n\tremoveBox: function(chart, layoutItem) {\n\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\tif (index !== -1) {\n\t\t\tchart.boxes.splice(index, 1);\n\t\t}\n\t},\n\n\t/**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {Object} item - the item to configure with the given options\n\t * @param {Object} options - the new item options.\n\t */\n\tconfigure: function(chart, item, options) {\n\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\tvar ilen = props.length;\n\t\tvar i = 0;\n\t\tvar prop;\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\tprop = props[i];\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\titem[prop] = options[prop];\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {Number} width - the width to fit into\n\t * @param {Number} height - the height to fit into\n\t */\n\tupdate: function(chart, width, height) {\n\t\tif (!chart) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar layoutOptions = chart.options.layout || {};\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\n\t\tvar leftPadding = padding.left;\n\t\tvar rightPadding = padding.right;\n\t\tvar topPadding = padding.top;\n\t\tvar bottomPadding = padding.bottom;\n\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\tsortByWeight(leftBoxes, true);\n\t\tsortByWeight(rightBoxes, false);\n\t\tsortByWeight(topBoxes, true);\n\t\tsortByWeight(bottomBoxes, false);\n\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t// Our canvas looks like the following.\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t// B1 is the bottom axis\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t// an error will be thrown.\n\t\t//\n\t\t// |----------------------------------------------------|\n\t\t// |                  T1 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t// |    |    |                 T2                  |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    | C1 |                           | C2 |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    |                                     |    |\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t// |    |    |                                     |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    | C3 |                           | C4 |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    |                 B1                  |    |\n\t\t// |----------------------------------------------------|\n\t\t// |                  B2 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t//\n\t\t// What we do to find the best sizing, we do the following\n\t\t// 1. Determine the minimum size of the chart area.\n\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t// 6. Refit each axis\n\t\t// 7. Position each axis in the final location\n\t\t// 8. Tell the chart the final location of the chart area\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t// Step 1\n\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t// Step 2\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t// Step 3\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t// Step 4\n\t\tvar maxChartAreaWidth = chartWidth;\n\t\tvar maxChartAreaHeight = chartHeight;\n\t\tvar minBoxSizes = [];\n\n\t\tfunction getMinimumBoxSize(box) {\n\t\t\tvar minSize;\n\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t} else {\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t}\n\n\t\t\tminBoxSizes.push({\n\t\t\t\thorizontal: isHorizontal,\n\t\t\t\tminSize: minSize,\n\t\t\t\tbox: box,\n\t\t\t});\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\tvar maxHorizontalLeftPadding = 0;\n\t\tvar maxHorizontalRightPadding = 0;\n\t\tvar maxVerticalTopPadding = 0;\n\t\tvar maxVerticalBottomPadding = 0;\n\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\tif (verticalBox.getPadding) {\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t}\n\t\t});\n\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t// be if the axes are drawn at their minimum sizes.\n\t\t// Steps 5 & 6\n\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\tvar totalRightBoxesWidth = rightPadding;\n\t\tvar totalTopBoxesHeight = topPadding;\n\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t// Function to fit a box\n\t\tfunction fitBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\treturn minBox.box === box;\n\t\t\t});\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t} else {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\t// Set the Left and Right margins for the horizontal boxes\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\tfunction finalFitVerticalBox(box) {\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\treturn minSize.box === box;\n\t\t\t});\n\n\t\t\tvar scaleMargin = {\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t};\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t}\n\t\t}\n\n\t\t// Let the left layout know the final margin\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\ttotalLeftBoxesWidth = leftPadding;\n\t\ttotalRightBoxesWidth = rightPadding;\n\t\ttotalTopBoxesHeight = topPadding;\n\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\thelpers.each(leftBoxes, function(box) {\n\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(rightBoxes, function(box) {\n\t\t\ttotalRightBoxesWidth += box.width;\n\t\t});\n\n\t\thelpers.each(topBoxes, function(box) {\n\t\t\ttotalTopBoxesHeight += box.height;\n\t\t});\n\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t});\n\n\t\t// We may be adding some padding to account for rotated x axis labels\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t// without calling `fit` again\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t}\n\n\t\t// Step 7 - Position the boxes\n\t\tvar left = leftPadding + leftPaddingAddition;\n\t\tvar top = topPadding + topPaddingAddition;\n\n\t\tfunction placeBox(box) {\n\t\t\tif (box.isHorizontal()) {\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\tbox.top = top;\n\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t// Move to next point\n\t\t\t\ttop = box.bottom;\n\n\t\t\t} else {\n\n\t\t\t\tbox.left = left;\n\t\t\t\tbox.right = left + box.width;\n\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t// Move to next point\n\t\t\t\tleft = box.right;\n\t\t\t}\n\t\t}\n\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t// Account for chart width and height\n\t\tleft += maxChartAreaWidth;\n\t\ttop += maxChartAreaHeight;\n\n\t\thelpers.each(rightBoxes, placeBox);\n\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t// Step 8\n\t\tchart.chartArea = {\n\t\t\tleft: totalLeftBoxesWidth,\n\t\t\ttop: totalTopBoxesHeight,\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t};\n\n\t\t// Step 9\n\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\tbox.left = chart.chartArea.left;\n\t\t\tbox.top = chart.chartArea.top;\n\t\t\tbox.right = chart.chartArea.right;\n\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t});\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.layouts.js\n// module id = 1233\n// module chunks = 6","'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nmodule.exports = {\n\t/**\n\t * Namespace to hold formatters for different types of ticks\n\t * @namespace Chart.Ticks.formatters\n\t */\n\tformatters: {\n\t\t/**\n\t\t * Formatter for value labels\n\t\t * @method Chart.Ticks.formatters.values\n\t\t * @param value the value to display\n\t\t * @return {String|Array} the label to display\n\t\t */\n\t\tvalues: function(value) {\n\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t},\n\n\t\t/**\n\t\t * Formatter for linear numeric ticks\n\t\t * @method Chart.Ticks.formatters.linear\n\t\t * @param tickValue {Number} the value to be formatted\n\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t * @return {String} string representation of the tickValue parameter\n\t\t */\n\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t// not an integer\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\tvar tickString = '';\n\n\t\t\tif (tickValue !== 0) {\n\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t} else {\n\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t}\n\n\t\t\treturn tickString;\n\t\t},\n\n\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\tif (tickValue === 0) {\n\t\t\t\treturn '0';\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\treturn tickValue.toExponential();\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.ticks.js\n// module id = 1234\n// module chunks = 6","'use strict';\n\n/**\n * @namespace Chart.helpers\n */\nvar helpers = {\n\t/**\n\t * An empty function that can be used, for example, for optional callback.\n\t */\n\tnoop: function() {},\n\n\t/**\n\t * Returns a unique id, sequentially generated from a global variable.\n\t * @returns {Number}\n\t * @function\n\t */\n\tuid: (function() {\n\t\tvar id = 0;\n\t\treturn function() {\n\t\t\treturn id++;\n\t\t};\n\t}()),\n\n\t/**\n\t * Returns true if `value` is neither null nor undefined, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @since 2.7.0\n\t */\n\tisNullOrUndef: function(value) {\n\t\treturn value === null || typeof value === 'undefined';\n\t},\n\n\t/**\n\t * Returns true if `value` is an array, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @function\n\t */\n\tisArray: Array.isArray ? Array.isArray : function(value) {\n\t\treturn Object.prototype.toString.call(value) === '[object Array]';\n\t},\n\n\t/**\n\t * Returns true if `value` is an object (excluding null), else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {Boolean}\n\t * @since 2.7.0\n\t */\n\tisObject: function(value) {\n\t\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\n\t},\n\n\t/**\n\t * Returns `value` if defined, else returns `defaultValue`.\n\t * @param {*} value - The value to return if defined.\n\t * @param {*} defaultValue - The value to return if `value` is undefined.\n\t * @returns {*}\n\t */\n\tvalueOrDefault: function(value, defaultValue) {\n\t\treturn typeof value === 'undefined' ? defaultValue : value;\n\t},\n\n\t/**\n\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\n\t * @param {Array} value - The array to lookup for value at `index`.\n\t * @param {Number} index - The index in `value` to lookup for value.\n\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\n\t * @returns {*}\n\t */\n\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\n\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n\t},\n\n\t/**\n\t * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n\t * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n\t * @param {Function} fn - The function to call.\n\t * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @returns {*}\n\t */\n\tcallback: function(fn, args, thisArg) {\n\t\tif (fn && typeof fn.call === 'function') {\n\t\t\treturn fn.apply(thisArg, args);\n\t\t}\n\t},\n\n\t/**\n\t * Note(SB) for performance sake, this method should only be used when loopable type\n\t * is unknown or in none intensive code (not called often and small loopable). Else\n\t * it's preferable to use a regular for() loop and save extra function calls.\n\t * @param {Object|Array} loopable - The object or array to be iterated.\n\t * @param {Function} fn - The function to call for each item.\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @param {Boolean} [reverse] - If true, iterates backward on the loopable.\n\t */\n\teach: function(loopable, fn, thisArg, reverse) {\n\t\tvar i, len, keys;\n\t\tif (helpers.isArray(loopable)) {\n\t\t\tlen = loopable.length;\n\t\t\tif (reverse) {\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (helpers.isObject(loopable)) {\n\t\t\tkeys = Object.keys(loopable);\n\t\t\tlen = keys.length;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n\t * @see http://stackoverflow.com/a/14853974\n\t * @param {Array} a0 - The array to compare\n\t * @param {Array} a1 - The array to compare\n\t * @returns {Boolean}\n\t */\n\tarrayEquals: function(a0, a1) {\n\t\tvar i, ilen, v0, v1;\n\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\t\tv0 = a0[i];\n\t\t\tv1 = a1[i];\n\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (v0 !== v1) {\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\n\t * @param {*} source - The value to clone.\n\t * @returns {*}\n\t */\n\tclone: function(source) {\n\t\tif (helpers.isArray(source)) {\n\t\t\treturn source.map(helpers.clone);\n\t\t}\n\n\t\tif (helpers.isObject(source)) {\n\t\t\tvar target = {};\n\t\t\tvar keys = Object.keys(source);\n\t\t\tvar klen = keys.length;\n\t\t\tvar k = 0;\n\n\t\t\tfor (; k < klen; ++k) {\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\treturn source;\n\t},\n\n\t/**\n\t * The default merger when Chart.helpers.merge is called without merger option.\n\t * Note(SB): this method is also used by configMerge and scaleMerge as fallback.\n\t * @private\n\t */\n\t_merger: function(key, target, source, options) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.merge(tval, sval, options);\n\t\t} else {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Merges source[key] in target[key] only if target[key] is undefined.\n\t * @private\n\t */\n\t_mergerIf: function(key, target, source) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.mergeIf(tval, sval);\n\t\t} else if (!target.hasOwnProperty(key)) {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {Object} target - The target object in which all sources are merged into.\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\n\t * @param {Object} [options] - Merging options:\n\t * @param {Function} [options.merger] - The merge method (key, target, source, options)\n\t * @returns {Object} The `target` object.\n\t */\n\tmerge: function(target, source, options) {\n\t\tvar sources = helpers.isArray(source) ? source : [source];\n\t\tvar ilen = sources.length;\n\t\tvar merge, i, keys, klen, k;\n\n\t\tif (!helpers.isObject(target)) {\n\t\t\treturn target;\n\t\t}\n\n\t\toptions = options || {};\n\t\tmerge = options.merger || helpers._merger;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!helpers.isObject(source)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkeys = Object.keys(source);\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\t\tmerge(keys[k], target, source, options);\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {Object} target - The target object in which all sources are merged into.\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\n\t * @returns {Object} The `target` object.\n\t */\n\tmergeIf: function(target, source) {\n\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\n\t},\n\n\t/**\n\t * Applies the contents of two or more objects together into the first object.\n\t * @param {Object} target - The target object in which all objects are merged into.\n\t * @param {Object} arg1 - Object containing additional properties to merge in target.\n\t * @param {Object} argN - Additional objects containing properties to merge in target.\n\t * @returns {Object} The `target` object.\n\t */\n\textend: function(target) {\n\t\tvar setFn = function(value, key) {\n\t\t\ttarget[key] = value;\n\t\t};\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; ++i) {\n\t\t\thelpers.each(arguments[i], setFn);\n\t\t}\n\t\treturn target;\n\t},\n\n\t/**\n\t * Basic javascript inheritance based on the model created in Backbone.js\n\t */\n\tinherits: function(extensions) {\n\t\tvar me = this;\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\treturn me.apply(this, arguments);\n\t\t};\n\n\t\tvar Surrogate = function() {\n\t\t\tthis.constructor = ChartElement;\n\t\t};\n\n\t\tSurrogate.prototype = me.prototype;\n\t\tChartElement.prototype = new Surrogate();\n\t\tChartElement.extend = helpers.inherits;\n\n\t\tif (extensions) {\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t}\n\n\t\tChartElement.__super__ = me.prototype;\n\t\treturn ChartElement;\n\t}\n};\n\nmodule.exports = helpers;\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.callback instead.\n * @function Chart.helpers.callCallback\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nhelpers.callCallback = helpers.callback;\n\n/**\n * Provided for backward compatibility, use Array.prototype.indexOf instead.\n * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\n * @function Chart.helpers.indexOf\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.indexOf = function(array, item, fromIndex) {\n\treturn Array.prototype.indexOf.call(array, item, fromIndex);\n};\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\n * @function Chart.helpers.getValueOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueOrDefault = helpers.valueOrDefault;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\n * @function Chart.helpers.getValueAtIndexOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/helpers/helpers.core.js\n// module id = 1251\n// module chunks = 6","import instance from './instance';\r\n\r\nfunction getGeneralAdministratorApi() {\r\n  return instance.get('System?action=getConfiguration');\r\n}\r\n\r\nfunction saveGeneralAdministratorApi(data) {\r\n  return instance.post('System?action=save', data);\r\n}\r\n\r\nexport {\r\n  getGeneralAdministratorApi,\r\n  saveGeneralAdministratorApi,\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/api/generalAdministrator.js","import {\r\n  GET_TECHNICAL_TEAM_SURVEY_PROGRESS,\r\n  GET_TECHNICAL_TEAM_SURVEY_SUCCESS,\r\n  FILTER_TECHNICAL_TEAM_SURVEY,\r\n  CALCULATE_TOTAL,\r\n  CHANGE_SCORE_TECHNICAL,\r\n  CHANGE_COMMENT_TECHNICAL,\r\n  UPDATE_ERRORS_TECHNICAL,\r\n  UPDATE_SUPPLIERS_TECHNICAL,\r\n  REQUEST_FAILED,\r\n} from './const';\r\n\r\nimport { getTechnicalTeamSurveyApi } from '../../api/call';\r\nimport { saveTechnicalTeamAnswerApi, saveTechnicalTeamCommentApi } from '../../api/technicalTeamAnswer';\r\nimport { finishTechnicalTeamSurveyApi } from '../../api/supplier';\r\nimport { requestApi, sortByField } from '../../utils/action';\r\nimport setMessage from '../Generic/action';\r\n\r\nconst getDataTechnicalTeamSurveyProgress = () => ({\r\n  type: GET_TECHNICAL_TEAM_SURVEY_PROGRESS,\r\n});\r\n\r\nconst getDataTechnicalTeamSurveySuccess = data => ({\r\n  type: GET_TECHNICAL_TEAM_SURVEY_SUCCESS,\r\n  data,\r\n});\r\n\r\nconst getFailedRequest = () => ({\r\n  type: REQUEST_FAILED,\r\n});\r\n\r\nconst filterTechnicalTeamSurvey = data => ({\r\n  type: FILTER_TECHNICAL_TEAM_SURVEY,\r\n  data,\r\n});\r\n\r\nconst calculateTotal = () => ({\r\n  type: CALCULATE_TOTAL,\r\n});\r\n\r\nconst changeScore = (idSupplier, id, answer, value) => ({\r\n  type: CHANGE_SCORE_TECHNICAL,\r\n  idSupplier,\r\n  answer,\r\n  value,\r\n  new: !id,\r\n});\r\n\r\nconst changeComment = (idSupplier, id, comment, value) => ({\r\n  type: CHANGE_COMMENT_TECHNICAL,\r\n  idSupplier,\r\n  comment,\r\n  value,\r\n  new: !id,\r\n});\r\n\r\nconst updateErrors = data => ({\r\n  type: UPDATE_ERRORS_TECHNICAL,\r\n  data,\r\n});\r\n\r\nconst updateSuppliers = (idSuppliers, idSuppliersByCall) => ({\r\n  type: UPDATE_SUPPLIERS_TECHNICAL,\r\n  idSuppliers,\r\n  idSuppliersByCall,\r\n});\r\n\r\nconst setScore = (idSupplier, value, answer) => (dispatch) => {\r\n  requestApi(dispatch, getDataTechnicalTeamSurveyProgress, saveTechnicalTeamAnswerApi, answer)\r\n    .then((response) => {\r\n      dispatch(changeScore(idSupplier, answer.id, response.data.data, value));\r\n      dispatch(calculateTotal());\r\n    }).catch(() => {\r\n      dispatch(changeScore(idSupplier, answer.id, answer, null));\r\n      dispatch(getFailedRequest());\r\n    });\r\n};\r\n\r\nconst setComment = (idSupplier, value, comment) => (dispatch, getState) => {\r\n  const storedValue = getState().technicalTeamSurvey.data.suppliers.find(\r\n    element => element.id === idSupplier).comments.find(\r\n    element => element.idService === comment.idService).value;\r\n  if (storedValue !== value) {\r\n    requestApi(dispatch, getDataTechnicalTeamSurveyProgress, saveTechnicalTeamCommentApi, comment)\r\n      .then((response) => {\r\n        dispatch(changeComment(idSupplier, comment.id, response.data.data, value));\r\n      }).catch(() => {\r\n        dispatch(changeComment(idSupplier, comment.id, comment, null));\r\n        dispatch(getFailedRequest());\r\n      });\r\n  }\r\n};\r\n\r\nconst getTechnicalTeamSurvey = (year = '', supplierId = '') => (dispatch) => {\r\n  requestApi(dispatch, getDataTechnicalTeamSurveyProgress, getTechnicalTeamSurveyApi, year)\r\n    .then((response) => {\r\n      const { data } = response.data;\r\n      data.suppliers = data.suppliers.map((supplier) => {\r\n        const supplierByCall = data.suppliersByCall.find(\r\n          element => element.idSupplier === supplier.id);\r\n\r\n        const idSupplierByCall = supplierByCall.id;\r\n        const idState = supplierByCall.idState;\r\n\r\n        const items = data.masters.Item.map((item) => {\r\n          const answer = data.masters.TechnicalTeamAnswer\r\n            .find(element =>\r\n              element.idItem === item.id && element.idSupplierByCall === idSupplierByCall);\r\n          const option = answer ?\r\n            data.masters.EvaluationScale\r\n              .find(element => element.id === answer.idEvaluationScale) : null;\r\n          return {\r\n            id: item.id,\r\n            idService: item.idService,\r\n            defaultValue: {\r\n              key: option ? option.id : null,\r\n              name: option ? option.name : null,\r\n            },\r\n            value: option ? option.score : null,\r\n            error: false,\r\n          };\r\n        });\r\n\r\n        const comments = [];\r\n        const totals = [];\r\n        data.masters.Service.forEach((service) => {\r\n          const comment = data.masters.TechnicalTeamComment.find(element =>\r\n            element.idSupplierByCall === idSupplierByCall && element.idService === service.id);\r\n          comments.push({\r\n            idService: service.id,\r\n            value: comment ? comment.comment : '',\r\n          });\r\n          totals.push({\r\n            idService: service.id,\r\n            value: null,\r\n          });\r\n        });\r\n\r\n        const state = data.masters.State.find(element => element.id === idState).shortName;\r\n        const readOnly =\r\n          (state !== 'NOT_STARTED_TECHNICAL_TEAM' && state !== 'TECHNICAL_TEAM') ||\r\n          (supplierByCall.whoEvaluateOfTechnicalTeam !== '' &&\r\n          supplierByCall.whoEvaluateOfTechnicalTeam !== data.masters.User[0].name);\r\n\r\n        const required = !readOnly &&\r\n          supplierByCall.whoEvaluateOfTechnicalTeam === data.masters.User[0].name;\r\n\r\n        supplier.visible = true;\r\n        supplier.readOnly = readOnly;\r\n        supplier.required = required;\r\n        supplier.items = items;\r\n        supplier.comments = comments;\r\n        supplier.totals = totals;\r\n        supplier.total = null;\r\n        return supplier;\r\n      });\r\n      data.masters.Service.push({\r\n        id: 'total',\r\n        name: 'Resumen total',\r\n      });\r\n      data.masters.Service.forEach((service, index) => {\r\n        if (service.id !== 'total') {\r\n          data.masters.Item = data.masters.Item.concat([\r\n            {\r\n              idService: service.id,\r\n              id: `comment${index.toString()}`,\r\n              type: 'comment',\r\n              name: 'Comentarios',\r\n            },\r\n            {\r\n              idService: service.id,\r\n              id: `subtotal${index.toString()}`,\r\n              idServiceForTotal: service.id,\r\n              type: 'subtotal',\r\n              name: 'Total',\r\n            },\r\n          ]);\r\n        }\r\n        data.masters.Item.push({\r\n          idService: 'total',\r\n          id: `total${index.toString()}`,\r\n          idServiceForTotal: service.id,\r\n          type: index < data.masters.Service.length - 1 ? 'subtotal' : 'total',\r\n          name: index < data.masters.Service.length - 1 ? service.name : 'Total general',\r\n        });\r\n      });\r\n      data.masters.EvaluationScale = sortByField(data.masters.EvaluationScale, 'score');\r\n      data.supplierId = supplierId;\r\n      dispatch(getDataTechnicalTeamSurveySuccess(data));\r\n      dispatch(calculateTotal());\r\n    }).catch(() => {\r\n      dispatch(getFailedRequest());\r\n    });\r\n};\r\n\r\nconst finishTechnicalTeamSurvey = () => (dispatch, getState) => {\r\n  const { suppliers, suppliersByCall } = getState().technicalTeamSurvey.data;\r\n  const idSuppliersByCall = [];\r\n  const idSuppliers = [];\r\n  const updatedErrors = suppliers.map((supplier) => {\r\n    const updatedError = {\r\n      ...supplier,\r\n      items: supplier.items.map(item => ({\r\n        ...item,\r\n        error: supplier.visible && supplier.required && !item.value,\r\n      })),\r\n    };\r\n    if (supplier.visible && !supplier.readOnly) {\r\n      if (supplier.items.filter(item => item.value).length === supplier.items.length) {\r\n        idSuppliersByCall.push(\r\n          suppliersByCall.find(element => element.idSupplier === supplier.id).id);\r\n        idSuppliers.push(supplier.id);\r\n      }\r\n    }\r\n    return updatedError;\r\n  });\r\n\r\n  if (suppliers.filter(element => element.required).length === idSuppliersByCall.length) {\r\n    requestApi(dispatch, getDataTechnicalTeamSurveyProgress, finishTechnicalTeamSurveyApi,\r\n      { idSuppliersByCall })\r\n      .then(() => {\r\n        dispatch(updateErrors(updatedErrors));\r\n        dispatch(updateSuppliers(idSuppliers, idSuppliersByCall));\r\n      }).catch(() => {\r\n        dispatch(getFailedRequest());\r\n      });\r\n  } else {\r\n    dispatch(updateErrors(updatedErrors));\r\n    setMessage('Algunos proveedores no han sido calificados completamente', 'error');\r\n  }\r\n};\r\n\r\nexport {\r\n  getTechnicalTeamSurvey,\r\n  getFailedRequest,\r\n  filterTechnicalTeamSurvey,\r\n  setScore,\r\n  setComment,\r\n  finishTechnicalTeamSurvey,\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/state/TechnicalTeamSurvey/action.js","import intance from './instance';\r\n\r\nconst saveTechnicalTeamAnswerApi = data => intance.post('TechnicalTeamAnswer?action=save', data);\r\n\r\nconst saveTechnicalTeamCommentApi = data => intance.post('TechnicalTeamComment?action=save', data);\r\n\r\nexport {\r\n  saveTechnicalTeamAnswerApi,\r\n  saveTechnicalTeamCommentApi,\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/api/technicalTeamAnswer.js","import {\r\n  GET_DATA_PENDINGS_PROGRESS,\r\n  GET_DATA_PENDINGS_SUCCESS,\r\n  FILTER_PENDINGS,\r\n  REQUEST_FAILED,\r\n} from './const';\r\n\r\nimport { getPendingsApi } from '../../api/supplier';\r\nimport { requestApi, sortByField } from '../../utils/action';\r\n\r\nconst getDataPendingsProgress = () => ({\r\n  type: GET_DATA_PENDINGS_PROGRESS,\r\n});\r\n\r\nconst getDataPendingsSuccess = data => ({\r\n  type: GET_DATA_PENDINGS_SUCCESS,\r\n  data,\r\n});\r\n\r\nconst getFailedRequest = () => ({\r\n  type: REQUEST_FAILED,\r\n});\r\n\r\nconst filterPendings = data => ({\r\n  type: FILTER_PENDINGS,\r\n  data,\r\n});\r\n\r\nconst getPendings = year => (dispatch) => {\r\n  requestApi(dispatch, getDataPendingsProgress, getPendingsApi, year)\r\n    .then((response) => {\r\n      const { data } = response.data;\r\n      data.suppliers = sortByField(data.suppliers, 'name').map((item) => {\r\n        item.visible = true;\r\n        return item;\r\n      });\r\n      dispatch(getDataPendingsSuccess(data));\r\n    }).catch(() => {\r\n      dispatch(getFailedRequest());\r\n    });\r\n};\r\n\r\nexport {\r\n  getPendings,\r\n  getFailedRequest,\r\n  filterPendings,\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/state/Pendings/action.js","import {\r\n  GET_DATA_GENERAL_PROGRESS,\r\n  GET_DATA_GENERAL_SUCCESS,\r\n  GET_DATA_STATISTICAL_PROGRESS,\r\n  GET_DATA_STATISTICAL_SUCCESS,\r\n  GET_DATA_CURRENT_PROGRESS,\r\n  GET_DATA_CURRENT_SUCCESS,\r\n  REQUEST_FAILED,\r\n} from './const';\r\n\r\nimport { getGeneralAdministratorApi } from '../../api/generalAdministrator';\r\nimport { getStatisticalProgressApi, identifyCurrentStageApi } from '../../api/call';\r\nimport { requestApi } from '../../utils/action';\r\nimport { getUserContext } from '../Main/action';\r\n\r\nconst getDataGeneralAdministratorProgress = () => ({\r\n  type: GET_DATA_GENERAL_PROGRESS,\r\n});\r\n\r\nconst getDataStatisticalProgress = () => ({\r\n  type: GET_DATA_STATISTICAL_PROGRESS,\r\n});\r\n\r\nconst getDataCurrentProgress = () => ({\r\n  type: GET_DATA_CURRENT_PROGRESS,\r\n});\r\n\r\nconst getDataGeneralAdministratorSuccess = data => ({\r\n  type: GET_DATA_GENERAL_SUCCESS,\r\n  data,\r\n});\r\n\r\nconst getDataCurrentSuccess = dataCurrent => ({\r\n  type: GET_DATA_CURRENT_SUCCESS,\r\n  dataCurrent,\r\n});\r\n\r\nconst getDataStatisticalSuccess = statisticalData => ({\r\n  type: GET_DATA_STATISTICAL_SUCCESS,\r\n  statisticalData,\r\n});\r\n\r\nconst getFailedRequest = () => ({\r\n  type: REQUEST_FAILED,\r\n});\r\n\r\nconst getAllGeneralData = () => (dispatch) => {\r\n  requestApi(dispatch, getDataGeneralAdministratorProgress, getGeneralAdministratorApi)\r\n    .then((response) => {\r\n      const { data } = response.data;\r\n      dispatch(getDataGeneralAdministratorSuccess(data));\r\n    }).catch(() => {\r\n      dispatch(getFailedRequest());\r\n    });\r\n};\r\n\r\nconst getStatisticalData = (filter = null) => (dispatch) => {\r\n  requestApi(dispatch, getDataStatisticalProgress, getStatisticalProgressApi, filter)\r\n    .then((response) => {\r\n      const { data } = response.data;\r\n      const objectStatisticData = data ? data.axesStatisticData : {};\r\n      Object.entries(objectStatisticData).forEach((item) => {\r\n        data.axesStatisticData[item[0]] = parseFloat(item[1]).toFixed(2);\r\n      });\r\n      dispatch(getDataStatisticalSuccess(data));\r\n    }).catch(() => {\r\n      dispatch(getFailedRequest());\r\n    });\r\n};\r\n\r\nconst getCurrentData = () => (dispatch) => {\r\n  requestApi(dispatch, getDataCurrentProgress, identifyCurrentStageApi)\r\n    .then((response) => {\r\n      const { data } = response.data;\r\n      dispatch(getDataCurrentSuccess(data));\r\n    }).catch(() => {\r\n      dispatch(getFailedRequest());\r\n    });\r\n};\r\n\r\nexport {\r\n  getAllGeneralData,\r\n  getFailedRequest,\r\n  getStatisticalData,\r\n  getCurrentData,\r\n  getUserContext,\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/state/Home/action.js","/* MIT license */\nvar convert = require('color-convert');\nvar string = require('chartjs-color-string');\n\nvar Color = function (obj) {\n\tif (obj instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0, 0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk: [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif (typeof obj === 'string') {\n\t\tvals = string.getRgba(obj);\n\t\tif (vals) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = string.getHsla(obj)) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = string.getHwb(obj)) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv', vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk', vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl: function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk', arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray: function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha: function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha', val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb', 0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1, val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue: function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360 + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation: function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness: function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv: function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness: function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness: function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val) {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val) {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val) {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val) {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function () {\n\t\treturn string.hexString(this.values.rgb);\n\t},\n\trgbString: function () {\n\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString: function () {\n\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString: function () {\n\t\treturn string.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString: function () {\n\t\treturn string.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString: function () {\n\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString: function () {\n\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword: function () {\n\t\treturn string.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb', rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1] += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb', [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2 = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except 'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source) {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv: ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb: [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360, 100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0; i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255, b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space, vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10, 10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red: 10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !== space) {\n\t\t\tvalues[sname] = convert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals = args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t// color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space, vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index, val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t// color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index]) {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index] = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nmodule.exports = Color;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chartjs-color/index.js\n// module id = 1266\n// module chunks = 6","'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Helper function to get relative position for an event\n * @param {Event|IEvent} event - The event to get the position for\n * @param {Chart} chart - The chart\n * @returns {Point} the event position\n */\nfunction getRelativePosition(e, chart) {\n\tif (e.native) {\n\t\treturn {\n\t\t\tx: e.x,\n\t\t\ty: e.y\n\t\t};\n\t}\n\n\treturn helpers.getRelativePosition(e, chart);\n}\n\n/**\n * Helper function to traverse all of the visible elements in the chart\n * @param chart {chart} the chart\n * @param handler {Function} the callback to execute for each visible item\n */\nfunction parseVisibleItems(chart, handler) {\n\tvar datasets = chart.data.datasets;\n\tvar meta, i, j, ilen, jlen;\n\n\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmeta = chart.getDatasetMeta(i);\n\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\tvar element = meta.data[j];\n\t\t\tif (!element._view.skip) {\n\t\t\t\thandler(element);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param items {ChartElement[]} elements to filter\n * @param position {Point} the point to be nearest to\n * @return {ChartElement[]} the nearest items\n */\nfunction getIntersectItems(chart, position) {\n\tvar elements = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (element.inRange(position.x, position.y)) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\n * @param chart {Chart} the chart to look at elements from\n * @param position {Point} the point to be nearest to\n * @param intersect {Boolean} if true, only consider items that intersect the position\n * @param distanceMetric {Function} function to provide the distance between points\n * @return {ChartElement[]} the nearest items\n */\nfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\tvar minDistance = Number.POSITIVE_INFINITY;\n\tvar nearestItems = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar center = element.getCenterPoint();\n\t\tvar distance = distanceMetric(position, center);\n\n\t\tif (distance < minDistance) {\n\t\t\tnearestItems = [element];\n\t\t\tminDistance = distance;\n\t\t} else if (distance === minDistance) {\n\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\tnearestItems.push(element);\n\t\t}\n\t});\n\n\treturn nearestItems;\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {String} axis the axis mode. x|y|xy\n */\nfunction getDistanceMetricForAxis(axis) {\n\tvar useX = axis.indexOf('x') !== -1;\n\tvar useY = axis.indexOf('y') !== -1;\n\n\treturn function(pt1, pt2) {\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\tvar deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t};\n}\n\nfunction indexMode(chart, e, options) {\n\tvar position = getRelativePosition(e, chart);\n\t// Default axis for index mode is 'x' to match old behaviour\n\toptions.axis = options.axis || 'x';\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\tvar elements = [];\n\n\tif (!items.length) {\n\t\treturn [];\n\t}\n\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\tvar element = meta.data[items[0]._index];\n\n\t\t\t// don't count items that are skipped (null data)\n\t\t\tif (element && !element._view.skip) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * @interface IInteractionOptions\n */\n/**\n * If true, only consider items that intersect the point\n * @name IInterfaceOptions#boolean\n * @type Boolean\n */\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nmodule.exports = {\n\t// Helper function for different modes\n\tmodes: {\n\t\tsingle: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar elements = [];\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn elements.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.label\n\t\t * @deprecated since version 2.4.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\tlabel: indexMode,\n\n\t\t/**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tindex: indexMode,\n\n\t\t/**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tdataset: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n\t\t\tif (items.length > 0) {\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t}\n\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.x-axis\n\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\t'x-axis': function(chart, e) {\n\t\t\treturn indexMode(chart, e, {intersect: false});\n\t\t},\n\n\t\t/**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tpoint: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\treturn getIntersectItems(chart, position);\n\t\t},\n\n\t\t/**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tnearest: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);\n\n\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\tif (nearestItems.length > 1) {\n\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Return only 1 item\n\t\t\treturn nearestItems.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tx: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param chart {chart} the chart we are returning items from\n\t\t * @param e {Event} the event we are find things at\n\t\t * @param options {IInteractionOptions} options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\ty: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.interaction.js\n// module id = 1267\n// module chunks = 6","'use strict';\n\nvar helpers = require('../helpers/index');\nvar basic = require('./platform.basic');\nvar dom = require('./platform.dom');\n\n// @TODO Make possible to select another platform at build time.\nvar implementation = dom._enabled ? dom : basic;\n\n/**\n * @namespace Chart.platform\n * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n * @since 2.4.0\n */\nmodule.exports = helpers.extend({\n\t/**\n\t * @since 2.7.0\n\t */\n\tinitialize: function() {},\n\n\t/**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t * @param {Object} options - The chart options\n\t * @returns {CanvasRenderingContext2D} context2d instance\n\t */\n\tacquireContext: function() {},\n\n\t/**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {Boolean} true if the method succeeded, else false\n\t */\n\treleaseContext: function() {},\n\n\t/**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {String} type - The ({@link IEvent}) type to listen for\n\t * @param {Function} listener - Receives a notification (an object that implements\n\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t */\n\taddEventListener: function() {},\n\n\t/**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart -Chart from which to remove the listener\n\t * @param {String} type - The ({@link IEvent}) type to remove\n\t * @param {Function} listener - The listener function to remove from the event target.\n\t */\n\tremoveEventListener: function() {}\n\n}, implementation);\n\n/**\n * @interface IPlatform\n * Allows abstracting platform dependencies away from the chart\n * @borrows Chart.platform.acquireContext as acquireContext\n * @borrows Chart.platform.releaseContext as releaseContext\n * @borrows Chart.platform.addEventListener as addEventListener\n * @borrows Chart.platform.removeEventListener as removeEventListener\n */\n\n/**\n * @interface IEvent\n * @prop {String} type - The event type name, possible values are:\n * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/platforms/platform.js\n// module id = 1268\n// module chunks = 6","'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tplugins: {}\n});\n\n/**\n * The plugin service singleton\n * @namespace Chart.plugins\n * @since 2.1.0\n */\nmodule.exports = {\n\t/**\n\t * Globally registered plugins.\n\t * @private\n\t */\n\t_plugins: [],\n\n\t/**\n\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t * incremented and descriptors are regenerated during following API calls.\n\t * @private\n\t */\n\t_cacheId: 0,\n\n\t/**\n\t * Registers the given plugin(s) if not already registered.\n\t * @param {Array|Object} plugins plugin instance(s).\n\t */\n\tregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\tp.push(plugin);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Unregisters the given plugin(s) only if registered.\n\t * @param {Array|Object} plugins plugin instance(s).\n\t */\n\tunregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tvar idx = p.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\tp.splice(idx, 1);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Remove all registered plugins.\n\t * @since 2.1.5\n\t */\n\tclear: function() {\n\t\tthis._plugins = [];\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Returns the number of registered plugins?\n\t * @returns {Number}\n\t * @since 2.1.5\n\t */\n\tcount: function() {\n\t\treturn this._plugins.length;\n\t},\n\n\t/**\n\t * Returns all registered plugin instances.\n\t * @returns {Array} array of plugin objects.\n\t * @since 2.1.5\n\t */\n\tgetAll: function() {\n\t\treturn this._plugins;\n\t},\n\n\t/**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Object} chart - The chart instance for which plugins should be called.\n\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t * @returns {Boolean} false if any of the plugins return false, else returns true.\n\t */\n\tnotify: function(chart, hook, args) {\n\t\tvar descriptors = this.descriptors(chart);\n\t\tvar ilen = descriptors.length;\n\t\tvar i, descriptor, plugin, params, method;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tdescriptor = descriptors[i];\n\t\t\tplugin = descriptor.plugin;\n\t\t\tmethod = plugin[hook];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\tparams.push(descriptor.options);\n\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns descriptors of enabled plugins for the given chart.\n\t * @returns {Array} [{ plugin, options }]\n\t * @private\n\t */\n\tdescriptors: function(chart) {\n\t\tvar cache = chart.$plugins || (chart.$plugins = {});\n\t\tif (cache.id === this._cacheId) {\n\t\t\treturn cache.descriptors;\n\t\t}\n\n\t\tvar plugins = [];\n\t\tvar descriptors = [];\n\t\tvar config = (chart && chart.config) || {};\n\t\tvar options = (config.options && config.options.plugins) || {};\n\n\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar id = plugin.id;\n\t\t\tvar opts = options[id];\n\t\t\tif (opts === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (opts === true) {\n\t\t\t\topts = helpers.clone(defaults.global.plugins[id]);\n\t\t\t}\n\n\t\t\tplugins.push(plugin);\n\t\t\tdescriptors.push({\n\t\t\t\tplugin: plugin,\n\t\t\t\toptions: opts || {}\n\t\t\t});\n\t\t});\n\n\t\tcache.descriptors = descriptors;\n\t\tcache.id = this._cacheId;\n\t\treturn descriptors;\n\t},\n\n\t/**\n\t * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\n\t * but in some cases, this reference can be changed by the user when updating options.\n\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t * @private\n\t */\n\t_invalidate: function(chart) {\n\t\tdelete chart.$plugins;\n\t}\n};\n\n/**\n * Plugin extension hooks.\n * @interface IPlugin\n * @since 2.1.0\n */\n/**\n * @method IPlugin#beforeInit\n * @desc Called before initializing `chart`.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#afterInit\n * @desc Called after `chart` has been initialized and before the first update.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeUpdate\n * @desc Called before updating `chart`. If any plugin returns `false`, the update\n * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart update.\n */\n/**\n * @method IPlugin#afterUpdate\n * @desc Called after `chart` has been updated and before rendering. Note that this\n * hook will not be called if the chart update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetsUpdate\n * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n * the datasets update is cancelled until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} false to cancel the datasets update.\n * @since version 2.1.5\n*/\n/**\n * @method IPlugin#afterDatasetsUpdate\n * @desc Called after the `chart` datasets have been updated. Note that this hook\n * will not be called if the datasets update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @since version 2.1.5\n */\n/**\n * @method IPlugin#beforeDatasetUpdate\n * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin\n * returns `false`, the datasets update is cancelled until another `update` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetUpdate\n * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note\n * that this hook will not be called if the datasets update has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeLayout\n * @desc Called before laying out `chart`. If any plugin returns `false`,\n * the layout update is cancelled until another `update` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart layout.\n */\n/**\n * @method IPlugin#afterLayout\n * @desc Called after the `chart` has been layed out. Note that this hook will not\n * be called if the layout update has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeRender\n * @desc Called before rendering `chart`. If any plugin returns `false`,\n * the rendering is cancelled until another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart rendering.\n */\n/**\n * @method IPlugin#afterRender\n * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n * that this hook will not be called if the rendering has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDraw\n * @desc Called before drawing `chart` at every animation frame specified by the given\n * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n * another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart drawing.\n */\n/**\n * @method IPlugin#afterDraw\n * @desc Called after the `chart` has been drawn for the specific easing value. Note\n * that this hook will not be called if the drawing has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetsDraw\n * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n * the datasets drawing is cancelled until another `render` is triggered.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetsDraw\n * @desc Called after the `chart` datasets have been drawn. Note that this hook\n * will not be called if the datasets drawing has been previously cancelled.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeDatasetDraw\n * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets\n * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing\n * is cancelled until another `render` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart datasets drawing.\n */\n/**\n * @method IPlugin#afterDatasetDraw\n * @desc Called after the `chart` datasets at the given `args.index` have been drawn\n * (datasets are drawn in the reverse order). Note that this hook will not be called\n * if the datasets drawing has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Number} args.index - The dataset index.\n * @param {Object} args.meta - The dataset metadata.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeTooltipDraw\n * @desc Called before drawing the `tooltip`. If any plugin returns `false`,\n * the tooltip drawing is cancelled until another `render` is triggered.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Object} args.tooltip - The tooltip.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n * @returns {Boolean} `false` to cancel the chart tooltip drawing.\n */\n/**\n * @method IPlugin#afterTooltipDraw\n * @desc Called after drawing the `tooltip`. Note that this hook will not\n * be called if the tooltip drawing has been previously cancelled.\n * @param {Chart} chart - The chart instance.\n * @param {Object} args - The call arguments.\n * @param {Object} args.tooltip - The tooltip.\n * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#beforeEvent\n * @desc Called before processing the specified `event`. If any plugin returns `false`,\n * the event will be discarded.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {IEvent} event - The event object.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#afterEvent\n * @desc Called after the `event` has been consumed. Note that this hook\n * will not be called if the `event` has been previously discarded.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {IEvent} event - The event object.\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#resize\n * @desc Called after the chart as been resized.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\n * @param {Object} options - The plugin options.\n */\n/**\n * @method IPlugin#destroy\n * @desc Called after the chart as been destroyed.\n * @param {Chart.Controller} chart - The chart instance.\n * @param {Object} options - The plugin options.\n */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.plugins.js\n// module id = 1269\n// module chunks = 6","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _classnames = require(\"classnames\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    CAROUSEL: function CAROUSEL(isSlider) {\n        return (0, _classnames2.default)({\n            \"carousel\": true,\n            \"carousel-slider\": isSlider\n        });\n    },\n\n    WRAPPER: function WRAPPER(isSlider, axis) {\n        return (0, _classnames2.default)({\n            \"thumbs-wrapper\": !isSlider,\n            \"slider-wrapper\": isSlider,\n            \"axis-horizontal\": axis === \"horizontal\",\n            \"axis-vertical\": axis !== \"horizontal\"\n        });\n    },\n\n    SLIDER: function SLIDER(isSlider, isSwiping) {\n        return (0, _classnames2.default)({\n            \"thumbs\": !isSlider,\n            \"slider\": isSlider,\n            \"animated\": !isSwiping\n        });\n    },\n\n    ITEM: function ITEM(isSlider, selected) {\n        return (0, _classnames2.default)({\n            \"thumb\": !isSlider,\n            \"slide\": isSlider,\n            \"selected\": selected\n        });\n    },\n\n    ARROW_PREV: function ARROW_PREV(disabled) {\n        return (0, _classnames2.default)({\n            \"control-arrow control-prev\": true,\n            \"control-disabled\": disabled\n        });\n    },\n\n    ARROW_NEXT: function ARROW_NEXT(disabled) {\n        return (0, _classnames2.default)({\n            \"control-arrow control-next\": true,\n            \"control-disabled\": disabled\n        });\n    },\n\n    DOT: function DOT(selected) {\n        return (0, _classnames2.default)({\n            \"dot\": true,\n            'selected': selected\n        });\n    }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-responsive-carousel/lib/cssClasses.js\n// module id = 1270\n// module chunks = 6","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (position, axis) {\n    var positionCss = axis === 'horizontal' ? [position, 0, 0] : [0, position, 0];\n    var transitionProp = 'translate3d';\n\n    var translatedPosition = '(' + positionCss.join(',') + ')';\n\n    return transitionProp + translatedPosition;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-responsive-carousel/lib/CSSTranslate.js\n// module id = 1271\n// module chunks = 6","(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports', './react-swipe'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('./react-swipe'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.reactSwipe);\n    global.index = mod.exports;\n  }\n})(this, function (exports, _reactSwipe) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _reactSwipe2 = _interopRequireDefault(_reactSwipe);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  exports.default = _reactSwipe2.default;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-easy-swipe/lib/index.js\n// module id = 1272\n// module chunks = 6","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _cssClasses = require('../cssClasses');\n\nvar _cssClasses2 = _interopRequireDefault(_cssClasses);\n\nvar _dimensions = require('../dimensions');\n\nvar _CSSTranslate = require('../CSSTranslate');\n\nvar _CSSTranslate2 = _interopRequireDefault(_CSSTranslate);\n\nvar _reactEasySwipe = require('react-easy-swipe');\n\nvar _reactEasySwipe2 = _interopRequireDefault(_reactEasySwipe);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Thumbs = function (_Component) {\n    _inherits(Thumbs, _Component);\n\n    function Thumbs(props) {\n        _classCallCheck(this, Thumbs);\n\n        var _this = _possibleConstructorReturn(this, (Thumbs.__proto__ || Object.getPrototypeOf(Thumbs)).call(this, props));\n\n        _this.setItemsWrapperRef = function (node) {\n            _this.itemsWrapperRef = node;\n        };\n\n        _this.setItemsListRef = function (node) {\n            _this.itemsListRef = node;\n        };\n\n        _this.setThumbsRef = function (node, index) {\n            if (!_this.thumbsRef) {\n                _this.thumbsRef = [];\n            }\n            _this.thumbsRef[index] = node;\n        };\n\n        _this.updateSizes = function () {\n            if (!_this.props.children || !_this.itemsWrapperRef) {\n                return;\n            }\n\n            var total = _this.props.children.length;\n            var wrapperSize = _this.itemsWrapperRef.clientWidth;\n            var itemSize = _this.props.thumbWidth ? _this.props.thumbWidth : (0, _dimensions.outerWidth)(_this.thumbsRef[0]);\n            var visibleItems = Math.floor(wrapperSize / itemSize);\n            var lastPosition = total - visibleItems;\n            var showArrows = visibleItems < total;\n            _this.setState({\n                itemSize: itemSize,\n                visibleItems: visibleItems,\n                firstItem: showArrows ? _this.getFirstItem(_this.props.selectedItem) : 0,\n                lastPosition: lastPosition,\n                showArrows: showArrows\n            });\n        };\n\n        _this.setMountState = function () {\n            _this.setState({ hasMount: true });\n            _this.updateSizes();\n        };\n\n        _this.handleClickItem = function (index, item) {\n            var handler = _this.props.onSelectItem;\n\n            if (typeof handler === 'function') {\n                handler(index, item);\n            }\n        };\n\n        _this.onSwipeStart = function () {\n            _this.setState({\n                swiping: true\n            });\n        };\n\n        _this.onSwipeEnd = function () {\n            _this.setState({\n                swiping: false\n            });\n        };\n\n        _this.onSwipeMove = function (deltaX) {\n            var leftBoundary = 0;\n\n            var currentPosition = -_this.state.firstItem * _this.state.itemSize;\n            var lastLeftBoundary = -_this.state.visibleItems * _this.state.itemSize;\n\n            // prevent user from swiping left out of boundaries\n            if (currentPosition === leftBoundary && deltaX > 0) {\n                deltaX = 0;\n            }\n\n            // prevent user from swiping right out of boundaries\n            if (currentPosition === lastLeftBoundary && deltaX < 0) {\n                deltaX = 0;\n            }\n\n            var wrapperSize = _this.itemsWrapperRef.clientWidth;\n            var position = currentPosition + 100 / (wrapperSize / deltaX) + '%';\n\n            // if 3d isn't available we will use left to move\n            ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {\n                _this.itemsListRef.style[prop] = (0, _CSSTranslate2.default)(position, _this.props.axis);\n            });\n        };\n\n        _this.slideRight = function (positions) {\n            _this.moveTo(_this.state.firstItem - (typeof positions === 'number' ? positions : 1));\n        };\n\n        _this.slideLeft = function (positions) {\n            _this.moveTo(_this.state.firstItem + (typeof positions === 'number' ? positions : 1));\n        };\n\n        _this.moveTo = function (position) {\n            // position can't be lower than 0\n            position = position < 0 ? 0 : position;\n            // position can't be higher than last postion\n            position = position >= _this.lastPosition ? _this.lastPosition : position;\n\n            _this.setState({\n                firstItem: position,\n                // if it's not a slider, we don't need to set position here\n                selectedItem: _this.state.selectedItem\n            });\n        };\n\n        _this.state = {\n            selectedItem: props.selectedItem,\n            hasMount: false,\n            firstItem: 0,\n            itemSize: null,\n            visibleItems: 0,\n            lastPosition: 0,\n            showArrows: false,\n            images: _this.getImages()\n        };\n        return _this;\n    }\n\n    _createClass(Thumbs, [{\n        key: 'componentDidMount',\n        value: function componentDidMount(nextProps) {\n            this.setupThumbs();\n        }\n    }, {\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(props, state) {\n            if (props.selectedItem !== this.state.selectedItem) {\n                this.setState({\n                    selectedItem: props.selectedItem,\n                    firstItem: this.getFirstItem(props.selectedItem)\n                });\n            }\n            if (props.children !== this.props.children) {\n                this.setState({\n                    images: this.getImages()\n                });\n            }\n        }\n    }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate(prevProps) {\n            if (this.props.children === prevProps.children) {\n                return;\n            }\n\n            // This will capture any size changes for arrow adjustments etc.\n            // usually in the same render cycle so we don't see any flickers\n            this.updateSizes();\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            this.destroyThumbs();\n        }\n    }, {\n        key: 'setupThumbs',\n        value: function setupThumbs() {\n            // as the widths are calculated, we need to resize\n            // the carousel when the window is resized\n            window.addEventListener(\"resize\", this.updateSizes);\n            // issue #2 - image loading smaller\n            window.addEventListener(\"DOMContentLoaded\", this.updateSizes);\n\n            // when the component is rendered we need to calculate\n            // the container size to adjust the responsive behaviour\n            this.updateSizes();\n        }\n    }, {\n        key: 'destroyThumbs',\n        value: function destroyThumbs() {\n            // removing listeners\n            window.removeEventListener(\"resize\", this.updateSizes);\n            window.removeEventListener(\"DOMContentLoaded\", this.updateSizes);\n        }\n    }, {\n        key: 'getImages',\n        value: function getImages() {\n            var images = _react.Children.map(this.props.children, function (item, index) {\n                var img = item;\n\n                // if the item is not an image, try to find the first image in the item's children.\n                if (item.type !== \"img\") {\n                    img = _react.Children.toArray(item.props.children).filter(function (children) {\n                        return children.type === \"img\";\n                    })[0];\n                }\n\n                if (!img || img.length === 0) {\n                    return null;\n                }\n\n                return img;\n            });\n\n            if (images.filter(function (image) {\n                return image !== null;\n            }).length === 0) {\n                console.warn('No images found! Can\\'t build the thumb list without images. If you don\\'t need thumbs, set showThumbs={false} in the Carousel. Note that it\\'s not possible to get images rendered inside custom components. More info at https://github.com/leandrowd/react-responsive-carousel/blob/master/TROUBLESHOOTING.md');\n\n                return null;\n            }\n\n            return images;\n        }\n    }, {\n        key: 'getFirstItem',\n        value: function getFirstItem(selectedItem) {\n            var firstItem = selectedItem;\n\n            if (selectedItem >= this.state.lastPosition) {\n                firstItem = this.state.lastPosition;\n            }\n\n            if (selectedItem < this.state.firstItem + this.state.visibleItems) {\n                firstItem = this.state.firstItem;\n            }\n\n            if (selectedItem < this.state.firstItem) {\n                firstItem = selectedItem;\n            }\n\n            return firstItem;\n        }\n    }, {\n        key: 'renderItems',\n        value: function renderItems() {\n            var _this2 = this;\n\n            return this.state.images.map(function (img, index) {\n                var itemClass = _cssClasses2.default.ITEM(false, index === _this2.state.selectedItem && _this2.state.hasMount);\n\n                var thumbProps = {\n                    key: index,\n                    ref: function ref(e) {\n                        return _this2.setThumbsRef(e, index);\n                    },\n                    className: itemClass,\n                    onClick: _this2.handleClickItem.bind(_this2, index, _this2.props.children[index])\n                };\n\n                if (index === 0) {\n                    img = _react2.default.cloneElement(img, {\n                        onLoad: _this2.setMountState\n                    });\n                }\n\n                return _react2.default.createElement(\n                    'li',\n                    thumbProps,\n                    img\n                );\n            });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            if (!this.props.children) {\n                return null;\n            }\n\n            // show left arrow?\n            var hasPrev = this.state.showArrows && this.state.firstItem > 0;\n            // show right arrow\n            var hasNext = this.state.showArrows && this.state.firstItem < this.state.lastPosition;\n            // obj to hold the transformations and styles\n            var itemListStyles = {};\n\n            var currentPosition = -this.state.firstItem * this.state.itemSize + 'px';\n\n            var transformProp = (0, _CSSTranslate2.default)(currentPosition, this.props.axis);\n\n            var transitionTime = this.props.transitionTime + 'ms';\n\n            itemListStyles = {\n                'WebkitTransform': transformProp,\n                'MozTransform': transformProp,\n                'MsTransform': transformProp,\n                'OTransform': transformProp,\n                'transform': transformProp,\n                'msTransform': transformProp,\n                'WebkitTransitionDuration': transitionTime,\n                'MozTransitionDuration': transitionTime,\n                'MsTransitionDuration': transitionTime,\n                'OTransitionDuration': transitionTime,\n                'transitionDuration': transitionTime,\n                'msTransitionDuration': transitionTime\n            };\n\n            return _react2.default.createElement(\n                'div',\n                { className: _cssClasses2.default.CAROUSEL(false) },\n                _react2.default.createElement(\n                    'div',\n                    { className: _cssClasses2.default.WRAPPER(false), ref: this.setItemsWrapperRef },\n                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_PREV(!hasPrev), onClick: this.slideRight }),\n                    _react2.default.createElement(\n                        _reactEasySwipe2.default,\n                        { tagName: 'ul',\n                            selectedItem: this.state.selectedItem,\n                            className: _cssClasses2.default.SLIDER(false, this.state.swiping),\n                            onSwipeLeft: this.slideLeft,\n                            onSwipeRight: this.slideRight,\n                            onSwipeMove: this.onSwipeMove,\n                            onSwipeStart: this.onSwipeStart,\n                            onSwipeEnd: this.onSwipeEnd,\n                            style: itemListStyles,\n                            ref: this.setItemsListRef },\n                        this.renderItems()\n                    ),\n                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_NEXT(!hasNext), onClick: this.slideLeft })\n                )\n            );\n        }\n    }]);\n\n    return Thumbs;\n}(_react.Component);\n\nThumbs.displayName = 'Thumbs';\nThumbs.propsTypes = {\n    children: _propTypes2.default.element.isRequired,\n    transitionTime: _propTypes2.default.number,\n    selectedItem: _propTypes2.default.number,\n    thumbWidth: _propTypes2.default.number\n};\nThumbs.defaultProps = {\n    selectedItem: 0,\n    transitionTime: 350,\n    axis: 'horizontal'\n};\nexports.default = Thumbs;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-responsive-carousel/lib/components/Thumbs.js\n// module id = 1273\n// module chunks = 6","import React, { Component } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport styled from 'styled-components';\r\nimport { Row, Col, Spin } from 'antd';\r\nimport * as actions from '../../state/Home/action';\r\nimport { Carousel, Doughnut, PendingsManager, PendingsTechnical, PendingsEvaluator, PendingsSupplier } from './';\r\nimport FormattedMessage from '../shared/FormattedMessage';\r\n\r\nconst H3 = styled.h3`\r\n  color: ${props => props.theme.color.primary};\r\n  margin-bottom: ${props => props.theme.spaces.main};\r\n  font-weight: bold;\r\n`;\r\n\r\nconst Linea = styled.div`\r\n  border: 1px solid #37907c7a;\r\n  margin: 20px 0;\r\n`;\r\n\r\nclass HomeContainer extends Component {\r\n  state = {\r\n    value: 1,\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.props.getAllGeneralData();\r\n    this.props.getCurrentData();\r\n  }\r\n\r\n  render() {\r\n    const { loading, dataCurrent, dataUser } = this.props;\r\n    const rol = dataUser.rols\r\n      && dataUser.rols.find(x => x).shortName;\r\n    return (\r\n      <Spin spinning={loading}>\r\n        <Row type=\"flex\" justify=\"center\">\r\n          <Col span={10} offset={2}>\r\n            <H3><FormattedMessage id=\"Title.imageGallery\" /></H3>\r\n            <Carousel {...this.props} />\r\n          </Col>\r\n          {\r\n            rol && rol !== 'SUPPLIER' &&\r\n              (\r\n                <Col span={10} offset={2}>\r\n                  <H3><FormattedMessage id=\"Title.percentageAdvance\" /></H3>\r\n                  <Doughnut {...this.props} />\r\n                </Col>\r\n              )\r\n          }\r\n        </Row>\r\n        {\r\n          rol === dataCurrent &&\r\n              (\r\n                <div>\r\n                  <Linea />\r\n                  <Row>\r\n                    <Col span={24}>\r\n                      <H3><FormattedMessage id=\"Title.pendings\" /></H3>\r\n                      <p><FormattedMessage id=\"Title.informationMessage\" /></p>\r\n                      {\r\n                        dataCurrent === 'MANAGER_TEAM' && <PendingsManager />\r\n                      }\r\n                      {\r\n                        dataCurrent === 'TECHNICAL_TEAM' && <PendingsTechnical />\r\n                      }\r\n                      {\r\n                        dataCurrent === 'EVALUATOR' && <PendingsEvaluator />\r\n                      }\r\n                      {\r\n                        dataCurrent === 'SUPPLIER' && <PendingsSupplier />\r\n                      }\r\n                    </Col>\r\n                  </Row>\r\n                </div>\r\n              )}\r\n      </Spin>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => (\r\n  {\r\n    data: state.home.data,\r\n    loading: state.home.loading,\r\n    dataUser: state.main.data,\r\n    dataCurrent: state.home.dataCurrent,\r\n  }\r\n);\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  actions,\r\n)(HomeContainer);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Home/HomeContainer.js","import React, { Component } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport styled from 'styled-components';\r\nimport ReactChartkick, { PieChart } from 'react-chartkick';\r\nimport Chart from 'chart.js';\r\nimport { Radio } from 'antd';\r\nimport { ADMINISTRATOR, LIBERATOR, READER } from '../../utils/const';\r\nimport * as actions from '../../state/Home/action';\r\nimport FormattedMessage from '../shared/FormattedMessage';\r\n\r\nconst RadioGroup = Radio.Group;\r\nReactChartkick.addAdapter(Chart);\r\n\r\nconst RadioGroupStyle = styled(RadioGroup)`\r\n  margin-bottom: 20px;\r\n  display: flex;\r\n  justify-content: center;\r\n`;\r\n\r\nclass Doughnut extends Component {\r\n  state = {\r\n    value: 'SUPPLY_FILTER',\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.props.getUserContext();\r\n  }\r\n  componentWillReceiveProps(nextProps) {\r\n    if (this.props.dataUser !== nextProps.dataUser) {\r\n      const { dataUser } = this.props;\r\n      if (dataUser.rols\r\n        && dataUser.rols.find(x => x).shortName !== 'SUPPLIER') {\r\n        this.props.getStatisticalData();\r\n      }\r\n    }\r\n  }\r\n\r\n  onChange = (e) => {\r\n    const value = e.target.value;\r\n    this.setState({\r\n      value,\r\n    });\r\n    this.props.getStatisticalData(value);\r\n  }\r\n\r\n  render() {\r\n    const { dataUser, statisticalData } = this.props;\r\n    const { axesStatisticData, totalSupplier } = statisticalData;\r\n    const data = axesStatisticData;\r\n    const options = {\r\n      donut: true,\r\n      data,\r\n      legend: 'bottom',\r\n      suffix: '%',\r\n      colors: ['#8ebfb4', '#fdbb6a', '#99bd73', '#eae57b', '#f00', '#0f0', '00f'],\r\n      messages: { empty: 'No hay datos' },\r\n      library: {\r\n        title: {\r\n          display: true,\r\n          text: [new Date().getFullYear(), `${totalSupplier} proveedores`],\r\n          fontColor: '#37907c',\r\n        },\r\n      },\r\n    };\r\n    if (dataUser.rols\r\n      && dataUser.rols.find(x => x).shortName === 'SUPPLIER') {\r\n      return null;\r\n    }\r\n    return (\r\n      <span>\r\n        <RadioGroupStyle onChange={this.onChange} value={this.state.value}>\r\n          <Radio value=\"SUPPLY_FILTER\"><FormattedMessage id=\"Title.supplyType\" /></Radio>\r\n          <Radio value=\"COMPANY_SIZE_FILTER\"><FormattedMessage id=\"Title.companySize\" /></Radio>\r\n          {\r\n            dataUser.rols\r\n              && dataUser.rols.find(x => x).shortName === (ADMINISTRATOR || LIBERATOR || READER) &&\r\n              (<Radio value=\"COUNTRY_FILTER\"><FormattedMessage id=\"Title.country\" /></Radio>)\r\n          }\r\n        </RadioGroupStyle>\r\n        <PieChart {...options} />\r\n      </span>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapDispatchToProps = {\r\n  ...actions,\r\n};\r\n\r\nconst mapStateToProps = state => (\r\n  {\r\n    statisticalData: state.home.statisticalData,\r\n    dataUser: state.main.data,\r\n  }\r\n);\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  mapDispatchToProps,\r\n)(Doughnut);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Home/Doughnut.js","/*\n * React Chartkick\n * Create beautiful JavaScript charts with one line of React\n * https://github.com/ankane/react-chartkick\n * v0.2.0\n * MIT License\n */\n\nimport React from 'react';\nimport Chartkick from 'chartkick';\n\nvar chartId = 1;\n\nvar ChartComponent = (function (superclass) {\n  function ChartComponent () {\n    superclass.apply(this, arguments);\n  }\n\n  if ( superclass ) ChartComponent.__proto__ = superclass;\n  ChartComponent.prototype = Object.create( superclass && superclass.prototype );\n  ChartComponent.prototype.constructor = ChartComponent;\n\n  ChartComponent.prototype.newChartType = function newChartType (props) {\n    var data = props.data;\n    var options = {};\n    for (var prop in props) {\n      if (props.hasOwnProperty(prop) && prop !== \"data\" && prop !== \"id\" && prop !== \"height\" && prop !== \"width\") {\n        options[prop] = props[prop];\n      }\n    }\n    if (this.element) {\n      new props.chartType(this.element, data, options);\n    }\n  };\n\n  ChartComponent.prototype.componentDidMount = function componentDidMount () {\n    this.newChartType(this.props);\n  };\n\n  ChartComponent.prototype.componentDidUpdate = function componentDidUpdate () {\n    this.newChartType(this.props);\n  };\n\n  ChartComponent.prototype.render = function render () {\n    var this$1 = this;\n\n    var props = this.props;\n    var style = {\n      height: props.height || \"300px\",\n      lineHeight: props.height || \"300px\",\n      width: props.width || \"100%\",\n      textAlign: \"center\",\n      color: \"#999\",\n      fontSize: \"14px\",\n      fontFamily: \"'Lucida Grande', 'Lucida Sans Unicode', Verdana, Arial, Helvetica, sans-serif\"\n    };\n    this.chartId = props.id || this.chartId || (\"chart-\" + chartId++);\n    return (\n      React.createElement(\"div\", {id: this.chartId, style: style, ref: function (element) { return this$1.element = element; }},\n        \"Loading...\"\n      )\n    )\n  };\n\n  return ChartComponent;\n}(React.Component));\n\nvar createComponent = function (chartType) {\n  return function (props) {\n    return React.createElement(ChartComponent, Object.assign({}, props, {chartType: chartType}))\n  }\n};\n\nvar LineChart = createComponent(Chartkick.LineChart);\nvar PieChart = createComponent(Chartkick.PieChart);\nvar ColumnChart = createComponent(Chartkick.ColumnChart);\nvar BarChart = createComponent(Chartkick.BarChart);\nvar AreaChart = createComponent(Chartkick.AreaChart);\nvar ScatterChart = createComponent(Chartkick.ScatterChart);\nvar GeoChart = createComponent(Chartkick.GeoChart);\nvar Timeline = createComponent(Chartkick.Timeline);\n\nvar index = {\n  addAdapter: function(library) {\n    Chartkick.addAdapter(library);\n  }\n}\n\nexport default index;\nexport { LineChart, PieChart, ColumnChart, BarChart, AreaChart, ScatterChart, GeoChart, Timeline };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-chartkick/dist/react-chartkick.esm.js\n// module id = 1281\n// module chunks = 6","/*\n * Chartkick.js\n * Create beautiful charts with one line of JavaScript\n * https://github.com/ankane/chartkick.js\n * v2.3.6\n * MIT License\n */\n\nfunction isArray(variable) {\n  return Object.prototype.toString.call(variable) === \"[object Array]\";\n}\n\nfunction isFunction(variable) {\n  return variable instanceof Function;\n}\n\nfunction isPlainObject(variable) {\n  return !isFunction(variable) && variable instanceof Object;\n}\n\n// https://github.com/madrobby/zepto/blob/master/src/zepto.js\nfunction extend(target, source) {\n  var key;\n  for (key in source) {\n    if (isPlainObject(source[key]) || isArray(source[key])) {\n      if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\n        target[key] = {};\n      }\n      if (isArray(source[key]) && !isArray(target[key])) {\n        target[key] = [];\n      }\n      extend(target[key], source[key]);\n    } else if (source[key] !== undefined) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction merge(obj1, obj2) {\n  var target = {};\n  extend(target, obj1);\n  extend(target, obj2);\n  return target;\n}\n\nvar DATE_PATTERN = /^(\\d\\d\\d\\d)(-)?(\\d\\d)(-)?(\\d\\d)$/i;\n\n// https://github.com/Do/iso8601.js\nvar ISO8601_PATTERN = /(\\d\\d\\d\\d)(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)?(:)?(\\d\\d)?([.,]\\d+)?($|Z|([+-])(\\d\\d)(:)?(\\d\\d)?)/i;\nvar DECIMAL_SEPARATOR = String(1.5).charAt(1);\n\nfunction parseISO8601(input) {\n  var day, hour, matches, milliseconds, minutes, month, offset, result, seconds, type, year;\n  type = Object.prototype.toString.call(input);\n  if (type === \"[object Date]\") {\n    return input;\n  }\n  if (type !== \"[object String]\") {\n    return;\n  }\n  matches = input.match(ISO8601_PATTERN);\n  if (matches) {\n    year = parseInt(matches[1], 10);\n    month = parseInt(matches[3], 10) - 1;\n    day = parseInt(matches[5], 10);\n    hour = parseInt(matches[7], 10);\n    minutes = matches[9] ? parseInt(matches[9], 10) : 0;\n    seconds = matches[11] ? parseInt(matches[11], 10) : 0;\n    milliseconds = matches[12] ? parseFloat(DECIMAL_SEPARATOR + matches[12].slice(1)) * 1000 : 0;\n    result = Date.UTC(year, month, day, hour, minutes, seconds, milliseconds);\n    if (matches[13] && matches[14]) {\n      offset = matches[15] * 60;\n      if (matches[17]) {\n        offset += parseInt(matches[17], 10);\n      }\n      offset *= matches[14] === \"-\" ? -1 : 1;\n      result -= offset * 60 * 1000;\n    }\n    return new Date(result);\n  }\n}\n// end iso8601.js\n\nfunction negativeValues(series) {\n  var i, j, data;\n  for (i = 0; i < series.length; i++) {\n    data = series[i].data;\n    for (j = 0; j < data.length; j++) {\n      if (data[j][1] < 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction toStr(n) {\n  return \"\" + n;\n}\n\nfunction toFloat(n) {\n  return parseFloat(n);\n}\n\nfunction toDate(n) {\n  var matches, year, month, day;\n  if (typeof n !== \"object\") {\n    if (typeof n === \"number\") {\n      n = new Date(n * 1000); // ms\n    } else {\n      n = toStr(n);\n      if ((matches = n.match(DATE_PATTERN))) {\n      year = parseInt(matches[1], 10);\n      month = parseInt(matches[3], 10) - 1;\n      day = parseInt(matches[5], 10);\n      return new Date(year, month, day);\n      } else { // str\n        // try our best to get the str into iso8601\n        // TODO be smarter about this\n        var str = n.replace(/ /, \"T\").replace(\" \", \"\").replace(\"UTC\", \"Z\");\n        n = parseISO8601(str) || new Date(n);\n      }\n    }\n  }\n  return n;\n}\n\nfunction toArr(n) {\n  if (!isArray(n)) {\n    var arr = [], i;\n    for (i in n) {\n      if (n.hasOwnProperty(i)) {\n        arr.push([i, n[i]]);\n      }\n    }\n    n = arr;\n  }\n  return n;\n}\n\nfunction jsOptionsFunc(defaultOptions, hideLegend, setTitle, setMin, setMax, setStacked, setXtitle, setYtitle) {\n  return function (chart, opts, chartOptions) {\n    var series = chart.data;\n    var options = merge({}, defaultOptions);\n    options = merge(options, chartOptions || {});\n\n    if (chart.hideLegend || \"legend\" in opts) {\n      hideLegend(options, opts.legend, chart.hideLegend);\n    }\n\n    if (opts.title) {\n      setTitle(options, opts.title);\n    }\n\n    // min\n    if (\"min\" in opts) {\n      setMin(options, opts.min);\n    } else if (!negativeValues(series)) {\n      setMin(options, 0);\n    }\n\n    // max\n    if (opts.max) {\n      setMax(options, opts.max);\n    }\n\n    if (\"stacked\" in opts) {\n      setStacked(options, opts.stacked);\n    }\n\n    if (opts.colors) {\n      options.colors = opts.colors;\n    }\n\n    if (opts.xtitle) {\n      setXtitle(options, opts.xtitle);\n    }\n\n    if (opts.ytitle) {\n      setYtitle(options, opts.ytitle);\n    }\n\n    // merge library last\n    options = merge(options, opts.library || {});\n\n    return options;\n  };\n}\n\nfunction sortByTime(a, b) {\n  return a[0].getTime() - b[0].getTime();\n}\n\nfunction sortByNumberSeries(a, b) {\n  return a[0] - b[0];\n}\n\nfunction sortByNumber(a, b) {\n  return a - b;\n}\n\nfunction isMinute(d) {\n  return d.getMilliseconds() === 0 && d.getSeconds() === 0;\n}\n\nfunction isHour(d) {\n  return isMinute(d) && d.getMinutes() === 0;\n}\n\nfunction isDay(d) {\n  return isHour(d) && d.getHours() === 0;\n}\n\nfunction isWeek(d, dayOfWeek) {\n  return isDay(d) && d.getDay() === dayOfWeek;\n}\n\nfunction isMonth(d) {\n  return isDay(d) && d.getDate() === 1;\n}\n\nfunction isYear(d) {\n  return isMonth(d) && d.getMonth() === 0;\n}\n\nfunction isDate(obj) {\n  return !isNaN(toDate(obj)) && toStr(obj).length >= 6;\n}\n\nfunction formatValue(pre, value, options) {\n  pre = pre || \"\";\n  if (options.prefix) {\n    if (value < 0) {\n      value = value * -1;\n      pre += \"-\";\n    }\n    pre += options.prefix;\n  }\n\n  if (options.thousands || options.decimal) {\n    value = toStr(value);\n    var parts = value.split(\".\");\n    value = parts[0];\n    if (options.thousands) {\n      value = value.replace(/\\B(?=(\\d{3})+(?!\\d))/g, options.thousands);\n    }\n    if (parts.length > 1) {\n      value += (options.decimal || \".\") + parts[1];\n    }\n  }\n\n  return pre + value + (options.suffix || \"\");\n}\n\nfunction allZeros(data) {\n  var i, j, d;\n  for (i = 0; i < data.length; i++) {\n    d = data[i].data;\n    for (j = 0; j < d.length; j++) {\n      if (d[j][1] != 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar baseOptions = {\n  maintainAspectRatio: false,\n  animation: false,\n  tooltips: {\n    displayColors: false,\n    callbacks: {}\n  },\n  legend: {},\n  title: {fontSize: 20, fontColor: \"#333\"}\n};\n\nvar defaultOptions = {\n  scales: {\n    yAxes: [\n      {\n        ticks: {\n          maxTicksLimit: 4\n        },\n        scaleLabel: {\n          fontSize: 16,\n          // fontStyle: \"bold\",\n          fontColor: \"#333\"\n        }\n      }\n    ],\n    xAxes: [\n      {\n        gridLines: {\n          drawOnChartArea: false\n        },\n        scaleLabel: {\n          fontSize: 16,\n          // fontStyle: \"bold\",\n          fontColor: \"#333\"\n        },\n        time: {},\n        ticks: {}\n      }\n    ]\n  }\n};\n\n// http://there4.io/2012/05/02/google-chart-color-list/\nvar defaultColors = [\n  \"#3366CC\", \"#DC3912\", \"#FF9900\", \"#109618\", \"#990099\", \"#3B3EAC\", \"#0099C6\",\n  \"#DD4477\", \"#66AA00\", \"#B82E2E\", \"#316395\", \"#994499\", \"#22AA99\", \"#AAAA11\",\n  \"#6633CC\", \"#E67300\", \"#8B0707\", \"#329262\", \"#5574A6\", \"#651067\"\n];\n\nvar hideLegend = function (options, legend, hideLegend) {\n  if (legend !== undefined) {\n    options.legend.display = !!legend;\n    if (legend && legend !== true) {\n      options.legend.position = legend;\n    }\n  } else if (hideLegend) {\n    options.legend.display = false;\n  }\n};\n\nvar setTitle = function (options, title) {\n  options.title.display = true;\n  options.title.text = title;\n};\n\nvar setMin = function (options, min) {\n  if (min !== null) {\n    options.scales.yAxes[0].ticks.min = toFloat(min);\n  }\n};\n\nvar setMax = function (options, max) {\n  options.scales.yAxes[0].ticks.max = toFloat(max);\n};\n\nvar setBarMin = function (options, min) {\n  if (min !== null) {\n    options.scales.xAxes[0].ticks.min = toFloat(min);\n  }\n};\n\nvar setBarMax = function (options, max) {\n  options.scales.xAxes[0].ticks.max = toFloat(max);\n};\n\nvar setStacked = function (options, stacked) {\n  options.scales.xAxes[0].stacked = !!stacked;\n  options.scales.yAxes[0].stacked = !!stacked;\n};\n\nvar setXtitle = function (options, title) {\n  options.scales.xAxes[0].scaleLabel.display = true;\n  options.scales.xAxes[0].scaleLabel.labelString = title;\n};\n\nvar setYtitle = function (options, title) {\n  options.scales.yAxes[0].scaleLabel.display = true;\n  options.scales.yAxes[0].scaleLabel.labelString = title;\n};\n\n// http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\nvar addOpacity = function(hex, opacity) {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? \"rgba(\" + parseInt(result[1], 16) + \", \" + parseInt(result[2], 16) + \", \" + parseInt(result[3], 16) + \", \" + opacity + \")\" : hex;\n};\n\nvar setLabelSize = function (chart, data, options) {\n  var maxLabelSize = Math.ceil(chart.element.offsetWidth / 4.0 / data.labels.length);\n  if (maxLabelSize > 25) {\n    maxLabelSize = 25;\n  }\n  options.scales.xAxes[0].ticks.callback = function (value) {\n    value = toStr(value);\n    if (value.length > maxLabelSize) {\n      return value.substring(0, maxLabelSize - 2) + \"...\";\n    } else {\n      return value;\n    }\n  };\n};\n\nvar setFormatOptions = function(chart, options, chartType) {\n  var formatOptions = {\n    prefix: chart.options.prefix,\n    suffix: chart.options.suffix,\n    thousands: chart.options.thousands,\n    decimal: chart.options.decimal\n  };\n\n  if (formatOptions.prefix || formatOptions.suffix || formatOptions.thousands || formatOptions.decimal) {\n    if (chartType !== \"pie\") {\n      var myAxes = options.scales.yAxes;\n      if (chartType === \"bar\") {\n        myAxes = options.scales.xAxes;\n      }\n\n      if (!myAxes[0].ticks.callback) {\n        myAxes[0].ticks.callback = function (value) {\n          return formatValue(\"\", value, formatOptions);\n        };\n      }\n    }\n\n    if (!options.tooltips.callbacks.label) {\n      if (chartType !== \"pie\") {\n        var valueLabel = chartType === \"bar\" ? \"xLabel\" : \"yLabel\";\n        options.tooltips.callbacks.label = function (tooltipItem, data) {\n          var label = data.datasets[tooltipItem.datasetIndex].label || '';\n          if (label) {\n            label += ': ';\n          }\n          return formatValue(label, tooltipItem[valueLabel], formatOptions);\n        };\n      } else {\n        // need to use separate label for pie charts\n        options.tooltips.callbacks.label = function (tooltipItem, data) {\n          var dataLabel = data.labels[tooltipItem.index];\n          var value = ': ';\n\n          if (isArray(dataLabel)) {\n            // show value on first line of multiline label\n            // need to clone because we are changing the value\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n\n          return formatValue(dataLabel, data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index], formatOptions);\n        };\n      }\n    }\n  }\n};\n\nvar jsOptions = jsOptionsFunc(merge(baseOptions, defaultOptions), hideLegend, setTitle, setMin, setMax, setStacked, setXtitle, setYtitle);\n\nvar createDataTable = function (chart, options, chartType) {\n  var datasets = [];\n  var labels = [];\n\n  var colors = chart.options.colors || defaultColors;\n\n  var day = true;\n  var week = true;\n  var dayOfWeek;\n  var month = true;\n  var year = true;\n  var hour = true;\n  var minute = true;\n  var detectType = (chartType === \"line\" || chartType === \"area\") && !chart.discrete;\n\n  var series = chart.data;\n\n  var sortedLabels = [];\n\n  var i, j, s, d, key, rows = [];\n  for (i = 0; i < series.length; i++) {\n    s = series[i];\n\n    for (j = 0; j < s.data.length; j++) {\n      d = s.data[j];\n      key = detectType ? d[0].getTime() : d[0];\n      if (!rows[key]) {\n        rows[key] = new Array(series.length);\n      }\n      rows[key][i] = toFloat(d[1]);\n      if (sortedLabels.indexOf(key) === -1) {\n        sortedLabels.push(key);\n      }\n    }\n  }\n\n  if (detectType || chart.options.xtype === \"number\") {\n    sortedLabels.sort(sortByNumber);\n  }\n\n  var rows2 = [];\n  for (j = 0; j < series.length; j++) {\n    rows2.push([]);\n  }\n\n  var value;\n  var k;\n  for (k = 0; k < sortedLabels.length; k++) {\n    i = sortedLabels[k];\n    if (detectType) {\n      value = new Date(toFloat(i));\n      // TODO make this efficient\n      day = day && isDay(value);\n      if (!dayOfWeek) {\n        dayOfWeek = value.getDay();\n      }\n      week = week && isWeek(value, dayOfWeek);\n      month = month && isMonth(value);\n      year = year && isYear(value);\n      hour = hour && isHour(value);\n      minute = minute && isMinute(value);\n    } else {\n      value = i;\n    }\n    labels.push(value);\n    for (j = 0; j < series.length; j++) {\n      // Chart.js doesn't like undefined\n      rows2[j].push(rows[i][j] === undefined ? null : rows[i][j]);\n    }\n  }\n\n  for (i = 0; i < series.length; i++) {\n    s = series[i];\n\n    var color = s.color || colors[i];\n    var backgroundColor = chartType !== \"line\" ? addOpacity(color, 0.5) : color;\n\n    var dataset = {\n      label: s.name,\n      data: rows2[i],\n      fill: chartType === \"area\",\n      borderColor: color,\n      backgroundColor: backgroundColor,\n      pointBackgroundColor: color,\n      pointHoverBackgroundColor: color,\n      borderWidth: 2\n    };\n\n    if (s.stack) {\n      dataset.stack = s.stack;\n    }\n\n    if (chart.options.curve === false) {\n      dataset.lineTension = 0;\n    }\n\n    if (chart.options.points === false) {\n      dataset.pointRadius = 0;\n      dataset.pointHitRadius = 5;\n    }\n\n    dataset = merge(dataset, chart.options.dataset || {});\n    dataset = merge(dataset, s.library || {});\n    dataset = merge(dataset, s.dataset || {});\n\n    datasets.push(dataset);\n  }\n\n  if (detectType && labels.length > 0) {\n    var minTime = labels[0].getTime();\n    var maxTime = labels[0].getTime();\n    for (i = 1; i < labels.length; i++) {\n      value = labels[i].getTime();\n      if (value < minTime) {\n        minTime = value;\n      }\n      if (value > maxTime) {\n        maxTime = value;\n      }\n    }\n\n    var timeDiff = (maxTime - minTime) / (86400 * 1000.0);\n\n    if (!options.scales.xAxes[0].time.unit) {\n      var step;\n      if (year || timeDiff > 365 * 10) {\n        options.scales.xAxes[0].time.unit = \"year\";\n        step = 365;\n      } else if (month || timeDiff > 30 * 10) {\n        options.scales.xAxes[0].time.unit = \"month\";\n        step = 30;\n      } else if (day || timeDiff > 10) {\n        options.scales.xAxes[0].time.unit = \"day\";\n        step = 1;\n      } else if (hour || timeDiff > 0.5) {\n        options.scales.xAxes[0].time.displayFormats = {hour: \"MMM D, h a\"};\n        options.scales.xAxes[0].time.unit = \"hour\";\n        step = 1 / 24.0;\n      } else if (minute) {\n        options.scales.xAxes[0].time.displayFormats = {minute: \"h:mm a\"};\n        options.scales.xAxes[0].time.unit = \"minute\";\n        step = 1 / 24.0 / 60.0;\n      }\n\n      if (step && timeDiff > 0) {\n        var unitStepSize = Math.ceil(timeDiff / step / (chart.element.offsetWidth / 100.0));\n        if (week && step === 1) {\n          unitStepSize = Math.ceil(unitStepSize / 7.0) * 7;\n        }\n        options.scales.xAxes[0].time.unitStepSize = unitStepSize;\n      }\n    }\n\n    if (!options.scales.xAxes[0].time.tooltipFormat) {\n      if (day) {\n        options.scales.xAxes[0].time.tooltipFormat = \"ll\";\n      } else if (hour) {\n        options.scales.xAxes[0].time.tooltipFormat = \"MMM D, h a\";\n      } else if (minute) {\n        options.scales.xAxes[0].time.tooltipFormat = \"h:mm a\";\n      }\n    }\n  }\n\n  var data = {\n    labels: labels,\n    datasets: datasets\n  };\n\n  return data;\n};\n\nvar defaultExport = function defaultExport(library) {\n  this.name = \"chartjs\";\n  this.library = library;\n};\n\ndefaultExport.prototype.renderLineChart = function renderLineChart (chart, chartType) {\n  if (chart.options.xtype === \"number\") {\n    return this.renderScatterChart(chart, chartType, true);\n  }\n\n  var chartOptions = {};\n  // fix for https://github.com/chartjs/Chart.js/issues/2441\n  if (!chart.options.max && allZeros(chart.data)) {\n    chartOptions.max = 1;\n  }\n\n  var options = jsOptions(chart, merge(chartOptions, chart.options));\n  setFormatOptions(chart, options, chartType);\n\n  var data = createDataTable(chart, options, chartType || \"line\");\n\n  options.scales.xAxes[0].type = chart.discrete ? \"category\" : \"time\";\n\n  this.drawChart(chart, \"line\", data, options);\n};\n\ndefaultExport.prototype.renderPieChart = function renderPieChart (chart) {\n  var options = merge({}, baseOptions);\n  if (chart.options.donut) {\n    options.cutoutPercentage = 50;\n  }\n\n  if (\"legend\" in chart.options) {\n    hideLegend(options, chart.options.legend);\n  }\n\n  if (chart.options.title) {\n    setTitle(options, chart.options.title);\n  }\n\n  options = merge(options, chart.options.library || {});\n  setFormatOptions(chart, options, \"pie\");\n\n  var labels = [];\n  var values = [];\n  for (var i = 0; i < chart.data.length; i++) {\n    var point = chart.data[i];\n    labels.push(point[0]);\n    values.push(point[1]);\n  }\n\n  var dataset = {\n    data: values,\n    backgroundColor: chart.options.colors || defaultColors\n  };\n  dataset = merge(dataset, chart.options.dataset || {});\n\n  var data = {\n    labels: labels,\n    datasets: [dataset]\n  };\n\n  this.drawChart(chart, \"pie\", data, options);\n};\n\ndefaultExport.prototype.renderColumnChart = function renderColumnChart (chart, chartType) {\n  var options;\n  if (chartType === \"bar\") {\n    options = jsOptionsFunc(merge(baseOptions, defaultOptions), hideLegend, setTitle, setBarMin, setBarMax, setStacked, setXtitle, setYtitle)(chart, chart.options);\n  } else {\n    options = jsOptions(chart, chart.options);\n  }\n  setFormatOptions(chart, options, chartType);\n  var data = createDataTable(chart, options, \"column\");\n  if (chartType !== \"bar\") {\n    setLabelSize(chart, data, options);\n  }\n  this.drawChart(chart, (chartType === \"bar\" ? \"horizontalBar\" : \"bar\"), data, options);\n};\n\ndefaultExport.prototype.renderAreaChart = function renderAreaChart (chart) {\n  this.renderLineChart(chart, \"area\");\n};\n\ndefaultExport.prototype.renderBarChart = function renderBarChart (chart) {\n  this.renderColumnChart(chart, \"bar\");\n};\n\ndefaultExport.prototype.renderScatterChart = function renderScatterChart (chart, chartType, lineChart) {\n  chartType = chartType || \"line\";\n\n  var options = jsOptions(chart, chart.options);\n  if (!lineChart) {\n    setFormatOptions(chart, options, chartType);\n  }\n\n  var colors = chart.options.colors || defaultColors;\n\n  var datasets = [];\n  var series = chart.data;\n  for (var i = 0; i < series.length; i++) {\n    var s = series[i];\n    var d = [];\n    for (var j = 0; j < s.data.length; j++) {\n      var point = {\n        x: toFloat(s.data[j][0]),\n        y: toFloat(s.data[j][1])\n      };\n      if (chartType === \"bubble\") {\n        point.r = toFloat(s.data[j][2]);\n      }\n      d.push(point);\n    }\n\n    var color = s.color || colors[i];\n    var backgroundColor = chartType === \"area\" ? addOpacity(color, 0.5) : color;\n\n    datasets.push({\n      label: s.name,\n      showLine: lineChart || false,\n      data: d,\n      borderColor: color,\n      backgroundColor: backgroundColor,\n      pointBackgroundColor: color,\n      fill: chartType === \"area\"\n    });\n  }\n\n  if (chartType === \"area\") {\n    chartType = \"line\";\n  }\n\n  var data = {datasets: datasets};\n\n  options.scales.xAxes[0].type = \"linear\";\n  options.scales.xAxes[0].position = \"bottom\";\n\n  this.drawChart(chart, chartType, data, options);\n};\n\ndefaultExport.prototype.renderBubbleChart = function renderBubbleChart (chart) {\n  this.renderScatterChart(chart, \"bubble\");\n};\n\ndefaultExport.prototype.destroy = function destroy (chart) {\n  if (chart.chart) {\n    chart.chart.destroy();\n  }\n};\n\ndefaultExport.prototype.drawChart = function drawChart (chart, type, data, options) {\n  this.destroy(chart);\n\n  chart.element.innerHTML = \"<canvas></canvas>\";\n  var ctx = chart.element.getElementsByTagName(\"CANVAS\")[0];\n  chart.chart = new this.library(ctx, {\n    type: type,\n    data: data,\n    options: options\n  });\n};\n\nvar defaultOptions$1 = {\n  chart: {},\n  xAxis: {\n    title: {\n      text: null\n    },\n    labels: {\n      style: {\n        fontSize: \"12px\"\n      }\n    }\n  },\n  yAxis: {\n    title: {\n      text: null\n    },\n    labels: {\n      style: {\n        fontSize: \"12px\"\n      }\n    }\n  },\n  title: {\n    text: null\n  },\n  credits: {\n    enabled: false\n  },\n  legend: {\n    borderWidth: 0\n  },\n  tooltip: {\n    style: {\n      fontSize: \"12px\"\n    }\n  },\n  plotOptions: {\n    areaspline: {},\n    series: {\n      marker: {}\n    }\n  }\n};\n\nvar hideLegend$1 = function (options, legend, hideLegend) {\n  if (legend !== undefined) {\n    options.legend.enabled = !!legend;\n    if (legend && legend !== true) {\n      if (legend === \"top\" || legend === \"bottom\") {\n        options.legend.verticalAlign = legend;\n      } else {\n        options.legend.layout = \"vertical\";\n        options.legend.verticalAlign = \"middle\";\n        options.legend.align = legend;\n      }\n    }\n  } else if (hideLegend) {\n    options.legend.enabled = false;\n  }\n};\n\nvar setTitle$1 = function (options, title) {\n  options.title.text = title;\n};\n\nvar setMin$1 = function (options, min) {\n  options.yAxis.min = min;\n};\n\nvar setMax$1 = function (options, max) {\n  options.yAxis.max = max;\n};\n\nvar setStacked$1 = function (options, stacked) {\n  options.plotOptions.series.stacking = stacked ? (stacked === true ? \"normal\" : stacked) : null;\n};\n\nvar setXtitle$1 = function (options, title) {\n  options.xAxis.title.text = title;\n};\n\nvar setYtitle$1 = function (options, title) {\n  options.yAxis.title.text = title;\n};\n\nvar jsOptions$1 = jsOptionsFunc(defaultOptions$1, hideLegend$1, setTitle$1, setMin$1, setMax$1, setStacked$1, setXtitle$1, setYtitle$1);\n\nvar setFormatOptions$1 = function(chart, options, chartType) {\n  var formatOptions = {\n    prefix: chart.options.prefix,\n    suffix: chart.options.suffix,\n    thousands: chart.options.thousands,\n    decimal: chart.options.decimal\n  };\n\n  if (formatOptions.prefix || formatOptions.suffix || formatOptions.thousands || formatOptions.decimal) {\n    if (chartType !== \"pie\" && !options.yAxis.labels.formatter) {\n      options.yAxis.labels.formatter = function () {\n        return formatValue(\"\", this.value, formatOptions);\n      };\n    }\n\n    if (!options.tooltip.pointFormatter) {\n      options.tooltip.pointFormatter = function () {\n        return '<span style=\"color:' + this.color + '>\\u25CF</span> ' + formatValue(this.series.name + ': <b>', this.y, formatOptions) + '</b><br/>';\n      };\n    }\n  }\n};\n\nvar defaultExport$1 = function defaultExport(library) {\n  this.name = \"highcharts\";\n  this.library = library;\n};\n\ndefaultExport$1.prototype.renderLineChart = function renderLineChart (chart, chartType) {\n  chartType = chartType || \"spline\";\n  var chartOptions = {};\n  if (chartType === \"areaspline\") {\n    chartOptions = {\n      plotOptions: {\n        areaspline: {\n          stacking: \"normal\"\n        },\n        area: {\n          stacking: \"normal\"\n        },\n        series: {\n          marker: {\n            enabled: false\n          }\n        }\n      }\n    };\n  }\n\n  if (chart.options.curve === false) {\n    if (chartType === \"areaspline\") {\n      chartType = \"area\";\n    } else if (chartType === \"spline\") {\n      chartType = \"line\";\n    }\n  }\n\n  var options = jsOptions$1(chart, chart.options, chartOptions), data, i, j;\n  options.xAxis.type = chart.discrete ? \"category\" : \"datetime\";\n  if (!options.chart.type) {\n    options.chart.type = chartType;\n  }\n  setFormatOptions$1(chart, options, chartType);\n\n  var series = chart.data;\n  for (i = 0; i < series.length; i++) {\n    data = series[i].data;\n    if (!chart.discrete) {\n      for (j = 0; j < data.length; j++) {\n        data[j][0] = data[j][0].getTime();\n      }\n    }\n    series[i].marker = {symbol: \"circle\"};\n    if (chart.options.points === false) {\n      series[i].marker.enabled = false;\n    }\n  }\n\n  this.drawChart(chart, series, options);\n};\n\ndefaultExport$1.prototype.renderScatterChart = function renderScatterChart (chart) {\n  var options = jsOptions$1(chart, chart.options, {});\n  options.chart.type = \"scatter\";\n  this.drawChart(chart, chart.data, options);\n};\n\ndefaultExport$1.prototype.renderPieChart = function renderPieChart (chart) {\n  var chartOptions = merge(defaultOptions$1, {});\n\n  if (chart.options.colors) {\n    chartOptions.colors = chart.options.colors;\n  }\n  if (chart.options.donut) {\n    chartOptions.plotOptions = {pie: {innerSize: \"50%\"}};\n  }\n\n  if (\"legend\" in chart.options) {\n    hideLegend$1(chartOptions, chart.options.legend);\n  }\n\n  if (chart.options.title) {\n    setTitle$1(chartOptions, chart.options.title);\n  }\n\n  var options = merge(chartOptions, chart.options.library || {});\n  setFormatOptions$1(chart, options, \"pie\");\n  var series = [{\n    type: \"pie\",\n    name: chart.options.label || \"Value\",\n    data: chart.data\n  }];\n\n  this.drawChart(chart, series, options);\n};\n\ndefaultExport$1.prototype.renderColumnChart = function renderColumnChart (chart, chartType) {\n  chartType = chartType || \"column\";\n  var series = chart.data;\n  var options = jsOptions$1(chart, chart.options), i, j, s, d, rows = [], categories = [];\n  options.chart.type = chartType;\n  setFormatOptions$1(chart, options, chartType);\n\n  for (i = 0; i < series.length; i++) {\n    s = series[i];\n\n    for (j = 0; j < s.data.length; j++) {\n      d = s.data[j];\n      if (!rows[d[0]]) {\n        rows[d[0]] = new Array(series.length);\n        categories.push(d[0]);\n      }\n      rows[d[0]][i] = d[1];\n    }\n  }\n\n  if (chart.options.xtype === \"number\") {\n    categories.sort(sortByNumber);\n  }\n\n  options.xAxis.categories = categories;\n\n  var newSeries = [], d2;\n  for (i = 0; i < series.length; i++) {\n    d = [];\n    for (j = 0; j < categories.length; j++) {\n      d.push(rows[categories[j]][i] || 0);\n    }\n\n    d2 = {\n      name: series[i].name,\n      data: d\n    };\n    if (series[i].stack) {\n      d2.stack = series[i].stack;\n    }\n\n    newSeries.push(d2);\n  }\n\n  this.drawChart(chart, newSeries, options);\n};\n\ndefaultExport$1.prototype.renderBarChart = function renderBarChart (chart) {\n  this.renderColumnChart(chart, \"bar\");\n};\n\ndefaultExport$1.prototype.renderAreaChart = function renderAreaChart (chart) {\n  this.renderLineChart(chart, \"areaspline\");\n};\n\ndefaultExport$1.prototype.destroy = function destroy (chart) {\n  if (chart.chart) {\n    chart.chart.destroy();\n  }\n};\n\ndefaultExport$1.prototype.drawChart = function drawChart (chart, data, options) {\n  this.destroy(chart);\n\n  options.chart.renderTo = chart.element.id;\n  options.series = data;\n  chart.chart = new this.library.Chart(options);\n};\n\nvar loaded = {};\nvar callbacks = [];\n\n// Set chart options\nvar defaultOptions$2 = {\n  chartArea: {},\n  fontName: \"'Lucida Grande', 'Lucida Sans Unicode', Verdana, Arial, Helvetica, sans-serif\",\n  pointSize: 6,\n  legend: {\n    textStyle: {\n      fontSize: 12,\n      color: \"#444\"\n    },\n    alignment: \"center\",\n    position: \"right\"\n  },\n  curveType: \"function\",\n  hAxis: {\n    textStyle: {\n      color: \"#666\",\n      fontSize: 12\n    },\n    titleTextStyle: {},\n    gridlines: {\n      color: \"transparent\"\n    },\n    baselineColor: \"#ccc\",\n    viewWindow: {}\n  },\n  vAxis: {\n    textStyle: {\n      color: \"#666\",\n      fontSize: 12\n    },\n    titleTextStyle: {},\n    baselineColor: \"#ccc\",\n    viewWindow: {}\n  },\n  tooltip: {\n    textStyle: {\n      color: \"#666\",\n      fontSize: 12\n    }\n  }\n};\n\nvar hideLegend$2 = function (options, legend, hideLegend) {\n  if (legend !== undefined) {\n    var position;\n    if (!legend) {\n      position = \"none\";\n    } else if (legend === true) {\n      position = \"right\";\n    } else {\n      position = legend;\n    }\n    options.legend.position = position;\n  } else if (hideLegend) {\n    options.legend.position = \"none\";\n  }\n};\n\nvar setTitle$2 = function (options, title) {\n  options.title = title;\n  options.titleTextStyle = {color: \"#333\", fontSize: \"20px\"};\n};\n\nvar setMin$2 = function (options, min) {\n  options.vAxis.viewWindow.min = min;\n};\n\nvar setMax$2 = function (options, max) {\n  options.vAxis.viewWindow.max = max;\n};\n\nvar setBarMin$1 = function (options, min) {\n  options.hAxis.viewWindow.min = min;\n};\n\nvar setBarMax$1 = function (options, max) {\n  options.hAxis.viewWindow.max = max;\n};\n\nvar setStacked$2 = function (options, stacked) {\n  options.isStacked = stacked ? stacked : false;\n};\n\nvar setXtitle$2 = function (options, title) {\n  options.hAxis.title = title;\n  options.hAxis.titleTextStyle.italic = false;\n};\n\nvar setYtitle$2 = function (options, title) {\n  options.vAxis.title = title;\n  options.vAxis.titleTextStyle.italic = false;\n};\n\nvar jsOptions$2 = jsOptionsFunc(defaultOptions$2, hideLegend$2, setTitle$2, setMin$2, setMax$2, setStacked$2, setXtitle$2, setYtitle$2);\n\nvar resize = function (callback) {\n  if (window.attachEvent) {\n    window.attachEvent(\"onresize\", callback);\n  } else if (window.addEventListener) {\n    window.addEventListener(\"resize\", callback, true);\n  }\n  callback();\n};\n\nvar defaultExport$2 = function defaultExport(library) {\n  this.name = \"google\";\n  this.library = library;\n};\n\ndefaultExport$2.prototype.renderLineChart = function renderLineChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {};\n\n    if (chart.options.curve === false) {\n      chartOptions.curveType = \"none\";\n    }\n\n    if (chart.options.points === false) {\n      chartOptions.pointSize = 0;\n    }\n\n    var options = jsOptions$2(chart, chart.options, chartOptions);\n    var columnType = chart.discrete ? \"string\" : \"datetime\";\n    if (chart.options.xtype === \"number\") {\n      columnType = \"number\";\n    }\n    var data = this$1.createDataTable(chart.data, columnType);\n\n    this$1.drawChart(chart, this$1.library.visualization.LineChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderPieChart = function renderPieChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {\n      chartArea: {\n        top: \"10%\",\n        height: \"80%\"\n      },\n      legend: {}\n    };\n    if (chart.options.colors) {\n      chartOptions.colors = chart.options.colors;\n    }\n    if (chart.options.donut) {\n      chartOptions.pieHole = 0.5;\n    }\n    if (\"legend\" in chart.options) {\n      hideLegend$2(chartOptions, chart.options.legend);\n    }\n    if (chart.options.title) {\n      setTitle$2(chartOptions, chart.options.title);\n    }\n    var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n\n    var data = new this$1.library.visualization.DataTable();\n    data.addColumn(\"string\", \"\");\n    data.addColumn(\"number\", \"Value\");\n    data.addRows(chart.data);\n\n    this$1.drawChart(chart, this$1.library.visualization.PieChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderColumnChart = function renderColumnChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var options = jsOptions$2(chart, chart.options);\n    var data = this$1.createDataTable(chart.data, \"string\", chart.options.xtype);\n\n    this$1.drawChart(chart, this$1.library.visualization.ColumnChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderBarChart = function renderBarChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {\n      hAxis: {\n        gridlines: {\n          color: \"#ccc\"\n        }\n      }\n    };\n    var options = jsOptionsFunc(defaultOptions$2, hideLegend$2, setTitle$2, setBarMin$1, setBarMax$1, setStacked$2, setXtitle$2, setYtitle$2)(chart, chart.options, chartOptions);\n    var data = this$1.createDataTable(chart.data, \"string\", chart.options.xtype);\n\n    this$1.drawChart(chart, this$1.library.visualization.BarChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderAreaChart = function renderAreaChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {\n      isStacked: true,\n      pointSize: 0,\n      areaOpacity: 0.5\n    };\n\n    var options = jsOptions$2(chart, chart.options, chartOptions);\n    var columnType = chart.discrete ? \"string\" : \"datetime\";\n    if (chart.options.xtype === \"number\") {\n      columnType = \"number\";\n    }\n    var data = this$1.createDataTable(chart.data, columnType);\n\n    this$1.drawChart(chart, this$1.library.visualization.AreaChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderGeoChart = function renderGeoChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {\n      legend: \"none\",\n      colorAxis: {\n        colors: chart.options.colors || [\"#f6c7b6\", \"#ce502d\"]\n      }\n    };\n    var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n\n    var data = new this$1.library.visualization.DataTable();\n    data.addColumn(\"string\", \"\");\n    data.addColumn(\"number\", chart.options.label || \"Value\");\n    data.addRows(chart.data);\n\n    this$1.drawChart(chart, this$1.library.visualization.GeoChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderScatterChart = function renderScatterChart (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, function () {\n    var chartOptions = {};\n    var options = jsOptions$2(chart, chart.options, chartOptions);\n\n    var series = chart.data, rows2 = [], i, j, data, d;\n    for (i = 0; i < series.length; i++) {\n      d = series[i].data;\n      for (j = 0; j < d.length; j++) {\n        var row = new Array(series.length + 1);\n        row[0] = d[j][0];\n        row[i + 1] = d[j][1];\n        rows2.push(row);\n      }\n    }\n\n    data = new this$1.library.visualization.DataTable();\n    data.addColumn(\"number\", \"\");\n    for (i = 0; i < series.length; i++) {\n      data.addColumn(\"number\", series[i].name);\n    }\n    data.addRows(rows2);\n\n    this$1.drawChart(chart, this$1.library.visualization.ScatterChart, data, options);\n  });\n};\n\ndefaultExport$2.prototype.renderTimeline = function renderTimeline (chart) {\n    var this$1 = this;\n\n  this.waitForLoaded(chart, \"timeline\", function () {\n    var chartOptions = {\n      legend: \"none\"\n    };\n\n    if (chart.options.colors) {\n      chartOptions.colors = chart.options.colors;\n    }\n    var options = merge(merge(defaultOptions$2, chartOptions), chart.options.library || {});\n\n    var data = new this$1.library.visualization.DataTable();\n    data.addColumn({type: \"string\", id: \"Name\"});\n    data.addColumn({type: \"date\", id: \"Start\"});\n    data.addColumn({type: \"date\", id: \"End\"});\n    data.addRows(chart.data);\n\n    chart.element.style.lineHeight = \"normal\";\n\n    this$1.drawChart(chart, this$1.library.visualization.Timeline, data, options);\n  });\n};\n\ndefaultExport$2.prototype.destroy = function destroy (chart) {\n  if (chart.chart) {\n    chart.chart.clearChart();\n  }\n};\n\ndefaultExport$2.prototype.drawChart = function drawChart (chart, type, data, options) {\n  this.destroy(chart);\n\n  chart.chart = new type(chart.element);\n  resize(function () {\n    chart.chart.draw(data, options);\n  });\n};\n\ndefaultExport$2.prototype.waitForLoaded = function waitForLoaded (chart, pack, callback) {\n    var this$1 = this;\n\n  if (!callback) {\n    callback = pack;\n    pack = \"corechart\";\n  }\n\n  callbacks.push({pack: pack, callback: callback});\n\n  if (loaded[pack]) {\n    this.runCallbacks();\n  } else {\n    loaded[pack] = true;\n\n    // https://groups.google.com/forum/#!topic/google-visualization-api/fMKJcyA2yyI\n    var loadOptions = {\n      packages: [pack],\n      callback: function () { this$1.runCallbacks(); }\n    };\n    var config = chart.__config();\n    if (config.language) {\n      loadOptions.language = config.language;\n    }\n    if (pack === \"corechart\" && config.mapsApiKey) {\n      loadOptions.mapsApiKey = config.mapsApiKey;\n    }\n\n    if (this.library.setOnLoadCallback) {\n      this.library.load(\"visualization\", \"1\", loadOptions);\n    } else {\n      this.library.charts.load(\"current\", loadOptions);\n    }\n  }\n};\n\ndefaultExport$2.prototype.runCallbacks = function runCallbacks () {\n    var this$1 = this;\n\n  var cb, call;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    call = this$1.library.visualization && ((cb.pack === \"corechart\" && this$1.library.visualization.LineChart) || (cb.pack === \"timeline\" && this$1.library.visualization.Timeline));\n    if (call) {\n      cb.callback();\n      callbacks.splice(i, 1);\n      i--;\n    }\n  }\n};\n\n// cant use object as key\ndefaultExport$2.prototype.createDataTable = function createDataTable (series, columnType, xtype) {\n  var i, j, s, d, key, rows = [], sortedLabels = [];\n  for (i = 0; i < series.length; i++) {\n    s = series[i];\n\n    for (j = 0; j < s.data.length; j++) {\n      d = s.data[j];\n      key = (columnType === \"datetime\") ? d[0].getTime() : d[0];\n      if (!rows[key]) {\n        rows[key] = new Array(series.length);\n        sortedLabels.push(key);\n      }\n      rows[key][i] = toFloat(d[1]);\n    }\n  }\n\n  var rows2 = [];\n  var day = true;\n  var value;\n  for (j = 0; j < sortedLabels.length; j++) {\n    i = sortedLabels[j];\n    if (columnType === \"datetime\") {\n      value = new Date(toFloat(i));\n      day = day && isDay(value);\n    } else if (columnType === \"number\") {\n      value = toFloat(i);\n    } else {\n      value = i;\n    }\n    rows2.push([value].concat(rows[i]));\n  }\n  if (columnType === \"datetime\") {\n    rows2.sort(sortByTime);\n  } else if (columnType === \"number\") {\n    rows2.sort(sortByNumberSeries);\n  }\n\n  if (xtype === \"number\") {\n    rows2.sort(sortByNumberSeries);\n\n    for (i = 0; i < rows2.length; i++) {\n      rows2[i][0] = toStr(rows2[i][0]);\n    }\n  }\n\n  // create datatable\n  var data = new this.library.visualization.DataTable();\n  columnType = columnType === \"datetime\" && day ? \"date\" : columnType;\n  data.addColumn(columnType, \"\");\n  for (i = 0; i < series.length; i++) {\n    data.addColumn(\"number\", series[i].name);\n  }\n  data.addRows(rows2);\n\n  return data;\n};\n\nvar pendingRequests = [], runningRequests = 0, maxRequests = 4;\n\nfunction pushRequest(url, success, error) {\n  pendingRequests.push([url, success, error]);\n  runNext();\n}\n\nfunction runNext() {\n  if (runningRequests < maxRequests) {\n    var request = pendingRequests.shift();\n    if (request) {\n      runningRequests++;\n      getJSON(request[0], request[1], request[2]);\n      runNext();\n    }\n  }\n}\n\nfunction requestComplete() {\n  runningRequests--;\n  runNext();\n}\n\nfunction getJSON(url, success, error) {\n  ajaxCall(url, success, function (jqXHR, textStatus, errorThrown) {\n    var message = (typeof errorThrown === \"string\") ? errorThrown : errorThrown.message;\n    error(message);\n  });\n}\n\nfunction ajaxCall(url, success, error) {\n  var $ = window.jQuery || window.Zepto || window.$;\n\n  if ($) {\n    $.ajax({\n      dataType: \"json\",\n      url: url,\n      success: success,\n      error: error,\n      complete: requestComplete\n    });\n  } else {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, true);\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n    xhr.onload = function () {\n      requestComplete();\n      if (xhr.status === 200) {\n        success(JSON.parse(xhr.responseText), xhr.statusText, xhr);\n      } else {\n        error(xhr, \"error\", xhr.statusText);\n      }\n    };\n    xhr.send();\n  }\n}\n\nvar config = (typeof window !== \"undefined\" && window.Chartkick) || {};\nvar adapters = [];\n\n// helpers\n\nfunction setText(element, text) {\n  if (document.body.innerText) {\n    element.innerText = text;\n  } else {\n    element.textContent = text;\n  }\n}\n\nfunction chartError(element, message) {\n  setText(element, \"Error Loading Chart: \" + message);\n  element.style.color = \"#ff0000\";\n}\n\nfunction errorCatcher(chart) {\n  try {\n    chart.__render();\n  } catch (err) {\n    chartError(chart.element, err.message);\n    throw err;\n  }\n}\n\nfunction fetchDataSource(chart, dataSource) {\n  if (typeof dataSource === \"string\") {\n    pushRequest(dataSource, function (data) {\n      chart.rawData = data;\n      errorCatcher(chart);\n    }, function (message) {\n      chartError(chart.element, message);\n    });\n  } else {\n    chart.rawData = dataSource;\n    errorCatcher(chart);\n  }\n}\n\nfunction addDownloadButton(chart) {\n  var element = chart.element;\n  var link = document.createElement(\"a\");\n  link.download = chart.options.download === true ? \"chart.png\" : chart.options.download; // http://caniuse.com/download\n  link.style.position = \"absolute\";\n  link.style.top = \"20px\";\n  link.style.right = \"20px\";\n  link.style.zIndex = 1000;\n  link.style.lineHeight = \"20px\";\n  link.target = \"_blank\"; // for safari\n  var image = document.createElement(\"img\");\n  image.alt = \"Download\";\n  image.style.border = \"none\";\n  // icon from font-awesome\n  // http://fa2png.io/\n  image.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAABCFBMVEUAAADMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMywEsqxAAAAV3RSTlMAAQIDBggJCgsMDQ4PERQaHB0eISIjJCouLzE0OTo/QUJHSUpLTU5PUllhYmltcHh5foWLjI+SlaCio6atr7S1t7m6vsHHyM7R2tze5Obo7fHz9ff5+/1hlxK2AAAA30lEQVQYGUXBhVYCQQBA0TdYWAt2d3d3YWAHyur7/z9xgD16Lw0DW+XKx+1GgX+FRzM3HWQWrHl5N/oapW5RPe0PkBu+UYeICvozTWZVK23Ao04B79oJrOsJDOoxkZoQPWgX29pHpCZEk7rEvQYiNSFq1UMqvlCjJkRBS1R8hb00Vb/TajtBL7nTHE1X1vyMQF732dQhyF2o6SAwrzP06iUQzvwsArlnzcOdrgBhJyHa1QOgO9U1GsKuvjUTjavliZYQ8nNPapG6sap/3nrIdJ6bOWzmX/fy0XVpfzZP3S8OJT3g9EEiJwAAAABJRU5ErkJggg==\";\n  link.appendChild(image);\n  element.style.position = \"relative\";\n\n  chart.__downloadAttached = true;\n\n  // mouseenter\n  chart.__enterEvent = addEvent(element, \"mouseover\", function(e) {\n    var related = e.relatedTarget;\n    // check download option again to ensure it wasn't changed\n    if ((!related || (related !== this && !childOf(this, related))) && chart.options.download) {\n      link.href = chart.toImage();\n      element.appendChild(link);\n    }\n  });\n\n  // mouseleave\n  chart.__leaveEvent = addEvent(element, \"mouseout\", function(e) {\n    var related = e.relatedTarget;\n    if (!related || (related !== this && !childOf(this, related))) {\n      if (link.parentNode) {\n        link.parentNode.removeChild(link);\n      }\n    }\n  });\n}\n\n// http://stackoverflow.com/questions/10149963/adding-event-listener-cross-browser\nfunction addEvent(elem, event, fn) {\n  if (elem.addEventListener) {\n    elem.addEventListener(event, fn, false);\n    return fn;\n  } else {\n    var fn2 = function() {\n      // set the this pointer same as addEventListener when fn is called\n      return(fn.call(elem, window.event));\n    };\n    elem.attachEvent(\"on\" + event, fn2);\n    return fn2;\n  }\n}\n\nfunction removeEvent(elem, event, fn) {\n  if (elem.removeEventListener) {\n    elem.removeEventListener(event, fn, false);\n  } else {\n    elem.detachEvent(\"on\" + event, fn);\n  }\n}\n\n// https://gist.github.com/shawnbot/4166283\nfunction childOf(p, c) {\n  if (p === c) { return false; }\n  while (c && c !== p) { c = c.parentNode; }\n  return c === p;\n}\n\nfunction getAdapterType(library) {\n  if (library) {\n    if (library.product === \"Highcharts\") {\n      return defaultExport$1;\n    } else if (library.setOnLoadCallback || library.charts) {\n      return defaultExport$2;\n    } else if (isFunction(library)) {\n      return defaultExport;\n    }\n  }\n  throw new Error(\"Unknown adapter\");\n}\n\nfunction addAdapter(library) {\n  var adapterType = getAdapterType(library);\n  var adapter = new adapterType(library);\n\n  if (adapters.indexOf(adapter) === -1) {\n    adapters.push(adapter);\n  }\n}\n\nfunction loadAdapters() {\n  if (\"Chart\" in window) {\n    addAdapter(window.Chart);\n  }\n\n  if (\"Highcharts\" in window) {\n    addAdapter(window.Highcharts);\n  }\n\n  if (window.google && (window.google.setOnLoadCallback || window.google.charts)) {\n    addAdapter(window.google);\n  }\n}\n\nfunction dataEmpty(data, chartType) {\n  if (chartType === \"PieChart\" || chartType === \"GeoChart\" || chartType === \"Timeline\") {\n    return data.length === 0;\n  } else {\n    for (var i = 0; i < data.length; i++) {\n      if (data[i].data.length > 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nfunction renderChart(chartType, chart) {\n  if (chart.options.messages && chart.options.messages.empty && dataEmpty(chart.data, chartType)) {\n    setText(chart.element, chart.options.messages.empty);\n  } else {\n    callAdapter(chartType, chart);\n    if (chart.options.download && !chart.__downloadAttached && chart.adapter === \"chartjs\") {\n      addDownloadButton(chart);\n    }\n  }\n}\n\n// TODO remove chartType if cross-browser way\n// to get the name of the chart class\nfunction callAdapter(chartType, chart) {\n  var i, adapter, fnName, adapterName;\n  fnName = \"render\" + chartType;\n  adapterName = chart.options.adapter;\n\n  loadAdapters();\n\n  for (i = 0; i < adapters.length; i++) {\n    adapter = adapters[i];\n    if ((!adapterName || adapterName === adapter.name) && isFunction(adapter[fnName])) {\n      chart.adapter = adapter.name;\n      chart.__adapterObject = adapter;\n      return adapter[fnName](chart);\n    }\n  }\n\n  if (adapters.length > 0) {\n    throw new Error(\"No charting library found for \" + chartType);\n  } else {\n    throw new Error(\"No charting libraries found - be sure to include one before your charts\");\n  }\n}\n\n// process data\n\nvar toFormattedKey = function (key, keyType) {\n  if (keyType === \"number\") {\n    key = toFloat(key);\n  } else if (keyType === \"datetime\") {\n    key = toDate(key);\n  } else {\n    key = toStr(key);\n  }\n  return key;\n};\n\nvar formatSeriesData = function (data, keyType) {\n  var r = [], key, j;\n  for (j = 0; j < data.length; j++) {\n    if (keyType === \"bubble\") {\n      r.push([toFloat(data[j][0]), toFloat(data[j][1]), toFloat(data[j][2])]);\n    } else {\n      key = toFormattedKey(data[j][0], keyType);\n      r.push([key, toFloat(data[j][1])]);\n    }\n  }\n  if (keyType === \"datetime\") {\n    r.sort(sortByTime);\n  } else if (keyType === \"number\") {\n    r.sort(sortByNumberSeries);\n  }\n  return r;\n};\n\nfunction detectDiscrete(series) {\n  var i, j, data;\n  for (i = 0; i < series.length; i++) {\n    data = toArr(series[i].data);\n    for (j = 0; j < data.length; j++) {\n      if (!isDate(data[j][0])) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// creates a shallow copy of each element of the array\n// elements are expected to be objects\nfunction copySeries(series) {\n  var newSeries = [], i, j;\n  for (i = 0; i < series.length; i++) {\n    var copy = {};\n    for (j in series[i]) {\n      if (series[i].hasOwnProperty(j)) {\n        copy[j] = series[i][j];\n      }\n    }\n    newSeries.push(copy);\n  }\n  return newSeries;\n}\n\nfunction processSeries(chart, keyType) {\n  var i;\n\n  var opts = chart.options;\n  var series = chart.rawData;\n\n  // see if one series or multiple\n  if (!isArray(series) || typeof series[0] !== \"object\" || isArray(series[0])) {\n    series = [{name: opts.label || \"Value\", data: series}];\n    chart.hideLegend = true;\n  } else {\n    chart.hideLegend = false;\n  }\n  if ((opts.discrete === null || opts.discrete === undefined) && keyType !== \"bubble\" && keyType !== \"number\") {\n    chart.discrete = detectDiscrete(series);\n  } else {\n    chart.discrete = opts.discrete;\n  }\n  if (chart.discrete) {\n    keyType = \"string\";\n  }\n  if (chart.options.xtype) {\n    keyType = chart.options.xtype;\n  }\n\n  // right format\n  series = copySeries(series);\n  for (i = 0; i < series.length; i++) {\n    series[i].data = formatSeriesData(toArr(series[i].data), keyType);\n  }\n\n  return series;\n}\n\nfunction processSimple(chart) {\n  var perfectData = toArr(chart.rawData), i;\n  for (i = 0; i < perfectData.length; i++) {\n    perfectData[i] = [toStr(perfectData[i][0]), toFloat(perfectData[i][1])];\n  }\n  return perfectData;\n}\n\n// define classes\n\nvar Chart = function Chart(element, dataSource, options) {\n  var elementId;\n  if (typeof element === \"string\") {\n    elementId = element;\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error(\"No element with id \" + elementId);\n    }\n  }\n  this.element = element;\n  this.options = merge(Chartkick.options, options || {});\n  this.dataSource = dataSource;\n\n  Chartkick.charts[element.id] = this;\n\n  fetchDataSource(this, dataSource);\n\n  if (this.options.refresh) {\n    this.startRefresh();\n  }\n};\n\nChart.prototype.getElement = function getElement () {\n  return this.element;\n};\n\nChart.prototype.getDataSource = function getDataSource () {\n  return this.dataSource;\n};\n\nChart.prototype.getData = function getData () {\n  return this.data;\n};\n\nChart.prototype.getOptions = function getOptions () {\n  return this.options;\n};\n\nChart.prototype.getChartObject = function getChartObject () {\n  return this.chart;\n};\n\nChart.prototype.getAdapter = function getAdapter () {\n  return this.adapter;\n};\n\nChart.prototype.updateData = function updateData (dataSource, options) {\n  this.dataSource = dataSource;\n  if (options) {\n    this.__updateOptions(options);\n  }\n  fetchDataSource(this, dataSource);\n};\n\nChart.prototype.setOptions = function setOptions (options) {\n  this.__updateOptions(options);\n  this.redraw();\n};\n\nChart.prototype.redraw = function redraw () {\n  fetchDataSource(this, this.rawData);\n};\n\nChart.prototype.refreshData = function refreshData () {\n  if (typeof this.dataSource === \"string\") {\n    // prevent browser from caching\n    var sep = this.dataSource.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n    var url = this.dataSource + sep + \"_=\" + (new Date()).getTime();\n    fetchDataSource(this, url);\n  }\n};\n\nChart.prototype.startRefresh = function startRefresh () {\n    var this$1 = this;\n\n  var refresh = this.options.refresh;\n\n  if (!this.intervalId) {\n    if (refresh) {\n      this.intervalId = setInterval( function () {\n        this$1.refreshData();\n      }, refresh * 1000);\n    } else {\n      throw new Error(\"No refresh interval\");\n    }\n  }\n};\n\nChart.prototype.stopRefresh = function stopRefresh () {\n  if (this.intervalId) {\n    clearInterval(this.intervalId);\n    this.intervalId = null;\n  }\n};\n\nChart.prototype.toImage = function toImage () {\n  if (this.adapter === \"chartjs\") {\n    return this.chart.toBase64Image();\n  } else {\n    return null;\n  }\n};\n\nChart.prototype.destroy = function destroy () {\n  if (this.__adapterObject) {\n    this.__adapterObject.destroy(this);\n  }\n\n  if (this.__enterEvent) {\n    removeEvent(this.element, \"mouseover\", this.__enterEvent);\n  }\n\n  if (this.__leaveEvent) {\n    removeEvent(this.element, \"mouseout\", this.__leaveEvent);\n  }\n};\n\nChart.prototype.__updateOptions = function __updateOptions (options) {\n  var updateRefresh = options.refresh && options.refresh !== this.options.refresh;\n  this.options = merge(Chartkick.options, options);\n  if (updateRefresh) {\n    this.stopRefresh();\n    this.startRefresh();\n  }\n};\n\nChart.prototype.__render = function __render () {\n  this.data = this.__processData();\n  renderChart(this.__chartName(), this);\n};\n\nChart.prototype.__config = function __config () {\n  return config;\n};\n\nvar LineChart = (function (Chart) {\n  function LineChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) LineChart.__proto__ = Chart;\n  LineChart.prototype = Object.create( Chart && Chart.prototype );\n  LineChart.prototype.constructor = LineChart;\n\n  LineChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"datetime\");\n  };\n\n  LineChart.prototype.__chartName = function __chartName () {\n    return \"LineChart\";\n  };\n\n  return LineChart;\n}(Chart));\n\nvar PieChart = (function (Chart) {\n  function PieChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) PieChart.__proto__ = Chart;\n  PieChart.prototype = Object.create( Chart && Chart.prototype );\n  PieChart.prototype.constructor = PieChart;\n\n  PieChart.prototype.__processData = function __processData () {\n    return processSimple(this);\n  };\n\n  PieChart.prototype.__chartName = function __chartName () {\n    return \"PieChart\";\n  };\n\n  return PieChart;\n}(Chart));\n\nvar ColumnChart = (function (Chart) {\n  function ColumnChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) ColumnChart.__proto__ = Chart;\n  ColumnChart.prototype = Object.create( Chart && Chart.prototype );\n  ColumnChart.prototype.constructor = ColumnChart;\n\n  ColumnChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"string\");\n  };\n\n  ColumnChart.prototype.__chartName = function __chartName () {\n    return \"ColumnChart\";\n  };\n\n  return ColumnChart;\n}(Chart));\n\nvar BarChart = (function (Chart) {\n  function BarChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) BarChart.__proto__ = Chart;\n  BarChart.prototype = Object.create( Chart && Chart.prototype );\n  BarChart.prototype.constructor = BarChart;\n\n  BarChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"string\");\n  };\n\n  BarChart.prototype.__chartName = function __chartName () {\n    return \"BarChart\";\n  };\n\n  return BarChart;\n}(Chart));\n\nvar AreaChart = (function (Chart) {\n  function AreaChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) AreaChart.__proto__ = Chart;\n  AreaChart.prototype = Object.create( Chart && Chart.prototype );\n  AreaChart.prototype.constructor = AreaChart;\n\n  AreaChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"datetime\");\n  };\n\n  AreaChart.prototype.__chartName = function __chartName () {\n    return \"AreaChart\";\n  };\n\n  return AreaChart;\n}(Chart));\n\nvar GeoChart = (function (Chart) {\n  function GeoChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) GeoChart.__proto__ = Chart;\n  GeoChart.prototype = Object.create( Chart && Chart.prototype );\n  GeoChart.prototype.constructor = GeoChart;\n\n  GeoChart.prototype.__processData = function __processData () {\n    return processSimple(this);\n  };\n\n  GeoChart.prototype.__chartName = function __chartName () {\n    return \"GeoChart\";\n  };\n\n  return GeoChart;\n}(Chart));\n\nvar ScatterChart = (function (Chart) {\n  function ScatterChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) ScatterChart.__proto__ = Chart;\n  ScatterChart.prototype = Object.create( Chart && Chart.prototype );\n  ScatterChart.prototype.constructor = ScatterChart;\n\n  ScatterChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"number\");\n  };\n\n  ScatterChart.prototype.__chartName = function __chartName () {\n    return \"ScatterChart\";\n  };\n\n  return ScatterChart;\n}(Chart));\n\nvar BubbleChart = (function (Chart) {\n  function BubbleChart () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) BubbleChart.__proto__ = Chart;\n  BubbleChart.prototype = Object.create( Chart && Chart.prototype );\n  BubbleChart.prototype.constructor = BubbleChart;\n\n  BubbleChart.prototype.__processData = function __processData () {\n    return processSeries(this, \"bubble\");\n  };\n\n  BubbleChart.prototype.__chartName = function __chartName () {\n    return \"BubbleChart\";\n  };\n\n  return BubbleChart;\n}(Chart));\n\nvar Timeline = (function (Chart) {\n  function Timeline () {\n    Chart.apply(this, arguments);\n  }\n\n  if ( Chart ) Timeline.__proto__ = Chart;\n  Timeline.prototype = Object.create( Chart && Chart.prototype );\n  Timeline.prototype.constructor = Timeline;\n\n  Timeline.prototype.__processData = function __processData () {\n    var i, data = this.rawData;\n    for (i = 0; i < data.length; i++) {\n      data[i][1] = toDate(data[i][1]);\n      data[i][2] = toDate(data[i][2]);\n    }\n    return data;\n  };\n\n  Timeline.prototype.__chartName = function __chartName () {\n    return \"Timeline\";\n  };\n\n  return Timeline;\n}(Chart));\n\nvar Chartkick = {\n  LineChart: LineChart,\n  PieChart: PieChart,\n  ColumnChart: ColumnChart,\n  BarChart: BarChart,\n  AreaChart: AreaChart,\n  GeoChart: GeoChart,\n  ScatterChart: ScatterChart,\n  BubbleChart: BubbleChart,\n  Timeline: Timeline,\n  charts: {},\n  configure: function (options) {\n    for (var key in options) {\n      if (options.hasOwnProperty(key)) {\n        config[key] = options[key];\n      }\n    }\n  },\n  eachChart: function (callback) {\n    for (var chartId in Chartkick.charts) {\n      if (Chartkick.charts.hasOwnProperty(chartId)) {\n        callback(Chartkick.charts[chartId]);\n      }\n    }\n  },\n  config: config,\n  options: {},\n  adapters: adapters,\n  addAdapter: addAdapter\n};\n\nexport default Chartkick;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chartkick/dist/chartkick.esm.js\n// module id = 1282\n// module chunks = 6","/**\n * @namespace Chart\n */\nvar Chart = require('./core/core')();\n\nChart.helpers = require('./helpers/index');\n\n// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\nrequire('./core/core.helpers')(Chart);\n\nChart.defaults = require('./core/core.defaults');\nChart.Element = require('./core/core.element');\nChart.elements = require('./elements/index');\nChart.Interaction = require('./core/core.interaction');\nChart.layouts = require('./core/core.layouts');\nChart.platform = require('./platforms/platform');\nChart.plugins = require('./core/core.plugins');\nChart.Ticks = require('./core/core.ticks');\n\nrequire('./core/core.animation')(Chart);\nrequire('./core/core.controller')(Chart);\nrequire('./core/core.datasetController')(Chart);\nrequire('./core/core.scaleService')(Chart);\nrequire('./core/core.scale')(Chart);\nrequire('./core/core.tooltip')(Chart);\n\nrequire('./scales/scale.linearbase')(Chart);\nrequire('./scales/scale.category')(Chart);\nrequire('./scales/scale.linear')(Chart);\nrequire('./scales/scale.logarithmic')(Chart);\nrequire('./scales/scale.radialLinear')(Chart);\nrequire('./scales/scale.time')(Chart);\n\n// Controllers must be loaded after elements\n// See Chart.core.datasetController.dataElementType\nrequire('./controllers/controller.bar')(Chart);\nrequire('./controllers/controller.bubble')(Chart);\nrequire('./controllers/controller.doughnut')(Chart);\nrequire('./controllers/controller.line')(Chart);\nrequire('./controllers/controller.polarArea')(Chart);\nrequire('./controllers/controller.radar')(Chart);\nrequire('./controllers/controller.scatter')(Chart);\n\nrequire('./charts/Chart.Bar')(Chart);\nrequire('./charts/Chart.Bubble')(Chart);\nrequire('./charts/Chart.Doughnut')(Chart);\nrequire('./charts/Chart.Line')(Chart);\nrequire('./charts/Chart.PolarArea')(Chart);\nrequire('./charts/Chart.Radar')(Chart);\nrequire('./charts/Chart.Scatter')(Chart);\n\n// Loading built-it plugins\nvar plugins = require('./plugins');\nfor (var k in plugins) {\n\tif (plugins.hasOwnProperty(k)) {\n\t\tChart.plugins.register(plugins[k]);\n\t}\n}\n\nChart.platform.initialize();\n\nmodule.exports = Chart;\nif (typeof window !== 'undefined') {\n\twindow.Chart = Chart;\n}\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Legend\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.Legend = plugins.legend._element;\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Title\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.Title = plugins.title._element;\n\n/**\n * Provided for backward compatibility, use Chart.plugins instead\n * @namespace Chart.pluginService\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\nChart.pluginService = Chart.plugins;\n\n/**\n * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n * effect, instead simply create/register plugins via plain JavaScript objects.\n * @interface Chart.PluginBase\n * @deprecated since version 2.5.0\n * @todo remove at version 3\n * @private\n */\nChart.PluginBase = Chart.Element.extend({});\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas instead.\n * @namespace Chart.canvasHelpers\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nChart.canvasHelpers = Chart.helpers.canvas;\n\n/**\n * Provided for backward compatibility, use Chart.layouts instead.\n * @namespace Chart.layoutService\n * @deprecated since version 2.8.0\n * @todo remove at version 3\n * @private\n */\nChart.layoutService = Chart.layouts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/chart.js\n// module id = 1283\n// module chunks = 6","'use strict';\n\nvar defaults = require('./core.defaults');\n\ndefaults._set('global', {\n\tresponsive: true,\n\tresponsiveAnimationDuration: 0,\n\tmaintainAspectRatio: true,\n\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\thover: {\n\t\tonHover: null,\n\t\tmode: 'nearest',\n\t\tintersect: true,\n\t\tanimationDuration: 400\n\t},\n\tonClick: null,\n\tdefaultColor: 'rgba(0,0,0,0.1)',\n\tdefaultFontColor: '#666',\n\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\tdefaultFontSize: 12,\n\tdefaultFontStyle: 'normal',\n\tshowLines: true,\n\n\t// Element defaults defined in element extensions\n\telements: {},\n\n\t// Layout options such as padding\n\tlayout: {\n\t\tpadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t}\n\t}\n});\n\nmodule.exports = function() {\n\n\t// Occupy the global variable of Chart, and create a simple base class\n\tvar Chart = function(item, config) {\n\t\tthis.construct(item, config);\n\t\treturn this;\n\t};\n\n\tChart.Chart = Chart;\n\n\treturn Chart;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.js\n// module id = 1284\n// module chunks = 6","'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easingEffects\n * @see http://www.robertpenner.com/easing/\n */\nvar effects = {\n\tlinear: function(t) {\n\t\treturn t;\n\t},\n\n\teaseInQuad: function(t) {\n\t\treturn t * t;\n\t},\n\n\teaseOutQuad: function(t) {\n\t\treturn -t * (t - 2);\n\t},\n\n\teaseInOutQuad: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t;\n\t\t}\n\t\treturn -0.5 * ((--t) * (t - 2) - 1);\n\t},\n\n\teaseInCubic: function(t) {\n\t\treturn t * t * t;\n\t},\n\n\teaseOutCubic: function(t) {\n\t\treturn (t = t - 1) * t * t + 1;\n\t},\n\n\teaseInOutCubic: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t + 2);\n\t},\n\n\teaseInQuart: function(t) {\n\t\treturn t * t * t * t;\n\t},\n\n\teaseOutQuart: function(t) {\n\t\treturn -((t = t - 1) * t * t * t - 1);\n\t},\n\n\teaseInOutQuart: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t;\n\t\t}\n\t\treturn -0.5 * ((t -= 2) * t * t * t - 2);\n\t},\n\n\teaseInQuint: function(t) {\n\t\treturn t * t * t * t * t;\n\t},\n\n\teaseOutQuint: function(t) {\n\t\treturn (t = t - 1) * t * t * t * t + 1;\n\t},\n\n\teaseInOutQuint: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t * t * t + 2);\n\t},\n\n\teaseInSine: function(t) {\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\n\t},\n\n\teaseOutSine: function(t) {\n\t\treturn Math.sin(t * (Math.PI / 2));\n\t},\n\n\teaseInOutSine: function(t) {\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\n\t},\n\n\teaseInExpo: function(t) {\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\n\t},\n\n\teaseOutExpo: function(t) {\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\n\t},\n\n\teaseInOutExpo: function(t) {\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * Math.pow(2, 10 * (t - 1));\n\t\t}\n\t\treturn 0.5 * (-Math.pow(2, -10 * --t) + 2);\n\t},\n\n\teaseInCirc: function(t) {\n\t\tif (t >= 1) {\n\t\t\treturn t;\n\t\t}\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\n\t},\n\n\teaseOutCirc: function(t) {\n\t\treturn Math.sqrt(1 - (t = t - 1) * t);\n\t},\n\n\teaseInOutCirc: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn -0.5 * (Math.sqrt(1 - t * t) - 1);\n\t\t}\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t},\n\n\teaseInElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t},\n\n\teaseOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n\t},\n\n\teaseInOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((t /= 0.5) === 2) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.45;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\tif (t < 1) {\n\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t\t}\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t},\n\teaseInBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn t * t * ((s + 1) * t - s);\n\t},\n\n\teaseOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\n\t},\n\n\teaseInOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t},\n\n\teaseInBounce: function(t) {\n\t\treturn 1 - effects.easeOutBounce(1 - t);\n\t},\n\n\teaseOutBounce: function(t) {\n\t\tif (t < (1 / 2.75)) {\n\t\t\treturn 7.5625 * t * t;\n\t\t}\n\t\tif (t < (2 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\n\t\t}\n\t\tif (t < (2.5 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\n\t\t}\n\t\treturn 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\n\t},\n\n\teaseInOutBounce: function(t) {\n\t\tif (t < 0.5) {\n\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\n\t\t}\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n\t}\n};\n\nmodule.exports = {\n\teffects: effects\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\n * @function Chart.helpers.easingEffects\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.easingEffects = effects;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/helpers/helpers.easing.js\n// module id = 1285\n// module chunks = 6","'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * @namespace Chart.helpers.canvas\n */\nvar exports = module.exports = {\n\t/**\n\t * Clears the entire canvas associated to the given `chart`.\n\t * @param {Chart} chart - The chart for which to clear the canvas.\n\t */\n\tclear: function(chart) {\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t},\n\n\t/**\n\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n\t * given size (width, height) and the same `radius` for all corners.\n\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n\t * @param {Number} x - The x axis of the coordinate for the rectangle starting point.\n\t * @param {Number} y - The y axis of the coordinate for the rectangle starting point.\n\t * @param {Number} width - The rectangle's width.\n\t * @param {Number} height - The rectangle's height.\n\t * @param {Number} radius - The rounded amount (in pixels) for the four corners.\n\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n\t */\n\troundedRect: function(ctx, x, y, width, height, radius) {\n\t\tif (radius) {\n\t\t\tvar rx = Math.min(radius, width / 2);\n\t\t\tvar ry = Math.min(radius, height / 2);\n\n\t\t\tctx.moveTo(x + rx, y);\n\t\t\tctx.lineTo(x + width - rx, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + ry);\n\t\t\tctx.lineTo(x + width, y + height - ry);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);\n\t\t\tctx.lineTo(x + rx, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - ry);\n\t\t\tctx.lineTo(x, y + ry);\n\t\t\tctx.quadraticCurveTo(x, y, x + rx, y);\n\t\t} else {\n\t\t\tctx.rect(x, y, width, height);\n\t\t}\n\t},\n\n\tdrawPoint: function(ctx, style, radius, x, y) {\n\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\n\t\tif (style && typeof style === 'object') {\n\t\t\ttype = style.toString();\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\tctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (style) {\n\t\t// Default includes circle\n\t\tdefault:\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'triangle':\n\t\t\tctx.beginPath();\n\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rect':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\tcase 'rectRounded':\n\t\t\tvar offset = radius / Math.SQRT2;\n\t\t\tvar leftX = x - offset;\n\t\t\tvar topY = y - offset;\n\t\t\tvar sideSize = Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tthis.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rectRot':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - size, y);\n\t\t\tctx.lineTo(x, y + size);\n\t\t\tctx.lineTo(x + size, y);\n\t\t\tctx.lineTo(x, y - size);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'cross':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'crossRot':\n\t\t\tctx.beginPath();\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'star':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'line':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'dash':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\t}\n\n\t\tctx.stroke();\n\t},\n\n\tclipArea: function(ctx, area) {\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\t\tctx.clip();\n\t},\n\n\tunclipArea: function(ctx) {\n\t\tctx.restore();\n\t},\n\n\tlineTo: function(ctx, previous, target, flip) {\n\t\tif (target.steppedLine) {\n\t\t\tif ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {\n\t\t\t\tctx.lineTo(previous.x, target.y);\n\t\t\t} else {\n\t\t\t\tctx.lineTo(target.x, previous.y);\n\t\t\t}\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target.tension) {\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tctx.bezierCurveTo(\n\t\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\n\t\t\ttarget.x,\n\t\t\ttarget.y);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\n * @namespace Chart.helpers.clear\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.clear = exports.clear;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\n * @namespace Chart.helpers.drawRoundedRectangle\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.drawRoundedRectangle = function(ctx) {\n\tctx.beginPath();\n\texports.roundedRect.apply(exports, arguments);\n\tctx.closePath();\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/helpers/helpers.canvas.js\n// module id = 1286\n// module chunks = 6","'use strict';\n\nvar helpers = require('./helpers.core');\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\nmodule.exports = {\n\t/**\n\t * Converts the given line height `value` in pixels for a specific font `size`.\n\t * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n\t * @param {Number} size - The font size (in pixels) used to resolve relative `value`.\n\t * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n\t * @since 2.7.0\n\t */\n\ttoLineHeight: function(value, size) {\n\t\tvar matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\t\tif (!matches || matches[1] === 'normal') {\n\t\t\treturn size * 1.2;\n\t\t}\n\n\t\tvalue = +matches[2];\n\n\t\tswitch (matches[3]) {\n\t\tcase 'px':\n\t\t\treturn value;\n\t\tcase '%':\n\t\t\tvalue /= 100;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn size * value;\n\t},\n\n\t/**\n\t * Converts the given value into a padding object with pre-computed width/height.\n\t * @param {Number|Object} value - If a number, set the value to all TRBL component,\n\t *  else, if and object, use defined properties and sets undefined ones to 0.\n\t * @returns {Object} The padding values (top, right, bottom, left, width, height)\n\t * @since 2.7.0\n\t */\n\ttoPadding: function(value) {\n\t\tvar t, r, b, l;\n\n\t\tif (helpers.isObject(value)) {\n\t\t\tt = +value.top || 0;\n\t\t\tr = +value.right || 0;\n\t\t\tb = +value.bottom || 0;\n\t\t\tl = +value.left || 0;\n\t\t} else {\n\t\t\tt = r = b = l = +value || 0;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: t,\n\t\t\tright: r,\n\t\t\tbottom: b,\n\t\t\tleft: l,\n\t\t\theight: t + b,\n\t\t\twidth: l + r\n\t\t};\n\t},\n\n\t/**\n\t * Evaluates the given `inputs` sequentially and returns the first defined value.\n\t * @param {Array[]} inputs - An array of values, falling back to the last value.\n\t * @param {Object} [context] - If defined and the current value is a function, the value\n\t * is called with `context` as first argument and the result becomes the new input.\n\t * @param {Number} [index] - If defined and the current value is an array, the value\n\t * at `index` become the new input.\n\t * @since 2.7.0\n\t */\n\tresolve: function(inputs, context, index) {\n\t\tvar i, ilen, value;\n\n\t\tfor (i = 0, ilen = inputs.length; i < ilen; ++i) {\n\t\t\tvalue = inputs[i];\n\t\t\tif (value === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (context !== undefined && typeof value === 'function') {\n\t\t\t\tvalue = value(context);\n\t\t\t}\n\t\t\tif (index !== undefined && helpers.isArray(value)) {\n\t\t\t\tvalue = value[index];\n\t\t\t}\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/helpers/helpers.options.js\n// module id = 1287\n// module chunks = 6","/* global window: false */\n/* global document: false */\n'use strict';\n\nvar color = require('chartjs-color');\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\n\nmodule.exports = function(Chart) {\n\n\t// -- Basic js utility methods\n\n\thelpers.configMerge = function(/* objects ... */) {\n\t\treturn helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tvar tval = target[key] || {};\n\t\t\t\tvar sval = source[key];\n\n\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t// scale config merging is complex. Add our own function here for that\n\t\t\t\t\ttarget[key] = helpers.scaleMerge(tval, sval);\n\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t// used in polar area & radar charts since there is only one scale\n\t\t\t\t\ttarget[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);\n\t\t\t\t} else {\n\t\t\t\t\thelpers._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\thelpers.scaleMerge = function(/* objects ... */) {\n\t\treturn helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t\tvar slen = source[key].length;\n\t\t\t\t\tvar i, type, scale;\n\n\t\t\t\t\tif (!target[key]) {\n\t\t\t\t\t\ttarget[key] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < slen; ++i) {\n\t\t\t\t\t\tscale = source[key][i];\n\t\t\t\t\t\ttype = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');\n\n\t\t\t\t\t\tif (i >= target[key].length) {\n\t\t\t\t\t\t\ttarget[key].push({});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\n\t\t\t\t\t\t\t// new/untyped scale or type changed: let's apply the new defaults\n\t\t\t\t\t\t\t// then merge source scale to correctly overwrite the defaults.\n\t\t\t\t\t\t\thelpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// scales type are the same\n\t\t\t\t\t\t\thelpers.merge(target[key][i], scale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thelpers._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\thelpers.where = function(collection, filterCallback) {\n\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\treturn collection.filter(filterCallback);\n\t\t}\n\t\tvar filtered = [];\n\n\t\thelpers.each(collection, function(item) {\n\t\t\tif (filterCallback(item)) {\n\t\t\t\tfiltered.push(item);\n\t\t\t}\n\t\t});\n\n\t\treturn filtered;\n\t};\n\thelpers.findIndex = Array.prototype.findIndex ?\n\t\tfunction(array, callback, scope) {\n\t\t\treturn array.findIndex(callback, scope);\n\t\t} :\n\t\tfunction(array, callback, scope) {\n\t\t\tscope = scope === undefined ? array : scope;\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to start of the array\n\t\tif (helpers.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = -1;\n\t\t}\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to end of the array\n\t\tif (helpers.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = arrayToSearch.length;\n\t\t}\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\n\t// -- Math methods\n\thelpers.isNumber = function(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\thelpers.almostEquals = function(x, y, epsilon) {\n\t\treturn Math.abs(x - y) < epsilon;\n\t};\n\thelpers.almostWhole = function(x, epsilon) {\n\t\tvar rounded = Math.round(x);\n\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t};\n\thelpers.max = function(array) {\n\t\treturn array.reduce(function(max, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.max(max, value);\n\t\t\t}\n\t\t\treturn max;\n\t\t}, Number.NEGATIVE_INFINITY);\n\t};\n\thelpers.min = function(array) {\n\t\treturn array.reduce(function(min, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.min(min, value);\n\t\t\t}\n\t\t\treturn min;\n\t\t}, Number.POSITIVE_INFINITY);\n\t};\n\thelpers.sign = Math.sign ?\n\t\tfunction(x) {\n\t\t\treturn Math.sign(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tx = +x; // convert to a number\n\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\treturn x > 0 ? 1 : -1;\n\t\t};\n\thelpers.log10 = Math.log10 ?\n\t\tfunction(x) {\n\t\t\treturn Math.log10(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tvar exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\n\t\t\t// Check for whole powers of 10,\n\t\t\t// which due to floating point rounding error should be corrected.\n\t\t\tvar powerOf10 = Math.round(exponent);\n\t\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\n\n\t\t\treturn isPowerOf10 ? powerOf10 : exponent;\n\t\t};\n\thelpers.toRadians = function(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t};\n\thelpers.toDegrees = function(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t};\n\t// Gets the angle from vertical upright to the point about a centre.\n\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x;\n\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\n\t\tvar radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t}\n\n\t\treturn {\n\t\t\tangle: angle,\n\t\t\tdistance: radialDistanceFromCenter\n\t\t};\n\t};\n\thelpers.distanceBetweenPoints = function(pt1, pt2) {\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t};\n\thelpers.aliasPixel = function(pixelWidth) {\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t};\n\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t// This function must also respect \"skipped\" points\n\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint;\n\t\tvar current = middlePoint;\n\t\tvar next = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\tvar s01 = d01 / (d01 + d12);\n\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t// If all points are the same, s01 & s02 will be inf\n\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\tvar fb = t * s12;\n\n\t\treturn {\n\t\t\tprevious: {\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t},\n\t\t\tnext: {\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t}\n\t\t};\n\t};\n\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\thelpers.splineCurveMonotone = function(points) {\n\t\t// This function calculates Bzier control points in a similar way than |splineCurve|,\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t// between the dataset discrete points due to the interpolation.\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\treturn {\n\t\t\t\tmodel: point._model,\n\t\t\t\tdeltaK: 0,\n\t\t\t\tmK: 0\n\t\t\t};\n\t\t});\n\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\tvar pointsLen = pointsWithTangents.length;\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t}\n\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\tpointCurrent.mK = 0;\n\t\t\t} else {\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t}\n\t\t}\n\n\t\t// Adjust tangents to ensure monotonic properties\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t}\n\n\t\t// Compute control points\n\t\tvar deltaX;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.nextItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t}\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t};\n\thelpers.previousItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t}\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t};\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\thelpers.niceNum = function(range, round) {\n\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\tvar fraction = range / Math.pow(10, exponent);\n\t\tvar niceFraction;\n\n\t\tif (round) {\n\t\t\tif (fraction < 1.5) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction < 3) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction < 7) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\t} else if (fraction <= 1.0) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\n\t\treturn niceFraction * Math.pow(10, exponent);\n\t};\n\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\thelpers.requestAnimFrame = (function() {\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn function(callback) {\n\t\t\t\tcallback();\n\t\t\t};\n\t\t}\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t}());\n\t// -- DOM methods\n\thelpers.getRelativePosition = function(evt, chart) {\n\t\tvar mouseX, mouseY;\n\t\tvar e = evt.originalEvent || evt;\n\t\tvar canvas = evt.currentTarget || evt.srcElement;\n\t\tvar boundingRect = canvas.getBoundingClientRect();\n\n\t\tvar touches = e.touches;\n\t\tif (touches && touches.length > 0) {\n\t\t\tmouseX = touches[0].clientX;\n\t\t\tmouseY = touches[0].clientY;\n\n\t\t} else {\n\t\t\tmouseX = e.clientX;\n\t\t\tmouseY = e.clientY;\n\t\t}\n\n\t\t// Scale mouse coordinates into canvas coordinates\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\n\t\treturn {\n\t\t\tx: mouseX,\n\t\t\ty: mouseY\n\t\t};\n\n\t};\n\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\tvar valueInPixels;\n\t\tif (typeof styleValue === 'string') {\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t// percentage * size in dimension\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t}\n\t\t} else {\n\t\t\tvalueInPixels = styleValue;\n\t\t}\n\n\t\treturn valueInPixels;\n\t}\n\n\t/**\n\t * Returns if the given value contains an effective constraint.\n\t * @private\n\t */\n\tfunction isConstrainedValue(value) {\n\t\treturn value !== undefined && value !== null && value !== 'none';\n\t}\n\n\t// Private helper to get a constraint dimension\n\t// @param domNode : the node to check the constraint on\n\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\tvar view = document.defaultView;\n\t\tvar parentNode = domNode.parentNode;\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\tif (hasCNode || hasCContainer) {\n\t\t\treturn Math.min(\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t}\n\n\t\treturn 'none';\n\t}\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintWidth = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t};\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintHeight = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t};\n\thelpers.getMaximumWidth = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tif (!container) {\n\t\t\treturn domNode.clientWidth;\n\t\t}\n\n\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\treturn isNaN(cw) ? w : Math.min(w, cw);\n\t};\n\thelpers.getMaximumHeight = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tif (!container) {\n\t\t\treturn domNode.clientHeight;\n\t\t}\n\n\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\treturn isNaN(ch) ? h : Math.min(h, ch);\n\t};\n\thelpers.getStyle = function(el, property) {\n\t\treturn el.currentStyle ?\n\t\t\tel.currentStyle[property] :\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t};\n\thelpers.retinaScale = function(chart, forceRatio) {\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;\n\t\tif (pixelRatio === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar canvas = chart.canvas;\n\t\tvar height = chart.height;\n\t\tvar width = chart.width;\n\n\t\tcanvas.height = height * pixelRatio;\n\t\tcanvas.width = width * pixelRatio;\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\tif (!canvas.style.height && !canvas.style.width) {\n\t\t\tcanvas.style.height = height + 'px';\n\t\t\tcanvas.style.width = width + 'px';\n\t\t}\n\t};\n\t// -- Canvas methods\n\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t};\n\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\tcache = cache || {};\n\t\tvar data = cache.data = cache.data || {};\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\tif (cache.font !== font) {\n\t\t\tdata = cache.data = {};\n\t\t\tgc = cache.garbageCollect = [];\n\t\t\tcache.font = font;\n\t\t}\n\n\t\tctx.font = font;\n\t\tvar longest = 0;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t// Undefined strings and arrays should not be measured\n\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\thelpers.each(thing, function(nestedThing) {\n\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar gcLen = gc.length / 2;\n\t\tif (gcLen > arrayOfThings.length) {\n\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\tdelete data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.measureText = function(ctx, data, gc, longest, string) {\n\t\tvar textWidth = data[string];\n\t\tif (!textWidth) {\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\tgc.push(string);\n\t\t}\n\t\tif (textWidth > longest) {\n\t\t\tlongest = textWidth;\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.numberOfLabelLines = function(arrayOfThings) {\n\t\tvar numberOfLines = 1;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn numberOfLines;\n\t};\n\n\thelpers.color = !color ?\n\t\tfunction(value) {\n\t\t\tconsole.error('Color.js not found!');\n\t\t\treturn value;\n\t\t} :\n\t\tfunction(value) {\n\t\t\t/* global CanvasGradient */\n\t\t\tif (value instanceof CanvasGradient) {\n\t\t\t\tvalue = defaults.global.defaultColor;\n\t\t\t}\n\n\t\t\treturn color(value);\n\t\t};\n\n\thelpers.getHoverColor = function(colorValue) {\n\t\t/* global CanvasPattern */\n\t\treturn (colorValue instanceof CanvasPattern) ?\n\t\t\tcolorValue :\n\t\t\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.helpers.js\n// module id = 1288\n// module chunks = 6","var conversions = require(\"./conversions\");\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chartjs-color/node_modules/color-convert/index.js\n// module id = 1289\n// module chunks = 6","/* MIT license */\n\nmodule.exports = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n}\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chartjs-color/node_modules/color-convert/conversions.js\n// module id = 1290\n// module chunks = 6","/* MIT license */\nvar colorNames = require('color-name');\n\nmodule.exports = {\n   getRgba: getRgba,\n   getHsla: getHsla,\n   getRgb: getRgb,\n   getHsl: getHsl,\n   getHwb: getHwb,\n   getAlpha: getAlpha,\n\n   hexString: hexString,\n   rgbString: rgbString,\n   rgbaString: rgbaString,\n   percentString: percentString,\n   percentaString: percentaString,\n   hslString: hslString,\n   hslaString: hslaString,\n   hwbString: hwbString,\n   keyword: keyword\n}\n\nfunction getRgba(string) {\n   if (!string) {\n      return;\n   }\n   var abbr =  /^#([a-fA-F0-9]{3})$/i,\n       hex =  /^#([a-fA-F0-9]{6})$/i,\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       keyword = /(\\w+)/;\n\n   var rgb = [0, 0, 0],\n       a = 1,\n       match = string.match(abbr);\n   if (match) {\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n   }\n   else if (match = string.match(hex)) {\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n   }\n   else if (match = string.match(rgba)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i + 1]);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(per)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n         return [0, 0, 0, 0];\n      }\n      rgb = colorNames[match[1]];\n      if (!rgb) {\n         return;\n      }\n   }\n\n   for (var i = 0; i < rgb.length; i++) {\n      rgb[i] = scale(rgb[i], 0, 255);\n   }\n   if (!a && a != 0) {\n      a = 1;\n   }\n   else {\n      a = scale(a, 0, 1);\n   }\n   rgb[3] = a;\n   return rgb;\n}\n\nfunction getHsla(string) {\n   if (!string) {\n      return;\n   }\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hsl);\n   if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]), 0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n   }\n}\n\nfunction getHwb(string) {\n   if (!string) {\n      return;\n   }\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hwb);\n   if (match) {\n    var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]), 0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n   }\n}\n\nfunction getRgb(string) {\n   var rgba = getRgba(string);\n   return rgba && rgba.slice(0, 3);\n}\n\nfunction getHsl(string) {\n  var hsla = getHsla(string);\n  return hsla && hsla.slice(0, 3);\n}\n\nfunction getAlpha(string) {\n   var vals = getRgba(string);\n   if (vals) {\n      return vals[3];\n   }\n   else if (vals = getHsla(string)) {\n      return vals[3];\n   }\n   else if (vals = getHwb(string)) {\n      return vals[3];\n   }\n}\n\n// generators\nfunction hexString(rgb) {\n   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\n              + hexDouble(rgb[2]);\n}\n\nfunction rgbString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return rgbaString(rgba, alpha);\n   }\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n}\n\nfunction rgbaString(rgba, alpha) {\n   if (alpha === undefined) {\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n   }\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n           + \", \" + alpha + \")\";\n}\n\nfunction percentString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return percentaString(rgba, alpha);\n   }\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n}\n\nfunction percentaString(rgba, alpha) {\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n}\n\nfunction hslString(hsla, alpha) {\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n      return hslaString(hsla, alpha);\n   }\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n}\n\nfunction hslaString(hsla, alpha) {\n   if (alpha === undefined) {\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n   }\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n           + alpha + \")\";\n}\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\nfunction hwbString(hwb, alpha) {\n   if (alpha === undefined) {\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\n   }\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n}\n\nfunction keyword(rgb) {\n  return reverseNames[rgb.slice(0, 3)];\n}\n\n// helpers\nfunction scale(num, min, max) {\n   return Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n  var str = num.toString(16).toUpperCase();\n  return (str.length < 2) ? \"0\" + str : str;\n}\n\n\n//create a list of reverse color names\nvar reverseNames = {};\nfor (var name in colorNames) {\n   reverseNames[colorNames[name]] = name;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chartjs-color-string/color-string.js\n// module id = 1291\n// module chunks = 6","'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/color-name/index.js\n// module id = 1292\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\telements: {\n\t\tarc: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: '#fff',\n\t\t\tborderWidth: 2\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tinLabelRange: function(mouseX) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t}\n\t\treturn false;\n\t},\n\n\tinRange: function(chartX, chartY) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});\n\t\t\tvar\tangle = pointRelativePosition.angle;\n\t\t\tvar distance = pointRelativePosition.distance;\n\n\t\t\t// Sanitise angle range\n\t\t\tvar startAngle = vm.startAngle;\n\t\t\tvar endAngle = vm.endAngle;\n\t\t\twhile (endAngle < startAngle) {\n\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle > endAngle) {\n\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle < startAngle) {\n\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t}\n\n\t\t\t// Check if within the range of the open/close angle\n\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle);\n\t\t\tvar withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\n\t\t\treturn (betweenAngles && withinRadius);\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\treturn {\n\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\n\t\tvar rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\n\t\treturn {\n\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t};\n\t},\n\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar sA = vm.startAngle;\n\t\tvar eA = vm.endAngle;\n\n\t\tctx.beginPath();\n\n\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\n\t\tctx.closePath();\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = vm.borderWidth;\n\n\t\tctx.fillStyle = vm.backgroundColor;\n\n\t\tctx.fill();\n\t\tctx.lineJoin = 'bevel';\n\n\t\tif (vm.borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/elements/element.arc.js\n// module id = 1293\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\nvar globalDefaults = defaults.global;\n\ndefaults._set('global', {\n\telements: {\n\t\tline: {\n\t\t\ttension: 0.4,\n\t\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\t\tborderWidth: 3,\n\t\t\tborderColor: globalDefaults.defaultColor,\n\t\t\tborderCapStyle: 'butt',\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0,\n\t\t\tborderJoinStyle: 'miter',\n\t\t\tcapBezierPoints: true,\n\t\t\tfill: true, // do we fill in the area between the line and its base axis\n\t\t}\n\t}\n});\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar vm = me._view;\n\t\tvar ctx = me._chart.ctx;\n\t\tvar spanGaps = vm.spanGaps;\n\t\tvar points = me._children.slice(); // clone array\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\tvar lastDrawnIndex = -1;\n\t\tvar index, current, previous, currentVM;\n\n\t\t// If we are looping, adding the first point again\n\t\tif (me._loop && points.length) {\n\t\t\tpoints.push(points[0]);\n\t\t}\n\n\t\tctx.save();\n\n\t\t// Stroke Line Options\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t// IE 9 and 10 do not support line dash\n\t\tif (ctx.setLineDash) {\n\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t}\n\n\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t// Stroke Line\n\t\tctx.beginPath();\n\t\tlastDrawnIndex = -1;\n\n\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\tcurrent = points[index];\n\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\tcurrentVM = current._view;\n\n\t\t\t// First point moves to it's starting position no matter what\n\t\t\tif (index === 0) {\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\thelpers.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t}\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.stroke();\n\t\tctx.restore();\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/elements/element.line.js\n// module id = 1294\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\nvar defaultColor = defaults.global.defaultColor;\n\ndefaults._set('global', {\n\telements: {\n\t\tpoint: {\n\t\t\tradius: 3,\n\t\t\tpointStyle: 'circle',\n\t\t\tbackgroundColor: defaultColor,\n\t\t\tborderColor: defaultColor,\n\t\t\tborderWidth: 1,\n\t\t\t// Hover\n\t\t\thitRadius: 1,\n\t\t\thoverRadius: 4,\n\t\t\thoverBorderWidth: 1\n\t\t}\n\t}\n});\n\nfunction xRange(mouseX) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\n}\n\nfunction yRange(mouseY) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;\n}\n\nmodule.exports = Element.extend({\n\tinRange: function(mouseX, mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t},\n\n\tinLabelRange: xRange,\n\tinXRange: xRange,\n\tinYRange: yRange,\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y,\n\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t};\n\t},\n\n\tdraw: function(chartArea) {\n\t\tvar vm = this._view;\n\t\tvar model = this._model;\n\t\tvar ctx = this._chart.ctx;\n\t\tvar pointStyle = vm.pointStyle;\n\t\tvar radius = vm.radius;\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\t\tvar color = helpers.color;\n\t\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n\t\tvar ratio = 0;\n\n\t\tif (vm.skip) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\tctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);\n\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\n\t\t// Cliping for Points.\n\t\t// going out from inner charArea?\n\t\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right * errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom * errMargin < model.y))) {\n\t\t\t// Point fade out\n\t\t\tif (model.x < chartArea.left) {\n\t\t\t\tratio = (x - model.x) / (chartArea.left - model.x);\n\t\t\t} else if (chartArea.right * errMargin < model.x) {\n\t\t\t\tratio = (model.x - x) / (model.x - chartArea.right);\n\t\t\t} else if (model.y < chartArea.top) {\n\t\t\t\tratio = (y - model.y) / (chartArea.top - model.y);\n\t\t\t} else if (chartArea.bottom * errMargin < model.y) {\n\t\t\t\tratio = (model.y - y) / (model.y - chartArea.bottom);\n\t\t\t}\n\t\t\tratio = Math.round(ratio * 100) / 100;\n\t\t\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n\t\t\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n\t\t}\n\n\t\thelpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/elements/element.point.js\n// module id = 1295\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\n\ndefaults._set('global', {\n\telements: {\n\t\trectangle: {\n\t\t\tbackgroundColor: defaults.global.defaultColor,\n\t\t\tborderColor: defaults.global.defaultColor,\n\t\t\tborderSkipped: 'bottom',\n\t\t\tborderWidth: 0\n\t\t}\n\t}\n});\n\nfunction isVertical(bar) {\n\treturn bar._view.width !== undefined;\n}\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param bar {Chart.Element.Rectangle} the bar\n * @return {Bounds} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar) {\n\tvar vm = bar._view;\n\tvar x1, x2, y1, y2;\n\n\tif (isVertical(bar)) {\n\t\t// vertical\n\t\tvar halfWidth = vm.width / 2;\n\t\tx1 = vm.x - halfWidth;\n\t\tx2 = vm.x + halfWidth;\n\t\ty1 = Math.min(vm.y, vm.base);\n\t\ty2 = Math.max(vm.y, vm.base);\n\t} else {\n\t\t// horizontal bar\n\t\tvar halfHeight = vm.height / 2;\n\t\tx1 = Math.min(vm.x, vm.base);\n\t\tx2 = Math.max(vm.x, vm.base);\n\t\ty1 = vm.y - halfHeight;\n\t\ty2 = vm.y + halfHeight;\n\t}\n\n\treturn {\n\t\tleft: x1,\n\t\ttop: y1,\n\t\tright: x2,\n\t\tbottom: y2\n\t};\n}\n\nmodule.exports = Element.extend({\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\tvar borderWidth = vm.borderWidth;\n\n\t\tif (!vm.horizontal) {\n\t\t\t// bar\n\t\t\tleft = vm.x - vm.width / 2;\n\t\t\tright = vm.x + vm.width / 2;\n\t\t\ttop = vm.y;\n\t\t\tbottom = vm.base;\n\t\t\tsignX = 1;\n\t\t\tsignY = bottom > top ? 1 : -1;\n\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tleft = vm.base;\n\t\t\tright = vm.x;\n\t\t\ttop = vm.y - vm.height / 2;\n\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\tsignX = right > left ? 1 : -1;\n\t\t\tsignY = 1;\n\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t}\n\n\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\tif (borderWidth) {\n\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\n\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\tvar borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n\t\t\tvar borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n\t\t\tvar borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n\t\t\t// not become a vertical line?\n\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\ttop = borderTop;\n\t\t\t\tbottom = borderBottom;\n\t\t\t}\n\t\t\t// not become a horizontal line?\n\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\tleft = borderLeft;\n\t\t\t\tright = borderRight;\n\t\t\t}\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.fillStyle = vm.backgroundColor;\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = borderWidth;\n\n\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t// | 1 2 |\n\t\t// | 0 3 |\n\t\tvar corners = [\n\t\t\t[left, bottom],\n\t\t\t[left, top],\n\t\t\t[right, top],\n\t\t\t[right, bottom]\n\t\t];\n\n\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\tif (startCorner === -1) {\n\t\t\tstartCorner = 0;\n\t\t}\n\n\t\tfunction cornerAt(index) {\n\t\t\treturn corners[(startCorner + index) % 4];\n\t\t}\n\n\t\t// Draw rectangle from 'startCorner'\n\t\tvar corner = cornerAt(0);\n\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\tfor (var i = 1; i < 4; i++) {\n\t\t\tcorner = cornerAt(i);\n\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t}\n\n\t\tctx.fill();\n\t\tif (borderWidth) {\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\theight: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.base - vm.y;\n\t},\n\n\tinRange: function(mouseX, mouseY) {\n\t\tvar inRange = false;\n\n\t\tif (this._view) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinLabelRange: function(mouseX, mouseY) {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar inRange = false;\n\t\tvar bounds = getBarBounds(me);\n\n\t\tif (isVertical(me)) {\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t} else {\n\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t}\n\n\t\treturn inRange;\n\t},\n\n\tinXRange: function(mouseX) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t},\n\n\tinYRange: function(mouseY) {\n\t\tvar bounds = getBarBounds(this);\n\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar x, y;\n\t\tif (isVertical(this)) {\n\t\t\tx = vm.x;\n\t\t\ty = (vm.y + vm.base) / 2;\n\t\t} else {\n\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\ty = vm.y;\n\t\t}\n\n\t\treturn {x: x, y: y};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/elements/element.rectangle.js\n// module id = 1296\n// module chunks = 6","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nmodule.exports = {\n\tacquireContext: function(item) {\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\treturn item && item.getContext('2d') || null;\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/platforms/platform.basic.js\n// module id = 1297\n// module chunks = 6","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\n'use strict';\n\nvar helpers = require('../helpers/index');\n\nvar EXPANDO_KEY = '$chartjs';\nvar CSS_PREFIX = 'chartjs-';\nvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\nvar CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\nvar ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nvar EVENT_TYPES = {\n\ttouchstart: 'mousedown',\n\ttouchmove: 'mousemove',\n\ttouchend: 'mouseup',\n\tpointerenter: 'mouseenter',\n\tpointerdown: 'mousedown',\n\tpointermove: 'mousemove',\n\tpointerup: 'mouseup',\n\tpointerleave: 'mouseout',\n\tpointerout: 'mouseout'\n};\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns {Number} Size in pixels or undefined if unknown.\n */\nfunction readUsedSize(element, property) {\n\tvar value = helpers.getStyle(element, property);\n\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\treturn matches ? Number(matches[1]) : undefined;\n}\n\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n */\nfunction initCanvas(canvas, config) {\n\tvar style = canvas.style;\n\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\tvar renderHeight = canvas.getAttribute('height');\n\tvar renderWidth = canvas.getAttribute('width');\n\n\t// Chart.js modifies some canvas values that we want to restore on destroy\n\tcanvas[EXPANDO_KEY] = {\n\t\tinitial: {\n\t\t\theight: renderHeight,\n\t\t\twidth: renderWidth,\n\t\t\tstyle: {\n\t\t\t\tdisplay: style.display,\n\t\t\t\theight: style.height,\n\t\t\t\twidth: style.width\n\t\t\t}\n\t\t}\n\t};\n\n\t// Force canvas to display as block to avoid extra space caused by inline\n\t// elements, which would interfere with the responsive resize process.\n\t// https://github.com/chartjs/Chart.js/issues/2538\n\tstyle.display = style.display || 'block';\n\n\tif (renderWidth === null || renderWidth === '') {\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\tif (displayWidth !== undefined) {\n\t\t\tcanvas.width = displayWidth;\n\t\t}\n\t}\n\n\tif (renderHeight === null || renderHeight === '') {\n\t\tif (canvas.style.height === '') {\n\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t} else {\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.height = displayHeight;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn canvas;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nvar supportsEventListenerOptions = (function() {\n\tvar supports = false;\n\ttry {\n\t\tvar options = Object.defineProperty({}, 'passive', {\n\t\t\tget: function() {\n\t\t\t\tsupports = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener('e', null, options);\n\t} catch (e) {\n\t\t// continue regardless of error\n\t}\n\treturn supports;\n}());\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nvar eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addEventListener(node, type, listener) {\n\tnode.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeEventListener(node, type, listener) {\n\tnode.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction createEvent(type, chart, x, y, nativeEvent) {\n\treturn {\n\t\ttype: type,\n\t\tchart: chart,\n\t\tnative: nativeEvent || null,\n\t\tx: x !== undefined ? x : null,\n\t\ty: y !== undefined ? y : null,\n\t};\n}\n\nfunction fromNativeEvent(event, chart) {\n\tvar type = EVENT_TYPES[event.type] || event.type;\n\tvar pos = helpers.getRelativePosition(event, chart);\n\treturn createEvent(type, chart, pos.x, pos.y, event);\n}\n\nfunction throttled(fn, thisArg) {\n\tvar ticking = false;\n\tvar args = [];\n\n\treturn function() {\n\t\targs = Array.prototype.slice.call(arguments);\n\t\tthisArg = thisArg || this;\n\n\t\tif (!ticking) {\n\t\t\tticking = true;\n\t\t\thelpers.requestAnimFrame.call(window, function() {\n\t\t\t\tticking = false;\n\t\t\t\tfn.apply(thisArg, args);\n\t\t\t});\n\t\t}\n\t};\n}\n\n// Implementation based on https://github.com/marcj/css-element-queries\nfunction createResizer(handler) {\n\tvar resizer = document.createElement('div');\n\tvar cls = CSS_PREFIX + 'size-monitor';\n\tvar maxSize = 1000000;\n\tvar style =\n\t\t'position:absolute;' +\n\t\t'left:0;' +\n\t\t'top:0;' +\n\t\t'right:0;' +\n\t\t'bottom:0;' +\n\t\t'overflow:hidden;' +\n\t\t'pointer-events:none;' +\n\t\t'visibility:hidden;' +\n\t\t'z-index:-1;';\n\n\tresizer.style.cssText = style;\n\tresizer.className = cls;\n\tresizer.innerHTML =\n\t\t'<div class=\"' + cls + '-expand\" style=\"' + style + '\">' +\n\t\t\t'<div style=\"' +\n\t\t\t\t'position:absolute;' +\n\t\t\t\t'width:' + maxSize + 'px;' +\n\t\t\t\t'height:' + maxSize + 'px;' +\n\t\t\t\t'left:0;' +\n\t\t\t\t'top:0\">' +\n\t\t\t'</div>' +\n\t\t'</div>' +\n\t\t'<div class=\"' + cls + '-shrink\" style=\"' + style + '\">' +\n\t\t\t'<div style=\"' +\n\t\t\t\t'position:absolute;' +\n\t\t\t\t'width:200%;' +\n\t\t\t\t'height:200%;' +\n\t\t\t\t'left:0; ' +\n\t\t\t\t'top:0\">' +\n\t\t\t'</div>' +\n\t\t'</div>';\n\n\tvar expand = resizer.childNodes[0];\n\tvar shrink = resizer.childNodes[1];\n\n\tresizer._reset = function() {\n\t\texpand.scrollLeft = maxSize;\n\t\texpand.scrollTop = maxSize;\n\t\tshrink.scrollLeft = maxSize;\n\t\tshrink.scrollTop = maxSize;\n\t};\n\tvar onScroll = function() {\n\t\tresizer._reset();\n\t\thandler();\n\t};\n\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n\n\treturn resizer;\n}\n\n// https://davidwalsh.name/detect-node-insertion\nfunction watchForRender(node, handler) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\tvar proxy = expando.renderProxy = function(e) {\n\t\tif (e.animationName === CSS_RENDER_ANIMATION) {\n\t\t\thandler();\n\t\t}\n\t};\n\n\thelpers.each(ANIMATION_START_EVENTS, function(type) {\n\t\taddEventListener(node, type, proxy);\n\t});\n\n\t// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\n\t// is removed then added back immediately (same animation frame?). Accessing the\n\t// `offsetParent` property will force a reflow and re-evaluate the CSS animation.\n\t// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\n\t// https://github.com/chartjs/Chart.js/issues/4737\n\texpando.reflow = !!node.offsetParent;\n\n\tnode.classList.add(CSS_RENDER_MONITOR);\n}\n\nfunction unwatchForRender(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar proxy = expando.renderProxy;\n\n\tif (proxy) {\n\t\thelpers.each(ANIMATION_START_EVENTS, function(type) {\n\t\t\tremoveEventListener(node, type, proxy);\n\t\t});\n\n\t\tdelete expando.renderProxy;\n\t}\n\n\tnode.classList.remove(CSS_RENDER_MONITOR);\n}\n\nfunction addResizeListener(node, listener, chart) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\n\t// Let's keep track of this added resizer and thus avoid DOM query when removing it.\n\tvar resizer = expando.resizer = createResizer(throttled(function() {\n\t\tif (expando.resizer) {\n\t\t\treturn listener(createEvent('resize', chart));\n\t\t}\n\t}));\n\n\t// The resizer needs to be attached to the node parent, so we first need to be\n\t// sure that `node` is attached to the DOM before injecting the resizer element.\n\twatchForRender(node, function() {\n\t\tif (expando.resizer) {\n\t\t\tvar container = node.parentNode;\n\t\t\tif (container && container !== resizer.parentNode) {\n\t\t\t\tcontainer.insertBefore(resizer, container.firstChild);\n\t\t\t}\n\n\t\t\t// The container size might have changed, let's reset the resizer state.\n\t\t\tresizer._reset();\n\t\t}\n\t});\n}\n\nfunction removeResizeListener(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar resizer = expando.resizer;\n\n\tdelete expando.resizer;\n\tunwatchForRender(node);\n\n\tif (resizer && resizer.parentNode) {\n\t\tresizer.parentNode.removeChild(resizer);\n\t}\n}\n\nfunction injectCSS(platform, css) {\n\t// http://stackoverflow.com/q/3922139\n\tvar style = platform._style || document.createElement('style');\n\tif (!platform._style) {\n\t\tplatform._style = style;\n\t\tcss = '/* Chart.js */\\n' + css;\n\t\tstyle.setAttribute('type', 'text/css');\n\t\tdocument.getElementsByTagName('head')[0].appendChild(style);\n\t}\n\n\tstyle.appendChild(document.createTextNode(css));\n}\n\nmodule.exports = {\n\t/**\n\t * This property holds whether this platform is enabled for the current environment.\n\t * Currently used by platform.js to select the proper implementation.\n\t * @private\n\t */\n\t_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n\tinitialize: function() {\n\t\tvar keyframes = 'from{opacity:0.99}to{opacity:1}';\n\n\t\tinjectCSS(this,\n\t\t\t// DOM rendering detection\n\t\t\t// https://davidwalsh.name/detect-node-insertion\n\t\t\t'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +\n\t\t\t'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +\n\t\t\t'.' + CSS_RENDER_MONITOR + '{' +\n\t\t\t\t'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +\n\t\t\t\t'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +\n\t\t\t'}'\n\t\t);\n\t},\n\n\tacquireContext: function(item, config) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.getElementById(item);\n\t\t} else if (item.length) {\n\t\t\t// Support for array based queries (such as jQuery)\n\t\t\titem = item[0];\n\t\t}\n\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\tvar context = item && item.getContext && item.getContext('2d');\n\n\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n\t\t// inside an iframe or when running in a protected environment. We could guess the\n\t\t// types from their toString() value but let's keep things flexible and assume it's\n\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\n\t\t// https://github.com/chartjs/Chart.js/issues/3887\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\n\t\t// https://github.com/chartjs/Chart.js/issues/4152\n\t\tif (context && context.canvas === item) {\n\t\t\tinitCanvas(item, config);\n\t\t\treturn context;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\treleaseContext: function(context) {\n\t\tvar canvas = context.canvas;\n\t\tif (!canvas[EXPANDO_KEY]) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar initial = canvas[EXPANDO_KEY].initial;\n\t\t['height', 'width'].forEach(function(prop) {\n\t\t\tvar value = initial[prop];\n\t\t\tif (helpers.isNullOrUndef(value)) {\n\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t} else {\n\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t}\n\t\t});\n\n\t\thelpers.each(initial.style || {}, function(value, key) {\n\t\t\tcanvas.style[key] = value;\n\t\t});\n\n\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\tcanvas.width = canvas.width;\n\n\t\tdelete canvas[EXPANDO_KEY];\n\t},\n\n\taddEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\taddResizeListener(canvas, listener, chart);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n\t\tvar proxies = expando.proxies || (expando.proxies = {});\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t};\n\n\t\taddEventListener(canvas, type, proxy);\n\t},\n\n\tremoveEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\tremoveResizeListener(canvas, listener);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || {};\n\t\tvar proxies = expando.proxies || {};\n\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\tif (!proxy) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveEventListener(canvas, type, proxy);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use EventTarget.addEventListener instead.\n * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n * @function Chart.helpers.addEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.addEvent = addEventListener;\n\n/**\n * Provided for backward compatibility, use EventTarget.removeEventListener instead.\n * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n * @function Chart.helpers.removeEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.removeEvent = removeEventListener;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/platforms/platform.dom.js\n// module id = 1298\n// module chunks = 6","/* global window: false */\n'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tanimation: {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.Animation = Element.extend({\n\t\tchart: null, // the animation associated chart instance\n\t\tcurrentStep: 0, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\n\t});\n\n\tChart.animationService = {\n\t\tframeDuration: 17,\n\t\tanimations: [],\n\t\tdropFrames: 0,\n\t\trequest: null,\n\n\t\t/**\n\t\t * @param {Chart} chart - The chart to animate.\n\t\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t\t * @param {Number} duration - The animation duration in ms.\n\t\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chart, animation, duration, lazy) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar i, ilen;\n\n\t\t\tanimation.chart = chart;\n\n\t\t\tif (!lazy) {\n\t\t\t\tchart.animating = true;\n\t\t\t}\n\n\t\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\n\t\t\t\tif (animations[i].chart === chart) {\n\t\t\t\t\tanimations[i] = animation;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(animation);\n\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (animations.length === 1) {\n\t\t\t\tthis.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\tcancelAnimation: function(chart) {\n\t\t\tvar index = helpers.findIndex(this.animations, function(animation) {\n\t\t\t\treturn animation.chart === chart;\n\t\t\t});\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchart.animating = false;\n\t\t\t}\n\t\t},\n\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\t\t\tvar startTime = Date.now();\n\t\t\tvar framesToDrop = 0;\n\n\t\t\tif (me.dropFrames > 1) {\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t}\n\n\t\t\tme.advance(1 + framesToDrop);\n\n\t\t\tvar endTime = Date.now();\n\n\t\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\n\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tadvance: function(count) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar animation, chart;\n\t\t\tvar i = 0;\n\n\t\t\twhile (i < animations.length) {\n\t\t\t\tanimation = animations[i];\n\t\t\t\tchart = animation.chart;\n\n\t\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\n\t\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n\n\t\t\t\thelpers.callback(animation.render, [chart, animation], chart);\n\t\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\n\n\t\t\t\tif (animation.currentStep >= animation.numSteps) {\n\t\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\t\tchart.animating = false;\n\t\t\t\t\tanimations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation instead\n\t * @prop Chart.Animation#animationObject\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'animationObject', {\n\t\tget: function() {\n\t\t\treturn this;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation#chart instead\n\t * @prop Chart.Animation#chartInstance\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'chartInstance', {\n\t\tget: function() {\n\t\t\treturn this.chart;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.chart = value;\n\t\t}\n\t});\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.animation.js\n// module id = 1299\n// module chunks = 6","'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\nvar Interaction = require('./core.interaction');\nvar layouts = require('./core.layouts');\nvar platform = require('../platforms/platform');\nvar plugins = require('./core.plugins');\n\nmodule.exports = function(Chart) {\n\n\t// Create a dictionary of chart types, to allow for extension of existing types\n\tChart.types = {};\n\n\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\tChart.instances = {};\n\n\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\tChart.controllers = {};\n\n\t/**\n\t * Initializes the given config with global and chart default values.\n\t */\n\tfunction initConfig(config) {\n\t\tconfig = config || {};\n\n\t\t// Do NOT use configMerge() for the data object because this method merges arrays\n\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\tvar data = config.data = config.data || {};\n\t\tdata.datasets = data.datasets || [];\n\t\tdata.labels = data.labels || [];\n\n\t\tconfig.options = helpers.configMerge(\n\t\t\tdefaults.global,\n\t\t\tdefaults[config.type],\n\t\t\tconfig.options || {});\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Updates the config of the chart\n\t * @param chart {Chart} chart to update the options for\n\t */\n\tfunction updateConfig(chart) {\n\t\tvar newOptions = chart.options;\n\n\t\thelpers.each(chart.scales, function(scale) {\n\t\t\tlayouts.removeBox(chart, scale);\n\t\t});\n\n\t\tnewOptions = helpers.configMerge(\n\t\t\tChart.defaults.global,\n\t\t\tChart.defaults[chart.config.type],\n\t\t\tnewOptions);\n\n\t\tchart.options = chart.config.options = newOptions;\n\t\tchart.ensureScalesHaveIDs();\n\t\tchart.buildOrUpdateScales();\n\t\t// Tooltip\n\t\tchart.tooltip._options = newOptions.tooltips;\n\t\tchart.tooltip.initialize();\n\t}\n\n\tfunction positionIsHorizontal(position) {\n\t\treturn position === 'top' || position === 'bottom';\n\t}\n\n\thelpers.extend(Chart.prototype, /** @lends Chart */ {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tconstruct: function(item, config) {\n\t\t\tvar me = this;\n\n\t\t\tconfig = initConfig(config);\n\n\t\t\tvar context = platform.acquireContext(item, config);\n\t\t\tvar canvas = context && context.canvas;\n\t\t\tvar height = canvas && canvas.height;\n\t\t\tvar width = canvas && canvas.width;\n\n\t\t\tme.id = helpers.uid();\n\t\t\tme.ctx = context;\n\t\t\tme.canvas = canvas;\n\t\t\tme.config = config;\n\t\t\tme.width = width;\n\t\t\tme.height = height;\n\t\t\tme.aspectRatio = height ? width / height : null;\n\t\t\tme.options = config.options;\n\t\t\tme._bufferedRender = false;\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n\t\t\t * the \"instance\" still need to be defined since it might be called from plugins.\n\t\t\t * @prop Chart#chart\n\t\t\t * @deprecated since version 2.6.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tme.chart = me;\n\t\t\tme.controller = me; // chart.chart.controller #inception\n\n\t\t\t// Add the chart instance to the global namespace\n\t\t\tChart.instances[me.id] = me;\n\n\t\t\t// Define alias to the config data: `chart.data === chart.config.data`\n\t\t\tObject.defineProperty(me, 'data', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn me.config.data;\n\t\t\t\t},\n\t\t\t\tset: function(value) {\n\t\t\t\t\tme.config.data = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!context || !canvas) {\n\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tme.initialize();\n\t\t\tme.update();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\n\t\t\t// Before init plugin notification\n\t\t\tplugins.notify(me, 'beforeInit');\n\n\t\t\thelpers.retinaScale(me, me.options.devicePixelRatio);\n\n\t\t\tme.bindEvents();\n\n\t\t\tif (me.options.responsive) {\n\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\tme.resize(true);\n\t\t\t}\n\n\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\tme.ensureScalesHaveIDs();\n\t\t\tme.buildOrUpdateScales();\n\t\t\tme.initToolTip();\n\n\t\t\t// After init plugin notification\n\t\t\tplugins.notify(me, 'afterInit');\n\n\t\t\treturn me;\n\t\t},\n\n\t\tclear: function() {\n\t\t\thelpers.canvas.clear(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tstop: function() {\n\t\t\t// Stops any current animation loop occurring\n\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tresize: function(silent) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n\n\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\n\t\t\t// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased\n\t\t\tvar newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));\n\t\t\tvar newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));\n\n\t\t\tif (me.width === newWidth && me.height === newHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcanvas.width = me.width = newWidth;\n\t\t\tcanvas.height = me.height = newHeight;\n\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\tcanvas.style.height = newHeight + 'px';\n\n\t\t\thelpers.retinaScale(me, options.devicePixelRatio);\n\n\t\t\tif (!silent) {\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tplugins.notify(me, 'resize', [newSize]);\n\n\t\t\t\t// Notify of resize\n\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t}\n\n\t\t\t\tme.stop();\n\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t}\n\t\t},\n\n\t\tensureScalesHaveIDs: function() {\n\t\t\tvar options = this.options;\n\t\t\tvar scalesOptions = options.scales || {};\n\t\t\tvar scaleOptions = options.scale;\n\n\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t});\n\n\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t});\n\n\t\t\tif (scaleOptions) {\n\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t */\n\t\tbuildOrUpdateScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar scales = me.scales || {};\n\t\t\tvar items = [];\n\t\t\tvar updated = Object.keys(scales).reduce(function(obj, id) {\n\t\t\t\tobj[id] = false;\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\n\t\t\tif (options.scales) {\n\t\t\t\titems = items.concat(\n\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n\t\t\t\t\t}),\n\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (options.scale) {\n\t\t\t\titems.push({\n\t\t\t\t\toptions: options.scale,\n\t\t\t\t\tdtype: 'radialLinear',\n\t\t\t\t\tisDefault: true,\n\t\t\t\t\tdposition: 'chartArea'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(items, function(item) {\n\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\tvar id = scaleOptions.id;\n\t\t\t\tvar scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);\n\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t\t}\n\n\t\t\t\tupdated[id] = true;\n\t\t\t\tvar scale = null;\n\t\t\t\tif (id in scales && scales[id].type === scaleType) {\n\t\t\t\t\tscale = scales[id];\n\t\t\t\t\tscale.options = scaleOptions;\n\t\t\t\t\tscale.ctx = me.ctx;\n\t\t\t\t\tscale.chart = me;\n\t\t\t\t} else {\n\t\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\t\tif (!scaleClass) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tscale = new scaleClass({\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: scaleType,\n\t\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\t\tchart: me\n\t\t\t\t\t});\n\t\t\t\t\tscales[scale.id] = scale;\n\t\t\t\t}\n\n\t\t\t\tscale.mergeTicksOptions();\n\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\tif (item.isDefault) {\n\t\t\t\t\tme.scale = scale;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// clear up discarded scales\n\t\t\thelpers.each(updated, function(hasUpdated, id) {\n\t\t\t\tif (!hasUpdated) {\n\t\t\t\t\tdelete scales[id];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.scales = scales;\n\n\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t},\n\n\t\tbuildOrUpdateControllers: function() {\n\t\t\tvar me = this;\n\t\t\tvar types = [];\n\t\t\tvar newControllers = [];\n\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\tvar type = dataset.type || me.config.type;\n\n\t\t\t\tif (meta.type && meta.type !== type) {\n\t\t\t\t\tme.destroyDatasetMeta(datasetIndex);\n\t\t\t\t\tmeta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t}\n\t\t\t\tmeta.type = type;\n\n\t\t\t\ttypes.push(meta.type);\n\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t\tmeta.controller.linkScales();\n\t\t\t\t} else {\n\t\t\t\t\tvar ControllerClass = Chart.controllers[meta.type];\n\t\t\t\t\tif (ControllerClass === undefined) {\n\t\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.controller = new ControllerClass(me, datasetIndex);\n\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\treturn newControllers;\n\t\t},\n\n\t\t/**\n\t\t * Reset the elements of all datasets\n\t\t * @private\n\t\t */\n\t\tresetElements: function() {\n\t\t\tvar me = this;\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t* Resets the chart back to it's state before the initial animation\n\t\t*/\n\t\treset: function() {\n\t\t\tthis.resetElements();\n\t\t\tthis.tooltip.initialize();\n\t\t},\n\n\t\tupdate: function(config) {\n\t\t\tvar me = this;\n\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tupdateConfig(me);\n\n\t\t\t// plugins options references might have change, let's invalidate the cache\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t\t\tplugins._invalidate(me);\n\n\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case the entire data object changed\n\t\t\tme.tooltip._data = me.data;\n\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t}, me);\n\n\t\t\tme.updateLayout();\n\n\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\tif (me.options.animation && me.options.animation.duration) {\n\t\t\t\thelpers.each(newControllers, function(controller) {\n\t\t\t\t\tcontroller.reset();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.updateDatasets();\n\n\t\t\t// Need to reset tooltip in case it is displayed with elements that are removed\n\t\t\t// after update.\n\t\t\tme.tooltip.initialize();\n\n\t\t\t// Last active contains items that were previously in the tooltip.\n\t\t\t// When we reset the tooltip, we need to clear it\n\t\t\tme.lastActive = [];\n\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\tplugins.notify(me, 'afterUpdate');\n\n\t\t\tif (me._bufferedRender) {\n\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\tduration: config.duration,\n\t\t\t\t\teasing: config.easing,\n\t\t\t\t\tlazy: config.lazy\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tme.render(config);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t\t * @private\n\t\t */\n\t\tupdateLayout: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlayouts.update(this, this.width, this.height);\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t\t * @method IPlugin#afterScaleUpdate\n\t\t\t * @deprecated since version 2.5.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tplugins.notify(me, 'afterScaleUpdate');\n\t\t\tplugins.notify(me, 'afterLayout');\n\t\t},\n\n\t\t/**\n\t\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDatasets: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.updateDataset(i);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsUpdate');\n\t\t},\n\n\t\t/**\n\t\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDataset: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.update();\n\n\t\t\tplugins.notify(me, 'afterDatasetUpdate', [args]);\n\t\t},\n\n\t\trender: function(config) {\n\t\t\tvar me = this;\n\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar duration = config.duration;\n\t\t\tvar lazy = config.lazy;\n\n\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar animationOptions = me.options.animation;\n\t\t\tvar onComplete = function(animation) {\n\t\t\t\tplugins.notify(me, 'afterRender');\n\t\t\t\thelpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\n\t\t\t};\n\n\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n\t\t\t\tvar animation = new Chart.Animation({\n\t\t\t\t\tnumSteps: (duration || animationOptions.duration) / 16.66, // 60 fps\n\t\t\t\t\teasing: config.easing || animationOptions.easing,\n\n\t\t\t\t\trender: function(chart, animationObject) {\n\t\t\t\t\t\tvar easingFunction = helpers.easing.effects[animationObject.easing];\n\t\t\t\t\t\tvar currentStep = animationObject.currentStep;\n\t\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\n\n\t\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n\t\t\t\t\t},\n\n\t\t\t\t\tonAnimationProgress: animationOptions.onProgress,\n\t\t\t\t\tonAnimationComplete: onComplete\n\t\t\t\t});\n\n\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t} else {\n\t\t\t\tme.draw();\n\n\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\n\t\t\t\tonComplete(new Chart.Animation({numSteps: 0, chart: me}));\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\n\t\tdraw: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tme.clear();\n\n\t\t\tif (helpers.isNullOrUndef(easingValue)) {\n\t\t\t\teasingValue = 1;\n\t\t\t}\n\n\t\t\tme.transition(easingValue);\n\n\t\t\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw all the scales\n\t\t\thelpers.each(me.boxes, function(box) {\n\t\t\t\tbox.draw(me.chartArea);\n\t\t\t}, me);\n\n\t\t\tif (me.scale) {\n\t\t\t\tme.scale.draw();\n\t\t\t}\n\n\t\t\tme.drawDatasets(easingValue);\n\t\t\tme._drawTooltip(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\ttransition: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tfor (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.tooltip.transition(easingValue);\n\t\t},\n\n\t\t/**\n\t\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDatasets: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw datasets reversed to support proper line stacking\n\t\t\tfor (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.drawDataset(i, easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDataset: function(index, easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.draw(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDatasetDraw', [args]);\n\t\t},\n\n\t\t/**\n\t\t * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\n\t\t * hook, in which case, plugins will not be called on `afterTooltipDraw`.\n\t\t * @private\n\t\t */\n\t\t_drawTooltip: function(easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\t\t\tvar args = {\n\t\t\t\ttooltip: tooltip,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttooltip.draw();\n\n\t\t\tplugins.notify(me, 'afterTooltipDraw', [args]);\n\t\t},\n\n\t\t// Get the single element that was clicked on\n\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\tgetElementAtEvent: function(e) {\n\t\t\treturn Interaction.modes.single(this, e);\n\t\t},\n\n\t\tgetElementsAtEvent: function(e) {\n\t\t\treturn Interaction.modes.label(this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtXAxis: function(e) {\n\t\t\treturn Interaction.modes['x-axis'](this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\t\tvar method = Interaction.modes[mode];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\treturn method(this, e, options);\n\t\t\t}\n\n\t\t\treturn [];\n\t\t},\n\n\t\tgetDatasetAtEvent: function(e) {\n\t\t\treturn Interaction.modes.dataset(this, e, {intersect: true});\n\t\t},\n\n\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\tif (!dataset._meta) {\n\t\t\t\tdataset._meta = {};\n\t\t\t}\n\n\t\t\tvar meta = dataset._meta[me.id];\n\t\t\tif (!meta) {\n\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tdata: [],\n\t\t\t\t\tdataset: null,\n\t\t\t\t\tcontroller: null,\n\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\txAxisID: null,\n\t\t\t\t\tyAxisID: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn meta;\n\t\t},\n\n\t\tgetVisibleDatasetCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t},\n\n\t\tgenerateLegend: function() {\n\t\t\treturn this.options.legendCallback(this);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroyDatasetMeta: function(datasetIndex) {\n\t\t\tvar id = this.id;\n\t\t\tvar dataset = this.data.datasets[datasetIndex];\n\t\t\tvar meta = dataset._meta && dataset._meta[id];\n\n\t\t\tif (meta) {\n\t\t\t\tmeta.controller.destroy();\n\t\t\t\tdelete dataset._meta[id];\n\t\t\t}\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tvar me = this;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar i, ilen;\n\n\t\t\tme.stop();\n\n\t\t\t// dataset controllers need to cleanup associated data\n\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.destroyDatasetMeta(i);\n\t\t\t}\n\n\t\t\tif (canvas) {\n\t\t\t\tme.unbindEvents();\n\t\t\t\thelpers.canvas.clear(me);\n\t\t\t\tplatform.releaseContext(me.ctx);\n\t\t\t\tme.canvas = null;\n\t\t\t\tme.ctx = null;\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'destroy');\n\n\t\t\tdelete Chart.instances[me.id];\n\t\t},\n\n\t\ttoBase64Image: function() {\n\t\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\n\t\t},\n\n\t\tinitToolTip: function() {\n\t\t\tvar me = this;\n\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t_chart: me,\n\t\t\t\t_chartInstance: me, // deprecated, backward compatibility\n\t\t\t\t_data: me.data,\n\t\t\t\t_options: me.options.tooltips\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners = {};\n\t\t\tvar listener = function() {\n\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t};\n\n\t\t\thelpers.each(me.options.events, function(type) {\n\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\tlisteners[type] = listener;\n\t\t\t});\n\n\t\t\t// Elements used to detect size change should not be injected for non responsive charts.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\tif (me.options.responsive) {\n\t\t\t\tlistener = function() {\n\t\t\t\t\tme.resize();\n\t\t\t\t};\n\n\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\tlisteners.resize = listener;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tunbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners;\n\t\t\tif (!listeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete me._listeners;\n\t\t\thelpers.each(listeners, function(listener, type) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t});\n\t\t},\n\n\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\tvar method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\tvar element, i, ilen;\n\n\t\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\t\telement = elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\teventHandler: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\n\t\t\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\tme._bufferedRender = true;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\tvar changed = me.handleEvent(e);\n\t\t\t// for smooth tooltip animations issue #4989\n\t\t\t// the tooltip should be the source of change\n\t\t\t// Animation check workaround:\n\t\t\t// tooltip._start will be null when tooltip isn't animating\n\t\t\tif (tooltip) {\n\t\t\t\tchanged = tooltip._start\n\t\t\t\t\t? tooltip.handleEvent(e)\n\t\t\t\t\t: changed | tooltip.handleEvent(e);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterEvent', [e]);\n\n\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\tif (bufferedRequest) {\n\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\tme.render(bufferedRequest);\n\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\tme.stop();\n\n\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\tme.render(me.options.hover.animationDuration, true);\n\t\t\t}\n\n\t\t\tme._bufferedRender = false;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\treturn me;\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event the event to handle\n\t\t * @return {Boolean} true if the chart needs to re-render\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options || {};\n\t\t\tvar hoverOptions = options.hover;\n\t\t\tvar changed = false;\n\n\t\t\tme.lastActive = me.lastActive || [];\n\n\t\t\t// Find Active Elements for hover and tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme.active = [];\n\t\t\t} else {\n\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t}\n\n\t\t\t// Invoke onHover hook\n\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\thelpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\n\n\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\tif (options.onClick) {\n\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\tif (me.lastActive.length) {\n\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t}\n\n\t\t\t// Built in hover styling\n\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t}\n\n\t\t\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\n\n\t\t\t// Remember Last Actives\n\t\t\tme.lastActive = me.active;\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart instead.\n\t * @class Chart.Controller\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.Controller = Chart;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.controller.js\n// module id = 1300\n// module chunks = 6","'use strict';\n\nvar helpers = require('../helpers/index');\n\nmodule.exports = function(Chart) {\n\n\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n\t/**\n\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n\t */\n\tfunction listenArrayEvents(array, listener) {\n\t\tif (array._chartjs) {\n\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\treturn;\n\t\t}\n\n\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: {\n\t\t\t\tlisteners: [listener]\n\t\t\t}\n\t\t});\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\tvar base = array[key];\n\n\t\t\tObject.defineProperty(array, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\t\thelpers.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the given array event listener and cleanup extra attached properties (such as\n\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n\t */\n\tfunction unlistenArrayEvents(array, listener) {\n\t\tvar stub = array._chartjs;\n\t\tif (!stub) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar listeners = stub.listeners;\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\tif (listeners.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tdelete array[key];\n\t\t});\n\n\t\tdelete array._chartjs;\n\t}\n\n\t// Base class for all dataset controllers (line, bar, etc)\n\tChart.DatasetController = function(chart, datasetIndex) {\n\t\tthis.initialize(chart, datasetIndex);\n\t};\n\n\thelpers.extend(Chart.DatasetController.prototype, {\n\n\t\t/**\n\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdatasetElementType: null,\n\n\t\t/**\n\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdataElementType: null,\n\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tme.chart = chart;\n\t\t\tme.index = datasetIndex;\n\t\t\tme.linkScales();\n\t\t\tme.addElements();\n\t\t},\n\n\t\tupdateIndex: function(datasetIndex) {\n\t\t\tthis.index = datasetIndex;\n\t\t},\n\n\t\tlinkScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\tif (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {\n\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t}\n\t\t\tif (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {\n\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t}\n\t\t},\n\n\t\tgetDataset: function() {\n\t\t\treturn this.chart.data.datasets[this.index];\n\t\t},\n\n\t\tgetMeta: function() {\n\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t},\n\n\t\tgetScaleForId: function(scaleID) {\n\t\t\treturn this.chart.scales[scaleID];\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.update(true);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._data) {\n\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t}\n\t\t},\n\n\t\tcreateMetaDataset: function() {\n\t\t\tvar me = this;\n\t\t\tvar type = me.datasetElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index\n\t\t\t});\n\t\t},\n\n\t\tcreateMetaData: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar type = me.dataElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index\n\t\t\t});\n\t\t},\n\n\t\taddElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data || [];\n\t\t\tvar metaData = meta.data;\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t}\n\n\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t},\n\n\t\taddElementAndReset: function(index) {\n\t\t\tvar element = this.createMetaData(index);\n\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\tthis.updateElement(element, index, true);\n\t\t},\n\n\t\tbuildOrUpdateElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t// the internal meta data accordingly.\n\t\t\tif (me._data !== data) {\n\t\t\t\tif (me._data) {\n\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t}\n\n\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\tme._data = data;\n\t\t\t}\n\n\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\tme.resyncElements();\n\t\t},\n\n\t\tupdate: helpers.noop,\n\n\t\ttransition: function(easingValue) {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].transition(easingValue);\n\t\t\t}\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.transition(easingValue);\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].draw();\n\t\t\t}\n\t\t},\n\n\t\tremoveHoverStyle: function(element, elementOpts) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar valueOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\tvar model = element._model;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t},\n\n\t\tsetHoverStyle: function(element) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar valueOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\tvar getHoverColor = helpers.getHoverColor;\n\t\t\tvar model = element._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tresyncElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data;\n\t\t\tvar numMeta = meta.data.length;\n\t\t\tvar numData = data.length;\n\n\t\t\tif (numData < numMeta) {\n\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t} else if (numData > numMeta) {\n\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinsertElements: function(start, count) {\n\t\t\tfor (var i = 0; i < count; ++i) {\n\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPush: function() {\n\t\t\tthis.insertElements(this.getDataset().data.length - 1, arguments.length);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPop: function() {\n\t\t\tthis.getMeta().data.pop();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataShift: function() {\n\t\t\tthis.getMeta().data.shift();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataSplice: function(start, count) {\n\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataUnshift: function() {\n\t\t\tthis.insertElements(0, arguments.length);\n\t\t}\n\t});\n\n\tChart.DatasetController.extend = helpers.inherits;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.datasetController.js\n// module id = 1301\n// module chunks = 6","'use strict';\n\nvar defaults = require('./core.defaults');\nvar helpers = require('../helpers/index');\nvar layouts = require('./core.layouts');\n\nmodule.exports = function(Chart) {\n\n\tChart.scaleService = {\n\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t// use the new chart options to grab the correct scale\n\t\tconstructors: {},\n\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t// old browsers\n\n\t\t// Scale config defaults\n\t\tdefaults: {},\n\t\tregisterScaleType: function(type, scaleConstructor, scaleDefaults) {\n\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\tthis.defaults[type] = helpers.clone(scaleDefaults);\n\t\t},\n\t\tgetScaleConstructor: function(type) {\n\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t},\n\t\tgetScaleDefaults: function(type) {\n\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};\n\t\t},\n\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\tvar me = this;\n\t\t\tif (me.defaults.hasOwnProperty(type)) {\n\t\t\t\tme.defaults[type] = helpers.extend(me.defaults[type], additions);\n\t\t\t}\n\t\t},\n\t\taddScalesToLayout: function(chart) {\n\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\thelpers.each(chart.scales, function(scale) {\n\t\t\t\t// Set ILayoutItem parameters for backwards compatibility\n\t\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\t\tscale.position = scale.options.position;\n\t\t\t\tscale.weight = scale.options.weight;\n\t\t\t\tlayouts.addBox(chart, scale);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.scaleService.js\n// module id = 1302\n// module chunks = 6","'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\nvar Ticks = require('./core.ticks');\n\ndefaults._set('scale', {\n\tdisplay: true,\n\tposition: 'left',\n\toffset: false,\n\n\t// grid line settings\n\tgridLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\tlineWidth: 1,\n\t\tdrawBorder: true,\n\t\tdrawOnChartArea: true,\n\t\tdrawTicks: true,\n\t\ttickMarkLength: 10,\n\t\tzeroLineWidth: 1,\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\tzeroLineBorderDash: [],\n\t\tzeroLineBorderDashOffset: 0.0,\n\t\toffsetGridLines: false,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\n\t// scale label\n\tscaleLabel: {\n\t\t// display property\n\t\tdisplay: false,\n\n\t\t// actual label\n\t\tlabelString: '',\n\n\t\t// line height\n\t\tlineHeight: 1.2,\n\n\t\t// top/bottom padding\n\t\tpadding: {\n\t\t\ttop: 4,\n\t\t\tbottom: 4\n\t\t}\n\t},\n\n\t// label settings\n\tticks: {\n\t\tbeginAtZero: false,\n\t\tminRotation: 0,\n\t\tmaxRotation: 50,\n\t\tmirror: false,\n\t\tpadding: 0,\n\t\treverse: false,\n\t\tdisplay: true,\n\t\tautoSkip: true,\n\t\tautoSkipPadding: 0,\n\t\tlabelOffset: 0,\n\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\tcallback: Ticks.formatters.values,\n\t\tminor: {},\n\t\tmajor: {}\n\t}\n});\n\nfunction labelsFromTicks(ticks) {\n\tvar labels = [];\n\tvar i, ilen;\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tlabels.push(ticks[i].label);\n\t}\n\n\treturn labels;\n}\n\nfunction getLineValue(scale, index, offsetGridLines) {\n\tvar lineValue = scale.getPixelForTick(index);\n\n\tif (offsetGridLines) {\n\t\tif (index === 0) {\n\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t}\n\t}\n\treturn lineValue;\n}\n\nmodule.exports = function(Chart) {\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar globalDefaults = defaults.global;\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tfunction parseLineHeight(options) {\n\t\treturn helpers.options.toLineHeight(\n\t\t\thelpers.valueOrDefault(options.lineHeight, 1.2),\n\t\t\thelpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));\n\t}\n\n\tChart.Scale = Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Returns the scale tick objects ({label, major})\n\t\t * @since 2.7\n\t\t */\n\t\tgetTicks: function() {\n\t\t\treturn this._ticks;\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tmergeTicksOptions: function() {\n\t\t\tvar ticks = this.options.ticks;\n\t\t\tif (ticks.minor === false) {\n\t\t\t\tticks.minor = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (ticks.major === false) {\n\t\t\t\tticks.major = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var key in ticks) {\n\t\t\t\tif (key !== 'major' && key !== 'minor') {\n\t\t\t\t\tif (typeof ticks.minor[key] === 'undefined') {\n\t\t\t\t\t\tticks.minor[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof ticks.major[key] === 'undefined') {\n\t\t\t\t\t\tticks.major[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\t\t\tvar i, ilen, labels, label, ticks, tick;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks - `this.ticks` is now DEPRECATED!\n\t\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n\t\t\t// and must not be accessed directly from outside this class. `this.ticks` being\n\t\t\t// around for long time and not marked as private, we can't change its structure\n\t\t\t// without unexpected breaking changes. If you need to access the scale ticks,\n\t\t\t// use scale.getTicks() instead.\n\n\t\t\tme.beforeBuildTicks();\n\n\t\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\n\t\t\t// we still support no return (`this.ticks` internally set by calling this method).\n\t\t\tticks = me.buildTicks() || [];\n\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\n\t\t\t// New implementations should return the formatted tick labels but for BACKWARD\n\t\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\n\t\t\t// this method and supposed to contain only string values).\n\t\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\n\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\n\n\t\t\t// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n\n\t\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\t\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\t\tlabel = labels[i];\n\t\t\t\ttick = ticks[i];\n\t\t\t\tif (!tick) {\n\t\t\t\t\tticks.push(tick = {\n\t\t\t\t\t\tlabel: label,\n\t\t\t\t\t\tmajor: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttick.label = label;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme._ticks = ticks;\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (labels.length && me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation, sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tvar scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);\n\t\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n\t\t\t\tvar deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += deltaHeight;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += deltaHeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\t\t\t\tvar tickPadding = me.options.ticks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * (tallestLabelHeightInLines - 1))\n\t\t\t\t\t\t+ lineSpace; // padding\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n\t\t\t\t\t// which means that the right padding is dominated by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\n\t\t\t\t\t// dominant factor here, so get that length first and account for padding\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// use lineSpace for consistency with horizontal axis\n\t\t\t\t\t\t// tickPadding is not implemented for horizontal\n\t\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\n\t\t\t\t\t}\n\n\t\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (helpers.isNullOrUndef(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof rawValue === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (rawValue) {\n\t\t\t\tif (this.isHorizontal()) {\n\t\t\t\t\tif (rawValue.x !== undefined) {\n\t\t\t\t\t\treturn this.getRightValue(rawValue.x);\n\t\t\t\t\t}\n\t\t\t\t} else if (rawValue.y !== undefined) {\n\t\t\t\t\treturn this.getRightValue(rawValue.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t/**\n\t\t * Used to get the value to display in the tooltip for the data at the given index\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param value\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t/**\n\t\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param pixel\n\t\t */\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the tick at the given index\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (offset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me._ticks.length - 1)));\n\t\t},\n\n\t\t/**\n\t\t * Utility for getting the pixel location of a percentage of scale\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForDecimal: function(decimal) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\t/**\n\t\t * Returns the pixel for the minimum chart value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t/**\n\t\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\n\t\t * @private\n\t\t */\n\t\t_autoSkip: function(ticks) {\n\t\t\tvar skipRatio;\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar optionTicks = me.options.ticks.minor;\n\t\t\tvar tickCount = ticks.length;\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\t\t\tvar result = [];\n\t\t\tvar i, tick, shouldSkip;\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && tickCount > maxTicks) {\n\t\t\t\t\tskipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < tickCount; i++) {\n\t\t\t\ttick = ticks[i];\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tshouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);\n\t\t\t\tif (shouldSkip && i !== tickCount - 1) {\n\t\t\t\t\t// leave tick in place but make sure it's not displayed (#4635)\n\t\t\t\t\tdelete tick.label;\n\t\t\t\t}\n\t\t\t\tresult.push(tick);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = defaults.global;\n\t\t\tvar optionTicks = options.ticks.minor;\n\t\t\tvar optionMajorTicks = options.ticks.major || optionTicks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n\t\t\tvar tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\t\t\tvar majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar majorTickFont = parseFontOptions(optionMajorTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\t\tvar scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tvar axisWidth = me.options.gridLines.lineWidth;\n\t\t\tvar xTickStart = options.position === 'right' ? me.right : me.right - axisWidth - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.right + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;\n\n\t\t\thelpers.each(ticks, function(tick, index) {\n\t\t\t\t// autoskipper skipped this tick (#4635)\n\t\t\t\tif (helpers.isNullOrUndef(tick.label)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar label = tick.label;\n\t\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\tborderDash = gridLines.zeroLineBorderDash;\n\t\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\tborderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\t\tborderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\t\t\t\tvar tickPadding = optionTicks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tvar labelYOffset = tl + tickPadding;\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'top' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\t\tlabelY = me.top + labelYOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'bottom' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\t\tlabelY = me.bottom - labelYOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (xLineValue < me.left) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\txLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom + axisWidth;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (yLineValue < me.top) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelY = me.getPixelForTick(index) + optionTicks.labelOffset;\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right + axisWidth;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tmajor: tick.major,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = itemToDraw.major ? majorTickFont.font : tickFont.font;\n\t\t\t\t\tcontext.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tvar lineCount = label.length;\n\t\t\t\t\t\tvar lineHeight = tickFont.size * 1.5;\n\t\t\t\t\t\tvar y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;\n\n\t\t\t\t\t\tfor (var i = 0; i < lineCount; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\t\t\t\tvar halfLineHeight = parseLineHeight(scaleLabel) / 2;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom'\n\t\t\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\n\t\t\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft\n\t\t\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left;\n\t\t\t\tvar x2 = me.right + axisWidth;\n\t\t\t\tvar y1 = me.top;\n\t\t\t\tvar y2 = me.bottom + axisWidth;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.scale.js\n// module id = 1303\n// module chunks = 6","'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\ttooltips: {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFontStyle: 'bold',\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleFontColor: '#fff',\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFontColor: '#fff',\n\t\tbodyAlign: 'left',\n\t\tfooterFontStyle: 'bold',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFontColor: '#fff',\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretPadding: 2,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tborderColor: 'rgba(0,0,0,0)',\n\t\tborderWidth: 0,\n\t\tcallbacks: {\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeTitle: helpers.noop,\n\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\t\t\t\tvar labels = data.labels;\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tvar item = tooltipItems[0];\n\n\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\t\t\tafterTitle: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tbeforeLabel: helpers.noop,\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel += ': ';\n\t\t\t\t}\n\t\t\t\tlabel += tooltipItem.yLabel;\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tlabelColor: function(tooltipItem, chart) {\n\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\tvar view = activeElement._view;\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tlabelTextColor: function() {\n\t\t\t\treturn this._options.bodyFontColor;\n\t\t\t},\n\t\t\tafterLabel: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tafterBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeFooter: helpers.noop,\n\t\t\tfooter: helpers.noop,\n\t\t\tafterFooter: helpers.noop\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\t/**\n \t * Helper method to merge the opacity into a color\n \t */\n\tfunction mergeOpacity(colorString, opacity) {\n\t\tvar color = helpers.color(colorString);\n\t\treturn color.alpha(opacity * color.alpha()).rgbaString();\n\t}\n\n\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\tfunction pushOrConcat(base, toPush) {\n\t\tif (toPush) {\n\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t// base = base.concat(toPush);\n\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t} else {\n\t\t\t\tbase.push(toPush);\n\t\t\t}\n\t\t}\n\n\t\treturn base;\n\t}\n\n\t// Private helper to create a tooltip item model\n\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t// @return : new tooltip item\n\tfunction createTooltipItem(element) {\n\t\tvar xScale = element._xScale;\n\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\tvar index = element._index;\n\t\tvar datasetIndex = element._datasetIndex;\n\n\t\treturn {\n\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tindex: index,\n\t\t\tdatasetIndex: datasetIndex,\n\t\t\tx: element._model.x,\n\t\t\ty: element._model.y\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the reset model for the tooltip\n\t * @param tooltipOpts {Object} the tooltip options\n\t */\n\tfunction getBaseModel(tooltipOpts) {\n\t\tvar globalDefaults = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\treturn {\n\t\t\t// Positioning\n\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t\t// Body\n\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\tbodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t\t// Title\n\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\ttitleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t\t// Footer\n\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\tfooterFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t\t// Appearance\n\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\topacity: 0,\n\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\tdisplayColors: tooltipOpts.displayColors,\n\t\t\tborderColor: tooltipOpts.borderColor,\n\t\t\tborderWidth: tooltipOpts.borderWidth\n\t\t};\n\t}\n\n\t/**\n\t * Get the size of the tooltip\n\t */\n\tfunction getTooltipSize(tooltip, model) {\n\t\tvar ctx = tooltip._chart.ctx;\n\n\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\tvar width = 0;\n\n\t\t// Count of all lines in the body\n\t\tvar body = model.body;\n\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t}, 0);\n\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\t\tvar titleLineCount = model.title.length;\n\t\tvar footerLineCount = model.footer.length;\n\t\tvar titleFontSize = model.titleFontSize;\n\t\tvar bodyFontSize = model.bodyFontSize;\n\t\tvar footerFontSize = model.footerFontSize;\n\n\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\theight += footerLineCount * (footerFontSize); // Footer Lines\n\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t\t// Title width\n\t\tvar widthPadding = 0;\n\t\tvar maxLineWidth = function(line) {\n\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t};\n\n\t\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\thelpers.each(model.title, maxLineWidth);\n\n\t\t// Body width\n\t\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t\t// Body lines may include some extra width due to the color box\n\t\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\t\thelpers.each(body, function(bodyItem) {\n\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t});\n\n\t\t// Reset back to 0\n\t\twidthPadding = 0;\n\n\t\t// Footer width\n\t\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\thelpers.each(model.footer, maxLineWidth);\n\n\t\t// Add padding\n\t\twidth += 2 * model.xPadding;\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the alignment of a tooltip given the size\n\t */\n\tfunction determineAlignment(tooltip, size) {\n\t\tvar model = tooltip._model;\n\t\tvar chart = tooltip._chart;\n\t\tvar chartArea = tooltip._chart.chartArea;\n\t\tvar xAlign = 'center';\n\t\tvar yAlign = 'center';\n\n\t\tif (model.y < size.height) {\n\t\t\tyAlign = 'top';\n\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\tyAlign = 'bottom';\n\t\t}\n\n\t\tvar lf, rf; // functions to determine left, right alignment\n\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\t\tif (yAlign === 'center') {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= midX;\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x > midX;\n\t\t\t};\n\t\t} else {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= (size.width / 2);\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t};\n\t\t}\n\n\t\tolf = function(x) {\n\t\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\n\t\t};\n\t\torf = function(x) {\n\t\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\n\t\t};\n\t\tyf = function(y) {\n\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t};\n\n\t\tif (lf(model.x)) {\n\t\t\txAlign = 'left';\n\n\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\tif (olf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t} else if (rf(model.x)) {\n\t\t\txAlign = 'right';\n\n\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\tif (orf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t}\n\n\t\tvar opts = tooltip._options;\n\t\treturn {\n\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t};\n\t}\n\n\t/**\n\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n\t */\n\tfunction getBackgroundPoint(vm, size, alignment, chart) {\n\t\t// Background Position\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\n\t\tvar caretSize = vm.caretSize;\n\t\tvar caretPadding = vm.caretPadding;\n\t\tvar cornerRadius = vm.cornerRadius;\n\t\tvar xAlign = alignment.xAlign;\n\t\tvar yAlign = alignment.yAlign;\n\t\tvar paddingAndSize = caretSize + caretPadding;\n\t\tvar radiusAndPadding = cornerRadius + caretPadding;\n\n\t\tif (xAlign === 'right') {\n\t\t\tx -= size.width;\n\t\t} else if (xAlign === 'center') {\n\t\t\tx -= (size.width / 2);\n\t\t\tif (x + size.width > chart.width) {\n\t\t\t\tx = chart.width - size.width;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (yAlign === 'top') {\n\t\t\ty += paddingAndSize;\n\t\t} else if (yAlign === 'bottom') {\n\t\t\ty -= size.height + paddingAndSize;\n\t\t} else {\n\t\t\ty -= (size.height / 2);\n\t\t}\n\n\t\tif (yAlign === 'center') {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx += paddingAndSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx -= paddingAndSize;\n\t\t\t}\n\t\t} else if (xAlign === 'left') {\n\t\t\tx -= radiusAndPadding;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx += radiusAndPadding;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\tChart.Tooltip = Element.extend({\n\t\tinitialize: function() {\n\t\t\tthis._model = getBaseModel(this._options);\n\t\t\tthis._lastActive = [];\n\t\t},\n\n\t\t// Get the title\n\t\t// Args are: (tooltipItem, data)\n\t\tgetTitle: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\t\tvar callbacks = opts.callbacks;\n\n\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n\t\t\tvar title = callbacks.title.apply(me, arguments);\n\t\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\tlines = pushOrConcat(lines, title);\n\t\t\tlines = pushOrConcat(lines, afterTitle);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBeforeBody: function() {\n\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBody: function(tooltipItems, data) {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\t\tvar bodyItems = [];\n\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tvar bodyItem = {\n\t\t\t\t\tbefore: [],\n\t\t\t\t\tlines: [],\n\t\t\t\t\tafter: []\n\t\t\t\t};\n\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\n\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t});\n\n\t\t\treturn bodyItems;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetAfterBody: function() {\n\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t// Args are: (tooltipItem, data)\n\t\tgetFooter: function() {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\n\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\tlines = pushOrConcat(lines, afterFooter);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\tupdate: function(changed) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\n\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t// which breaks any animations.\n\t\t\tvar existingModel = me._model;\n\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\tvar active = me._active;\n\n\t\t\tvar data = me._data;\n\n\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\tvar alignment = {\n\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t};\n\t\t\tvar backgroundPoint = {\n\t\t\t\tx: existingModel.x,\n\t\t\t\ty: existingModel.y\n\t\t\t};\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: existingModel.width,\n\t\t\t\theight: existingModel.height\n\t\t\t};\n\t\t\tvar tooltipPosition = {\n\t\t\t\tx: existingModel.caretX,\n\t\t\t\ty: existingModel.caretY\n\t\t\t};\n\n\t\t\tvar i, len;\n\n\t\t\tif (active.length) {\n\t\t\t\tmodel.opacity = 1;\n\n\t\t\t\tvar labelColors = [];\n\t\t\t\tvar labelTextColors = [];\n\t\t\t\ttooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);\n\n\t\t\t\tvar tooltipItems = [];\n\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\tif (opts.filter) {\n\t\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Determine colors for boxes\n\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n\t\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n\t\t\t\t});\n\n\n\t\t\t\t// Build the Text Lines\n\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t\t// Initial positioning and colors\n\t\t\t\tmodel.x = Math.round(tooltipPosition.x);\n\t\t\t\tmodel.y = Math.round(tooltipPosition.y);\n\t\t\t\tmodel.caretPadding = opts.caretPadding;\n\t\t\t\tmodel.labelColors = labelColors;\n\t\t\t\tmodel.labelTextColors = labelTextColors;\n\n\t\t\t\t// data points\n\t\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t// Final Size and Position\n\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n\t\t\t} else {\n\t\t\t\tmodel.opacity = 0;\n\t\t\t}\n\n\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\tmodel.x = backgroundPoint.x;\n\t\t\tmodel.y = backgroundPoint.y;\n\t\t\tmodel.width = tooltipSize.width;\n\t\t\tmodel.height = tooltipSize.height;\n\n\t\t\t// Point where the caret on the tooltip points to\n\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\tmodel.caretY = tooltipPosition.y;\n\n\t\t\tme._model = model;\n\n\t\t\tif (changed && opts.custom) {\n\t\t\t\topts.custom.call(me, model);\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\t\tdrawCaret: function(tooltipPoint, size) {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n\n\t\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t\t},\n\t\tgetCaretPosition: function(tooltipPoint, size, vm) {\n\t\t\tvar x1, x2, x3, y1, y2, y3;\n\t\t\tvar caretSize = vm.caretSize;\n\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar ptX = tooltipPoint.x;\n\t\t\tvar ptY = tooltipPoint.y;\n\t\t\tvar width = size.width;\n\t\t\tvar height = size.height;\n\n\t\t\tif (yAlign === 'center') {\n\t\t\t\ty2 = ptY + (height / 2);\n\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\t\ty3 = y2 - caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx2 = vm.caretX;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t}\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\ty1 = ptY;\n\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t\t// invert drawing order\n\t\t\t\t\tvar tmp = x3;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t\tx1 = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n\t\t},\n\t\tdrawTitle: function(pt, vm, ctx, opacity) {\n\t\t\tvar title = vm.title;\n\n\t\t\tif (title.length) {\n\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tvar titleFontSize = vm.titleFontSize;\n\t\t\t\tvar titleSpacing = vm.titleSpacing;\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\t\tvar i, len;\n\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdrawBody: function(pt, vm, ctx, opacity) {\n\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\tvar body = vm.body;\n\n\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\tctx.textBaseline = 'top';\n\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\t\t// Before Body\n\t\t\tvar xLinePadding = 0;\n\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t};\n\n\t\t\t// Before body lines\n\t\t\tctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);\n\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\n\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n\n\t\t\t// Draw body lines now\n\t\t\thelpers.each(body, function(bodyItem, i) {\n\t\t\t\tvar textColor = mergeOpacity(vm.labelTextColors[i], opacity);\n\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\n\t\t\t\thelpers.each(bodyItem.lines, function(line) {\n\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Border\n\t\t\t\t\t\tctx.lineWidth = 1;\n\t\t\t\t\t\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t});\n\n\t\t\t// Reset back to 0 for after body\n\t\t\txLinePadding = 0;\n\n\t\t\t// After body lines\n\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t},\n\t\tdrawFooter: function(pt, vm, ctx, opacity) {\n\t\t\tvar footer = vm.footer;\n\n\t\t\tif (footer.length) {\n\t\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\t\thelpers.each(footer, function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\n\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\tctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);\n\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar x = pt.x;\n\t\t\tvar y = pt.y;\n\t\t\tvar width = tooltipSize.width;\n\t\t\tvar height = tooltipSize.height;\n\t\t\tvar radius = vm.cornerRadius;\n\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\tif (yAlign === 'top') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\tif (yAlign === 'bottom') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.closePath();\n\n\t\t\tctx.fill();\n\n\t\t\tif (vm.borderWidth > 0) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm.opacity === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: vm.width,\n\t\t\t\theight: vm.height\n\t\t\t};\n\t\t\tvar pt = {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\n\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t\t// Truthy/falsey value for empty tooltip\n\t\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n\t\t\tif (this._options.enabled && hasTooltipContent) {\n\t\t\t\t// Draw Background\n\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n\n\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\tpt.y += vm.yPadding;\n\n\t\t\t\t// Titles\n\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\n\t\t\t\t// Body\n\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\n\t\t\t\t// Footer\n\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @returns {Boolean} true if the tooltip changed\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me._options;\n\t\t\tvar changed = false;\n\n\t\t\tme._lastActive = me._lastActive || [];\n\n\t\t\t// Find Active Elements for tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme._active = [];\n\t\t\t} else {\n\t\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t}\n\n\t\t\t// Remember Last Actives\n\t\t\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\n\n\t\t\t// Only handle target event on tooltip change\n\t\t\tif (changed) {\n\t\t\t\tme._lastActive = me._active;\n\n\t\t\t\tif (options.enabled || options.custom) {\n\t\t\t\t\tme._eventPosition = {\n\t\t\t\t\t\tx: e.x,\n\t\t\t\t\t\ty: e.y\n\t\t\t\t\t};\n\n\t\t\t\t\tme.update(true);\n\t\t\t\t\tme.pivot();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * @namespace Chart.Tooltip.positioners\n\t */\n\tChart.Tooltip.positioners = {\n\t\t/**\n\t\t * Average mode places the tooltip at the average position of the elements shown\n\t\t * @function Chart.Tooltip.positioners.average\n\t\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t\t * @returns {Point} tooltip position\n\t\t */\n\t\taverage: function(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, len;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar count = 0;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\tx += pos.x;\n\t\t\t\t\ty += pos.y;\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: Math.round(x / count),\n\t\t\t\ty: Math.round(y / count)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Gets the tooltip position nearest of the item nearest to the event position\n\t\t * @function Chart.Tooltip.positioners.nearest\n\t\t * @param elements {Chart.Element[]} the tooltip elements\n\t\t * @param eventPosition {Point} the position of the event in canvas coordinates\n\t\t * @returns {Point} the tooltip position\n\t\t */\n\t\tnearest: function(elements, eventPosition) {\n\t\t\tvar x = eventPosition.x;\n\t\t\tvar y = eventPosition.y;\n\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\tvar i, len, nearestElement;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nearestElement) {\n\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\tx = tp.x;\n\t\t\t\ty = tp.y;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/core/core.tooltip.js\n// module id = 1304\n// module chunks = 6","'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t// for details.\n\n\tvar spacing;\n\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\tspacing = generationOptions.stepSize;\n\t} else {\n\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t}\n\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t// If very close to our whole number, use it.\n\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\tniceMin = generationOptions.min;\n\t\t\tniceMax = generationOptions.max;\n\t\t}\n\t}\n\n\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t// If very close to our rounded value, use it.\n\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\tnumSpaces = Math.round(numSpaces);\n\t} else {\n\t\tnumSpaces = Math.ceil(numSpaces);\n\t}\n\n\tvar precision = 1;\n\tif (spacing < 1) {\n\t\tprecision = Math.pow(10, spacing.toString().length - 2);\n\t\tniceMin = Math.round(niceMin * precision) / precision;\n\t\tniceMax = Math.round(niceMax * precision) / precision;\n\t}\n\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\tfor (var j = 1; j < numSpaces; ++j) {\n\t\tticks.push(Math.round((niceMin + j * spacing) * precision) / precision);\n\t}\n\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar noop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\tgetRightValue: function(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn +value;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, value);\n\t\t},\n\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (setMin !== setMax) {\n\t\t\t\t// We set the min or the max but not both.\n\t\t\t\t// So ensure that our range is good\n\t\t\t\t// Inverted or 0 length range can happen when\n\t\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\t\tif (me.min >= me.max) {\n\t\t\t\t\tif (setMin) {\n\t\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/scales/scale.linearbase.js\n// module id = 1305\n// module chunks = 6","'use strict';\n\nmodule.exports = function(Chart) {\n\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);\n\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (offset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (offset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (offset) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value + me.minIndex;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/scales/scale.category.js\n// module id = 1306\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar DEFAULT_MIN = 0;\n\t\t\tvar DEFAULT_MAX = 1;\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n\t\t\tme.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t} else {\n\t\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/scales/scale.linear.js\n// module id = 1307\n// module chunks = 6","'use strict';\n\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t// Figure out what the max number of ticks we can support it is based on the size of\n\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t// the graph\n\tvar tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\tvar exp, significand;\n\n\tif (tickVal === 0) {\n\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\tticks.push(tickVal);\n\t\ttickVal = significand * Math.pow(10, exp);\n\t} else {\n\t\texp = Math.floor(helpers.log10(tickVal));\n\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t}\n\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n\tdo {\n\t\tticks.push(tickVal);\n\n\t\t++significand;\n\t\tif (significand === 10) {\n\t\t\tsignificand = 1;\n\t\t\t++exp;\n\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t}\n\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\tvar lastTick = valueOrDefault(generationOptions.max, tickVal);\n\tticks.push(lastTick);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tif (valuesForType.length > 0) {\n\t\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar DEFAULT_MIN = 1;\n\t\t\tvar DEFAULT_MAX = 10;\n\n\t\t\tme.min = valueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = valueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = DEFAULT_MIN;\n\t\t\t\t\tme.max = DEFAULT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);\n\t\t\t}\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = me.min !== 0\n\t\t\t\t\t? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)\n\t\t\t\t\t: DEFAULT_MAX;\n\t\t\t}\n\t\t\tif (me.minNotZero === null) {\n\t\t\t\tif (me.min > 0) {\n\t\t\t\t\tme.minNotZero = me.min;\n\t\t\t\t} else if (me.max < 1) {\n\t\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));\n\t\t\t\t} else {\n\t\t\t\t\tme.minNotZero = DEFAULT_MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar reverse = !me.isHorizontal();\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(generationOptions, me);\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\treverse = !reverse;\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t\tif (reverse) {\n\t\t\t\tticks.reverse();\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\t/**\n\t\t * Returns the value of the first tick.\n\t\t * @param {Number} value - The minimum not zero value.\n\t\t * @return {Number} The first tick value.\n\t\t * @private\n\t\t */\n\t\t_getFirstTickValue: function(value) {\n\t\t\tvar exp = Math.floor(helpers.log10(value));\n\t\t\tvar significand = Math.floor(value / Math.pow(10, exp));\n\n\t\t\treturn significand * Math.pow(10, exp);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar offset = 0;\n\t\t\tvar innerDimension, pixel, start, end, sign;\n\n\t\t\tvalue = +me.getRightValue(value);\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t\tsign = -1;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t\tsign = 1;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tpixel = reverse ? me.right : me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tsign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\t\t\t\tpixel = reverse ? me.top : me.bottom;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\toffset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\toffset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n\t\t\t\t}\n\t\t\t\tpixel += sign * offset;\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar reverse = me.options.ticks.reverse;\n\t\t\tvar log10 = helpers.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar innerDimension, start, end, value;\n\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = reverse ? me.right - pixel : pixel - me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = reverse ? pixel - me.top : me.bottom - pixel;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\tvar offset = helpers.getValueOrDefault(\n\t\t\t\t\t\tme.options.ticks.fontSize,\n\t\t\t\t\t\tChart.defaults.global.defaultFontSize\n\t\t\t\t\t);\n\t\t\t\t\tvalue -= offset;\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tvalue *= log10(end) - log10(start);\n\t\t\t\tvalue /= innerDimension;\n\t\t\t\tvalue = Math.pow(10, log10(start) + value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/scales/scale.logarithmic.js\n// module id = 1308\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar globalDefaults = defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\tgridLines: {\n\t\t\tcircular: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Boolean - if true, show point labels\n\t\t\tdisplay: true,\n\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\tvar opts = scale.options;\n\t\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tr: scale.width,\n\t\t\tl: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i, textSize, pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty += spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tif (pointLabelOpts.display) {\n\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);\n\t\t\t\tctx.font = plFont.font;\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.gridLines.circular) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.pointLabels.display) {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t} else {\n\t\t\t\tfit(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\n\t\t\tvar maxLeft = leftMovement + me.drawingArea;\n\t\t\tvar maxTop = topMovement + me.drawingArea;\n\t\t\tvar maxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.ticks.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\t\t\t\tvar startAngle = this.getIndexAngle(0);\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || tickOpts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\n\t\t\t\t\t\t\tctx.rotate(startAngle);\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\t-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/scales/scale.radialLinear.js\n// module id = 1309\n// module chunks = 6","/* global window: false */\n'use strict';\n\nvar moment = require('moment');\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nvar defaults = require('../core/core.defaults');\nvar helpers = require('../helpers/index');\n\n// Integer constants are from the ES6 spec.\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nvar INTERVALS = {\n\tmillisecond: {\n\t\tcommon: true,\n\t\tsize: 1,\n\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t},\n\tsecond: {\n\t\tcommon: true,\n\t\tsize: 1000,\n\t\tsteps: [1, 2, 5, 10, 30]\n\t},\n\tminute: {\n\t\tcommon: true,\n\t\tsize: 60000,\n\t\tsteps: [1, 2, 5, 10, 30]\n\t},\n\thour: {\n\t\tcommon: true,\n\t\tsize: 3600000,\n\t\tsteps: [1, 2, 3, 6, 12]\n\t},\n\tday: {\n\t\tcommon: true,\n\t\tsize: 86400000,\n\t\tsteps: [1, 2, 5]\n\t},\n\tweek: {\n\t\tcommon: false,\n\t\tsize: 604800000,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tmonth: {\n\t\tcommon: true,\n\t\tsize: 2.628e9,\n\t\tsteps: [1, 2, 3]\n\t},\n\tquarter: {\n\t\tcommon: false,\n\t\tsize: 7.884e9,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tyear: {\n\t\tcommon: true,\n\t\tsize: 3.154e10\n\t}\n};\n\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n\treturn a - b;\n}\n\nfunction arrayUnique(items) {\n\tvar hash = {};\n\tvar out = [];\n\tvar i, ilen, item;\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\titem = items[i];\n\t\tif (!hash[item]) {\n\t\t\thash[item] = true;\n\t\t\tout.push(item);\n\t\t}\n\t}\n\n\treturn out;\n}\n\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\nfunction buildLookupTable(timestamps, min, max, distribution) {\n\tif (distribution === 'linear' || !timestamps.length) {\n\t\treturn [\n\t\t\t{time: min, pos: 0},\n\t\t\t{time: max, pos: 1}\n\t\t];\n\t}\n\n\tvar table = [];\n\tvar items = [min];\n\tvar i, ilen, prev, curr, next;\n\n\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\tcurr = timestamps[i];\n\t\tif (curr > min && curr < max) {\n\t\t\titems.push(curr);\n\t\t}\n\t}\n\n\titems.push(max);\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\tnext = items[i + 1];\n\t\tprev = items[i - 1];\n\t\tcurr = items[i];\n\n\t\t// only add points that breaks the scale linearity\n\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\n\t\t}\n\t}\n\n\treturn table;\n}\n\n// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\nfunction lookup(table, key, value) {\n\tvar lo = 0;\n\tvar hi = table.length - 1;\n\tvar mid, i0, i1;\n\n\twhile (lo >= 0 && lo <= hi) {\n\t\tmid = (lo + hi) >> 1;\n\t\ti0 = table[mid - 1] || null;\n\t\ti1 = table[mid];\n\n\t\tif (!i0) {\n\t\t\t// given value is outside table (before first item)\n\t\t\treturn {lo: null, hi: i1};\n\t\t} else if (i1[key] < value) {\n\t\t\tlo = mid + 1;\n\t\t} else if (i0[key] > value) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\treturn {lo: i0, hi: i1};\n\t\t}\n\t}\n\n\t// given value is outside table (after last item)\n\treturn {lo: i1, hi: null};\n}\n\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\nfunction interpolate(table, skey, sval, tkey) {\n\tvar range = lookup(table, skey, sval);\n\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n\n\tvar span = next[skey] - prev[skey];\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\n\n\treturn prev[tkey] + offset;\n}\n\n/**\n * Convert the given value to a moment object using the given time options.\n * @see http://momentjs.com/docs/#/parsing/\n */\nfunction momentify(value, options) {\n\tvar parser = options.parser;\n\tvar format = options.parser || options.format;\n\n\tif (typeof parser === 'function') {\n\t\treturn parser(value);\n\t}\n\n\tif (typeof value === 'string' && typeof format === 'string') {\n\t\treturn moment(value, format);\n\t}\n\n\tif (!(value instanceof moment)) {\n\t\tvalue = moment(value);\n\t}\n\n\tif (value.isValid()) {\n\t\treturn value;\n\t}\n\n\t// Labels are in an incompatible moment format and no `parser` has been provided.\n\t// The user might still use the deprecated `format` option to convert his inputs.\n\tif (typeof format === 'function') {\n\t\treturn format(value);\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, scale) {\n\tif (helpers.isNullOrUndef(input)) {\n\t\treturn null;\n\t}\n\n\tvar options = scale.options.time;\n\tvar value = momentify(scale.getRightValue(input), options);\n\tif (!value.isValid()) {\n\t\treturn null;\n\t}\n\n\tif (options.round) {\n\t\tvalue.startOf(options.round);\n\t}\n\n\treturn value.valueOf();\n}\n\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\nfunction determineStepSize(min, max, unit, capacity) {\n\tvar range = max - min;\n\tvar interval = INTERVALS[unit];\n\tvar milliseconds = interval.size;\n\tvar steps = interval.steps;\n\tvar i, ilen, factor;\n\n\tif (!steps) {\n\t\treturn Math.ceil(range / (capacity * milliseconds));\n\t}\n\n\tfor (i = 0, ilen = steps.length; i < ilen; ++i) {\n\t\tfactor = steps[i];\n\t\tif (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn factor;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\tvar ilen = UNITS.length;\n\tvar i, interval, factor;\n\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\tinterval = INTERVALS[UNITS[i]];\n\t\tfactor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n\n\treturn UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n */\nfunction determineUnitForFormatting(ticks, minUnit, min, max) {\n\tvar duration = moment.duration(moment(max).diff(moment(min)));\n\tvar ilen = UNITS.length;\n\tvar i, unit;\n\n\tfor (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\tunit = UNITS[i];\n\t\tif (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {\n\t\t\treturn unit;\n\t\t}\n\t}\n\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n}\n\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\nfunction generate(min, max, capacity, options) {\n\tvar timeOpts = options.time;\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n\tvar major = determineMajorUnit(minor);\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\tvar majorTicksEnabled = options.ticks.major.enabled;\n\tvar interval = INTERVALS[minor];\n\tvar first = moment(min);\n\tvar last = moment(max);\n\tvar ticks = [];\n\tvar time;\n\n\tif (!stepSize) {\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\n\t}\n\n\t// For 'week' unit, handle the first day of week option\n\tif (weekday) {\n\t\tfirst = first.isoWeekday(weekday);\n\t\tlast = last.isoWeekday(weekday);\n\t}\n\n\t// Align first/last ticks on unit\n\tfirst = first.startOf(weekday ? 'day' : minor);\n\tlast = last.startOf(weekday ? 'day' : minor);\n\n\t// Make sure that the last tick include max\n\tif (last < max) {\n\t\tlast.add(1, minor);\n\t}\n\n\ttime = moment(first);\n\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\n\t\t// we first aligned time on the previous `major` unit then add the number of full\n\t\t// stepSize there is between first and the previous major time.\n\t\ttime.startOf(major);\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n\t}\n\n\tfor (; time < last; time.add(stepSize, minor)) {\n\t\tticks.push(+time);\n\t}\n\n\tticks.push(+time);\n\n\treturn ticks;\n}\n\n/**\n * Returns the right and left offsets from edges in the form of {left, right}.\n * Offsets are added when the `offset` option is true.\n */\nfunction computeOffsets(table, ticks, min, max, options) {\n\tvar left = 0;\n\tvar right = 0;\n\tvar upper, lower;\n\n\tif (options.offset && ticks.length) {\n\t\tif (!options.time.min) {\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\n\t\t\tlower = ticks[0];\n\t\t\tleft = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t\tif (!options.time.max) {\n\t\t\tupper = ticks[ticks.length - 1];\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\n\t\t\tright = (\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\n\t\t\t) / 2;\n\t\t}\n\t}\n\n\treturn {left: left, right: right};\n}\n\nfunction ticksFromTimestamps(values, majorUnit) {\n\tvar ticks = [];\n\tvar i, ilen, value, major;\n\n\tfor (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\tvalue = values[i];\n\t\tmajor = majorUnit ? value === +moment(value).startOf(majorUnit) : false;\n\n\t\tticks.push({\n\t\t\tvalue: value,\n\t\t\tmajor: major\n\t\t});\n\t}\n\n\treturn ticks;\n}\n\nfunction determineLabelFormat(data, timeOpts) {\n\tvar i, momentDate, hasTime;\n\tvar ilen = data.length;\n\n\t// find the label with the most parts (milliseconds, minutes, etc.)\n\t// format all labels with the same level of detail as the most specific label\n\tfor (i = 0; i < ilen; i++) {\n\t\tmomentDate = momentify(data[i], timeOpts);\n\t\tif (momentDate.millisecond() !== 0) {\n\t\t\treturn 'MMM D, YYYY h:mm:ss.SSS a';\n\t\t}\n\t\tif (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\n\t\t\thasTime = true;\n\t\t}\n\t}\n\tif (hasTime) {\n\t\treturn 'MMM D, YYYY h:mm:ss a';\n\t}\n\treturn 'MMM D, YYYY';\n}\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\t/**\n\t\t * Data distribution along the scale:\n\t\t * - 'linear': data are spread according to their time (distances can vary),\n\t\t * - 'series': data are spread at the same distance from each other.\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t * @since 2.7.0\n\t\t */\n\t\tdistribution: 'linear',\n\n\t\t/**\n\t\t * Scale boundary strategy (bypassed by min/max time options)\n\t\t * - `data`: make sure data are fully visible, ticks outside are removed\n\t\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4556\n\t\t * @since 2.7.0\n\t\t */\n\t\tbounds: 'data',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm a', // 11:20 AM\n\t\t\t\thour: 'hA', // 5PM\n\t\t\t\tday: 'MMM D', // Sep 4\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t},\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false,\n\n\t\t\t/**\n\t\t\t * Ticks generation input values:\n\t\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n\t\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n\t\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\n\t\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t\t * @since 2.7.0\n\t\t\t */\n\t\t\tsource: 'auto',\n\n\t\t\tmajor: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t}\n\t};\n\n\tvar TimeScale = Chart.Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tthis.mergeTicksOptions();\n\n\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t},\n\n\t\tupdate: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\n\t\t\t// DEPRECATIONS: output a message only one time per update\n\t\t\tif (options.time && options.time.format) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\t}\n\n\t\t\treturn Chart.Scale.prototype.update.apply(me, arguments);\n\t\t},\n\n\t\t/**\n\t\t * Allows data to be referenced via 't' attribute\n\t\t */\n\t\tgetRightValue: function(rawValue) {\n\t\t\tif (rawValue && rawValue.t !== undefined) {\n\t\t\t\trawValue = rawValue.t;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, rawValue);\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar unit = timeOpts.unit || 'day';\n\t\t\tvar min = MAX_INTEGER;\n\t\t\tvar max = MIN_INTEGER;\n\t\t\tvar timestamps = [];\n\t\t\tvar datasets = [];\n\t\t\tvar labels = [];\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\n\n\t\t\t// Convert labels to timestamps\n\t\t\tfor (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(parse(chart.data.labels[i], me));\n\t\t\t}\n\n\t\t\t// Convert data to timestamps\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tdata = chart.data.datasets[i].data;\n\n\t\t\t\t\t// Let's consider that all data have the same format.\n\t\t\t\t\tif (helpers.isObject(data[0])) {\n\t\t\t\t\t\tdatasets[i] = [];\n\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdatasets[i] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (labels.length) {\n\t\t\t\t// Sort labels **after** data have been converted\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\n\t\t\t\tmin = Math.min(min, labels[0]);\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\n\t\t\t}\n\n\t\t\tif (timestamps.length) {\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\n\t\t\t\tmin = Math.min(min, timestamps[0]);\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\n\t\t\t}\n\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\n\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\n\t\t\tme.min = Math.min(min, max);\n\t\t\tme.max = Math.max(min + 1, max);\n\n\t\t\t// PRIVATE\n\t\t\tme._horizontal = me.isHorizontal();\n\t\t\tme._table = [];\n\t\t\tme._timestamps = {\n\t\t\t\tdata: timestamps,\n\t\t\t\tdatasets: datasets,\n\t\t\t\tlabels: labels\n\t\t\t};\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\t\tvar options = me.options;\n\t\t\tvar timeOpts = options.time;\n\t\t\tvar timestamps = [];\n\t\t\tvar ticks = [];\n\t\t\tvar i, ilen, timestamp;\n\n\t\t\tswitch (options.ticks.source) {\n\t\t\tcase 'data':\n\t\t\t\ttimestamps = me._timestamps.data;\n\t\t\t\tbreak;\n\t\t\tcase 'labels':\n\t\t\t\ttimestamps = me._timestamps.labels;\n\t\t\t\tbreak;\n\t\t\tcase 'auto':\n\t\t\tdefault:\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\n\t\t\t}\n\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\t\tmin = timestamps[0];\n\t\t\t\tmax = timestamps[timestamps.length - 1];\n\t\t\t}\n\n\t\t\t// Enforce limits with user min/max options\n\t\t\tmin = parse(timeOpts.min, me) || min;\n\t\t\tmax = parse(timeOpts.max, me) || max;\n\n\t\t\t// Remove ticks outside the min/max range\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\t\ttimestamp = timestamps[i];\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\n\t\t\t\t\tticks.push(timestamp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.min = min;\n\t\t\tme.max = max;\n\n\t\t\t// PRIVATE\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\n\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\n\n\t\t\tif (helpers.isObject(value)) {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\t\t\tif (timeOpts.tooltipFormat) {\n\t\t\t\treturn momentify(label, timeOpts).format(timeOpts.tooltipFormat);\n\t\t\t}\n\t\t\tif (typeof label === 'string') {\n\t\t\t\treturn label;\n\t\t\t}\n\n\t\t\treturn momentify(label, timeOpts).format(me._labelFormat);\n\t\t},\n\n\t\t/**\n\t\t * Function to format an individual tick mark\n\t\t * @private\n\t\t */\n\t\ttickFormatFunction: function(tick, index, ticks, formatOverride) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar time = tick.valueOf();\n\t\t\tvar formats = options.time.displayFormats;\n\t\t\tvar minorFormat = formats[me._unit];\n\t\t\tvar majorUnit = me._majorUnit;\n\t\t\tvar majorFormat = formats[majorUnit];\n\t\t\tvar majorTime = tick.clone().startOf(majorUnit).valueOf();\n\t\t\tvar majorTickOpts = options.ticks.major;\n\t\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\t\tvar label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);\n\t\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\t\tvar formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t\t},\n\n\t\tconvertTicksToLabels: function(ticks) {\n\t\t\tvar labels = [];\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));\n\t\t\t}\n\n\t\t\treturn labels;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetPixelForOffset: function(time) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = interpolate(me._table, 'time', time, 'pos');\n\n\t\t\treturn start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);\n\t\t},\n\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar time = null;\n\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\n\t\t\t}\n\n\t\t\tif (time === null) {\n\t\t\t\ttime = parse(value, me);\n\t\t\t}\n\n\t\t\tif (time !== null) {\n\t\t\t\treturn me.getPixelForOffset(time);\n\t\t\t}\n\t\t},\n\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar ticks = this.getTicks();\n\t\t\treturn index >= 0 && index < ticks.length ?\n\t\t\t\tthis.getPixelForOffset(ticks[index].value) :\n\t\t\t\tnull;\n\t\t},\n\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;\n\t\t\tvar time = interpolate(me._table, 'pos', pos, 'time');\n\n\t\t\treturn moment(time);\n\t\t},\n\n\t\t/**\n\t\t * Crude approximation of what the label width might be\n\t\t * @private\n\t\t */\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticksOpts = me.options.ticks;\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar angle = helpers.toRadians(ticksOpts.maxRotation);\n\t\t\tvar cosRotation = Math.cos(angle);\n\t\t\tvar sinRotation = Math.sin(angle);\n\t\t\tvar tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);\n\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\n\t\t\tvar formatOverride = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n\n\t\t\tvar exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\tvar capacity = Math.floor(innerWidth / tickLabelWidth);\n\t\t\treturn capacity > 0 ? capacity : 1;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/scales/scale.time.js\n// module id = 1310\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('bar', {\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\ttype: 'linear'\n\t\t}]\n\t}\n});\n\ndefaults._set('horizontalBar', {\n\thover: {\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'bottom'\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\tposition: 'left',\n\t\t\ttype: 'category',\n\n\t\t\t// Specific to Horizontal Bar Controller\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\n\t\t\t// offset settings\n\t\t\toffset: true,\n\n\t\t\t// grid line settings\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}]\n\t},\n\n\telements: {\n\t\trectangle: {\n\t\t\tborderSkipped: 'left'\n\t\t}\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function(item, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\n\t\t\t\tif (item.length > 0) {\n\t\t\t\t\tif (item[0].yLabel) {\n\t\t\t\t\t\ttitle = item[0].yLabel;\n\t\t\t\t\t} else if (data.labels.length > 0 && item[0].index < data.labels.length) {\n\t\t\t\t\t\ttitle = data.labels[item[0].index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\treturn datasetLabel + ': ' + item.xLabel;\n\t\t\t}\n\t\t},\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t}\n});\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(scale, pixels) {\n\tvar min = scale.isHorizontal() ? scale.width : scale.height;\n\tvar ticks = scale.getTicks();\n\tvar prev, curr, i, ilen;\n\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\tmin = Math.min(min, pixels[i] - pixels[i - 1]);\n\t}\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tcurr = scale.getPixelForTick(i);\n\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\n\t\tprev = curr;\n\t}\n\n\treturn min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options) {\n\tvar thickness = options.barThickness;\n\tvar count = ruler.stackCount;\n\tvar curr = ruler.pixels[index];\n\tvar size, ratio;\n\n\tif (helpers.isNullOrUndef(thickness)) {\n\t\tsize = ruler.min * options.categoryPercentage;\n\t\tratio = options.barPercentage;\n\t} else {\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\n\t\tsize = thickness * count;\n\t\tratio = 1;\n\t}\n\n\treturn {\n\t\tchunk: size / count,\n\t\tratio: ratio,\n\t\tstart: curr - (size / 2)\n\t};\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options) {\n\tvar pixels = ruler.pixels;\n\tvar curr = pixels[index];\n\tvar prev = index > 0 ? pixels[index - 1] : null;\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\tvar percent = options.categoryPercentage;\n\tvar start, size;\n\n\tif (prev === null) {\n\t\t// first data: its size is double based on the next point or,\n\t\t// if it's also the last data, we use the scale end extremity.\n\t\tprev = curr - (next === null ? ruler.end - curr : next - curr);\n\t}\n\n\tif (next === null) {\n\t\t// last data: its size is also double based on the previous point.\n\t\tnext = curr + curr - prev;\n\t}\n\n\tstart = curr - ((curr - prev) / 2) * percent;\n\tsize = ((next - prev) / 2) * percent;\n\n\treturn {\n\t\tchunk: size / ruler.stackCount,\n\t\tratio: options.barPercentage,\n\t\tstart: start\n\t};\n}\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Rectangle,\n\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\n\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar i, ilen;\n\n\t\t\tme._ruler = me.getRuler();\n\n\t\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(rects[i], i, reset);\n\t\t\t}\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\trectangle._model = {\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: chart.data.labels[index],\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n\t\t\t};\n\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me.getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset ? base : vpixels.base;\n\t\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n\t\t\tmodel.height = horizontal ? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal ? undefined : ipixels.size;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScale: function() {\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScale: function() {\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\n\t\t},\n\n\t\t/**\n\t\t * Returns the stacks based on groups and bar visibility.\n\t\t * @param {Number} [last] - The dataset index\n\t\t * @returns {Array} The stack list\n\t\t * @private\n\t\t */\n\t\t_getStacks: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks;\n\t\t},\n\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function() {\n\t\t\treturn this._getStacks().length;\n\t\t},\n\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @param {Number} [datasetIndex] - The dataset index\n\t\t * @param {String} [name] - The stack name to find\n\t\t * @returns {Number} The stack index\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex, name) {\n\t\t\tvar stacks = this._getStacks(datasetIndex);\n\t\t\tvar index = (name !== undefined)\n\t\t\t\t? stacks.indexOf(name)\n\t\t\t\t: -1; // indexOf returns -1 if element is not present\n\n\t\t\treturn (index === -1)\n\t\t\t\t? stacks.length - 1\n\t\t\t\t: index;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar isHorizontal = scale.isHorizontal();\n\t\t\tvar start = isHorizontal ? scale.left : scale.top;\n\t\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\n\t\t\tvar pixels = [];\n\t\t\tvar i, ilen, min;\n\n\t\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n\t\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\n\t\t\t}\n\n\t\t\tmin = helpers.isNullOrUndef(scale.options.barThickness)\n\t\t\t\t? computeMinSampleSize(scale, pixels)\n\t\t\t\t: -1;\n\n\t\t\treturn {\n\t\t\t\tmin: min,\n\t\t\t\tpixels: pixels,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tstackCount: stackCount,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = scale.getRightValue(datasets[datasetIndex].data[index]);\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\t\tivalue = scale.getRightValue(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = (head - base) / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar options = ruler.scale.options;\n\t\t\tvar range = options.barThickness === 'flex'\n\t\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n\t\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\t\tvar size = Math.min(\n\t\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\n\t\t\t\trange.chunk * range.ratio);\n\n\t\t\treturn {\n\t\t\t\tbase: center - size / 2,\n\t\t\t\thead: center + size / 2,\n\t\t\t\tcenter: center,\n\t\t\t\tsize: size\n\t\t\t};\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = rects.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\n\t\t\t\t\trects[i].draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\t\t},\n\n\t\tsetHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t}\n\t});\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/controllers/controller.bar.js\n// module id = 1311\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('bubble', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\tposition: 'bottom',\n\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\n\t\t\t\treturn datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.bubble = Chart.DatasetController.extend({\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tdataElementType: elements.Point,\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data;\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar options = me._resolveElementOptions(point, index);\n\t\t\tvar data = me.getDataset().data[index];\n\t\t\tvar dsIndex = me.index;\n\n\t\t\tvar x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n\t\t\tvar y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._options = options;\n\t\t\tpoint._datasetIndex = dsIndex;\n\t\t\tpoint._index = index;\n\t\t\tpoint._model = {\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\thitRadius: options.hitRadius,\n\t\t\t\tpointStyle: options.pointStyle,\n\t\t\t\tradius: reset ? 0 : options.radius,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t};\n\n\t\t\tpoint.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\n\t\t\tmodel.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n\t\t\tmodel.radius = options.radius + options.hoverRadius;\n\t\t},\n\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\n\t\t\tmodel.backgroundColor = options.backgroundColor;\n\t\t\tmodel.borderColor = options.borderColor;\n\t\t\tmodel.borderWidth = options.borderWidth;\n\t\t\tmodel.radius = options.radius;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveElementOptions: function(point, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar dataset = datasets[me.index];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar options = chart.options.elements.point;\n\t\t\tvar resolve = helpers.options.resolve;\n\t\t\tvar data = dataset.data[index];\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'hoverBackgroundColor',\n\t\t\t\t'hoverBorderColor',\n\t\t\t\t'hoverBorderWidth',\n\t\t\t\t'hoverRadius',\n\t\t\t\t'hitRadius',\n\t\t\t\t'pointStyle'\n\t\t\t];\n\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\n\t\t\t// Custom radius resolution\n\t\t\tvalues.radius = resolve([\n\t\t\t\tcustom.radius,\n\t\t\t\tdata ? data.r : undefined,\n\t\t\t\tdataset.radius,\n\t\t\t\toptions.radius\n\t\t\t], context, index);\n\n\t\t\treturn values;\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/controllers/controller.bubble.js\n// module id = 1312\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('doughnut', {\n\tanimation: {\n\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\tanimateRotate: true,\n\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\tanimateScale: false\n\t},\n\thover: {\n\t\tmode: 'single'\n\t},\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t// toggle visibility of index if exists\n\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// The percentage of the chart that we cut out of the middle.\n\tcutoutPercentage: 50,\n\n\t// The rotation of the chart, where the first data arc begins.\n\trotation: Math.PI * -0.5,\n\n\t// The total circumference of the chart.\n\tcircumference: Math.PI * 2.0,\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\tif (helpers.isArray(dataLabel)) {\n\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t} else {\n\t\t\t\t\tdataLabel += value;\n\t\t\t\t}\n\n\t\t\t\treturn dataLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\ndefaults._set('pie', helpers.clone(defaults.doughnut));\ndefaults._set('pie', {\n\tcutoutPercentage: 0\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\tgetRingIndex: function(datasetIndex) {\n\t\t\tvar ringIndex = 0;\n\n\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t++ringIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ringIndex;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;\n\t\t\tvar availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;\n\t\t\tvar minSize = Math.min(availableWidth, availableHeight);\n\t\t\tvar offset = {x: 0, y: 0};\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar cutoutPercentage = opts.cutoutPercentage;\n\t\t\tvar circumference = opts.circumference;\n\n\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\tvar contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t}\n\n\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\t\tmeta.total = me.calculateTotal();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\n\t\t\tvar centerY = (chartArea.top + chartArea.bottom) / 2;\n\t\t\tvar startAngle = opts.rotation; // non reset case handled later\n\t\t\tvar endAngle = opts.rotation; // non reset case handled later\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));\n\t\t\tvar innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n\t\t\tvar outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar model = arc._model;\n\t\t\t// Resets the visual styles\n\t\t\tthis.removeHoverStyle(arc);\n\n\t\t\t// Set correct angles if not resetting\n\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t} else {\n\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t}\n\n\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t}\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcalculateTotal: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar total = 0;\n\t\t\tvar value;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tvalue = dataset.data[index];\n\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* if (total === 0) {\n\t\t\t\ttotal = NaN;\n\t\t\t}*/\n\n\t\t\treturn total;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar total = this.getMeta().total;\n\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\treturn (Math.PI * 2.0) * (Math.abs(value) / total);\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// gets the max border or hover width to properly scale pie charts\n\t\tgetMaxBorderWidth: function(arcs) {\n\t\t\tvar max = 0;\n\t\t\tvar index = this.index;\n\t\t\tvar length = arcs.length;\n\t\t\tvar borderWidth;\n\t\t\tvar hoverWidth;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tborderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;\n\t\t\t\thoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/controllers/controller.doughnut.js\n// module id = 1313\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('line', {\n\tshowLines: true,\n\tspanGaps: false,\n\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\t\t\tid: 'x-axis-0'\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tfunction lineEnabled(dataset, options) {\n\t\treturn helpers.valueOrDefault(dataset.showLine, options.showLines);\n\t}\n\n\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar options = me.chart.options;\n\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar i, ilen, custom;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = {\n\t\t\t\t\t// Appearance\n\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t};\n\n\t\t\t\tline.pivot();\n\t\t\t}\n\n\t\t\t// Update Points\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\n\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.backgroundColor) {\n\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\tbackgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t}\n\n\t\t\treturn backgroundColor;\n\t\t},\n\n\t\tgetPointBorderColor: function(point, index) {\n\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.borderColor) {\n\t\t\t\tborderColor = custom.borderColor;\n\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\tborderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t} else if (dataset.borderColor) {\n\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t}\n\n\t\t\treturn borderColor;\n\t\t},\n\n\t\tgetPointBorderWidth: function(point, index) {\n\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {\n\t\t\t\tborderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t}\n\n\t\t\treturn borderWidth;\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\tvar x, y;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\tpointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t};\n\t\t},\n\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = (meta.data || []);\n\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\n\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tmodel = point._model;\n\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar ilen = points.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, area);\n\n\t\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\n\t\t\t// Draw the points\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tpoints[i].draw(area);\n\t\t\t}\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\n\t\t\tmodel.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/controllers/controller.line.js\n// module id = 1314\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('polarArea', {\n\tscale: {\n\t\ttype: 'radialLinear',\n\t\tangleLines: {\n\t\t\tdisplay: false\n\t\t},\n\t\tgridLines: {\n\t\t\tcircular: true\n\t\t},\n\t\tpointLabels: {\n\t\t\tdisplay: false\n\t\t},\n\t\tticks: {\n\t\t\tbeginAtZero: true\n\t\t}\n\t},\n\n\t// Boolean - Whether to animate the rotation of the chart\n\tanimation: {\n\t\tanimateRotate: true,\n\t\tanimateScale: true\n\t},\n\n\tstartAngle: -0.5 * Math.PI,\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\tvar valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\n\t\tdataElementType: elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\n\t\t\tmeta.count = me.countVisibleElements();\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar scale = chart.scale;\n\t\t\tvar labels = chart.data.labels;\n\n\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\tvar centerX = scale.xCenter;\n\t\t\tvar centerY = scale.yCenter;\n\n\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\tvar visibleCount = 0;\n\t\t\tvar meta = me.getMeta();\n\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t++visibleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\n\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\n\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX,\n\t\t\t\t\ty: centerY,\n\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\tlabel: helpers.valueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply border and fill style\n\t\t\tme.removeHoverStyle(arc);\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcountVisibleElements: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar count = 0;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn count;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar count = this.getMeta().count;\n\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\treturn (2 * Math.PI) / count;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/controllers/controller.polarArea.js\n// module id = 1315\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('radar', {\n\tscale: {\n\t\ttype: 'radialLinear'\n\t},\n\telements: {\n\t\tline: {\n\t\t\ttension: 0 // no bezier in radar\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tChart.controllers.radar = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data;\n\t\t\tvar custom = line.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\tvar scale = me.chart.scale;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\n\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_scale: scale,\n\t\t\t\t// Data\n\t\t\t\t_children: points,\n\t\t\t\t_loop: true,\n\t\t\t\t// Model\n\t\t\t\t_model: {\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmeta.dataset.pivot();\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t}, me);\n\n\t\t\t// Update bezier control points\n\t\t\tme.updateBezierControlPoints();\n\t\t},\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n\t\t},\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\tvar meta = this.getMeta();\n\n\t\t\thelpers.each(meta.data, function(point, index) {\n\t\t\t\tvar model = point._model;\n\t\t\t\tvar controlPoints = helpers.splineCurve(\n\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel.tension\n\t\t\t\t);\n\n\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t// Now pivot the point for animation\n\t\t\t\tpoint.pivot();\n\t\t\t});\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/controllers/controller.radar.js\n// module id = 1316\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\n\ndefaults._set('scatter', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\n\t\t\ttype: 'linear',    // scatter should not use a category axis\n\t\t\tposition: 'bottom'\n\t\t}],\n\t\tyAxes: [{\n\t\t\tid: 'y-axis-1',\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left'\n\t\t}]\n\t},\n\n\tshowLines: false,\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';     // doesn't make sense for scatter since data are formatted as a point\n\t\t\t},\n\t\t\tlabel: function(item) {\n\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\t// Scatter charts use line controllers\n\tChart.controllers.scatter = Chart.controllers.line;\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/controllers/controller.scatter.js\n// module id = 1317\n// module chunks = 6","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bar = function(context, config) {\n\t\tconfig.type = 'bar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/charts/Chart.Bar.js\n// module id = 1318\n// module chunks = 6","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bubble = function(context, config) {\n\t\tconfig.type = 'bubble';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/charts/Chart.Bubble.js\n// module id = 1319\n// module chunks = 6","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Doughnut = function(context, config) {\n\t\tconfig.type = 'doughnut';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/charts/Chart.Doughnut.js\n// module id = 1320\n// module chunks = 6","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Line = function(context, config) {\n\t\tconfig.type = 'line';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/charts/Chart.Line.js\n// module id = 1321\n// module chunks = 6","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.PolarArea = function(context, config) {\n\t\tconfig.type = 'polarArea';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/charts/Chart.PolarArea.js\n// module id = 1322\n// module chunks = 6","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Radar = function(context, config) {\n\t\tconfig.type = 'radar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/charts/Chart.Radar.js\n// module id = 1323\n// module chunks = 6","'use strict';\n\nmodule.exports = function(Chart) {\n\tChart.Scatter = function(context, config) {\n\t\tconfig.type = 'scatter';\n\t\treturn new Chart(context, config);\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/charts/Chart.Scatter.js\n// module id = 1324\n// module chunks = 6","'use strict';\n\nmodule.exports = {};\nmodule.exports.filler = require('./plugin.filler');\nmodule.exports.legend = require('./plugin.legend');\nmodule.exports.title = require('./plugin.title');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/plugins/index.js\n// module id = 1325\n// module chunks = 6","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tplugins: {\n\t\tfiller: {\n\t\t\tpropagate: true\n\t\t}\n\t}\n});\n\nvar mappers = {\n\tdataset: function(source) {\n\t\tvar index = source.fill;\n\t\tvar chart = source.chart;\n\t\tvar meta = chart.getDatasetMeta(index);\n\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\tvar points = (visible && meta.dataset._children) || [];\n\t\tvar length = points.length || 0;\n\n\t\treturn !length ? null : function(point, i) {\n\t\t\treturn (i < length && points[i]._view) || null;\n\t\t};\n\t},\n\n\tboundary: function(source) {\n\t\tvar boundary = source.boundary;\n\t\tvar x = boundary ? boundary.x : null;\n\t\tvar y = boundary ? boundary.y : null;\n\n\t\treturn function(point) {\n\t\t\treturn {\n\t\t\t\tx: x === null ? point.x : x,\n\t\t\t\ty: y === null ? point.y : y,\n\t\t\t};\n\t\t};\n\t}\n};\n\n// @todo if (fill[0] === '#')\nfunction decodeFill(el, index, count) {\n\tvar model = el._model || {};\n\tvar fill = model.fill;\n\tvar target;\n\n\tif (fill === undefined) {\n\t\tfill = !!model.backgroundColor;\n\t}\n\n\tif (fill === false || fill === null) {\n\t\treturn false;\n\t}\n\n\tif (fill === true) {\n\t\treturn 'origin';\n\t}\n\n\ttarget = parseFloat(fill, 10);\n\tif (isFinite(target) && Math.floor(target) === target) {\n\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\ttarget = index + target;\n\t\t}\n\n\t\tif (target === index || target < 0 || target >= count) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tswitch (fill) {\n\t// compatibility\n\tcase 'bottom':\n\t\treturn 'start';\n\tcase 'top':\n\t\treturn 'end';\n\tcase 'zero':\n\t\treturn 'origin';\n\t// supported boundaries\n\tcase 'origin':\n\tcase 'start':\n\tcase 'end':\n\t\treturn fill;\n\t// invalid fill values\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nfunction computeBoundary(source) {\n\tvar model = source.el._model || {};\n\tvar scale = source.el._scale || {};\n\tvar fill = source.fill;\n\tvar target = null;\n\tvar horizontal;\n\n\tif (isFinite(fill)) {\n\t\treturn null;\n\t}\n\n\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t// controllers might still use it (e.g. the Smith chart).\n\n\tif (fill === 'start') {\n\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n\t} else if (fill === 'end') {\n\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\n\t} else if (model.scaleZero !== undefined) {\n\t\ttarget = model.scaleZero;\n\t} else if (scale.getBasePosition) {\n\t\ttarget = scale.getBasePosition();\n\t} else if (scale.getBasePixel) {\n\t\ttarget = scale.getBasePixel();\n\t}\n\n\tif (target !== undefined && target !== null) {\n\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\treturn target;\n\t\t}\n\n\t\tif (typeof target === 'number' && isFinite(target)) {\n\t\t\thorizontal = scale.isHorizontal();\n\t\t\treturn {\n\t\t\t\tx: horizontal ? target : null,\n\t\t\t\ty: horizontal ? null : target\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n\tvar source = sources[index];\n\tvar fill = source.fill;\n\tvar visited = [index];\n\tvar target;\n\n\tif (!propagate) {\n\t\treturn fill;\n\t}\n\n\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\tif (!isFinite(fill)) {\n\t\t\treturn fill;\n\t\t}\n\n\t\ttarget = sources[fill];\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (target.visible) {\n\t\t\treturn fill;\n\t\t}\n\n\t\tvisited.push(fill);\n\t\tfill = target.fill;\n\t}\n\n\treturn false;\n}\n\nfunction createMapper(source) {\n\tvar fill = source.fill;\n\tvar type = 'dataset';\n\n\tif (fill === false) {\n\t\treturn null;\n\t}\n\n\tif (!isFinite(fill)) {\n\t\ttype = 'boundary';\n\t}\n\n\treturn mappers[type](source);\n}\n\nfunction isDrawable(point) {\n\treturn point && !point.skip;\n}\n\nfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\tvar i;\n\n\tif (!len0 || !len1) {\n\t\treturn;\n\t}\n\n\t// building first area curve (normal)\n\tctx.moveTo(curve0[0].x, curve0[0].y);\n\tfor (i = 1; i < len0; ++i) {\n\t\thelpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n\t}\n\n\t// joining the two area curves\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n\n\t// building opposite area curve (reverse)\n\tfor (i = len1 - 1; i > 0; --i) {\n\t\thelpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n\t}\n}\n\nfunction doFill(ctx, points, mapper, view, color, loop) {\n\tvar count = points.length;\n\tvar span = view.spanGaps;\n\tvar curve0 = [];\n\tvar curve1 = [];\n\tvar len0 = 0;\n\tvar len1 = 0;\n\tvar i, ilen, index, p0, p1, d0, d1;\n\n\tctx.beginPath();\n\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\tindex = i % count;\n\t\tp0 = points[index]._view;\n\t\tp1 = mapper(p0, index, view);\n\t\td0 = isDrawable(p0);\n\t\td1 = isDrawable(p1);\n\n\t\tif (d0 && d1) {\n\t\t\tlen0 = curve0.push(p0);\n\t\t\tlen1 = curve1.push(p1);\n\t\t} else if (len0 && len1) {\n\t\t\tif (!span) {\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\tlen0 = len1 = 0;\n\t\t\t\tcurve0 = [];\n\t\t\t\tcurve1 = [];\n\t\t\t} else {\n\t\t\t\tif (d0) {\n\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t}\n\t\t\t\tif (d1) {\n\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\tctx.closePath();\n\tctx.fillStyle = color;\n\tctx.fill();\n}\n\nmodule.exports = {\n\tid: 'filler',\n\n\tafterDatasetsUpdate: function(chart, options) {\n\t\tvar count = (chart.data.datasets || []).length;\n\t\tvar propagate = options.propagate;\n\t\tvar sources = [];\n\t\tvar meta, i, el, source;\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tel = meta.dataset;\n\t\t\tsource = null;\n\n\t\t\tif (el && el._model && el instanceof elements.Line) {\n\t\t\t\tsource = {\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\tchart: chart,\n\t\t\t\t\tel: el\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tmeta.$filler = source;\n\t\t\tsources.push(source);\n\t\t}\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!source) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\tsource.boundary = computeBoundary(source);\n\t\t\tsource.mapper = createMapper(source);\n\t\t}\n\t},\n\n\tbeforeDatasetDraw: function(chart, args) {\n\t\tvar meta = args.meta.$filler;\n\t\tif (!meta) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctx = chart.ctx;\n\t\tvar el = meta.el;\n\t\tvar view = el._view;\n\t\tvar points = el._children || [];\n\t\tvar mapper = meta.mapper;\n\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\n\n\t\tif (mapper && color && points.length) {\n\t\t\thelpers.canvas.clipArea(ctx, chart.chartArea);\n\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\n\t\t\thelpers.canvas.unclipArea(ctx);\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/plugins/plugin.filler.js\n// module id = 1326\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\nvar layouts = require('../core/core.layouts');\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\tlegend: {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t},\n\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t}\n\t\t\ttext.push('</li>');\n\t\t}\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t}\n});\n\n/**\n * Helper function to get the box width based on the usePointStyle option\n * @param labelopts {Object} the label options on the legend\n * @param fontSize {Number} the label font size\n * @return {Number} width of the color box area\n */\nfunction getBoxWidth(labelOpts, fontSize) {\n\treturn labelOpts.usePointStyle ?\n\t\tfontSize * Math.SQRT2 :\n\t\tlabelOpts.boxWidth;\n}\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Legend = Element.extend({\n\n\tinitialize: function(config) {\n\t\thelpers.extend(this, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tthis.legendHitBoxes = [];\n\n\t\t// Are we in doughnut mode which has a different data type\n\t\tthis.doughnutMode = false;\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\t// Any function defined here is inherited by all legend types.\n\t// Any function can be extended by the legend type\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: function() {\n\t\tvar me = this;\n\t\tvar labelOpts = me.options.labels || {};\n\t\tvar legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n\t\tif (labelOpts.filter) {\n\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t});\n\t\t}\n\n\t\tif (me.options.reverse) {\n\t\t\tlegendItems.reverse();\n\t\t}\n\n\t\tme.legendItems = legendItems;\n\t},\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar display = opts.display;\n\n\t\tvar ctx = me.ctx;\n\n\t\tvar globalDefault = defaults.global;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t// Reset hit boxes\n\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\tvar minSize = me.minSize;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tif (isHorizontal) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = display ? 10 : 0;\n\t\t} else {\n\t\t\tminSize.width = display ? 10 : 0;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\t// Increase sizes here\n\t\tif (display) {\n\t\t\tctx.font = labelFont;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\t// Labels\n\n\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\n\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t});\n\n\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t} else {\n\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\tvar currentColWidth = 0;\n\t\t\t\tvar currentColHeight = 0;\n\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get max width\n\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\tminSize.width += totalWidth;\n\t\t\t}\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t},\n\n\t// Actually draw the legend on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar globalDefault = defaults.global;\n\t\tvar lineDefault = globalDefault.elements.line;\n\t\tvar legendWidth = me.width;\n\t\tvar lineWidths = me.lineWidths;\n\n\t\tif (opts.display) {\n\t\t\tvar ctx = me.ctx;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);\n\t\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar cursor;\n\n\t\t\t// Canvas setup\n\t\t\tctx.textAlign = 'left';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.lineWidth = 0.5;\n\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\tctx.font = labelFont;\n\n\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\tvar hitboxes = me.legendHitBoxes;\n\n\t\t\t// current position\n\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the ctx for the box\n\t\t\t\tctx.save();\n\n\t\t\t\tctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\tctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\tctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\tctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\tctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\tctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\tvar isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\tctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t}\n\n\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\thelpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t} else {\n\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t}\n\n\t\t\t\tctx.restore();\n\t\t\t};\n\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\tvar halfFontSize = fontSize / 2;\n\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\n\t\t\t\tvar yMiddle = y + halfFontSize;\n\n\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\n\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Horizontal\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tif (isHorizontal) {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\t\tvar x = cursor.x;\n\t\t\t\tvar y = cursor.y;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t}\n\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\tcursor.line++;\n\t\t\t\t}\n\n\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\thitboxes[i].left = x;\n\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t// Fill the actual label\n\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t} else {\n\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Handle an event\n\t * @private\n\t * @param {IEvent} event - The event to handle\n\t * @return {Boolean} true if a change occured\n\t */\n\thandleEvent: function(e) {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\tvar changed = false;\n\n\t\tif (type === 'mousemove') {\n\t\t\tif (!opts.onHover) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (type === 'click') {\n\t\t\tif (!opts.onClick) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// Chart event already has relative position in it\n\t\tvar x = e.x;\n\t\tvar y = e.y;\n\n\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t// See if we are touching one of the dataset boxes\n\t\t\tvar lh = me.legendHitBoxes;\n\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t// Touching an element\n\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n});\n\nfunction createNewLegendAndAttach(chart, legendOpts) {\n\tvar legend = new Legend({\n\t\tctx: chart.ctx,\n\t\toptions: legendOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, legend, legendOpts);\n\tlayouts.addBox(chart, legend);\n\tchart.legend = legend;\n}\n\nmodule.exports = {\n\tid: 'legend',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n\t * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Legend,\n\n\tbeforeInit: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\n\t\tif (legendOpts) {\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\t\tvar legend = chart.legend;\n\n\t\tif (legendOpts) {\n\t\t\thelpers.mergeIf(legendOpts, defaults.global.legend);\n\n\t\t\tif (legend) {\n\t\t\t\tlayouts.configure(chart, legend, legendOpts);\n\t\t\t\tlegend.options = legendOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t} else if (legend) {\n\t\t\tlayouts.removeBox(chart, legend);\n\t\t\tdelete chart.legend;\n\t\t}\n\t},\n\n\tafterEvent: function(chart, e) {\n\t\tvar legend = chart.legend;\n\t\tif (legend) {\n\t\t\tlegend.handleEvent(e);\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/plugins/plugin.legend.js\n// module id = 1327\n// module chunks = 6","'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\nvar layouts = require('../core/core.layouts');\n\nvar noop = helpers.noop;\n\ndefaults._set('global', {\n\ttitle: {\n\t\tdisplay: false,\n\t\tfontStyle: 'bold',\n\t\tfullWidth: true,\n\t\tlineHeight: 1.2,\n\t\tpadding: 10,\n\t\tposition: 'top',\n\t\ttext: '',\n\t\tweight: 2000         // by default greater than legend (1000) to be above\n\t}\n});\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Title = Element.extend({\n\tinitialize: function(config) {\n\t\tvar me = this;\n\t\thelpers.extend(me, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tme.legendHitBoxes = [];\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\tbeforeUpdate: noop,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\n\t},\n\tafterUpdate: noop,\n\n\t//\n\n\tbeforeSetDimensions: noop,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop,\n\n\t//\n\n\tbeforeBuildLabels: noop,\n\tbuildLabels: noop,\n\tafterBuildLabels: noop,\n\n\t//\n\n\tbeforeFit: noop,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar opts = me.options;\n\t\tvar display = opts.display;\n\t\tvar fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);\n\t\tvar minSize = me.minSize;\n\t\tvar lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;\n\t\tvar lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);\n\t\tvar textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;\n\n\t\tif (me.isHorizontal()) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = textSize;\n\t\t} else {\n\t\t\tminSize.width = textSize;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\n\t},\n\tafterFit: noop,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\tvar pos = this.options.position;\n\t\treturn pos === 'top' || pos === 'bottom';\n\t},\n\n\t// Actually draw the title block on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar ctx = me.ctx;\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar opts = me.options;\n\t\tvar globalDefaults = defaults.global;\n\n\t\tif (opts.display) {\n\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\tvar titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\tvar lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);\n\t\t\tvar offset = lineHeight / 2 + opts.padding;\n\t\t\tvar rotation = 0;\n\t\t\tvar top = me.top;\n\t\t\tvar left = me.left;\n\t\t\tvar bottom = me.bottom;\n\t\t\tvar right = me.right;\n\t\t\tvar maxWidth, titleX, titleY;\n\n\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\tctx.font = titleFont;\n\n\t\t\t// Horizontal\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\ttitleY = top + offset;\n\t\t\t\tmaxWidth = right - left;\n\t\t\t} else {\n\t\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\n\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t}\n\n\t\t\tctx.save();\n\t\t\tctx.translate(titleX, titleY);\n\t\t\tctx.rotate(rotation);\n\t\t\tctx.textAlign = 'center';\n\t\t\tctx.textBaseline = 'middle';\n\n\t\t\tvar text = opts.text;\n\t\t\tif (helpers.isArray(text)) {\n\t\t\t\tvar y = 0;\n\t\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\t\tctx.fillText(text[i], 0, y, maxWidth);\n\t\t\t\t\ty += lineHeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tctx.fillText(text, 0, 0, maxWidth);\n\t\t\t}\n\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\tvar title = new Title({\n\t\tctx: chart.ctx,\n\t\toptions: titleOpts,\n\t\tchart: chart\n\t});\n\n\tlayouts.configure(chart, title, titleOpts);\n\tlayouts.addBox(chart, title);\n\tchart.titleBlock = title;\n}\n\nmodule.exports = {\n\tid: 'title',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\n\t * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Title,\n\n\tbeforeInit: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\n\t\tif (titleOpts) {\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\t\tvar titleBlock = chart.titleBlock;\n\n\t\tif (titleOpts) {\n\t\t\thelpers.mergeIf(titleOpts, defaults.global.title);\n\n\t\t\tif (titleBlock) {\n\t\t\t\tlayouts.configure(chart, titleBlock, titleOpts);\n\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t} else if (titleBlock) {\n\t\t\tlayouts.removeBox(chart, titleBlock);\n\t\t\tdelete chart.titleBlock;\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/chart.js/src/plugins/plugin.title.js\n// module id = 1328\n// module chunks = 6","import React from 'react';\r\nimport { Carousel as CarouselResponsive } from 'react-responsive-carousel';\r\nimport styled from 'styled-components';\r\n\r\nconst CarouselResponsiveStyle = styled(CarouselResponsive)`\r\n  & .carousel .slide {\r\n    margin: auto 0;\r\n    border: solid 3px white;\r\n  }\r\n  \r\n  & .carousel:hover .slide .legend {\r\n    opacity: 1 !important;\r\n  }\r\n\r\n  & .legend {\r\n    opacity: 0.15 !important;\r\n  }\r\n\r\n  & .legend:hover {\r\n    opacity: 1 !important;\r\n  }\r\n`;\r\n\r\nconst Slider = styled.div`\r\n  margin: auto 0;\r\n  max-height: 60vh;\r\n  overflow: auto;\r\n`;\r\n\r\nfunction Carousel({ data }) {\r\n  return (\r\n    <div>\r\n      {data.document && data.document.length === 0 ? (\r\n        <span>No hay imgenes configuradas.</span>\r\n      ) : null}\r\n      <CarouselResponsiveStyle\r\n        showArrows={false}\r\n        autoPlay\r\n        infiniteLoop\r\n        stopOnHover\r\n        interval={data.rotationTime * 1000}\r\n        showStatus={false}\r\n      >\r\n        {\r\n          data.document && data.document.map(element => (\r\n            <Slider key={element.id} >\r\n              <img src={element.url} alt={element.name} />\r\n              <div className=\"legend\">\r\n                <span>\r\n                  {data.title}\r\n                </span>\r\n                <div>\r\n                  <p>{data.content}</p>\r\n                </div>\r\n              </div>\r\n            </Slider>\r\n          ))\r\n        }\r\n      </CarouselResponsiveStyle>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Carousel;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Home/Carousel.js","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Thumbs = exports.Carousel = undefined;\n\nvar _Carousel = require('./components/Carousel');\n\nvar _Carousel2 = _interopRequireDefault(_Carousel);\n\nvar _Thumbs = require('./components/Thumbs');\n\nvar _Thumbs2 = _interopRequireDefault(_Thumbs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Carousel = _Carousel2.default;\nexports.Thumbs = _Thumbs2.default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-responsive-carousel/lib/index.js\n// module id = 1330\n// module chunks = 6","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _cssClasses = require('../cssClasses');\n\nvar _cssClasses2 = _interopRequireDefault(_cssClasses);\n\nvar _CSSTranslate = require('../CSSTranslate');\n\nvar _CSSTranslate2 = _interopRequireDefault(_CSSTranslate);\n\nvar _reactEasySwipe = require('react-easy-swipe');\n\nvar _reactEasySwipe2 = _interopRequireDefault(_reactEasySwipe);\n\nvar _Thumbs = require('./Thumbs');\n\nvar _Thumbs2 = _interopRequireDefault(_Thumbs);\n\nvar _customPropTypes = require('../customPropTypes');\n\nvar customPropTypes = _interopRequireWildcard(_customPropTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar noop = function noop() {};\n\nvar defaultStatusFormatter = function defaultStatusFormatter(current, total) {\n    return current + ' of ' + total;\n};\n\nvar Carousel = function (_Component) {\n    _inherits(Carousel, _Component);\n\n    function Carousel(props) {\n        _classCallCheck(this, Carousel);\n\n        var _this = _possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call(this, props));\n\n        _this.setThumbsRef = function (node) {\n            _this.thumbsRef = node;\n        };\n\n        _this.setCarouselWrapperRef = function (node) {\n            _this.carouselWrapperRef = node;\n        };\n\n        _this.setListRef = function (node) {\n            _this.listRef = node;\n        };\n\n        _this.setItemsWrapperRef = function (node) {\n            _this.itemsWrapperRef = node;\n        };\n\n        _this.setItemsRef = function (node, index) {\n            if (!_this.itemsRef) {\n                _this.itemsRef = [];\n            }\n            _this.itemsRef[index] = node;\n        };\n\n        _this.autoPlay = function () {\n            if (!_this.props.autoPlay || _react.Children.count(_this.props.children) <= 1) {\n                return;\n            }\n\n            clearTimeout(_this.timer);\n            _this.timer = setTimeout(function () {\n                _this.increment();\n            }, _this.props.interval);\n        };\n\n        _this.clearAutoPlay = function () {\n            if (!_this.props.autoPlay) {\n                return;\n            }\n\n            clearTimeout(_this.timer);\n        };\n\n        _this.resetAutoPlay = function () {\n            _this.clearAutoPlay();\n            _this.autoPlay();\n        };\n\n        _this.stopOnHover = function () {\n            _this.setState({ isMouseEntered: true });\n            _this.clearAutoPlay();\n        };\n\n        _this.startOnLeave = function () {\n            _this.setState({ isMouseEntered: false });\n            _this.autoPlay();\n        };\n\n        _this.navigateWithKeyboard = function (e) {\n            var axis = _this.props.axis;\n\n            var isHorizontal = axis === 'horizontal';\n            var keyNames = {\n                ArrowUp: 38,\n                ArrowRight: 39,\n                ArrowDown: 40,\n                ArrowLeft: 37\n            };\n\n            var nextKey = isHorizontal ? keyNames.ArrowRight : keyNames.ArrowDown;\n            var prevKey = isHorizontal ? keyNames.ArrowLeft : keyNames.ArrowUp;\n\n            if (nextKey === e.keyCode) {\n                _this.increment();\n            } else if (prevKey === e.keyCode) {\n                _this.decrement();\n            }\n        };\n\n        _this.updateSizes = function () {\n            if (!_this.state.initialized) {\n                return;\n            }\n\n            var isHorizontal = _this.props.axis === 'horizontal';\n            var firstItem = _this.itemsRef[0];\n            var itemSize = isHorizontal ? firstItem.clientWidth : firstItem.clientHeight;\n\n            _this.setState({\n                itemSize: itemSize,\n                wrapperSize: isHorizontal ? itemSize * _react.Children.count(_this.props.children) : itemSize\n            });\n\n            if (_this.thumbsRef) {\n                _this.thumbsRef.updateSizes();\n            }\n        };\n\n        _this.setMountState = function () {\n            _this.setState({ hasMount: true });\n            _this.updateSizes();\n        };\n\n        _this.handleClickItem = function (index, item) {\n            if (_react.Children.count(_this.props.children) <= 1) {\n                return;\n            }\n\n            if (_this.state.cancelClick) {\n                _this.setState({\n                    cancelClick: false\n                });\n\n                return;\n            }\n\n            _this.props.onClickItem(index, item);\n\n            if (index !== _this.state.selectedItem) {\n                _this.setState({\n                    selectedItem: index\n                });\n            }\n        };\n\n        _this.handleOnChange = function (index, item) {\n            if (_react.Children.count(_this.props.children) <= 1) {\n                return;\n            }\n\n            _this.props.onChange(index, item);\n        };\n\n        _this.handleClickThumb = function (index, item) {\n            _this.props.onClickThumb(index, item);\n\n            _this.selectItem({\n                selectedItem: index\n            });\n        };\n\n        _this.onSwipeStart = function () {\n            _this.setState({\n                swiping: true\n            });\n            _this.clearAutoPlay();\n        };\n\n        _this.onSwipeEnd = function () {\n            _this.resetPosition();\n            _this.setState({\n                swiping: false\n            });\n            _this.autoPlay();\n        };\n\n        _this.onSwipeMove = function (delta) {\n            var isHorizontal = _this.props.axis === 'horizontal';\n\n            var initialBoundry = 0;\n\n            var currentPosition = _this.getPosition(_this.state.selectedItem);\n            var finalBoundry = _this.getPosition(_react.Children.count(_this.props.children) - 1);\n\n            var axisDelta = isHorizontal ? delta.x : delta.y;\n            var handledDelta = axisDelta;\n\n            // prevent user from swiping left out of boundaries\n            if (currentPosition === initialBoundry && axisDelta > 0) {\n                handledDelta = 0;\n            }\n\n            // prevent user from swiping right out of boundaries\n            if (currentPosition === finalBoundry && axisDelta < 0) {\n                handledDelta = 0;\n            }\n\n            var position = currentPosition + 100 / (_this.state.itemSize / handledDelta) + '%';\n\n            _this.setPosition(position);\n\n            // allows scroll if the swipe was within the tolerance\n            var hasMoved = Math.abs(axisDelta) > _this.props.swipeScrollTolerance;\n\n            if (hasMoved && !_this.state.cancelClick) {\n                _this.setState({\n                    cancelClick: true\n                });\n            }\n\n            return hasMoved;\n        };\n\n        _this.resetPosition = function () {\n            var currentPosition = _this.getPosition(_this.state.selectedItem) + '%';\n            _this.setPosition(currentPosition);\n        };\n\n        _this.setPosition = function (position) {\n            var list = _reactDom2.default.findDOMNode(_this.listRef);\n            ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {\n                list.style[prop] = (0, _CSSTranslate2.default)(position, _this.props.axis);\n            });\n        };\n\n        _this.decrement = function (positions) {\n            _this.moveTo(_this.state.selectedItem - (typeof positions === 'Number' ? positions : 1));\n        };\n\n        _this.increment = function (positions) {\n            _this.moveTo(_this.state.selectedItem + (typeof positions === 'Number' ? positions : 1));\n        };\n\n        _this.moveTo = function (position) {\n            var lastPosition = _react.Children.count(_this.props.children) - 1;\n\n            if (position < 0) {\n                position = _this.props.infiniteLoop ? lastPosition : 0;\n            }\n\n            if (position > lastPosition) {\n                position = _this.props.infiniteLoop ? 0 : lastPosition;\n            }\n\n            _this.selectItem({\n                // if it's not a slider, we don't need to set position here\n                selectedItem: position\n            });\n\n            // don't reset auto play when stop on hover is enabled, doing so will trigger a call to auto play more than once\n            // and will result in the interval function not being cleared correctly.\n            if (_this.props.autoPlay && _this.state.isMouseEntered === false) {\n                _this.resetAutoPlay();\n            }\n        };\n\n        _this.changeItem = function (e) {\n            var newIndex = e.target.value;\n\n            _this.selectItem({\n                selectedItem: newIndex\n            });\n        };\n\n        _this.selectItem = function (state) {\n            _this.setState(state);\n            _this.handleOnChange(state.selectedItem, _react.Children.toArray(_this.props.children)[state.selectedItem]);\n        };\n\n        _this.getInitialImage = function () {\n            var selectedItem = _this.props.selectedItem;\n            var item = _this.itemsRef && _this.itemsRef[selectedItem];\n            var images = item && item.getElementsByTagName('img');\n            return images && images[selectedItem];\n        };\n\n        _this.getVariableImageHeight = function (position) {\n            var item = _this.itemsRef && _this.itemsRef[position];\n            var images = item && item.getElementsByTagName('img');\n            if (_this.state.hasMount && images.length > 0) {\n                var image = images[0];\n\n                if (!image.complete) {\n                    // if the image is still loading, the size won't be available so we trigger a new render after it's done\n                    var onImageLoad = function onImageLoad() {\n                        _this.forceUpdate();\n                        image.removeEventListener('load', onImageLoad);\n                    };\n\n                    image.addEventListener('load', onImageLoad);\n                }\n\n                var height = image.clientHeight;\n                return height > 0 ? height : null;\n            }\n\n            return null;\n        };\n\n        _this.state = {\n            initialized: false,\n            selectedItem: props.selectedItem,\n            hasMount: false,\n            isMouseEntered: false\n        };\n        return _this;\n    }\n\n    _createClass(Carousel, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            if (!this.props.children) {\n                return;\n            }\n\n            this.setupCarousel();\n        }\n    }, {\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(nextProps) {\n            if (nextProps.selectedItem !== this.state.selectedItem) {\n                this.updateSizes();\n                this.moveTo(nextProps.selectedItem);\n            }\n\n            if (nextProps.autoPlay !== this.props.autoPlay) {\n                if (nextProps.autoPlay) {\n                    this.setupAutoPlay();\n                } else {\n                    this.destroyAutoPlay();\n                }\n            }\n        }\n    }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate(prevProps) {\n            if (!prevProps.children && this.props.children && !this.state.initialized) {\n                this.setupCarousel();\n            }\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            this.destroyCarousel();\n        }\n    }, {\n        key: 'setupCarousel',\n        value: function setupCarousel() {\n            this.bindEvents();\n\n            if (this.props.autoPlay && _react.Children.count(this.props.children) > 1) {\n                this.setupAutoPlay();\n            }\n\n            this.setState({\n                initialized: true\n            });\n\n            var initialImage = this.getInitialImage();\n            if (initialImage) {\n                // if it's a carousel of images, we set the mount state after the first image is loaded\n                initialImage.addEventListener('load', this.setMountState);\n            } else {\n                this.setMountState();\n            }\n        }\n    }, {\n        key: 'destroyCarousel',\n        value: function destroyCarousel() {\n            if (this.state.initialized) {\n                this.unbindEvents();\n                this.destroyAutoPlay();\n            }\n        }\n    }, {\n        key: 'setupAutoPlay',\n        value: function setupAutoPlay() {\n            this.autoPlay();\n            var carouselWrapper = this.carouselWrapperRef;\n\n            if (this.props.stopOnHover && carouselWrapper) {\n                carouselWrapper.addEventListener('mouseenter', this.stopOnHover);\n                carouselWrapper.addEventListener('mouseleave', this.startOnLeave);\n            }\n        }\n    }, {\n        key: 'destroyAutoPlay',\n        value: function destroyAutoPlay() {\n            this.clearAutoPlay();\n            var carouselWrapper = this.carouselWrapperRef;\n\n            if (this.props.stopOnHover && carouselWrapper) {\n                carouselWrapper.removeEventListener('mouseenter', this.stopOnHover);\n                carouselWrapper.removeEventListener('mouseleave', this.startOnLeave);\n            }\n        }\n    }, {\n        key: 'bindEvents',\n        value: function bindEvents() {\n            // as the widths are calculated, we need to resize\n            // the carousel when the window is resized\n            window.addEventListener(\"resize\", this.updateSizes);\n            // issue #2 - image loading smaller\n            window.addEventListener(\"DOMContentLoaded\", this.updateSizes);\n\n            if (this.props.useKeyboardArrows) {\n                document.addEventListener(\"keydown\", this.navigateWithKeyboard);\n            }\n        }\n    }, {\n        key: 'unbindEvents',\n        value: function unbindEvents() {\n            // removing listeners\n            window.removeEventListener(\"resize\", this.updateSizes);\n            window.removeEventListener(\"DOMContentLoaded\", this.updateSizes);\n\n            var initialImage = this.getInitialImage();\n            if (initialImage) {\n                initialImage.removeEventListener(\"load\", this.setMountState);\n            }\n\n            if (this.props.useKeyboardArrows) {\n                document.removeEventListener(\"keydown\", this.navigateWithKeyboard);\n            }\n        }\n    }, {\n        key: 'getPosition',\n        value: function getPosition(index) {\n            if (this.props.centerMode && this.props.axis === 'horizontal') {\n                var currentPosition = -index * this.props.centerSlidePercentage;\n                var lastPosition = _react.Children.count(this.props.children) - 1;\n\n                if (index && index !== lastPosition) {\n                    currentPosition += (100 - this.props.centerSlidePercentage) / 2;\n                } else if (index === lastPosition) {\n                    currentPosition += 100 - this.props.centerSlidePercentage;\n                }\n\n                return currentPosition;\n            }\n\n            return -index * 100;\n        }\n    }, {\n        key: 'renderItems',\n        value: function renderItems() {\n            var _this2 = this;\n\n            return _react.Children.map(this.props.children, function (item, index) {\n                var itemClass = _cssClasses2.default.ITEM(true, index === _this2.state.selectedItem);\n                var slideProps = {\n                    ref: function ref(e) {\n                        return _this2.setItemsRef(e, index);\n                    },\n                    key: 'itemKey' + index,\n                    className: _cssClasses2.default.ITEM(true, index === _this2.state.selectedItem),\n                    onClick: _this2.handleClickItem.bind(_this2, index, item)\n                };\n\n                if (_this2.props.centerMode && _this2.props.axis === 'horizontal') {\n                    slideProps.style = {\n                        minWidth: _this2.props.centerSlidePercentage + '%'\n                    };\n                }\n\n                return _react2.default.createElement(\n                    'li',\n                    slideProps,\n                    item\n                );\n            });\n        }\n    }, {\n        key: 'renderControls',\n        value: function renderControls() {\n            var _this3 = this;\n\n            if (!this.props.showIndicators) {\n                return null;\n            }\n\n            return _react2.default.createElement(\n                'ul',\n                { className: 'control-dots' },\n                _react.Children.map(this.props.children, function (item, index) {\n                    return _react2.default.createElement('li', { className: _cssClasses2.default.DOT(index === _this3.state.selectedItem), onClick: _this3.changeItem, value: index, key: index });\n                })\n            );\n        }\n    }, {\n        key: 'renderStatus',\n        value: function renderStatus() {\n            if (!this.props.showStatus) {\n                return null;\n            }\n\n            return _react2.default.createElement(\n                'p',\n                { className: 'carousel-status' },\n                this.props.statusFormatter(this.state.selectedItem + 1, _react.Children.count(this.props.children))\n            );\n        }\n    }, {\n        key: 'renderThumbs',\n        value: function renderThumbs() {\n            if (!this.props.showThumbs || _react.Children.count(this.props.children) === 0) {\n                return null;\n            }\n\n            return _react2.default.createElement(\n                _Thumbs2.default,\n                { ref: this.setThumbsRef, onSelectItem: this.handleClickThumb, selectedItem: this.state.selectedItem, transitionTime: this.props.transitionTime, thumbWidth: this.props.thumbWidth },\n                this.props.children\n            );\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            if (!this.props.children || _react.Children.count(this.props.children) === 0) {\n                return null;\n            }\n\n            var itemsLength = _react.Children.count(this.props.children);\n\n            var isHorizontal = this.props.axis === 'horizontal';\n\n            var canShowArrows = this.props.showArrows && itemsLength > 1;\n\n            // show left arrow?\n            var hasPrev = canShowArrows && (this.state.selectedItem > 0 || this.props.infiniteLoop);\n            // show right arrow\n            var hasNext = canShowArrows && (this.state.selectedItem < itemsLength - 1 || this.props.infiniteLoop);\n            // obj to hold the transformations and styles\n            var itemListStyles = {};\n\n            var currentPosition = this.getPosition(this.state.selectedItem);\n\n            // if 3d is available, let's take advantage of the performance of transform\n            var transformProp = (0, _CSSTranslate2.default)(currentPosition + '%', this.props.axis);\n\n            var transitionTime = this.props.transitionTime + 'ms';\n\n            itemListStyles = {\n                'WebkitTransform': transformProp,\n                'MozTransform': transformProp,\n                'MsTransform': transformProp,\n                'OTransform': transformProp,\n                'transform': transformProp,\n                'msTransform': transformProp\n            };\n\n            if (!this.state.swiping) {\n                itemListStyles = _extends({}, itemListStyles, {\n                    'WebkitTransitionDuration': transitionTime,\n                    'MozTransitionDuration': transitionTime,\n                    'MsTransitionDuration': transitionTime,\n                    'OTransitionDuration': transitionTime,\n                    'transitionDuration': transitionTime,\n                    'msTransitionDuration': transitionTime\n                });\n            }\n\n            var swiperProps = {\n                selectedItem: this.state.selectedItem,\n                className: _cssClasses2.default.SLIDER(true, this.state.swiping),\n                onSwipeMove: this.onSwipeMove,\n                onSwipeStart: this.onSwipeStart,\n                onSwipeEnd: this.onSwipeEnd,\n                style: itemListStyles,\n                tolerance: this.props.swipeScrollTolerance\n            };\n\n            var containerStyles = {};\n\n            if (isHorizontal) {\n                swiperProps.onSwipeLeft = this.increment;\n                swiperProps.onSwipeRight = this.decrement;\n\n                if (this.props.dynamicHeight) {\n                    var itemHeight = this.getVariableImageHeight(this.state.selectedItem);\n                    swiperProps.style.height = itemHeight || 'auto';\n                    containerStyles.height = itemHeight || 'auto';\n                }\n            } else {\n                swiperProps.onSwipeUp = this.props.verticalSwipe === 'natural' ? this.increment : this.decrement;\n                swiperProps.onSwipeDown = this.props.verticalSwipe === 'natural' ? this.decrement : this.increment;\n                swiperProps.style.height = this.state.itemSize;\n                containerStyles.height = this.state.itemSize;\n            }\n            return _react2.default.createElement(\n                'div',\n                { className: this.props.className, ref: this.setCarouselWrapperRef },\n                _react2.default.createElement(\n                    'div',\n                    { className: _cssClasses2.default.CAROUSEL(true), style: { width: this.props.width } },\n                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_PREV(!hasPrev), onClick: this.decrement }),\n                    _react2.default.createElement(\n                        'div',\n                        { className: _cssClasses2.default.WRAPPER(true, this.props.axis), style: containerStyles, ref: this.setItemsWrapperRef },\n                        this.props.swipeable ? _react2.default.createElement(\n                            _reactEasySwipe2.default,\n                            _extends({\n                                tagName: 'ul',\n                                ref: this.setListRef\n                            }, swiperProps, {\n                                allowMouseEvents: this.props.emulateTouch }),\n                            this.renderItems()\n                        ) : _react2.default.createElement(\n                            'ul',\n                            {\n                                className: _cssClasses2.default.SLIDER(true, this.state.swiping),\n                                style: itemListStyles },\n                            this.renderItems()\n                        )\n                    ),\n                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_NEXT(!hasNext), onClick: this.increment }),\n                    this.renderControls(),\n                    this.renderStatus()\n                ),\n                this.renderThumbs()\n            );\n        }\n    }]);\n\n    return Carousel;\n}(_react.Component);\n\nCarousel.displayName = 'Carousel';\nCarousel.propTypes = {\n    className: _propTypes2.default.string,\n    children: _propTypes2.default.node,\n    showArrows: _propTypes2.default.bool,\n    showStatus: _propTypes2.default.bool,\n    showIndicators: _propTypes2.default.bool,\n    infiniteLoop: _propTypes2.default.bool,\n    showThumbs: _propTypes2.default.bool,\n    thumbWidth: _propTypes2.default.number,\n    selectedItem: _propTypes2.default.number,\n    onClickItem: _propTypes2.default.func.isRequired,\n    onClickThumb: _propTypes2.default.func.isRequired,\n    onChange: _propTypes2.default.func.isRequired,\n    axis: _propTypes2.default.oneOf(['horizontal', 'vertical']),\n    verticalSwipe: _propTypes2.default.oneOf(['natural', 'standard']),\n    width: customPropTypes.unit,\n    useKeyboardArrows: _propTypes2.default.bool,\n    autoPlay: _propTypes2.default.bool,\n    stopOnHover: _propTypes2.default.bool,\n    interval: _propTypes2.default.number,\n    transitionTime: _propTypes2.default.number,\n    swipeScrollTolerance: _propTypes2.default.number,\n    swipeable: _propTypes2.default.bool,\n    dynamicHeight: _propTypes2.default.bool,\n    emulateTouch: _propTypes2.default.bool,\n    statusFormatter: _propTypes2.default.func.isRequired,\n    centerMode: _propTypes2.default.bool,\n    centerSlidePercentage: _propTypes2.default.number\n};\nCarousel.defaultProps = {\n    showIndicators: true,\n    showArrows: true,\n    showStatus: true,\n    showThumbs: true,\n    infiniteLoop: false,\n    selectedItem: 0,\n    axis: 'horizontal',\n    verticalSwipe: 'standard',\n    width: '100%',\n    useKeyboardArrows: false,\n    autoPlay: false,\n    stopOnHover: true,\n    interval: 3000,\n    transitionTime: 350,\n    swipeScrollTolerance: 5,\n    swipeable: true,\n    dynamicHeight: false,\n    emulateTouch: false,\n    onClickItem: noop,\n    onClickThumb: noop,\n    onChange: noop,\n    statusFormatter: defaultStatusFormatter,\n    centerMode: false,\n    centerSlidePercentage: 80\n};\nexports.default = Carousel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-responsive-carousel/lib/components/Carousel.js\n// module id = 1331\n// module chunks = 6","(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports', 'react', 'prop-types'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('react'), require('prop-types'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.react, global.propTypes);\n    global.reactSwipe = mod.exports;\n  }\n})(this, function (exports, _react, _propTypes) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.setHasSupportToCaptureOption = setHasSupportToCaptureOption;\n\n  var _react2 = _interopRequireDefault(_react);\n\n  var _propTypes2 = _interopRequireDefault(_propTypes);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  }\n\n  var supportsCaptureOption = false;\n  function setHasSupportToCaptureOption(hasSupport) {\n    supportsCaptureOption = hasSupport;\n  }\n\n  try {\n    addEventListener(\"test\", null, Object.defineProperty({}, 'capture', { get: function get() {\n        setHasSupportToCaptureOption(true);\n      } }));\n  } catch (e) {}\n\n  function getSafeEventHandlerOpts() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { capture: true };\n\n    return supportsCaptureOption ? options : options.capture;\n  }\n\n  /**\n   * [getPosition returns a position element that works for mouse or touch events]\n   * @param  {[Event]} event [the received event]\n   * @return {[Object]}      [x and y coords]\n   */\n  function getPosition(event) {\n    if ('touches' in event) {\n      var _event$touches$ = event.touches[0],\n          pageX = _event$touches$.pageX,\n          pageY = _event$touches$.pageY;\n\n      return { x: pageX, y: pageY };\n    }\n\n    var screenX = event.screenX,\n        screenY = event.screenY;\n\n    return { x: screenX, y: screenY };\n  }\n\n  var ReactSwipe = function (_Component) {\n    _inherits(ReactSwipe, _Component);\n\n    function ReactSwipe() {\n      var _ref;\n\n      _classCallCheck(this, ReactSwipe);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var _this = _possibleConstructorReturn(this, (_ref = ReactSwipe.__proto__ || Object.getPrototypeOf(ReactSwipe)).call.apply(_ref, [this].concat(args)));\n\n      _this._handleSwipeStart = _this._handleSwipeStart.bind(_this);\n      _this._handleSwipeMove = _this._handleSwipeMove.bind(_this);\n      _this._handleSwipeEnd = _this._handleSwipeEnd.bind(_this);\n\n      _this._onMouseDown = _this._onMouseDown.bind(_this);\n      _this._onMouseMove = _this._onMouseMove.bind(_this);\n      _this._onMouseUp = _this._onMouseUp.bind(_this);\n      return _this;\n    }\n\n    _createClass(ReactSwipe, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (this.swiper) {\n          this.swiper.addEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({\n            capture: true,\n            passive: false\n          }));\n        }\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        if (this.swiper) {\n          this.swiper.removeEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({\n            capture: true,\n            passive: false\n          }));\n        }\n      }\n    }, {\n      key: '_onMouseDown',\n      value: function _onMouseDown(event) {\n        if (!this.props.allowMouseEvents) {\n          return;\n        }\n\n        this.mouseDown = true;\n\n        document.addEventListener('mouseup', this._onMouseUp);\n        document.addEventListener('mousemove', this._onMouseMove);\n\n        this._handleSwipeStart(event);\n      }\n    }, {\n      key: '_onMouseMove',\n      value: function _onMouseMove(event) {\n        if (!this.mouseDown) {\n          return;\n        }\n\n        this._handleSwipeMove(event);\n      }\n    }, {\n      key: '_onMouseUp',\n      value: function _onMouseUp(event) {\n        this.mouseDown = false;\n\n        document.removeEventListener('mouseup', this._onMouseUp);\n        document.removeEventListener('mousemove', this._onMouseMove);\n\n        this._handleSwipeEnd(event);\n      }\n    }, {\n      key: '_handleSwipeStart',\n      value: function _handleSwipeStart(event) {\n        var _getPosition = getPosition(event),\n            x = _getPosition.x,\n            y = _getPosition.y;\n\n        this.moveStart = { x: x, y: y };\n        this.props.onSwipeStart(event);\n      }\n    }, {\n      key: '_handleSwipeMove',\n      value: function _handleSwipeMove(event) {\n        if (!this.moveStart) {\n          return;\n        }\n\n        var _getPosition2 = getPosition(event),\n            x = _getPosition2.x,\n            y = _getPosition2.y;\n\n        var deltaX = x - this.moveStart.x;\n        var deltaY = y - this.moveStart.y;\n        this.moving = true;\n\n        // handling the responsability of cancelling the scroll to\n        // the component handling the event\n        var shouldPreventDefault = this.props.onSwipeMove({\n          x: deltaX,\n          y: deltaY\n        }, event);\n\n        if (shouldPreventDefault) {\n          event.preventDefault();\n        }\n\n        this.movePosition = { deltaX: deltaX, deltaY: deltaY };\n      }\n    }, {\n      key: '_handleSwipeEnd',\n      value: function _handleSwipeEnd(event) {\n        this.props.onSwipeEnd(event);\n\n        var tolerance = this.props.tolerance;\n\n\n        if (this.moving && this.movePosition) {\n          if (this.movePosition.deltaX < -tolerance) {\n            this.props.onSwipeLeft(1, event);\n          } else if (this.movePosition.deltaX > tolerance) {\n            this.props.onSwipeRight(1, event);\n          }\n          if (this.movePosition.deltaY < -tolerance) {\n            this.props.onSwipeUp(1, event);\n          } else if (this.movePosition.deltaY > tolerance) {\n            this.props.onSwipeDown(1, event);\n          }\n        }\n\n        this.moveStart = null;\n        this.moving = false;\n        this.movePosition = null;\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _this2 = this;\n\n        return _react2.default.createElement(\n          this.props.tagName,\n          {\n            ref: function ref(node) {\n              return _this2.swiper = node;\n            },\n            onMouseDown: this._onMouseDown,\n            onTouchStart: this._handleSwipeStart,\n            onTouchEnd: this._handleSwipeEnd,\n            className: this.props.className,\n            style: this.props.style\n          },\n          this.props.children\n        );\n      }\n    }]);\n\n    return ReactSwipe;\n  }(_react.Component);\n\n  ReactSwipe.displayName = 'ReactSwipe';\n  ReactSwipe.propTypes = {\n    tagName: _propTypes2.default.string,\n    className: _propTypes2.default.string,\n    style: _propTypes2.default.object,\n    children: _propTypes2.default.node,\n    allowMouseEvents: _propTypes2.default.bool,\n    onSwipeUp: _propTypes2.default.func,\n    onSwipeDown: _propTypes2.default.func,\n    onSwipeLeft: _propTypes2.default.func,\n    onSwipeRight: _propTypes2.default.func,\n    onSwipeStart: _propTypes2.default.func,\n    onSwipeMove: _propTypes2.default.func,\n    onSwipeEnd: _propTypes2.default.func,\n    tolerance: _propTypes2.default.number.isRequired\n  };\n  ReactSwipe.defaultProps = {\n    tagName: 'div',\n    allowMouseEvents: false,\n    onSwipeUp: function onSwipeUp() {},\n    onSwipeDown: function onSwipeDown() {},\n    onSwipeLeft: function onSwipeLeft() {},\n    onSwipeRight: function onSwipeRight() {},\n    onSwipeStart: function onSwipeStart() {},\n    onSwipeMove: function onSwipeMove() {},\n    onSwipeEnd: function onSwipeEnd() {},\n\n    tolerance: 0\n  };\n  exports.default = ReactSwipe;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-easy-swipe/lib/react-swipe.js\n// module id = 1332\n// module chunks = 6","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nvar outerWidth = exports.outerWidth = function outerWidth(el) {\n\tvar width = el.offsetWidth;\n\tvar style = getComputedStyle(el);\n\n\twidth += parseInt(style.marginLeft) + parseInt(style.marginRight);\n\treturn width;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-responsive-carousel/lib/dimensions.js\n// module id = 1333\n// module chunks = 6","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar unit = exports.unit = function unit(props, propName, componentName) {\n    if (!/(pt|px|em|rem|vw|vh|%)$/.test(props[propName])) {\n        return new Error('Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed. It needs to be a size unit like pt, px, em, rem, vw, %');\n    }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-responsive-carousel/lib/customPropTypes.js\n// module id = 1334\n// module chunks = 6","import React, { Component } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Link } from 'react-router-dom';\r\nimport { Table, Spin } from 'antd';\r\nimport * as actions from '../../state/ManagerTeamSurvey/action';\r\nimport FormattedMessage from '../shared/FormattedMessage';\r\n\r\nconst { Column } = Table;\r\n\r\nclass PendingsManager extends Component {\r\n  componentDidMount() {\r\n    this.props.getManagerTeamSurvey();\r\n  }\r\n  getPendingsColumns = () => {\r\n    const { data } = this.props;\r\n    const { masters } = data;\r\n\r\n    const columns = [{\r\n      title: 'Supplier.supplier',\r\n      key: 'businessName',\r\n    }, {\r\n      title: 'Supplier.supplyType',\r\n      key: 'idSupply',\r\n      render(text, record) {\r\n        return masters.Supply.find(supply => supply.id === record.idSupply).name;\r\n      },\r\n    }, {\r\n      title: 'Supplier.idCompanySize',\r\n      key: 'idCompanySize',\r\n      render(text, record) {\r\n        const companySize = masters.CompanySize.find(\r\n          element => element.id === record.idCompanySize);\r\n        return companySize ? companySize.name : '';\r\n      },\r\n    }, {\r\n      title: 'Supplier.action',\r\n      key: 'linkManager',\r\n      render(text, record) {\r\n        return (\r\n          <Link to={`/managerTeamSurvey/${record.id}`}>\r\n            Ver\r\n          </Link>\r\n        );\r\n      },\r\n    }];\r\n\r\n    return columns.map(column => (\r\n      <Column\r\n        title={<FormattedMessage id={column.title} />}\r\n        key={column.key}\r\n        dataIndex={column.key}\r\n        render={column.render}\r\n      />\r\n    ));\r\n  }\r\n  render() {\r\n    const { data, loading } = this.props;\r\n    const { suppliers } = data;\r\n    return (\r\n      <Spin spinning={loading}>\r\n        <Table\r\n          rowKey={record => record.id}\r\n          dataSource={suppliers && suppliers.filter(x => x.state === 'NOT_STARTED_MANAGER_TEAM')}\r\n        >\r\n          {\r\n            this.getPendingsColumns()\r\n          }\r\n        </Table>\r\n      </Spin>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n  data: state.managerTeamSurvey.data,\r\n  loading: state.managerTeamSurvey.loading,\r\n});\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  actions,\r\n)(PendingsManager);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Home/PendingsManager.js","import React, { Component } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Link } from 'react-router-dom';\r\nimport { Table, Spin } from 'antd';\r\nimport * as actions from '../../state/TechnicalTeamSurvey/action';\r\nimport FormattedMessage from '../shared/FormattedMessage';\r\n\r\nconst { Column } = Table;\r\n\r\nclass PendingsTechnical extends Component {\r\n  componentDidMount() {\r\n    this.props.getTechnicalTeamSurvey();\r\n  }\r\n  getPendingsColumns = () => {\r\n    const { data } = this.props;\r\n    const { masters } = data;\r\n\r\n    const columns = [{\r\n      title: 'Supplier.supplier',\r\n      key: 'businessName',\r\n    }, {\r\n      title: 'Supplier.supplyType',\r\n      key: 'idSupply',\r\n      render(text, record) {\r\n        return masters.Supply.find(supply => supply.id === record.idSupply).name;\r\n      },\r\n    }, {\r\n      title: 'Supplier.idCompanySize',\r\n      key: 'idCompanySize',\r\n      render(text, record) {\r\n        const companySize = masters.CompanySize.find(\r\n          element => element.id === record.idCompanySize);\r\n        return companySize ? companySize.name : '';\r\n      },\r\n    }, {\r\n      title: 'Supplier.action',\r\n      key: 'linkTechnical',\r\n      render(text, record) {\r\n        return (\r\n          <Link to={`/TechnicalTeamSurvey/${record.id}`}>\r\n            Ver\r\n          </Link>\r\n        );\r\n      },\r\n    }];\r\n\r\n    return columns.map(column => (\r\n      <Column\r\n        title={<FormattedMessage id={column.title} />}\r\n        key={column.key}\r\n        dataIndex={column.key}\r\n        render={column.render}\r\n      />\r\n    ));\r\n  }\r\n  render() {\r\n    const { data, loading } = this.props;\r\n    const { suppliers } = data;\r\n    return (\r\n      <Spin spinning={loading}>\r\n        <Table\r\n          rowKey={record => record.id}\r\n          dataSource={suppliers && suppliers.filter(x => x.state !== 'ENDED_TECHNICAL_TEAM')}\r\n        >\r\n          {\r\n            this.getPendingsColumns()\r\n          }\r\n        </Table>\r\n      </Spin>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n  data: state.technicalTeamSurvey.data,\r\n  loading: state.technicalTeamSurvey.loading,\r\n});\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  actions,\r\n)(PendingsTechnical);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Home/PendingsTechnical.js","import React, { Component } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Link } from 'react-router-dom';\r\nimport { Table, Spin } from 'antd';\r\nimport * as actions from '../../state/Pendings/action';\r\nimport FormattedMessage from '../shared/FormattedMessage';\r\n\r\nconst { Column } = Table;\r\n\r\nclass PendingsEvaluator extends Component {\r\n  componentDidMount() {\r\n    this.props.getPendings();\r\n  }\r\n  getPendingsColumns = () => {\r\n    const { data } = this.props;\r\n    const { suppliersByCall, masters } = data;\r\n\r\n    const columns = [{\r\n      title: 'Supplier.supplier',\r\n      key: 'businessName',\r\n    }, {\r\n      title: 'Supplier.supplyType',\r\n      key: 'idSupply',\r\n      render(text, record) {\r\n        return masters.Supply.find(supply => supply.id === record.idSupply).name;\r\n      },\r\n    }, {\r\n      title: 'Supplier.idCompanySize',\r\n      key: 'idCompanySize',\r\n      render(text, record) {\r\n        const companySize = masters.CompanySize.find(\r\n          element => element.id === record.idCompanySize);\r\n        return companySize ? companySize.name : '';\r\n      },\r\n    }, {\r\n      title: 'Supplier.action',\r\n      key: 'linkManager',\r\n      render(text, record) {\r\n        const idSupplierByCall = suppliersByCall\r\n          .find(item => item.idSupplier === record.id)\r\n          .id;\r\n        return (\r\n          <Link to={`/supplier/${record.id}/${idSupplierByCall}`}>\r\n            Ver\r\n          </Link>\r\n        );\r\n      },\r\n    }];\r\n\r\n    return columns.map(column => (\r\n      <Column\r\n        title={<FormattedMessage id={column.title} />}\r\n        key={column.key}\r\n        dataIndex={column.key}\r\n        render={column.render}\r\n      />\r\n    ));\r\n  }\r\n  render() {\r\n    const { data, loading } = this.props;\r\n    const { suppliers, suppliersByCall, states } = data;\r\n    return (\r\n      <Spin spinning={loading}>\r\n        <Table\r\n          rowKey={record => record.id}\r\n          dataSource={suppliers && suppliers.filter((x) => {\r\n            const idStateSupplier = suppliersByCall\r\n              .find(element => element.idSupplier === x.id).idState;\r\n            const stateName = states.find(state => state.id === idStateSupplier).shortName;\r\n            return stateName !== 'ENDED_EVALUATOR';\r\n          })}\r\n        >\r\n          {\r\n            this.getPendingsColumns()\r\n          }\r\n        </Table>\r\n      </Spin>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n  data: state.pendings.data,\r\n  loading: state.pendings.loading,\r\n});\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  actions,\r\n)(PendingsEvaluator);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Home/PendingsEvaluator.js","import React, { Component } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { Link } from 'react-router-dom';\r\nimport { Table, Spin } from 'antd';\r\nimport FormattedMessage from '../shared/FormattedMessage';\r\n\r\nconst { Column } = Table;\r\n\r\nclass PendingsSupplier extends Component {\r\n  getPendingsColumns = () => {\r\n    const columns = [{\r\n      title: 'Supplier.supplier',\r\n      key: 'name',\r\n    }, {\r\n      title: 'Supplier.supplyType',\r\n      key: 'supply',\r\n    }, {\r\n      title: 'Supplier.idCompanySize',\r\n      key: 'company_size',\r\n    }, {\r\n      title: 'Supplier.action',\r\n      key: 'linkManager',\r\n      render() {\r\n        return (\r\n          <Link to={'/supplier'}>\r\n            Ver\r\n          </Link>\r\n        );\r\n      },\r\n    }];\r\n\r\n    return columns.map(column => (\r\n      <Column\r\n        title={<FormattedMessage id={column.title} />}\r\n        key={column.key}\r\n        dataIndex={column.key}\r\n        render={column.render}\r\n      />\r\n    ));\r\n  }\r\n  render() {\r\n    const { data, loading } = this.props;\r\n    const { userInfo } = data;\r\n    return (\r\n      <Spin spinning={loading}>\r\n        <Table\r\n          rowKey={record => record.id}\r\n          dataSource={[userInfo]}\r\n        >\r\n          {\r\n            this.getPendingsColumns()\r\n          }\r\n        </Table>\r\n      </Spin>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n  data: state.main.data,\r\n  loading: state.main.loading,\r\n});\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n)(PendingsSupplier);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Home/PendingsSupplier.js"],"sourceRoot":""}